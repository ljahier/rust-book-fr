<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Les types de données génériques - Le langage de programmation Rust</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilité</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de données</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrôle</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les références et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des données apparentées</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Définir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des méthodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les énumérations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Définir une énumération</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrôle match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrôle concise : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Gérer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Définir des modules pour gérer la portée et la visibilité</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Désigner un élément dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portée via le mot-clé use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Séparer les modules dans différents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodé en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clés associées à des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrécupérables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs récupérables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types génériques, les traits et les durées de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html" class="active"><strong aria-hidden="true">10.1.</strong> Les types de données génériques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Définir des comportements partagés avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformité des références avec les durées de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatisés</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment écrire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Gérer l'exécution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entrée/sortie : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Récupérer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour améliorer sa modularité et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Développer les fonctionnalités de la bibliothèque avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalités des langages fonctionnels : les itérateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une série d'éléments avec un itérateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Amélioration de notre projet d'entrée/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances : les boucles et les itérateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires à partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalités de cargo avec des commandes personnalisées</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des données présentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Considérer les pointeurs intelligents comme des références grâce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Exécuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les références</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilité interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de références qui peuvent provoquer des fuites de mémoire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les tâches pour exécuter simultanément du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transférer des données entre les tâches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'état en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalités orientées objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caractéristiques des langages orientés objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types différents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implémenter un patron de conception orienté-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits où les motifs peuvent être utilisés</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La réfutabilité : lorsqu'un motif peut échouer à correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalités avancées</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non sécurisé (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avancés</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avancés</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avancées</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multitâches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Développer un serveur web monotâche</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monotâche en serveur multitâches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arrêt propre et nettoyage</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Generic Data Types
-->
<h2 id="les-types-de-données-génériques"><a class="header" href="#les-types-de-données-génériques">Les types de données génériques</a></h2>
<!--
We can use generics to create definitions for items like function signatures or
structs, which we can then use with many different concrete data types. Let’s
first look at how to define functions, structs, enums, and methods using
generics. Then we’ll discuss how generics affect code performance.
-->
<p>Nous pouvons utiliser la généricité pour créer des définitions pour des éléments
comme les signatures de fonctions ou les structures, que nous pouvons ensuite
utiliser sur de nombreux types de données concrets. Commençons par regarder
comment définir des fonctions, des structures, des énumérations, et des méthodes
en utilisant la généricité. Ensuite nous verrons comment la généricité impacte
la performance du code.</p>
<!--
### In Function Definitions
-->
<h3 id="dans-la-définition-dune-fonction"><a class="header" href="#dans-la-définition-dune-fonction">Dans la définition d'une fonction</a></h3>
<!--
When defining a function that uses generics, we place the generics in the
signature of the function where we would usually specify the data types of the
parameters and return value. Doing so makes our code more flexible and provides
more functionality to callers of our function while preventing code duplication.
-->
<p>Lorsque nous définissons une fonction en utilisant la généricité, nous utilisons
des types génériques dans la signature de la fonction là où nous précisons
habituellement
les types de données des paramètres et de la valeur de retour. Faire ainsi rend
notre code plus flexible et apporte plus de fonctionnalités au code appelant
notre fonction, tout en évitant la duplication de code.</p>
<!--
Continuing with our `largest` function, Listing 10-4 shows two functions that
both find the largest value in a slice.
-->
<p>Pour continuer avec notre fonction <code>le_plus_grand</code>, l'encart 10-4 nous montre
deux fonctions qui trouvent toutes les deux la valeur la plus grande dans une
slice.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn largest_i32(list: &[i32]) -> i32 {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &[char]) -> char {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&number_list);
    println!("The largest number is {}", result);
#     assert_eq!(result, 100);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&char_list);
    println!("The largest char is {}", result);
#     assert_eq!(result, 'y');
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn le_plus_grand_i32(liste: &amp;[i32]) -&gt; i32 {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste.iter() {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn le_plus_grand_caractere(liste: &amp;[char]) -&gt; char {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste.iter() {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand_i32(&amp;liste_de_nombres);
    println!(&quot;Le plus grand nombre est {}&quot;, resultat);
<span class="boring">    assert_eq!(resultat, 100);
</span>
    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];

    let resultat = le_plus_grand_caractere(&amp;liste_de_caracteres);
    println!(&quot;Le plus grand caractère est {}&quot;, resultat);
<span class="boring">    assert_eq!(resultat, 'y');
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 10-4: Two functions that differ only in their
names and the types in their signatures</span>
-->
<p><span class="caption">Encart 10-4 : deux fonctions qui se distinguent seulement
par leur nom et le type dans leur signature</span></p>
<!--
The `largest_i32` function is the one we extracted in Listing 10-3 that finds
the largest `i32` in a slice. The `largest_char` function finds the largest
`char` in a slice. The function bodies have the same code, so let’s eliminate
the duplication by introducing a generic type parameter in a single function.
-->
<p>La fonction <code>le_plus_grand_i32</code> est celle que nous avons construite à l'encart 10-3
lorsqu'elle trouvait le plus grand <code>i32</code> dans une slice. La fonction
<code>le_plus_grand_caractere</code> recherche le plus grand <code>char</code> dans une slice. Les
corps des fonctions ont le même code, donc essayons d'éviter cette duplication
en utilisant un paramètre de type générique dans une seule et unique fonction.</p>
<!--
To parameterize the types in the new function we’ll define, we need to name the
type parameter, just as we do for the value parameters to a function. You can
use any identifier as a type parameter name. But we’ll use `T` because, by
convention, parameter names in Rust are short, often just a letter, and Rust’s
type-naming convention is CamelCase. Short for “type,” `T` is the default
choice of most Rust programmers.
-->
<p>Pour paramétrer les types dans la nouvelle fonction que nous allons définir,
nous avons besoin de donner un nom au paramètre de type, comme nous l'avons
fait pour les paramètres de valeur des fonctions. Vous pouvez utiliser
n'importe quel identificateur pour nommer le paramètre de type. Mais ici nous allons
utiliser <code>T</code> car, par convention, les noms de paramètres en Rust sont courts,
souvent même une seule lettre, et la convention de nommage des types en Rust est
d'utiliser le CamelCase. Et puisque la version courte de “type” est <code>T</code>, c'est
le choix par défaut de nombreux développeurs Rust.</p>
<!--
When we use a parameter in the body of the function, we have to declare the
parameter name in the signature so the compiler knows what that name means.
Similarly, when we use a type parameter name in a function signature, we have
to declare the type parameter name before we use it. To define the generic
`largest` function, place type name declarations inside angle brackets, `<>`,
between the name of the function and the parameter list, like this:
-->
<p>Lorsqu'on utilise un paramètre dans le corps de la fonction, nous devons
déclarer le nom du paramètre dans la signature afin que le compilateur puisse
savoir à quoi réfère ce nom. De la même manière, lorsqu'on utilise un nom de
paramètre de type dans la signature d'une fonction, nous devons déclarer le nom
du paramètre de type avant de pouvoir l'utiliser. Pour déclarer la fonction
générique <code>le_plus_grand</code>, il faut placer la déclaration du nom du type entre
des chevrons <code>&lt;&gt;</code>, le tout entre le nom de la fonction et la liste des
paramètres, comme ceci :</p>
<!--
```rust,ignore
fn largest<T>(list: &[T]) -> T {
```
-->
<pre><code class="language-rust ignore">fn le_plus_grand&lt;T&gt;(liste: &amp;[T]) -&gt; &amp;T {
</code></pre>
<!--
We read this definition as: the function `largest` is generic over some type
`T`. This function has one parameter named `list`, which is a slice of values
of type `T`. The `largest` function will return a value of the
same type `T`.
-->
<p>Cette définition se lit comme ceci : la fonction <code>le_plus_grand</code> est générique
en fonction du type <code>T</code>. Cette fonction a un paramètre qui s'appelle <code>liste</code>,
qui est une slice de valeurs de type <code>T</code>. Cette fonction <code>le_plus_grand</code> va
retourner une référence vers la valeur du même type <code>T</code>.</p>
<!--
Listing 10-5 shows the combined `largest` function definition using the generic
data type in its signature. The listing also shows how we can call the function
with either a slice of `i32` values or `char` values. Note that this code won’t
compile yet, but we’ll fix it later in this chapter.
-->
<p>L'encart 10-5 nous montre la combinaison de la définition de la fonction
<code>le_plus_grand</code> avec le type de données générique présent dans sa signature.
L'encart montre aussi que nous pouvons appeler la fonction avec une slice soit
de valeurs <code>i32</code>, soit de valeurs <code>char</code>. Notez que ce code ne se compile pas
encore, mais nous allons y remédier plus tard dans ce chapitre.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn le_plus_grand&lt;T&gt;(liste: &amp;[T]) -&gt; T {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand(&amp;liste_de_nombres);
    println!(&quot;Le nombre le plus grand est {}&quot;, resultat);

    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];

    let resultat = le_plus_grand(&amp;liste_de_caracteres);
    println!(&quot;Le plus grand caractère est {}&quot;, resultat);
}
</code></pre>
<!--
<span class="caption">Listing 10-5: A definition of the `largest` function that
uses generic type parameters but doesn’t compile yet</span>
-->
<p><span class="caption">Encart 10-5 : une définition de la fonction
<code>le_plus_grand</code> qui utilise des paramètres de type génériques, mais qui ne
compile pas encore</span></p>
<!--
If we compile this code right now, we’ll get this error:
-->
<p>Si nous essayons de compiler ce code dès maintenant, nous aurons l'erreur
suivante :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 -- > src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if element &gt; le_plus_grand {
  |            ------- ^ ------------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn le_plus_grand&lt;T: std::cmp::PartialOrd&gt;(liste: &amp;[T]) -&gt; T {
  |                  ^^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
<!--
The note mentions `std::cmp::PartialOrd`, which is a *trait*. We’ll talk about
traits in the next section. For now, this error states that the body of
`largest` won’t work for all possible types that `T` could be. Because we want
to compare values of type `T` in the body, we can only use types whose values
can be ordered. To enable comparisons, the standard library has the
`std::cmp::PartialOrd` trait that you can implement on types (see Appendix C
for more on this trait). You’ll learn how to specify that a generic type has a
particular trait in the [“Traits as Parameters”][traits-as-parameters]<!--
ignore -- > section, but let’s first explore other ways of using generic type
parameters.
-->
<p>La note cite <code>std::cmp::PartialOrd</code>, qui est un <em>trait</em>. Nous allons voir les
traits dans la prochaine section. Pour le moment, cette erreur nous informe que
le corps de <code>le_plus_grand</code> ne va pas fonctionner pour tous les types possibles
que <code>T</code> peut représenter. Comme nous voulons comparer des valeurs de type <code>T</code>
dans le corps, nous pouvons utiliser uniquement des types dont les valeurs
peuvent être triées dans l'ordre. Pour effectuer des comparaisons, la bibliothèque
standard propose le trait <code>std::cmp::PartialOrd</code> que vous pouvez implémenter sur
des types (voir l'annexe C pour en savoir plus sur ce trait). Vous allez
apprendre à indiquer qu'un type générique a un trait spécifique dans la section
<a href="ch10-02-traits.html#des-traits-en-param%C3%A8tres">“Des traits en paramètres”</a><!-- ignore -->, mais d'abord
nous allons explorer d'autres manières d'utiliser les paramètres de types
génériques.</p>
<!--
### In Struct Definitions
-->
<h3 id="dans-la-définition-des-structures"><a class="header" href="#dans-la-définition-des-structures">Dans la définition des structures</a></h3>
<!--
We can also define structs to use a generic type parameter in one or more
fields using the `<>` syntax. Listing 10-6 shows how to define a `Point<T>`
struct to hold `x` and `y` coordinate values of any type.
-->
<p>Nous pouvons aussi définir des structures en utilisant des paramètres de type
génériques dans un ou plusieurs champs en utilisant la syntaxe <code>&lt;&gt;</code>. L'encart
10-6 nous montre comment définir une structure <code>Point&lt;T&gt;</code> pour stocker des
valeurs de coordonnées <code>x</code> et <code>y</code> de n'importe quel type.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let entiers = Point { x: 5, y: 10 };
    let flottants = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-6: A `Point<T>` struct that holds `x` and `y`
values of type `T`</span>
-->
<p><span class="caption">Encart 10-6 : une structure <code>Point&lt;T&gt;</code> qui stocke les
valeurs <code>x</code> et <code>y</code> de type <code>T</code></span></p>
<!--
The syntax for using generics in struct definitions is similar to that used in
function definitions. First, we declare the name of the type parameter inside
angle brackets just after the name of the struct. Then we can use the generic
type in the struct definition where we would otherwise specify concrete data
types.
-->
<p>La syntaxe pour l'utilisation des génériques dans les définitions de structures
est similaire à celle utilisée dans les définitions de fonctions. D'abord, on
déclare le nom du paramètre de type entre des chevrons juste après le nom de la
structure. Ensuite, on peut utiliser le type générique dans la définition de la
structure là où on indiquerait en temps normal des types de données concrets.</p>
<!--
Note that because we’ve used only one generic type to define `Point<T>`, this
definition says that the `Point<T>` struct is generic over some type `T`, and
the fields `x` and `y` are *both* that same type, whatever that type may be. If
we create an instance of a `Point<T>` that has values of different types, as in
Listing 10-7, our code won’t compile.
-->
<p>Notez que comme nous n'avons utilisé qu'un seul type générique pour définir
<code>Point&lt;T&gt;</code>, cette définition dit que la structure <code>Point&lt;T&gt;</code> est générique en
fonction d'un type <code>T</code>, et les champs <code>x</code> et <code>y</code> sont <em>tous les deux</em> de ce même
type, quel qu'il soit. Si nous créons une instance de <code>Point&lt;T&gt;</code> qui a des
valeurs de types différents, comme dans l'encart 10-7, notre code ne va pas se
compiler.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
```
-->
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let ne_fonctionnera_pas = Point { x: 5, y: 4.0 };
}
</code></pre>
<!--
<span class="caption">Listing 10-7: The fields `x` and `y` must be the same
type because both have the same generic data type `T`.</span>
-->
<p><span class="caption">Encart 10-7 : les champs <code>x</code> et <code>y</code> doivent être du même
type car ils ont tous les deux le même type de données générique <code>T</code>.</span></p>
<!--
In this example, when we assign the integer value 5 to `x`, we let the
compiler know that the generic type `T` will be an integer for this instance of
`Point<T>`. Then when we specify 4.0 for `y`, which we’ve defined to have the
same type as `x`, we’ll get a type mismatch error like this:
-->
<p>Dans cet exemple, lorsque nous assignons l'entier 5 à <code>x</code>, nous laissons
entendre au compilateur que le type générique <code>T</code> sera un entier pour cette
instance de <code>Point&lt;T&gt;</code>. Ensuite, lorsque nous assignons 4.0 à <code>y</code>, que nous
avons défini comme ayant le même type que <code>x</code>, nous obtenons une erreur
d'incompatibilité de type comme celle-ci :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 -- > src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let ne_fonctionnera_pas = Point { x: 5, y: 4.0 };
  |                                                ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
</code></pre>
<!--
To define a `Point` struct where `x` and `y` are both generics but could have
different types, we can use multiple generic type parameters. For example, in
Listing 10-8, we can change the definition of `Point` to be generic over types
`T` and `U` where `x` is of type `T` and `y` is of type `U`.
-->
<p>Pour définir une structure <code>Point</code> où <code>x</code> et <code>y</code> sont tous les deux génériques
mais peuvent avoir des types différents, nous pouvons utiliser plusieurs
paramètres de types génériques différents. Par exemple, dans l'encart 10-8,
nous pouvons changer la définition de <code>Point</code> pour être générique en fonction
des types <code>T</code> et <code>U</code> où <code>x</code> est de type <code>T</code> et <code>y</code> est de type <code>U</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let deux_entiers = Point { x: 5, y: 10 };
    let deux_flottants = Point { x: 1.0, y: 4.0 };
    let un_entier_et_un_flottant = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-8: A `Point<T, U>` generic over two types so
that `x` and `y` can be values of different types</span>
-->
<p><span class="caption">Encart 10-8: un <code>Point&lt;T, U&gt;</code> générique en fonction de
deux types <code>x</code> et <code>y</code> qui peuvent être des valeurs de types différents</span></p>
<!--
Now all the instances of `Point` shown are allowed! You can use as many generic
type parameters in a definition as you want, but using more than a few makes
your code hard to read. When you need lots of generic types in your code, it
could indicate that your code needs restructuring into smaller pieces.
-->
<p>Maintenant, toutes les instances de <code>Point</code> montrées ici sont valides ! Vous
pouvez utiliser autant de paramètres de type génériques que vous souhaitez dans
la déclaration de la définition, mais en utiliser plus de quelques-uns rend
votre code difficile à lire. Lorsque vous avez besoin de nombreux types
génériques dans votre code, cela peut être un signe que votre code a besoin
d'être remanié en éléments plus petits.</p>
<!--
### In Enum Definitions
-->
<h3 id="dans-les-définitions-dénumérations"><a class="header" href="#dans-les-définitions-dénumérations">Dans les définitions d'énumérations</a></h3>
<!--
As we did with structs, we can define enums to hold generic data types in their
variants. Let’s take another look at the `Option<T>` enum that the standard
library provides, which we used in Chapter 6:
-->
<p>Comme nous l'avons fait avec les structures, nous pouvons définir des
énumérations qui utilisent des types de données génériques dans leurs variantes.
Commençons par regarder à nouveau l'énumération <code>Option&lt;T&gt;</code> que fournit la
bibliothèque standard, et que nous avons utilisée au chapitre 6 :</p>
<!--
```rust
enum Option<T> {
    Some(T),
    None,
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<!--
This definition should now make more sense to you. As you can see, `Option<T>`
is an enum that is generic over type `T` and has two variants: `Some`, which
holds one value of type `T`, and a `None` variant that doesn’t hold any value.
By using the `Option<T>` enum, we can express the abstract concept of having an
optional value, and because `Option<T>` is generic, we can use this abstraction
no matter what the type of the optional value is.
-->
<p>Cette définition devrait désormais avoir plus de sens pour vous. Comme vous
pouvez le constater, <code>Option&lt;T&gt;</code> est une énumération qui est générique en
fonction du type <code>T</code> et a deux variantes : <code>Some</code>, qui contient une valeur de
type <code>T</code>, et une variante <code>None</code> qui ne contient aucune valeur. En utilisant
l'énumération <code>Option&lt;T&gt;</code>, nous pouvons exprimer le concept abstrait d'avoir
une valeur optionnelle, et comme <code>Option&lt;T&gt;</code> est générique, nous pouvons
utiliser cette abstraction peu importe le type de la valeur optionnelle.</p>
<!--
Enums can use multiple generic types as well. The definition of the `Result`
enum that we used in Chapter 9 is one example:
-->
<p>Les énumérations peuvent aussi utiliser plusieurs types génériques. La
définition de l'énumération <code>Result</code> que nous avons utilisée au chapitre 9 en est
un exemple :</p>
<!--
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `Result` enum is generic over two types, `T` and `E`, and has two variants:
`Ok`, which holds a value of type `T`, and `Err`, which holds a value of type
`E`. This definition makes it convenient to use the `Result` enum anywhere we
have an operation that might succeed (return a value of some type `T`) or fail
(return an error of some type `E`). In fact, this is what we used to open a
file in Listing 9-3, where `T` was filled in with the type `std::fs::File` when
the file was opened successfully and `E` was filled in with the type
`std::io::Error` when there were problems opening the file.
-->
<p>L'énumération <code>Result</code> est générique en fonction de deux types, <code>T</code> et <code>E</code>, et a
deux variantes : <code>Ok</code>, qui contient une valeur de type <code>T</code>, et <code>Err</code>, qui
contient une valeur de type <code>E</code>. Cette définition rend possible l'utilisation de
l'énumération <code>Result</code> partout où nous avons une opération qui peut réussir (et
retourner une valeur du type <code>T</code>) ou échouer (et retourner une erreur du type
<code>E</code>). En fait, c'est ce qui est utilisé pour ouvrir un fichier dans l'encart
9-3, où <code>T</code> contenait un type <code>std::fs::File</code> lorsque le fichier était ouvert
avec succès et <code>E</code> contenait un type <code>std::io::Error</code> lorsqu'il y avait des
problèmes pour ouvrir le fichier.</p>
<!--
When you recognize situations in your code with multiple struct or enum
definitions that differ only in the types of the values they hold, you can
avoid duplication by using generic types instead.
-->
<p>Lorsque vous reconnaîtrez des cas dans votre code où vous aurez plusieurs
définitions de structures ou d'énumérations qui se distinguent uniquement par le
type de valeurs qu'elles stockent, vous pourrez éviter les doublons en utilisant
des types génériques à la place.</p>
<!--
### In Method Definitions
-->
<h3 id="dans-la-définition-des-méthodes"><a class="header" href="#dans-la-définition-des-méthodes">Dans la définition des méthodes</a></h3>
<!--
We can implement methods on structs and enums (as we did in Chapter 5) and use
generic types in their definitions, too. Listing 10-9 shows the `Point<T>`
struct we defined in Listing 10-6 with a method named `x` implemented on it.
-->
<p>Nous pouvons implémenter des méthodes sur des structures et des énumérations
(comme nous l'avons fait dans le chapitre 5) et aussi utiliser des types
génériques dans leurs définitions. L'encart 10-9 montre la structure <code>Point&lt;T&gt;</code>
que nous avons définie dans l'encart 10-6 avec une méthode qui s'appelle <code>x</code>
implémentée sur cette dernière.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-9: Implementing a method named `x` on the
`Point<T>` struct that will return a reference to the `x` field of type
`T`</span>
-->
<p><span class="caption">Encart 10-9 : implémentation d'une méthode <code>x</code> sur la
structure <code>Point&lt;T&gt;</code> qui va retourner une référence au champ <code>x</code>, de type <code>T</code>
</span></p>
<!--
Here, we’ve defined a method named `x` on `Point<T>` that returns a reference
to the data in the field `x`.
-->
<p>Ici, nous avons défini une méthode qui s'appelle <code>x</code> sur <code>Point&lt;T&gt;</code> qui retourne
une référence à la donnée présente dans le champ <code>x</code>.</p>
<!--
Note that we have to declare `T` just after `impl` so we can use it to specify
that we’re implementing methods on the type `Point<T>`. By declaring `T` as a
generic type after `impl`, Rust can identify that the type in the angle
brackets in `Point` is a generic type rather than a concrete type. Because this
is declaring the generic again, we could have chosen a different name for the
generic parameter than the generic parameter declared in the struct definition,
but using the same name is conventional. Methods written within an `impl` that
declares the generic type will be defined on any instance of the type, no
matter what concrete type ends up substituting for the generic type.
-->
<p>Notez que nous devons déclarer <code>T</code> juste après <code>impl</code> afin de pouvoir l'utiliser
pour préciser que nous implémentons des méthodes sur le type <code>Point&lt;T&gt;</code>. En
déclarant <code>T</code> comme un type générique après <code>impl</code>, Rust peut comprendre que le
type entre les chevrons dans <code>Point</code> est un type générique plutôt qu'un type
concret. Comme cela revient à déclarer à nouveau le générique, nous aurions pu
choisir un nom différent pour le paramètre générique plutôt que de réutiliser
le même nom que dans la définition de la structure, mais c'est devenu une
convention d'utiliser le même nom. Les méthodes écrites dans un <code>impl</code> qui
déclarent un type générique peuvent être définies sur n'importe quelle instance
du type, peu importe quel type concret sera substitué dans le type générique.</p>
<!--
The other option we have is defining methods on the type with some constraint
on the generic type. We could, for example, implement methods only on
`Point<f32>` instances rather than on `Point<T>` instances with any generic
type. In Listing 10-10 we use the concrete type `f32`, meaning we don’t declare
any types after `impl`.
-->
<p>L'autre possibilité que nous avons est de définir les méthodes sur le type avec
des contraintes sur le type générique. Nous pouvons par exemple implémenter des
méthodes uniquement sur des instances de <code>Point&lt;f32&gt;</code> plutôt que sur des
instances de n'importe quel type <code>Point&lt;T&gt;</code>. Dans l'encart 10-10, nous
utilisons le type concret <code>f32</code>, ce qui veut dire que nous n'avons pas besoin
de déclarer un type après <code>impl</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# struct Point<T> {
#     x: T,
#     y: T,
# }
# 
# impl<T> Point<T> {
#     fn x(&self) -> &T {
#         &self.x
#     }
# }
# 
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
# 
# fn main() {
#     let p = Point { x: 5, y: 10 };
# 
#     println!("p.x = {}", p.x());
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_depuis_lorigine(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!(&quot;p.x = {}&quot;, p.x());
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-10: An `impl` block that only applies to a
struct with a particular concrete type for the generic type parameter `T`</span>
-->
<p><span class="caption">Encart 10-10 : un bloc <code>impl</code> qui ne s'applique que sur
une structure d'un type concret particulier pour le paramètre de type générique
<code>T</code>
</span></p>
<!--
This code means the type `Point<f32>` will have a method named
`distance_from_origin` and other instances of `Point<T>` where `T` is not of
type `f32` will not have this method defined. The method measures how far our
point is from the point at coordinates (0.0, 0.0) and uses mathematical
operations that are available only for floating point types.
-->
<p>Ce code signifie que le type <code>Point&lt;f32&gt;</code> va avoir une méthode qui s'appelle
<code>distance_depuis_lorigine</code> et les autres instances de <code>Point&lt;T&gt;</code> où <code>T</code> n'est
pas du type <code>f32</code> ne pourront pas appeler cette méthode. Cette méthode calcule
la distance entre notre point et la coordonnée (0.0, 0.0) et utilise des
opérations mathématiques qui ne sont disponibles que pour les types de
flottants.</p>
<!--
Generic type parameters in a struct definition aren’t always the same as those
you use in that struct’s method signatures. Listing 10-11 uses the generic
types `X1` and `Y1` for the `Point` struct and `X2` `Y2` for the `mixup` method
signature to make the example clearer. The method creates a new `Point`
instance with the `x` value from the `self` `Point` (of type `X1`) and the `y`
value from the passed-in `Point` (of type `Y2`).
-->
<p>Les paramètres de type génériques dans la définition d'une structure ne sont
pas toujours les mêmes que ceux qui sont utilisés dans la signature des
méthodes de cette structure. Par exemple, l'encart 10-11 utilise les types
génériques <code>X1</code> et <code>Y1</code> pour la structure <code>Point</code>, ainsi que <code>X2</code> et <code>Y2</code> pour
la signature de la méthode <code>melange</code> pour rendre l'exemple plus clair. La
méthode crée une nouvelle instance de <code>Point</code> avec la valeur de <code>x</code> provenant
du <code>Point</code> <code>self</code> (de type <code>X1</code>) et la valeur de <code>y</code> provenant du <code>Point</code> en
paramètre (de type <code>Y2</code>).</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn melange&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c' };

    let p3 = p1.melange(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-11: A method that uses different generic types
from its struct’s definition</span>
-->
<p><span class="caption">Encart 10-11 : une méthode qui utilise différents types
génériques provenant de la définition de la structure</span></p>
<!--
In `main`, we’ve defined a `Point` that has an `i32` for `x` (with value `5`)
and an `f64` for `y` (with value `10.4`). The `p2` variable is a `Point` struct
that has a string slice for `x` (with value `"Hello"`) and a `char` for `y`
(with value `c`). Calling `mixup` on `p1` with the argument `p2` gives us `p3`,
which will have an `i32` for `x`, because `x` came from `p1`. The `p3` variable
will have a `char` for `y`, because `y` came from `p2`. The `println!` macro
call will print `p3.x = 5, p3.y = c`.
-->
<p>Dans le <code>main</code>, nous avons défini un <code>Point</code> qui a un <code>i32</code> pour <code>x</code> (avec la
valeur <code>5</code>) et un <code>f64</code> pour <code>y</code> (avec la valeur 10.4). La variable <code>p2</code> est une
structure <code>Point</code> qui a une slice de chaine de caractères pour <code>x</code> (avec la
valeur <code>&quot;Hello&quot;</code>) et un caractère <code>char</code> pour <code>y</code> (avec la valeur <code>c</code>). L'appel
à <code>melange</code> sur <code>p1</code> avec l'argument <code>p2</code> nous donne <code>p3</code>, qui aura un <code>i32</code> pour
<code>x</code>, car <code>x</code> provient de <code>p1</code>. La variable <code>p3</code> aura un caractère <code>char</code> pour
<code>y</code>, car <code>y</code> provient de <code>p2</code>. L'appel à la macro <code>println!</code> va afficher
<code>p3.x = 5, p3.y = c</code>.</p>
<!--
The purpose of this example is to demonstrate a situation in which some generic
parameters are declared with `impl` and some are declared with the method
definition. Here, the generic parameters `X1` and `Y1` are declared after
`impl` because they go with the struct definition. The generic parameters `X2`
and `Y2` are declared after `fn mixup`, because they’re only relevant to the
method.
-->
<p>Le but de cet exemple est de montrer une situation dans laquelle des paramètres
génériques sont déclarés avec <code>impl</code> et d'autres sont déclarés dans la
définition de la méthode. Ici, les paramètres génériques <code>X1</code> et <code>Y1</code> sont
déclarés après <code>impl</code>, car ils sont liés à la définition de la structure. Les
paramètres génériques <code>X2</code> et <code>Y2</code> sont déclarés après <code>fn melange</code>, car ils ne
sont liés qu'à cette méthode.</p>
<!--
### Performance of Code Using Generics
-->
<h3 id="performance-du-code-utilisant-les-génériques"><a class="header" href="#performance-du-code-utilisant-les-génériques">Performance du code utilisant les génériques</a></h3>
<!--
You might be wondering whether there is a runtime cost when you’re using
generic type parameters. The good news is that Rust implements generics in such
a way that your code doesn’t run any slower using generic types than it would
with concrete types.
-->
<p>Vous vous demandez peut-être s'il y a un coût à l'exécution lorsque vous
utilisez des paramètres de type génériques. La bonne nouvelle est que Rust
implémente les génériques de manière à ce que votre code ne s'exécute pas plus
lentement que vous utilisiez les types génériques ou des types concrets.</p>
<!--
Rust accomplishes this by performing monomorphization of the code that is using
generics at compile time. *Monomorphization* is the process of turning generic
code into specific code by filling in the concrete types that are used when
compiled.
-->
<p>Rust accomplit cela en pratiquant la monomorphisation à la compilation du code
qui utilise les génériques. La <em>monomorphisation</em> est un processus qui transforme
du code générique en code spécifique en définissant au moment de la compilation les
types concrets utilisés dans le code.</p>
<!--
In this process, the compiler does the opposite of the steps we used to create
the generic function in Listing 10-5: the compiler looks at all the places
where generic code is called and generates code for the concrete types the
generic code is called with.
-->
<p>Dans ce processus, le compilateur fait l'inverse des étapes que nous avons suivies
pour créer la fonction générique de l'encart 10-5 : le compilateur cherche tous
les endroits où le code générique est utilisé et génère du code pour les types
concrets avec lesquels le code générique est appelé.</p>
<!--
Let’s look at how this works with an example that uses the standard library’s
`Option<T>` enum:
-->
<p>Regardons comment cela fonctionne avec un exemple qui utilise l'énumération
<code>Option&lt;T&gt;</code> de la bibliothèque standard :</p>
<!--
```rust
let integer = Some(5);
let float = Some(5.0);
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entier = Some(5);
let flottant = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<!--
When Rust compiles this code, it performs monomorphization. During that
process, the compiler reads the values that have been used in `Option<T>`
instances and identifies two kinds of `Option<T>`: one is `i32` and the other
is `f64`. As such, it expands the generic definition of `Option<T>` into
`Option_i32` and `Option_f64`, thereby replacing the generic definition with
the specific ones.
-->
<p>Lorsque Rust compile ce code, il applique la monomorphisation. Pendant ce
processus, le compilateur lit les valeurs qui ont été utilisées dans les
instances de <code>Option&lt;T&gt;</code> et en déduit les deux sortes de <code>Option&lt;T&gt;</code> : une est
<code>i32</code> et l'autre est <code>f64</code>. Ainsi, il décompose la définition générique de
<code>Option&lt;T&gt;</code> en <code>Option_i32</code> et en <code>Option_f64</code>, remplaçant ainsi la définition
générique par deux définitions concrètes.</p>
<!--
The monomorphized version of the code looks like the following. The generic
`Option<T>` is replaced with the specific definitions created by the compiler:
-->
<p>La version monomorphe du code ressemble à ce qui suit. Le <code>Option&lt;T&gt;</code> générique
est remplacé par deux définitions concrètes créées par le compilateur :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let entier = Option_i32::Some(5);
    let flottant = Option_f64::Some(5.0);
}
</code></pre></pre>
<!--
Because Rust compiles generic code into code that specifies the type in each
instance, we pay no runtime cost for using generics. When the code runs, it
performs just as it would if we had duplicated each definition by hand. The
process of monomorphization makes Rust’s generics extremely efficient at
runtime.
-->
<p>Comme Rust compile le code générique dans du code qui précise le type dans
chaque instance, l'utilisation des génériques n'a pas de conséquence sur les
performances de l'exécution. Quand le code s'exécute, il fonctionne comme il
devrait le faire si nous avions dupliqué chaque définition à la main. Le
processus de monomorphisation rend les génériques de Rust très performants au
moment de l'exécution.</p>
<!--
[traits-as-parameters]: ch10-02-traits.html#traits-as-parameters
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-00-generics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch10-02-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-00-generics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch10-02-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>


    </body>
</html>
