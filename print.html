<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Le langage de programmation Rust</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilité</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de données</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrôle</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les références et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des données apparentées</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Définir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des méthodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les énumérations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Définir une énumération</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrôle match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrôle concise : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Gérer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Définir des modules pour gérer la portée et la visibilité</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Désigner un élément dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portée via le mot-clé use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Séparer les modules dans différents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodé en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clés associées à des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrécupérables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs récupérables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types génériques, les traits et les durées de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de données génériques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Définir des comportements partagés avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformité des références avec les durées de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatisés</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment écrire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Gérer l'exécution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entrée/sortie : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Récupérer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour améliorer sa modularité et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Développer les fonctionnalités de la bibliothèque avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalités des langages fonctionnels : les itérateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une série d'éléments avec un itérateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Amélioration de notre projet d'entrée/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances : les boucles et les itérateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> 🚧 En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 🚧 Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> 🚧 Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> 🚧 Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> 🚧 Installer des binaires à partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 🚧 Etendre les fonctionnalités de cargo avec des commandes personnalisées</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 🚧 Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> 🚧 Utiliser Box&lt;T&gt; pour pointer sur des données présentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> 🚧 Considérer les pointeurs intelligents comme des références grâce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> 🚧 Exécuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> 🚧 Rc&lt;T&gt;, le pointeur intelligent qui compte les références</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> 🚧 RefCell&lt;T&gt; et le motif de mutabilité interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 🚧 Les boucles de références qui peuvent provoquer des fuites de mémoire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 🚧 La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 🚧 Utiliser les tâches pour exécuter simultanément du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 🚧 Utiliser l'envoi de messages pour transférer des données entre les tâches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 🚧 Le partage d'état en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 🚧 Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalités orientées objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 🚧 Les caractéristiques des langages orientés objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 🚧 Utiliser les objets traits qui permettent des valeurs de types différents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 🚧 Implémenter un patron de conception orienté-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 🚧 Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 🚧 Tous les endroits où les motifs peuvent être utilisés</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 🚧 La réfutabilité : lorsqu'un motif peut échouer à correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> 🚧 La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 🚧 Les fonctionnalités avancées</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> 🚧 Le Rust non sécurisé (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> 🚧 Les traits avancés</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> 🚧 Les types avancés</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> 🚧 Les fonctions et fermetures avancées</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> 🚧 Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 🚧 Projet final : construire un serveur web multitâches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 🚧 Développer un serveur web monotâche</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 🚧 Transformer notre serveur monotâche en serveur multitâches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 🚧 Arrêt propre et nettoyage</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 🚧 Annexes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> 🚧 A - les mots-clés</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> 🚧 B - les opérateurs et les symboles</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> 🚧 C - les traits dérivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> 🚧 D - Des outils de développement utiles</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> 🚧 E - Les éditions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> 🚧 F - Les traductions de ce livre</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> 🚧 G - Comment Rust est construit, et “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# The Rust Programming Language
-->
<h1 id="le-langage-de-programmation-rust"><a class="header" href="#le-langage-de-programmation-rust">Le langage de programmation Rust</a></h1>
<!--
*by Steve Klabnik and Carol Nichols, with contributions from the Rust Community*
-->
<p><em>par Steve Klabnik et Carol Nichols, avec la participation de la Communauté
Rust</em></p>
<!--
This version of the text assumes you’re using Rust 1.55 or later with
`edition="2018"` in *Cargo.toml* of all projects to use Rust 2018 Edition
idioms. See the [“Installation” section of Chapter 1][install]<!-- ignore -- >
to install or update Rust, and see the new [Appendix E][editions]<!-- ignore
-- > for information on editions.
-->
<p>Cette version du document suppose que vous utilisez Rust 1.55 ou ultérieur
avec <code>edition=&quot;2018&quot;</code> dans <em>Cargo.toml</em> de tous les projets afin d'utiliser les
expressions idiomatiques de l'édition 2018 de Rust.
Voir la <a href="ch01-01-installation.html">section “Installation” du chapitre 1</a><!-- ignore -->
pour installer ou mettre à jour Rust, et
voir la nouvelle <a href="appendix-05-editions.html">annexe E</a><!-- ignore --> pour plus d'informations
sur les éditions.</p>
<!--
The 2018 Edition of the Rust language includes a number of improvements that
make Rust more ergonomic and easier to learn. This iteration of the book
contains a number of changes to reflect those improvements:
-->
<p>L'édition 2018 du langage Rust apporte quelques améliorations qui rendent Rust
plus ergonomique et plus facile à apprendre. Cette version du livre comprend un
certain nombre de changements pour refléter ces améliorations :</p>
<!--
- Chapter 7, “Managing Growing Projects with Packages, Crates, and Modules,”
  has been mostly rewritten. The module system and the way paths work in the
  2018 Edition were made more consistent.
- Chapter 10 has new sections titled “Traits as Parameters” and “Returning
  Types that Implement Traits” that explain the new `impl Trait` syntax.
- Chapter 11 has a new section titled “Using `Result<T, E>` in Tests” that
  shows how to write tests that use the `?` operator.
- The “Advanced Lifetimes” section in Chapter 19 was removed because compiler
  improvements have made the constructs in that section even rarer.
- The previous Appendix D, “Macros,” has been expanded to include procedural
  macros and was moved to the “Macros” section in Chapter 19.
- Appendix A, “Keywords,” also explains the new raw identifiers feature that
  enables code written in the 2015 Edition and the 2018 Edition to interoperate.
- Appendix D is now titled “Useful Development Tools” and covers recently
  released tools that help you write Rust code.
- We fixed a number of small errors and imprecise wording throughout the book.
  Thank you to the readers who reported them!
-->
<ul>
<li>Le chapitre 7 a été réécrit en grande partie. Le système de modules et le
fonctionnement des chemins dans l'édition 2018 ont été rendus plus cohérents.</li>
<li>Le chapitre 10 a deux nouvelles parties qui expliquent la nouvelle syntaxe
<code>impl Trait</code>.</li>
<li>Le chapitre 11 a une nouvelle partie qui montre comment écrire des tests qui
utilisent l'opérateur <code>?</code>.</li>
<li>La partie &quot;Durée de vie avancée&quot; du chapitre 19 a été retirée, car les
améliorations du compilateur ont rendu encore plus rare les concepts de cette
section.</li>
<li>L'ancienne Annexe D a été complétée pour couvrir les macros procédurales et a
été déplacée dans la section &quot;Macros&quot; du chapitre 19.</li>
<li>L'annexe A explique aussi la nouvelle fonctionnalité d'identificateurs bruts
qui rend du code écrit avec l'édition 2015 interopérable avec l'édition 2018.</li>
<li>L'annexe D a été renommée et couvre les nouveaux outils ajoutés récemment
pour vous aider à écrire du code Rust.</li>
<li>Nous avons corrigé quelques petites erreurs et certaines formulations floues
dans tout le livre. Merci aux lecteurs qui nous les ont signalées !</li>
</ul>
<!--
Note that any code in earlier iterations of *The Rust Programming Language*
that compiled will continue to compile without `edition="2018"` in the
project’s *Cargo.toml*, even as you update the Rust compiler version you’re
using. That’s Rust’s backward compatibility guarantees at work!
-->
<p>Veuillez noter que tout le code dans les versions précédentes du livre
<em>Le langage de programmation Rust</em> qui se compilait va continuer à compiler sans
<code>edition=&quot;2018&quot;</code> dans le <em>Cargo.toml</em> du projet, même si vous mettez à jour le
compilateur Rust que vous utilisez. C'est la garantie de la rétrocompatibilité
de Rust qui est à l'œuvre ici !</p>
<!--
The HTML format is available online at
[https://doc.rust-lang.org/stable/book/](https://doc.rust-lang.org/stable/book/)
and offline with installations of Rust made with `rustup`; run `rustup docs
--book` to open.
-->
<p>Le format HTML de la version anglaise est disponible en ligne à l'adresse
<a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a>
et en hors-ligne avec l'installation de Rust qui a été effectuée avec <code>rustup</code> ;
vous pouvez lancer <code>rustup docs --book</code> pour l'ouvrir.</p>
<!--
This text is available in [paperback and ebook format from No Starch
Press][nsprust].
-->
<p>La version anglaise de ce livre est disponible
<a href="https://nostarch.com/rust">au format papier et e-book chez No Starch Press</a>.</p>
<!--
[install]: ch01-01-installation.html
[editions]: appendix-05-editions.html
[nsprust]: https://nostarch.com/rust
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Foreword
-->
<h1 id="avant-propos"><a class="header" href="#avant-propos">Avant-propos</a></h1>
<!--
It wasn’t always so clear, but the Rust programming language is fundamentally
about *empowerment*: no matter what kind of code you are writing now, Rust
empowers you to reach farther, to program with confidence in a wider variety of
domains than you did before.
-->
<p>Cela n'a pas toujours été aussi évident, mais le langage de programmation Rust
apporte avant tout plus de <em>puissance</em> : peu importe le type de code que vous
écrivez en ce moment, Rust vous permet d'aller plus loin et de
programmer en toute confiance dans une plus grande diversité de domaines
qu'auparavant.</p>
<!--
Take, for example, “systems-level” work that deals with low-level details of
memory management, data representation, and concurrency. Traditionally, this
realm of programming is seen as arcane, accessible only to a select few who
have devoted the necessary years learning to avoid its infamous pitfalls. And
even those who practice it do so with caution, lest their code be open to
exploits, crashes, or corruption.
-->
<p>Prenez par exemple la gestion des éléments au “niveau système” qui traite de
détails bas niveau de gestion de mémoire, de modèles de données, et de
concurrence. Traditionnellement, ce domaine de la programmation est jugé
ésotérique, compréhensible uniquement par une poignée de personnes qui ont
consacré des années d'apprentissage à en déjouer les pièges infâmes.
Et même ceux qui travaillent dans ce domaine le font avec beaucoup de prudence,
de crainte que leur code soit soumis à des failles ou des plantages,
ou qu'il soit corrompu.</p>
<!--
Rust breaks down these barriers by eliminating the old pitfalls and providing a
friendly, polished set of tools to help you along the way. Programmers who need
to “dip down” into lower-level control can do so with Rust, without taking on
the customary risk of crashes or security holes, and without having to learn
the fine points of a fickle toolchain. Better yet, the language is designed to
guide you naturally towards reliable code that is efficient in terms of speed
and memory usage.
-->
<p>Rust fait tomber ces obstacles en éliminant les vieux pièges et en apportant un
ensemble d'outils soignés et conviviaux pour vous aider sur votre chemin.
Les développeurs qui ont besoin de &quot;se plonger&quot; dans le contrôle de plus
bas niveau peuvent ainsi le faire avec Rust, sans prendre le risque habituel
de plantages ou de failles de sécurité, et sans avoir à apprendre les subtilités
d'un enchevêtrement d'outils capricieux. Encore mieux, le langage est conçu pour
vous guider naturellement vers un code fiable et efficace en termes de rapidité
d'exécution et d'utilisation de la mémoire.</p>
<!--
Programmers who are already working with low-level code can use Rust to raise
their ambitions. For example, introducing parallelism in Rust is a relatively
low-risk operation: the compiler will catch the classical mistakes for you. And
you can tackle more aggressive optimizations in your code with the confidence
that you won’t accidentally introduce crashes or vulnerabilities.
-->
<p>Les développeurs qui travaillent déjà avec du code bas niveau peuvent utiliser
Rust pour accroître leurs ambitions. Par exemple, introduire du parallélisme en
Rust est une opération à faible risque : le compilateur va détecter les erreurs
classiques pour vous. Et vous pourrez vous lancer dans des améliorations plus
agressives de votre code avec la certitude que vous n'introduirez pas
accidentellement des causes de plantage ou des vulnérabilités.</p>
<!--
But Rust isn’t limited to low-level systems programming. It’s expressive and
ergonomic enough to make CLI apps, web servers, and many other kinds of code
quite pleasant to write — you’ll find simple examples of both later in the
book. Working with Rust allows you to build skills that transfer from one
domain to another; you can learn Rust by writing a web app, then apply those
same skills to target your Raspberry Pi.
-->
<p>Mais Rust n'est pas cantonné à la programmation de bas niveau. C'est un langage
suffisamment expressif et ergonomique pour rendre les applications en ligne
de commande, les serveurs web et bien d'autres types de code agréables à écrire
— vous trouverez plus tard des exemples simples de chacun dans ce livre.
Travailler avec Rust vous permet d'acquérir des compétences qui sont
transposables d'un domaine à un autre ; vous pouvez apprendre Rust en écrivant
une application web, puis appliquer les mêmes notions pour les utiliser avec
votre Raspberry Pi.</p>
<!--
This book fully embraces the potential of Rust to empower its users. It’s a
friendly and approachable text intended to help you level up not just your
knowledge of Rust, but also your reach and confidence as a programmer in
general. So dive in, get ready to learn—and welcome to the Rust community!
-->
<p>Ce livre exploite pleinement le potentiel de Rust pour permettre à ses
utilisateurs de se développer. C'est une documentation conviviale et accessible
destinée à améliorer vos connaissances en Rust, mais aussi à améliorer vos
capacités et votre assurance en tant que développeur en général. Alors foncez,
et préparez-vous à apprendre — et bienvenue dans la communauté Rust !</p>
<!--
— Nicholas Matsakis and Aaron Turon
-->
<p>— Nicholas Matsakis et Aaron Turon</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Introduction
-->
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<!--
> Note: This edition of the book is the same as [The Rust Programming
> Language][nsprust] available in print and ebook format from [No Starch
> Press][nsp].
-->
<blockquote>
<p>Note : la version anglaise de ce livre est disponible au format papier et
ebook chez <a href="https://nostarch.com/">No Starch Press</a> à cette adresse :
<a href="https://nostarch.com/rust">The Rust Programming Language</a></p>
</blockquote>
<!--
[nsprust]: https://nostarch.com/rust
[nsp]: https://nostarch.com/
-->
<!--
Welcome to *The Rust Programming Language*, an introductory book about Rust.
The Rust programming language helps you write faster, more reliable software.
High-level ergonomics and low-level control are often at odds in programming
language design; Rust challenges that conflict. Through balancing powerful
technical capacity and a great developer experience, Rust gives you the option
to control low-level details (such as memory usage) without all the hassle
traditionally associated with such control.
-->
<p>Bienvenue sur <em>Le langage de programmation Rust</em>, un livre d'initiation à Rust.
Le langage de programmation Rust vous aide à écrire plus rapidement des
logiciels plus fiables. L'ergonomie de haut-niveau et la maîtrise de bas-niveau
sont souvent en opposition dans la conception des langages de programmation ;
Rust remet en cause ce conflit. Grâce à l'équilibre entre ses puissantes
capacités techniques et une bonne ergonomie de développement, Rust vous donne
la possibilité de contrôler les détails de bas-niveau (comme l'utilisation de
la mémoire) sans tous les soucis traditionnellement associés à ce genre de
pratique.</p>
<!--
## Who Rust Is For
-->
<h2 id="À-qui-sadresse-rust"><a class="header" href="#À-qui-sadresse-rust">À qui s'adresse Rust</a></h2>
<!--
Rust is ideal for many people for a variety of reasons. Let’s look at a few of
the most important groups.
-->
<p>Rust est idéal pour de nombreuses personnes pour diverses raisons. Analysons
quelques-uns des groupes les plus importants.</p>
<!--
### Teams of Developers
-->
<h3 id="Équipes-de-développeurs"><a class="header" href="#Équipes-de-développeurs">Équipes de développeurs</a></h3>
<!--
Rust is proving to be a productive tool for collaborating among large teams of
developers with varying levels of systems programming knowledge. Low-level code
is prone to a variety of subtle bugs, which in most other languages can be
caught only through extensive testing and careful code review by experienced
developers. In Rust, the compiler plays a gatekeeper role by refusing to
compile code with these elusive bugs, including concurrency bugs. By working
alongside the compiler, the team can spend their time focusing on the program’s
logic rather than chasing down bugs.
-->
<p>Rust se révèle être un outil productif pour la collaboration entre de grandes
équipes de développeurs ayant différents niveaux de connaissances en
programmation système. Le code de bas-niveau est sujet à une multitude de bogues
subtils, qui, dans la plupart des autres langages, ne peuvent être prévenus
qu'au moyen de campagnes de test étendues et de minutieuses revues de
code menées par des développeurs chevronnés. Avec Rust, le compilateur joue le
rôle de gardien en refusant de compiler du code qui comprend ces bogues
discrets et vicieux, y compris les bogues de concurrence. En travaillant avec
le compilateur, l'équipe peut se concentrer sur la logique du programme plutôt
que de traquer les bogues.</p>
<!--
Rust also brings contemporary developer tools to the systems programming world:
-->
<p>Rust offre aussi des outils de développement modernes au monde de la
programmation système :</p>
<!--
* Cargo, the included dependency manager and build tool, makes adding,
  compiling, and managing dependencies painless and consistent across the Rust
  ecosystem.
* Rustfmt ensures a consistent coding style across developers.
* The Rust Language Server powers Integrated Development Environment (IDE)
  integration for code completion and inline error messages.
-->
<ul>
<li>Cargo, l'outil intégré de gestion de dépendances et de compilation, qui
uniformise et facilite l'ajout, la compilation, et la gestion des dépendances
dans l'écosystème Rust.</li>
<li>Rustfmt, qui assure une cohérence de style de codage pour tous les
développeurs.</li>
<li>Le <em>Rust Langage Server</em> alimente les environnements de développement
intégrés (IDE) pour la complétion du code et l'affichage direct des messages
d'erreur.</li>
</ul>
<!--
By using these and other tools in the Rust ecosystem, developers can be
productive while writing systems-level code.
-->
<p>En utilisant ces outils ainsi que d'autres dans l'écosystème Rust, les
développeurs peuvent être plus productifs quand ils écrivent du code système.</p>
<!--
### Students
-->
<h3 id="Étudiants"><a class="header" href="#Étudiants">Étudiants</a></h3>
<!--
Rust is for students and those who are interested in learning about systems
concepts. Using Rust, many people have learned about topics like operating
systems development. The community is very welcoming and happy to answer
student questions. Through efforts such as this book, the Rust teams want to
make systems concepts more accessible to more people, especially those new to
programming.
-->
<p>Rust est conçu pour les étudiants et ceux qui s'intéressent à l'apprentissage
des concepts système. En utilisant Rust, de nombreuses personnes ont appris
des domaines comme le développement de systèmes d'exploitation. La communauté
est très accueillante et répond volontiers aux questions des étudiants. Grâce à
des initiatives comme ce livre, les équipes de Rust veulent rendre les notions
système accessibles au plus grand nombre, particulièrement à ceux qui débutent
dans la programmation.</p>
<!--
### Companies
-->
<h3 id="entreprises"><a class="header" href="#entreprises">Entreprises</a></h3>
<!--
Hundreds of companies, large and small, use Rust in production for a variety of
tasks. Those tasks include command line tools, web services, DevOps tooling,
embedded devices, audio and video analysis and transcoding, cryptocurrencies,
bioinformatics, search engines, Internet of Things applications, machine
learning, and even major parts of the Firefox web browser.
-->
<p>Des centaines d'entreprises, petites et grosses, utilisent Rust en production
pour différentes missions. Ils l'utilisent pour des outils en ligne de commande,
des services web, des outils DevOps, des systèmes embarqués, de l'analyse et de
la conversion audio et vidéo, des cryptomonnaies, de la bio-informatique, des
moteurs de recherche, de l'internet des objets <em>(IoT)</em>, de l'apprentissage
automatique <em>(marchine learning)</em>, et même des parties importantes du navigateur
internet Firefox.</p>
<!--
### Open Source Developers
-->
<h3 id="développeurs-de-logiciel-libre"><a class="header" href="#développeurs-de-logiciel-libre">Développeurs de logiciel libre</a></h3>
<!--
Rust is for people who want to build the Rust programming language, community,
developer tools, and libraries. We’d love to have you contribute to the Rust
language.
-->
<p>Rust est ouvert aux personnes qui veulent développer le langage de programmation
Rust, la communauté, les outils de développement et les bibliothèques. Nous
serions ravis que vous contribuiez au langage Rust.</p>
<!--
### People Who Value Speed and Stability
-->
<h3 id="les-personnes-qui-recherchent-la-rapidité-et-la-stabilité"><a class="header" href="#les-personnes-qui-recherchent-la-rapidité-et-la-stabilité">Les personnes qui recherchent la rapidité et la stabilité</a></h3>
<!--
Rust is for people who crave speed and stability in a language. By speed, we
mean the speed of the programs that you can create with Rust and the speed at
which Rust lets you write them. The Rust compiler’s checks ensure stability
through feature additions and refactoring. This is in contrast to the brittle
legacy code in languages without these checks, which developers are often
afraid to modify. By striving for zero-cost abstractions, higher-level features
that compile to lower-level code as fast as code written manually, Rust
endeavors to make safe code be fast code as well.
-->
<p>Rust est une solution pour les personnes qui chérissent la rapidité et la
stabilité dans un langage. Par rapidité, nous entendons la vitesse des
programmes que vous pouvez créer avec Rust et la rapidité avec laquelle Rust
vous permet de les écrire. Les vérifications du compilateur de Rust assurent la
stabilité durant l'ajout de fonctionnalités ou le remaniement du code. Cela
le démarque des langages qui ne font pas ces contrôles sur du code instable que
le programme a hérité avec le temps, et que bien souvent les développeurs ont
peur de modifier. En s'efforçant de mettre en place des abstractions sans coût,
des fonctionnalités de haut-niveau qui compilent vers du code bas-niveau aussi
rapide que s'il avait été écrit à la main, Rust fait en sorte que le
code sûr soit aussi du code rapide.</p>
<!--
The Rust language hopes to support many other users as well; those mentioned
here are merely some of the biggest stakeholders. Overall, Rust’s greatest
ambition is to eliminate the trade-offs that programmers have accepted for
decades by providing safety *and* productivity, speed *and* ergonomics. Give
Rust a try and see if its choices work for you.
-->
<p>Le langage Rust espère aider beaucoup d'autres utilisateurs ; ceux cités ici ne
font partie que d'un univers bien plus grand. Globalement, la plus grande
ambition de Rust est d'éradiquer les compromis auxquels les développeurs
se soumettaient depuis des décennies en leur apportant sécurité <em>et</em>
productivité, rapidité <em>et</em> ergonomie. Essayez Rust et vérifiez si ses décisions
vous conviennent.</p>
<!--
## Who This Book Is For
-->
<h2 id="À-qui-est-destiné-ce-livre"><a class="header" href="#À-qui-est-destiné-ce-livre">À qui est destiné ce livre</a></h2>
<!--
This book assumes that you’ve written code in another programming language but
doesn’t make any assumptions about which one. We’ve tried to make the material
broadly accessible to those from a wide variety of programming backgrounds. We
don’t spend a lot of time talking about what programming *is* or how to think
about it. If you’re entirely new to programming, you would be better served by
reading a book that specifically provides an introduction to programming.
-->
<p>Ce livre suppose que vous avez écrit du code dans un autre langage de
programmation mais ne suppose pas lequel. Nous avons essayé de rendre son
contenu le plus accessible au plus grand nombre d'expériences de programmation
possible. Nous ne nous évertuons pas à nous questionner sur <em>ce qu'est</em> la
programmation ou comment l'envisager. Si vous êtes débutant en programmation,
vous seriez mieux avisé en lisant un livre qui vous initie à la programmation.</p>
<!--
## How to Use This Book
-->
<h2 id="comment-utiliser-ce-livre"><a class="header" href="#comment-utiliser-ce-livre">Comment utiliser ce livre</a></h2>
<!--
In general, this book assumes that you’re reading it in sequence from front to
back. Later chapters build on concepts in earlier chapters, and earlier
chapters might not delve into details on a topic; we typically revisit the
topic in a later chapter.
-->
<p>Globalement, ce livre est prévu pour être lu dans l'ordre. Les chapitres
suivants s'appuient sur les notions abordées dans les chapitres précédents, et
lorsque les chapitres précédents ne peuvent pas approfondir un sujet, ce sera
généralement fait dans un chapitre suivant.</p>
<!--
You’ll find two kinds of chapters in this book: concept chapters and project
chapters. In concept chapters, you’ll learn about an aspect of Rust. In project
chapters, we’ll build small programs together, applying what you’ve learned so
far. Chapters 2, 12, and 20 are project chapters; the rest are concept chapters.
-->
<p>Vous allez rencontrer deux différents types de chapitres dans ce livre : les
chapitres théoriques et les chapitres de projet. Dans les chapitres théoriques,
vous allez apprendre un sujet à propos de Rust. Dans un chapitre de projet, nous
allons construire ensemble des petits programmes, pour appliquer ce que vous
avez appris précédemment. Les chapitres 2, 12 et 20 sont des chapitres de
projet ; les autres sont des chapitres théoriques.</p>
<!--
Chapter 1 explains how to install Rust, how to write a “Hello, world!” program,
and how to use Cargo, Rust’s package manager and build tool. Chapter 2 is a
hands-on introduction to the Rust language. Here we cover concepts at a high
level, and later chapters will provide additional detail. If you want to get
your hands dirty right away, Chapter 2 is the place for that. At first, you
might even want to skip Chapter 3, which covers Rust features similar to those
of other programming languages, and head straight to Chapter 4 to learn about
Rust’s ownership system. However, if you’re a particularly meticulous learner
who prefers to learn every detail before moving on to the next, you might want
to skip Chapter 2 and go straight to Chapter 3, returning to Chapter 2 when
you’d like to work on a project applying the details you’ve learned.
-->
<p>Le chapitre 1 explique comment installer Rust, comment écrire un programme
&quot;Hello, world!&quot; et comment utiliser Cargo, le gestionnaire de paquets et outil
de compilation. Le chapitre 2 est une initiation pratique au langage Rust. Nous
y aborderons des concepts de haut-niveau, et les chapitres suivants apporteront
plus de détails. Si vous voulez vous <em>salir les mains</em> tout de suite,
le chapitre 2 est l'endroit pour cela. Au début, vous pouvez même sauter le
chapitre 3, qui aborde les fonctionnalités de Rust semblables aux autres
langages de programmation, et passer directement au chapitre 4 pour en savoir
plus sur le système de possession <em>(ownership)</em> de Rust. Toutefois, si vous êtes
un apprenti particulièrement minutieux qui préfère apprendre chaque
particularité avant de passer à la suivante, vous pouvez sauter le chapitre 2 et
passer directement au chapitre 3, puis revenir au chapitre 2 lorsque vous
souhaitez travailler sur un projet en appliquant les notions que vous avez
apprises.</p>
<!--
Chapter 5 discusses structs and methods, and Chapter 6 covers enums, `match`
expressions, and the `if let` control flow construct. You’ll use structs and
enums to make custom types in Rust.
-->
<p>Le chapitre 5 traite des structures et des méthodes, et le chapitre 6 couvre les
énumérations, les expressions <code>match</code>, et la structure de contrôle <code>if let</code>.
Vous emploierez les structures et les énumérations pour créer des types
personnalisés avec Rust.</p>
<!--
In Chapter 7, you’ll learn about Rust’s module system and about privacy rules
for organizing your code and its public Application Programming Interface
(API). Chapter 8 discusses some common collection data structures that the
standard library provides, such as vectors, strings, and hash maps. Chapter 9
explores Rust’s error-handling philosophy and techniques.
-->
<p>Au chapitre 7, vous apprendrez le système de modules de Rust et les règles de
visibilité, afin d'organiser votre code et son interface de programmation
applicative (API) publique. Le chapitre 8 traitera des structures de collections
de données usuelles fournies par la bibliothèque standard, comme les vecteurs,
les chaînes de caractères et les tables de hachage <em>(hash maps)</em>. Le chapitre 9
explorera la philosophie et les techniques de gestion d'erreurs de Rust.</p>
<!--
Chapter 10 digs into generics, traits, and lifetimes, which give you the power
to define code that applies to multiple types. Chapter 11 is all about testing,
which even with Rust’s safety guarantees is necessary to ensure your program’s
logic is correct. In Chapter 12, we’ll build our own implementation of a subset
of functionality from the `grep` command line tool that searches for text
within files. For this, we’ll use many of the concepts we discussed in the
previous chapters.
-->
<p>Le chapitre 10 nous plongera dans la généricité, les <em>traits</em> et
les durées de vie, qui vous donneront la capacité de créer du code qui s'adapte
à différents types. Le chapitre 11 traitera des techniques de test, qui restent
nécessaires malgré les garanties de sécurité de Rust, pour s'assurer que
la logique de votre programme est valide. Au chapitre 12, nous écrirons
notre propre implémentation d'un sous-ensemble des fonctionnalités du programme
en ligne de commande <code>grep</code>, qui recherche du texte dans des fichiers.
Pour ce faire, nous utiliserons de nombreuses notions abordées dans les
chapitres précédents.</p>
<!--
Chapter 13 explores closures and iterators: features of Rust that come from
functional programming languages. In Chapter 14, we’ll examine Cargo in more
depth and talk about best practices for sharing your libraries with others.
Chapter 15 discusses smart pointers that the standard library provides and the
traits that enable their functionality.
-->
<p>Le chapitre 13 explorera les fermetures <em>(closures)</em> et itérateurs : ce sont les
fonctionnalités de Rust inspirées des langages de programmation fonctionnels.
Au chapitre 14, nous explorerons plus en profondeur Cargo et les bonnes
pratiques pour partager vos propres bibliothèques avec les autres. Le chapitre
15 parlera de pointeurs intelligents qu'apporte la bibliothèque standard et des
<em>traits</em> qui activent leurs fonctionnalités.</p>
<!--
In Chapter 16, we’ll walk through different models of concurrent programming
and talk about how Rust helps you to program in multiple threads fearlessly.
Chapter 17 looks at how Rust idioms compare to object-oriented programming
principles you might be familiar with.
-->
<p>Au chapitre 16, nous passerons en revue les différents modes de programmation
concurrente et comment Rust nous aide à développer dans des tâches parallèles
sans crainte. Le chapitre 17 comparera les fonctionnalités de Rust aux
principes de programmation orientée objet, que vous connaissez peut-être.</p>
<!--
Chapter 18 is a reference on patterns and pattern matching, which are powerful
ways of expressing ideas throughout Rust programs. Chapter 19 contains a
smorgasbord of advanced topics of interest, including unsafe Rust, macros, and
more about lifetimes, traits, types, functions, and closures.
-->
<p>Le chapitre 18 est une référence sur les motifs et le filtrage de motif
<em>(pattern matching)</em>, qui sont des moyens puissants permettant de communiquer
des idées dans les programmes Rust. Le chapitre 19 contient une foultitude de
sujets avancés intéressants, comme le code Rust non sécurisé <em>(unsafe)</em>, les
macros et plus de détails sur les durées de vie, les <em>traits</em>, les types, les
fonctions et les fermetures <em>(closures)</em>.</p>
<!--
In Chapter 20, we’ll complete a project in which we’ll implement a low-level
multithreaded web server!
-->
<p>Au chapitre 20, nous terminerons un projet dans lequel nous allons
implémenter en bas-niveau un serveur web multitâches !</p>
<!--
Finally, some appendices contain useful information about the language in a
more reference-like format. Appendix A covers Rust’s keywords, Appendix B
covers Rust’s operators and symbols, Appendix C covers derivable traits
provided by the standard library, Appendix D covers some useful development
tools, and Appendix E explains Rust editions.
-->
<p>Et finalement, quelques annexes qui contiennent des informations utiles sur le
langage sous forme de référentiels qui renvoient à d'autres documents. L'annexe
A liste les mots-clés de Rust, l'annexe B couvre les opérateurs et symboles de
Rust, l'annexe C parle des <em>traits</em> dérivables qu'apporte la bibliothèque
standard, l'annexe D référence certains outils de développement utiles, et
l'annexe E explique les différentes éditions de Rust.</p>
<!--
There is no wrong way to read this book: if you want to skip ahead, go for it!
You might have to jump back to earlier chapters if you experience any
confusion. But do whatever works for you.
-->
<p>Il n'y a pas de mauvaise manière de lire ce livre : si vous voulez sauter des
étapes, allez-y !
Vous devrez alors peut-être revenir sur les chapitres précédents si vous
éprouvez des difficultés. Mais faites comme bon vous semble.</p>
<!--
<span id="ferris"></span>
-->
<p><span id="ferris"></span></p>
<!--
An important part of the process of learning Rust is learning how to read the
error messages the compiler displays: these will guide you toward working code.
As such, we’ll provide many examples that don’t compile along with the error
message the compiler will show you in each situation. Know that if you enter
and run a random example, it may not compile! Make sure you read the
surrounding text to see whether the example you’re trying to run is meant to
error. Ferris will also help you distinguish code that isn’t meant to work:
-->
<p>Une composante importante du processus d'apprentissage de Rust est de comprendre
comment lire les messages d'erreur qu'affiche le compilateur : ils vous
guideront vers du code correct.
Ainsi, nous citerons de nombreux exemples qui ne compilent pas, avec le message
d'erreur que le compilateur devrait vous afficher dans chaque cas. C'est donc
normal que dans certains cas, si vous copiez et exécutez un exemple au hasard,
il ne compile pas ! Assurez-vous d'avoir lu le texte autour pour savoir si
l'exemple que vous tentez de compiler doit échouer. Ferris va aussi vous aider
à identifier du code qui ne devrait pas fonctionner :</p>
<!-- markdownlint-disable -->
<!--
| Ferris                                                                                                           | Meaning                                          |
|------------------------------------------------------------------------------------------------------------------|--------------------------------------------------|
| <img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris with a question mark"/>            | This code does not compile!                      |
| <img src="img/ferris/panics.svg" class="ferris-explain" alt="Ferris throwing up their hands"/>                   | This code panics!                                |
| <img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris with one claw up, shrugging"/> | This code does not produce the desired behavior. |
-->
<!-- markdownlint-restore -->
<table><thead><tr><th>Ferris</th><th>Signification</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris avec un point d'interrogation"/></td><td>Ce code ne compile pas !</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="Ferris qui lève ses bras"/></td><td>Ce code panique !</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris avec une pince en l'air, haussant les épaules"/></td><td>Ce code ne se comporte pas comme voulu.</td></tr>
</tbody></table>
<!--
In most situations, we’ll lead you to the correct version of any code that
doesn’t compile.
-->
<p>Dans la plupart des cas, nous vous guiderons vers la version du code qui devrait
fonctionner.</p>
<!--
## Source Code
-->
<h2 id="code-source"><a class="header" href="#code-source">Code source</a></h2>
<!--
The source files from which this book is generated can be found on
[GitHub][book].
-->
<p>Les fichiers du code source qui a généré ce livre en anglais sont disponibles
sur <a href="https://github.com/rust-lang/book/tree/master/src">GitHub</a>.</p>
<p>La version française est aussi disponible sur <a href="https://github.com/Jimskapt/rust-book-fr">GitHub</a>.</p>
<!--
[book]: https://github.com/rust-lang/book/tree/master/src
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="traduction-des-termes"><a class="header" href="#traduction-des-termes">Traduction des termes</a></h1>
<p>Voici les principaux termes techniques qui ont été traduits de l'anglais vers le
français.</p>
<table><thead><tr><th>Anglais</th><th>Français</th><th>Remarques</th></tr></thead><tbody>
<tr><td>adaptor</td><td>adaptateur</td><td>-</td></tr>
<tr><td>ahead-of-time compilation</td><td>compilation anticipée</td><td>sigle : AOT</td></tr>
<tr><td>alias</td><td>alias</td><td>-</td></tr>
<tr><td>allocated</td><td>alloué</td><td>-</td></tr>
<tr><td>angle bracket</td><td>chevrons</td><td>-</td></tr>
<tr><td>annotate</td><td>indiquer</td><td>-</td></tr>
<tr><td>anti-pattern</td><td>anti-patron</td><td>-</td></tr>
<tr><td>Appendix</td><td>annexe</td><td>tout en minuscule (sauf en début de phrase)</td></tr>
<tr><td>append</td><td>ajouter</td><td>-</td></tr>
<tr><td>Application Programming Interface (API)</td><td>interface de programmation applicative (API)</td><td>-</td></tr>
<tr><td>assertion</td><td>vérification</td><td>-</td></tr>
<tr><td>assign</td><td>assigner</td><td>-</td></tr>
<tr><td>argument</td><td>argument / paramètre</td><td>-</td></tr>
<tr><td>arm</td><td>branche</td><td>dans une expression <code>match</code></td></tr>
<tr><td>array</td><td>tableau</td><td>-</td></tr>
<tr><td>artifact</td><td>artéfact</td><td>-</td></tr>
<tr><td>associated function</td><td>fonction associée</td><td>-</td></tr>
<tr><td>attribute</td><td>attribut</td><td>-</td></tr>
<tr><td>backend</td><td>application dorsale</td><td>-</td></tr>
<tr><td>backtrace</td><td>retraçage</td><td>-</td></tr>
<tr><td>benchmark</td><td>benchmark</td><td>-</td></tr>
<tr><td>binary crate</td><td>crate binaire</td><td>s'utilise au féminin</td></tr>
<tr><td>buffer overread</td><td>lecture hors limites</td><td>-</td></tr>
<tr><td><em>n</em>-bit number</td><td>nombre encodé sur <em>n</em> bits</td><td>-</td></tr>
<tr><td>blanket implementation</td><td>implémentation générale</td><td>-</td></tr>
<tr><td>blob</td><td>blob</td><td>-</td></tr>
<tr><td>boilerplate code</td><td>code standard</td><td>-</td></tr>
<tr><td>boolean</td><td>booléen</td><td>-</td></tr>
<tr><td>borrow</td><td>emprunt(er)</td><td>-</td></tr>
<tr><td>borrow checker</td><td>vérificateur d'emprunt</td><td>-</td></tr>
<tr><td>box</td><td>boite</td><td>-</td></tr>
<tr><td>buffer overread</td><td>sur-lecture de tampon</td><td>-</td></tr>
<tr><td>bug</td><td>bogue</td><td>-</td></tr>
<tr><td>build</td><td>compilation</td><td>-</td></tr>
<tr><td>build system</td><td>système de compilation</td><td>-</td></tr>
<tr><td>byte</td><td>octet</td><td>-</td></tr>
<tr><td>Cargo</td><td>Cargo</td><td>-</td></tr>
<tr><td>catchall value</td><td>valeur passe-partout</td><td>-</td></tr>
<tr><td>channel</td><td>canal</td><td>-</td></tr>
<tr><td>Chapter</td><td>chapitre</td><td>tout en minuscule (sauf en début de phrase)</td></tr>
<tr><td>CI system</td><td>système d'Intégration Continue</td><td>-</td></tr>
<tr><td>clause</td><td>clause</td><td>-</td></tr>
<tr><td>cleanup</td><td>nettoyage</td><td>-</td></tr>
<tr><td>closure</td><td>fermeture</td><td>-</td></tr>
<tr><td>code review</td><td>revue de code</td><td>-</td></tr>
<tr><td>coercion</td><td>extrapolation</td><td>-</td></tr>
<tr><td>collection</td><td>collection</td><td>-</td></tr>
<tr><td>command</td><td>commande</td><td>dans un terminal</td></tr>
<tr><td>commit</td><td>commit</td><td>-</td></tr>
<tr><td>compound</td><td>composé</td><td>-</td></tr>
<tr><td>concept chapter</td><td>chapitre théorique</td><td>-</td></tr>
<tr><td>concurrency</td><td>concurrence</td><td>-</td></tr>
<tr><td>concurrent</td><td>concurrent</td><td>-</td></tr>
<tr><td>concurrent programming</td><td>programmation concurrente</td><td>-</td></tr>
<tr><td>conditional</td><td>structure conditionnelle</td><td>-</td></tr>
<tr><td>cons list</td><td>liste de construction</td><td>-</td></tr>
<tr><td>constant</td><td>constant / constante</td><td>-</td></tr>
<tr><td>construct</td><td>instruction</td><td>-</td></tr>
<tr><td>consuming adaptor</td><td>adaptateur de consommation</td><td>-</td></tr>
<tr><td>constructor</td><td>constructeur</td><td>-</td></tr>
<tr><td>control flow construct</td><td>structure de contrôle</td><td>-</td></tr>
<tr><td>core of the error</td><td>message d'erreur</td><td>-</td></tr>
<tr><td>corruption</td><td>corruption / être corrompu</td><td>-</td></tr>
<tr><td>CPU</td><td>processeur</td><td>-</td></tr>
<tr><td>crash</td><td>plantage</td><td>-</td></tr>
<tr><td>crate</td><td>crate</td><td>nom féminin (une <em>crate</em>)</td></tr>
<tr><td>curly bracket</td><td>accolade</td><td>-</td></tr>
<tr><td>dangling</td><td>pendouillant</td><td>-</td></tr>
<tr><td>data race</td><td>accès concurrent</td><td>-</td></tr>
<tr><td>data representation</td><td>modèle de données</td><td>-</td></tr>
<tr><td>deadlock</td><td>interblocage</td><td>-</td></tr>
<tr><td>deallocate</td><td>désalloué</td><td>-</td></tr>
<tr><td>debug</td><td>déboguer</td><td>-</td></tr>
<tr><td>debugging</td><td>débogage</td><td>-</td></tr>
<tr><td>deep copy</td><td>copie en profondeur</td><td>-</td></tr>
<tr><td>dependency</td><td>dépendance</td><td>-</td></tr>
<tr><td>deref coercion</td><td>extrapolation de déréferencement</td><td>-</td></tr>
<tr><td>dereference operator</td><td>opérateur de déréférencement</td><td>-</td></tr>
<tr><td>dereferencing</td><td>déréférencement</td><td>-</td></tr>
<tr><td>design pattern</td><td>patron de conception</td><td>-</td></tr>
<tr><td>destructor</td><td>destructeur</td><td>-</td></tr>
<tr><td>destructure</td><td>déstructurer</td><td>-</td></tr>
<tr><td>DevOps</td><td>DevOps</td><td>-</td></tr>
<tr><td>directory</td><td>dossier</td><td>-</td></tr>
<tr><td>dot notation</td><td>la notation avec un point</td><td>-</td></tr>
<tr><td>double free</td><td>double libération</td><td>-</td></tr>
<tr><td>drop</td><td>libérér</td><td>-</td></tr>
<tr><td>elision</td><td>élision</td><td>-</td></tr>
<tr><td>enum</td><td>énumération</td><td>-</td></tr>
<tr><td>enumeration</td><td>énumération</td><td>-</td></tr>
<tr><td>enum’s variant</td><td>variante d'énumération</td><td>-</td></tr>
<tr><td>exploit</td><td>faille</td><td>-</td></tr>
<tr><td>expression</td><td>expression</td><td>-</td></tr>
<tr><td>field</td><td>champ</td><td>d'une structure</td></tr>
<tr><td>Figure</td><td>Illustration</td><td>-</td></tr>
<tr><td>flag</td><td>drapeau</td><td>pour les programmes en ligne de commande</td></tr>
<tr><td>float</td><td>nombre à virgule flottante</td><td>-</td></tr>
<tr><td>floating-point number</td><td>nombre à virgule flottante</td><td>-</td></tr>
<tr><td>framework</td><td>environnement de développement</td><td>-</td></tr>
<tr><td>frontend</td><td>application frontale</td><td>-</td></tr>
<tr><td>fully qualified syntax</td><td>syntaxe totalement définie</td><td>-</td></tr>
<tr><td>function</td><td>fonction</td><td>-</td></tr>
<tr><td>functional programming</td><td>programmation fonctionnelle</td><td>-</td></tr>
<tr><td>garbage collector</td><td>ramasse-miettes</td><td>-</td></tr>
<tr><td>generics</td><td>génériques / généricité</td><td>-</td></tr>
<tr><td>generic type parameter</td><td>paramètre de type générique</td><td>-</td></tr>
<tr><td>getter</td><td>accesseur</td><td>-</td></tr>
<tr><td>glob</td><td>global</td><td>opérateur</td></tr>
<tr><td>global scope</td><td>portée globale</td><td>-</td></tr>
<tr><td>grapheme cluster</td><td>groupe de graphèmes</td><td>-</td></tr>
<tr><td>green thread</td><td>tâche virtuelle</td><td>-</td></tr>
<tr><td>guessing game</td><td>jeu de devinettes</td><td>-</td></tr>
<tr><td>handle</td><td>référence abstraite</td><td>-</td></tr>
<tr><td>hash</td><td>hash / relatif au hachage</td><td>-</td></tr>
<tr><td>hash map</td><td>table de hachage</td><td>-</td></tr>
<tr><td>heap</td><td>tas</td><td>-</td></tr>
<tr><td>Hello, world!</td><td>Hello, world!</td><td>-</td></tr>
<tr><td>high-level</td><td>haut niveau</td><td>-</td></tr>
<tr><td>identifier</td><td>identificateur</td><td>-</td></tr>
<tr><td>idiomatic</td><td>idéal</td><td>-</td></tr>
<tr><td>immutability</td><td>immuabilité</td><td>-</td></tr>
<tr><td>immutable</td><td>immuable</td><td>-</td></tr>
<tr><td>index</td><td>indice</td><td>-</td></tr>
<tr><td>indexing</td><td>indexation</td><td>-</td></tr>
<tr><td>input/output</td><td>entrée/sortie</td><td>sigle : IO</td></tr>
<tr><td>instance</td><td>instance</td><td>-</td></tr>
<tr><td>instantiate</td><td>instancier</td><td>créer une instance</td></tr>
<tr><td>integer literal</td><td>littéral d'entiers</td><td>-</td></tr>
<tr><td>integer overflow</td><td>dépassement d'entier</td><td>-</td></tr>
<tr><td>Integrated Development Environment (IDE)</td><td>environnement de développement intégré (IDE)</td><td>-</td></tr>
<tr><td>interior mutability</td><td>mutabilité interne</td><td>-</td></tr>
<tr><td>interrupt signal</td><td>signal d'arrêt</td><td>-</td></tr>
<tr><td>invalidate</td><td>neutraliser</td><td>-</td></tr>
<tr><td>IOT</td><td>internet des objets (IOT)</td><td>-</td></tr>
<tr><td>iterator</td><td>itérateur</td><td>-</td></tr>
<tr><td>iterator adaptor</td><td>adaptateur d'itération</td><td>-</td></tr>
<tr><td>job</td><td>mission</td><td>-</td></tr>
<tr><td>just-in-time compilation</td><td>compilation à la volée</td><td>sigle : JIT</td></tr>
<tr><td>keyword</td><td>mot-clé</td><td>-</td></tr>
<tr><td>lazy</td><td>évaluation paresseuse</td><td>comportement d'un itérateur</td></tr>
<tr><td>legacy code</td><td>code instable que le programme a hérité avec le temps</td><td>-</td></tr>
<tr><td>library</td><td>bibliothèque</td><td>-</td></tr>
<tr><td>library crate</td><td>crate de bibliothèque</td><td>s'utilise au féminin</td></tr>
<tr><td>lifetime</td><td>durée de vie</td><td>-</td></tr>
<tr><td>linker</td><td>linker</td><td>-</td></tr>
<tr><td>linter</td><td>analyse statique</td><td>-</td></tr>
<tr><td>literal value</td><td>valeur littérale</td><td>-</td></tr>
<tr><td>Listing</td><td>encart</td><td>tout en minuscule (sauf en début de phrase)</td></tr>
<tr><td>loop</td><td>boucle</td><td>-</td></tr>
<tr><td>low-level</td><td>bas niveau</td><td>-</td></tr>
<tr><td>machine learning</td><td>apprentissage automatique</td><td>-</td></tr>
<tr><td>macro</td><td>macro</td><td>-</td></tr>
<tr><td>main</td><td>main</td><td>-</td></tr>
<tr><td>map</td><td>tableau associatif</td><td>-</td></tr>
<tr><td>match guard</td><td>contrôle de correspondance</td><td>-</td></tr>
<tr><td>memory leak</td><td>fuite de mémoire</td><td>-</td></tr>
<tr><td>memory management</td><td>gestion de mémoire</td><td>-</td></tr>
<tr><td>message-passing</td><td>passage de messages</td><td>-</td></tr>
<tr><td>method</td><td>méthode</td><td>-</td></tr>
<tr><td>mock object</td><td>mock object</td><td>-</td></tr>
<tr><td>modern</td><td>récent</td><td>-</td></tr>
<tr><td>module</td><td>module</td><td>-</td></tr>
<tr><td>module system</td><td>système de modules</td><td>-</td></tr>
<tr><td>monomorphization</td><td>monomorphisation</td><td>-</td></tr>
<tr><td>move</td><td>déplacement</td><td>-</td></tr>
<tr><td>mutability</td><td>mutabilité</td><td>-</td></tr>
<tr><td>mutable</td><td>mutable</td><td>modifiable</td></tr>
<tr><td>mutate</td><td>muter</td><td>-</td></tr>
<tr><td>namespace</td><td>espace de nom</td><td>-</td></tr>
<tr><td>namespacing</td><td>l'espace de nom</td><td>-</td></tr>
<tr><td>nested (path)</td><td>(chemin) imbriqué</td><td>-</td></tr>
<tr><td>nightly Rust</td><td>version expérimentale de Rust</td><td>-</td></tr>
<tr><td>Note</td><td>remarque</td><td>tout en minuscule (sauf en début de phrase)</td></tr>
<tr><td>numerical characters</td><td>chiffres</td><td>-</td></tr>
<tr><td>object-oriented language</td><td>langage orienté objet</td><td>-</td></tr>
<tr><td>operating system</td><td>système d'exploitation</td><td>-</td></tr>
<tr><td>output</td><td>sortie</td><td>-</td></tr>
<tr><td>overload</td><td>surcharge</td><td>-</td></tr>
<tr><td>owner</td><td>propriétaire</td><td>-</td></tr>
<tr><td>ownership</td><td>possession</td><td>-</td></tr>
<tr><td>package manager</td><td>système de gestion de paquets</td><td>-</td></tr>
<tr><td>panic</td><td>panique(r)</td><td>-</td></tr>
<tr><td>parallelism</td><td>parallélisme</td><td>-</td></tr>
<tr><td>parallel programming</td><td>parallélisme</td><td>-</td></tr>
<tr><td>parameter</td><td>paramètre</td><td>-</td></tr>
<tr><td>parse</td><td>interpréter</td><td>-</td></tr>
<tr><td>PATH</td><td>PATH</td><td>-</td></tr>
<tr><td>pattern</td><td>motif</td><td>-</td></tr>
<tr><td>pattern-matching</td><td>filtrage par motif</td><td>-</td></tr>
<tr><td>placeholder</td><td>espace réservé</td><td><code>{}</code> pour <code>fmt</code></td></tr>
<tr><td>pointer</td><td>pointeur</td><td>-</td></tr>
<tr><td>popping off the stack</td><td>dépiler</td><td>-</td></tr>
<tr><td>prelude</td><td>étape préliminaire</td><td>-</td></tr>
<tr><td>primitive obsession</td><td>obsession primitive</td><td>-</td></tr>
<tr><td>privacy</td><td>visibilité</td><td>en parlant des éléments d'un module</td></tr>
<tr><td>procedural macro</td><td>macro procédurale</td><td>-</td></tr>
<tr><td>process</td><td>processus</td><td>-</td></tr>
<tr><td>project chapter</td><td>chapitre de projet</td><td>-</td></tr>
<tr><td>propagate</td><td>propager</td><td>-</td></tr>
<tr><td>pushing onto the stack</td><td>empiler</td><td>-</td></tr>
<tr><td>race condition</td><td>situation de concurrence</td><td>-</td></tr>
<tr><td>raw identifier</td><td>identificateur brut</td><td>-</td></tr>
<tr><td>README</td><td>README</td><td>-</td></tr>
<tr><td>recursive type</td><td>type récursif</td><td>-</td></tr>
<tr><td>refactoring</td><td>remaniement</td><td>-</td></tr>
<tr><td>reference</td><td>référence</td><td>-</td></tr>
<tr><td>reference counting</td><td>compteur de références</td><td>-</td></tr>
<tr><td>reference cycle</td><td>boucle de références</td><td>-</td></tr>
<tr><td>release</td><td>publication</td><td>-</td></tr>
<tr><td>registry</td><td>registre</td><td>-</td></tr>
<tr><td>regression</td><td>régression</td><td>-</td></tr>
<tr><td>remainder</td><td>modulo</td><td>opération <code>%</code></td></tr>
<tr><td>reproducible build</td><td>compilation reproductible</td><td>-</td></tr>
<tr><td>Resource Acquisition Is Initialization (RAII)</td><td>l'acquisition d'une ressource est une initialisation (RAII)</td><td>-</td></tr>
<tr><td>return</td><td>retourner</td><td>-</td></tr>
<tr><td>run</td><td>exécuter</td><td>pour les programmes</td></tr>
<tr><td>Rustacean</td><td>Rustacé</td><td>-</td></tr>
<tr><td>section header</td><td>entête de section</td><td>-</td></tr>
<tr><td>semantic version</td><td>version sémantique</td><td>-</td></tr>
<tr><td>scalar</td><td>scalaire</td><td>-</td></tr>
<tr><td>scope</td><td>portée</td><td>-</td></tr>
<tr><td>script</td><td>script</td><td>-</td></tr>
<tr><td>secret</td><td>secret</td><td>-</td></tr>
<tr><td>section header</td><td>en-tête de section</td><td>-</td></tr>
<tr><td>semantic version</td><td>version sémantique</td><td>-</td></tr>
<tr><td>semantic versioning</td><td>versionnage sémantique</td><td>abréviation : SemVer</td></tr>
<tr><td>shadow</td><td>masquer</td><td>remplacer une variable par une autre de même nom</td></tr>
<tr><td>shadowing</td><td>masquage</td><td>-</td></tr>
<tr><td>shallow copy</td><td>copie superficielle</td><td>-</td></tr>
<tr><td>shell</td><td>terminal / invite de commande</td><td>-</td></tr>
<tr><td>shorthand</td><td>abréviation</td><td>-</td></tr>
<tr><td>sidebar</td><td>volet latéral</td><td>-</td></tr>
<tr><td>signature</td><td>signature</td><td>d'une fonction</td></tr>
<tr><td>signed</td><td>signé</td><td>-</td></tr>
<tr><td>slash</td><td>barre oblique</td><td>-</td></tr>
<tr><td>slice</td><td>slice</td><td>-</td></tr>
<tr><td>smart pointer</td><td>pointeur intelligent</td><td>-</td></tr>
<tr><td>snake case</td><td>snake case</td><td>-</td></tr>
<tr><td>snip</td><td>partie masquée ici</td><td>dans un encart</td></tr>
<tr><td>space</td><td>espace</td><td>ce mot est féminin quand on parle du caractère typographique</td></tr>
<tr><td>square brackets</td><td>crochets</td><td>-</td></tr>
<tr><td>stack</td><td>pile</td><td>-</td></tr>
<tr><td>stack overflow</td><td>débordement de pile</td><td>-</td></tr>
<tr><td>standard</td><td>standard <em>(adj. inv.)</em> / norme <em>(n.f.)</em></td><td>-</td></tr>
<tr><td>standard error</td><td>erreur standard</td><td>-</td></tr>
<tr><td>standard input</td><td>entrée standard</td><td>-</td></tr>
<tr><td>standard library</td><td>bibliothèque standard</td><td>-</td></tr>
<tr><td>standard output</td><td>sortie standard</td><td>-</td></tr>
<tr><td>statement</td><td>instruction</td><td>-</td></tr>
<tr><td>statically typed</td><td>statiquement typé</td><td>-</td></tr>
<tr><td>string</td><td>chaîne de caractères</td><td>-</td></tr>
<tr><td>string literal</td><td>un littéral de chaîne de caractères</td><td>-</td></tr>
<tr><td><code>String</code></td><td><code>String</code></td><td>nom féminin (une <code>String</code>)</td></tr>
<tr><td>struct</td><td>structure</td><td>-</td></tr>
<tr><td>submodule</td><td>sous-module</td><td>-</td></tr>
<tr><td>supertrait</td><td>supertrait</td><td>-</td></tr>
<tr><td>syntax sugar</td><td>sucre syntaxique</td><td>-</td></tr>
<tr><td>systems concept</td><td>notion système</td><td>-</td></tr>
<tr><td>systems-level</td><td>niveau système</td><td>-</td></tr>
<tr><td>systems-level code</td><td>code système</td><td>-</td></tr>
<tr><td>terminal</td><td>terminal</td><td>-</td></tr>
<tr><td>thread</td><td>tâche</td><td>-</td></tr>
<tr><td>token</td><td>jeton</td><td>-</td></tr>
<tr><td>test double</td><td>double de test</td><td>-</td></tr>
<tr><td>thread pool</td><td>groupe de tâches</td><td>-</td></tr>
<tr><td>trait</td><td>trait</td><td>-</td></tr>
<tr><td>trait bound</td><td>trait lié</td><td>-</td></tr>
<tr><td>trait object</td><td>objet trait</td><td>-</td></tr>
<tr><td>tree</td><td>arborescence</td><td>-</td></tr>
<tr><td>troubleshooting</td><td>dépannage</td><td>-</td></tr>
<tr><td>tuple</td><td>tuple</td><td>-</td></tr>
<tr><td>tuple struct</td><td>structure tuple</td><td>-</td></tr>
<tr><td>tuple enum</td><td>énumération tuple</td><td>-</td></tr>
<tr><td>type</td><td>type</td><td>-</td></tr>
<tr><td>type annotation</td><td>annotation de type</td><td>-</td></tr>
<tr><td>type inference</td><td>inférence de types</td><td>-</td></tr>
<tr><td>two’s complement</td><td>complément à deux</td><td>-</td></tr>
<tr><td>two’s complement wrapping</td><td>rebouclage du complément à deux</td><td>-</td></tr>
<tr><td>underlying operating system</td><td>système d'exploitation sous-jacent</td><td>-</td></tr>
<tr><td>underscore</td><td>tiret bas</td><td>le caractère <code>_</code></td></tr>
<tr><td>unit-like struct</td><td>structure unité</td><td>-</td></tr>
<tr><td>unit type</td><td>type unité</td><td>le <code>()</code></td></tr>
<tr><td>unit value</td><td>valeur unité</td><td>-</td></tr>
<tr><td>unrolling</td><td>déroulage</td><td>pour une boucle à taille connue à la compilation</td></tr>
<tr><td>unsafe</td><td>non sécurisé</td><td>-</td></tr>
<tr><td>unsigned</td><td>sans signe (toujours positif)</td><td>-</td></tr>
<tr><td>unsigned</td><td>non signé</td><td>-</td></tr>
<tr><td>unwind</td><td>dérouler</td><td>(la pile)</td></tr>
<tr><td>user input</td><td>saisie utilisateur</td><td>-</td></tr>
<tr><td>variable</td><td>variable</td><td>-</td></tr>
<tr><td>variant</td><td>variante</td><td>d'une énumération</td></tr>
<tr><td>vector</td><td>vecteur</td><td>-</td></tr>
<tr><td>version control system (VCS)</td><td>système de gestion de versions (VCS)</td><td>-</td></tr>
<tr><td>vertical pipe</td><td>barre verticale</td><td>la barre `</td></tr>
<tr><td>warning</td><td>avertissement</td><td>-</td></tr>
<tr><td>weak reference</td><td>pointeur faible</td><td>-</td></tr>
<tr><td>wildcard</td><td>joker</td><td>-</td></tr>
<tr><td>worker</td><td>opérateur</td><td>-</td></tr>
<tr><td>workspace</td><td>espace de travail</td><td>-</td></tr>
<tr><td>yank</td><td>déprécier</td><td>-</td></tr>
<tr><td>zero-cost abstraction</td><td>abstraction sans coût</td><td>-</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><!--
# Getting Started
-->
<h1 id="prise-en-main"><a class="header" href="#prise-en-main">Prise en main</a></h1>
<!--
Let’s start your Rust journey! There’s a lot to learn, but every journey starts
somewhere. In this chapter, we’ll discuss:
-->
<p>Démarrons notre périple avec Rust ! Il y a beaucoup à apprendre, mais chaque
aventure doit commencer quelque part. Dans ce chapitre, nous allons aborder :</p>
<!--
* Installing Rust on Linux, macOS, and Windows
* Writing a program that prints `Hello, world!`
* Using `cargo`, Rust’s package manager and build system
-->
<ul>
<li>L'installation de Rust sur Linux, macOS et Windows</li>
<li>L'écriture d'un programme qui affiche <code>Hello, world!</code></li>
<li>L'utilisation de <code>cargo</code>, le gestionnaire de paquets et système de compilation
de Rust</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
## Installation
-->
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<!--
The first step is to install Rust. We’ll download Rust through `rustup`, a
command line tool for managing Rust versions and associated tools. You’ll need
an internet connection for the download.
-->
<p>La première étape consiste à installer Rust. Nous allons télécharger Rust via
<code>rustup</code>, un outil en ligne de commande conçu pour gérer les versions de Rust et
les outils qui leur sont associés. Vous allez avoir besoin d'une connexion
Internet pour le téléchargement.</p>
<!--
> Note: If you prefer not to use `rustup` for some reason, please see the
> [Other Rust Installation Methods page][install] for more options.
-->
<blockquote>
<p>Note : si vous préférez ne pas utiliser <code>rustup</code> pour une raison ou une autre,
vous pouvez vous référer à
[la page des autres moyens d'installation de Rust][rust-installation-page]
pour d'autres méthodes d'installation.</p>
</blockquote>
<!--
[install]: https://forge.rust-lang.org/infra/other-installation-methods.html
-->
<!--
The following steps install the latest stable version of the Rust compiler.
Rust’s stability guarantees ensure that all the examples in the book that
compile will continue to compile with newer Rust versions. The output might
differ slightly between versions, because Rust often improves error messages
and warnings. In other words, any newer, stable version of Rust you install
using these steps should work as expected with the content of this book.
-->
<p>L'étape suivante est d'installer la dernière version stable du compilateur Rust.
La garantie de stabilité de Rust assurera que tous les exemples dans le livre
qui se compilent bien vont continuer à se compiler avec les nouvelles versions
de Rust. La sortie peut varier légèrement d'une version à une autre, car Rust
améliore souvent les messages d'erreur et les avertissements. En résumé, toute
nouvelle version stable de Rust que vous installez de cette manière devrait
fonctionner en cohérence avec le contenu de ce livre.</p>
<!--
> ### Command Line Notation
>
> In this chapter and throughout the book, we’ll show some commands used in the
> terminal. Lines that you should enter in a terminal all start with `$`. You
> don’t need to type in the `$` character; it indicates the start of each
> command. Lines that don’t start with `$` typically show the output of the
> previous command. Additionally, PowerShell-specific examples will use `>`
> rather than `$`.
-->
<blockquote>
<h3 id="la-notation-en-ligne-de-commande"><a class="header" href="#la-notation-en-ligne-de-commande">La notation en ligne de commande</a></h3>
<p>Dans ce chapitre et les suivants dans le livre, nous allons montrer quelques
commandes tapées dans le terminal. Les lignes que vous devrez écrire dans le
terminal commencent toutes par <code>$</code>. Vous n'avez pas besoin d'écrire le
caractère <code>$</code>; il marque le début de chaque commande. Les lignes qui ne
commencent pas par <code>$</code> montrent généralement le résultat de la commande
précédente. De plus, les exemples propres à PowerShell utiliseront
<code>&gt;</code> plutôt que <code>$</code>.</p>
</blockquote>
<!--
### Installing `rustup` on Linux or macOS
-->
<h3 id="installer-rustup-sur-linux-ou-macos"><a class="header" href="#installer-rustup-sur-linux-ou-macos">Installer <code>rustup</code> sur Linux ou macOS</a></h3>
<!--
If you’re using Linux or macOS, open a terminal and enter the following command:
-->
<p>Si vous utilisez Linux ou macOS, ouvrez un terminal et écrivez la commande
suivante :</p>
<!--
```console
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
```
-->
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<!--
The command downloads a script and starts the installation of the `rustup`
tool, which installs the latest stable version of Rust. You might be prompted
for your password. If the install is successful, the following line will appear:
-->
<p>Cette commande télécharge un script et lance l'installation de l'outil <code>rustup</code>,
qui va installer la dernière version stable de Rust. Il est possible que l'on
vous demande votre mot de passe. Si l'installation se déroule bien, vous
devriez voir la ligne suivante s'afficher :</p>
<!--
```text
Rust is installed now. Great!
```
-->
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<!--
You will also need a linker, which is a program that Rust uses to join its
compiled outputs into one file. It is likely you already have one. If you get
linker errors, you should install a C compiler, which will typically include a
linker. A C compiler is also useful because some common Rust packages depend on
C code and will need a C compiler.
-->
<p>Vous aurez aussi besoin d'un <em>linker</em>, qui est un programme que Rust utilise
pour regrouper ses multiples résultats de compilation dans un unique fichier.
Il est probable que vous en ayez déjà un d'installé, mais si vous avez des
erreurs à propos du <em>linker</em>, cela veut dire vous devrez installer un
compilateur de langage C, qui inclura généralement un <em>linker</em>. Un compilateur
est parfois utile car certains paquets Rust communs nécessitent du code C et
auront besoin d'un compilateur C.</p>
<!--
On macOS, you can get a C compiler by running:
-->
<p>Sur macOS, vous pouvez obtenir un compilateur C en lançant la commande :</p>
<!--
```console
$ xcode-select --install
```
-->
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<!--
Linux users should generally install GCC or Clang, according to their
distribution’s documentation. For example, if you use Ubuntu, you can install
the `build-essential` package.
-->
<p>Les utilisateurs de Linux doivent généralement install GCC ou Clang, en fonction
de la documentation de leur distribution. Par exemple, si vous utilisez Ubuntu,
vous pouvez installer le paquet <code>build-essential</code>.</p>
<!--
### Installing `rustup` on Windows
-->
<h3 id="installer-rustup-sous-windows"><a class="header" href="#installer-rustup-sous-windows">Installer <code>rustup</code> sous Windows</a></h3>
<!--
On Windows, go to [https://www.rust-lang.org/tools/install][install] and follow
the instructions for installing Rust. At some point in the installation, you’ll
receive a message explaining that you’ll also need the C++ build tools for
Visual Studio 2013 or later. The easiest way to acquire the build tools is to
install [Build Tools for Visual Studio 2019][visualstudio]. When asked which
workloads to install make sure “C++ build tools” is selected and that the
Windows 10 SDK and the English language pack components are included.
-->
<p>Sous Windows, il faut aller sur
<a href="https://forge.rust-lang.org/infra/other-installation-methods.html">https://www.rust-lang.org/tools/install</a> et suivre les instructions
pour installer Rust. À un moment donné durant l'installation, vous aurez un
message vous expliquant qu'il va vous falloir l'outil de compilation C++
pour Visual Studio 2013 ou plus récent. La méthode la plus facile pour obtenir
les outils de compilation est d'installer
<a href="https://visualstudio.microsoft.com/fr/visual-cpp-build-tools/">Build Tools pour Visual Studio 2019</a>. Lorsque vous aurez à
sélectionner les composants à installer, assurez-vous que les “Outils de
compilation C++” sont bien sélectionnés, et que le SDK Windows 10 et les paquets
de langage Anglais sont bien inclus.</p>
<!--
[install]: https://www.rust-lang.org/tools/install
[visualstudio]: https://visualstudio.microsoft.com/visual-cpp-build-tools/

FR translation: the website redirects to French version, we lose the "id" link.
Fix is directly below:
-->
<!--
The rest of this book uses commands that work in both *cmd.exe* and PowerShell.
If there are specific differences, we’ll explain which to use.
-->
<p>La suite de ce livre utilisera des commandes qui fonctionnent à la fois dans
<em>cmd.exe</em> et PowerShell. S'il y a des différences particulières, nous vous
expliquerons lesquelles utiliser.</p>
<!--
### Updating and Uninstalling
-->
<h3 id="mettre-à-jour-et-désinstaller"><a class="header" href="#mettre-à-jour-et-désinstaller">Mettre à jour et désinstaller</a></h3>
<!--
After you’ve installed Rust via `rustup`, updating to the latest version is
easy. From your shell, run the following update script:
-->
<p>Après avoir installé Rust avec <code>rustup</code>, la mise à jour vers la dernière version
est facile. Dans votre terminal, lancez le script de mise à jour suivant :</p>
<!--
```console
$ rustup update
```
-->
<pre><code class="language-console">$ rustup update
</code></pre>
<!--
To uninstall Rust and `rustup`, run the following uninstall script from your
shell:
-->
<p>Pour désinstaller Rust et <code>rustup</code>, exécutez le script de désinstallation
suivant dans votre terminal :</p>
<!--
```console
$ rustup self uninstall
```
-->
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<!--
### Troubleshooting
-->
<h3 id="dépannage"><a class="header" href="#dépannage">Dépannage</a></h3>
<!--
To check whether you have Rust installed correctly, open a shell and enter this
line:
-->
<p>Pour vérifier si Rust est correctement installé, ouvrez un terminal et entrez
cette ligne :</p>
<!--
```console
$ rustc --version
```
-->
<pre><code class="language-console">$ rustc --version
</code></pre>
<!--
You should see the version number, commit hash, and commit date for the latest
stable version that has been released in the following format:
-->
<p>Vous devriez voir le numéro de version, le <em>hash</em> de <em>commit</em>,
et la date de <em>commit</em> de la dernière version stable qui a été publiée,
au format suivant :</p>
<!--
```text
rustc x.y.z (abcabcabc yyyy-mm-dd)
```
-->
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<!--
If you see this information, you have installed Rust successfully! If you don’t
see this information and you’re on Windows, check that Rust is in your `%PATH%`
system variable. If that’s all correct and Rust still isn’t working, there are
a number of places you can get help. The easiest is the #beginners channel on
[the official Rust Discord][discord]. There, you can chat with other Rustaceans
(a silly nickname we call ourselves) who can help you out. Other great
resources include [the Users forum][users] and [Stack Overflow][stackoverflow].
-->
<p>Si vous voyez cette information, c'est que vous avez installé Rust avec succès !
Si vous ne voyez pas cette information et que vous êtes sous Windows, vérifiez
que Rust est présent dans votre variable d'environnement système <code>%PATH%</code>. Si
tout est correct et que Rust ne fonctionne toujours pas, il y a quelques
endroits où vous pourrez trouver de l'aide. Le plus accessible est le
canal #beginners sur le <a href="https://discord.gg/rust-lang">Discord officiel de Rust</a>. Là-bas, vous pouvez
dialoguer en ligne avec d'autres <em>Rustacés</em> (un surnom ridicule que nous nous
donnons entre nous) qui pourront vous aider. D'autres bonnes sources de données
sont <a href="https://users.rust-lang.org/">le forum d'utilisateurs</a> et <a href="https://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<!--
[discord]: https://discord.gg/rust-lang
[users]: https://users.rust-lang.org/
[stackoverflow]: https://stackoverflow.com/questions/tagged/rust
-->
<!--
### Local Documentation
-->
<h3 id="documentation-en-local"><a class="header" href="#documentation-en-local">Documentation en local</a></h3>
<!--
The installation of Rust also includes a copy of the documentation locally, so
you can read it offline. Run `rustup doc` to open the local documentation in
your browser.
-->
<p>L'installation de Rust embarque aussi une copie de la documentation en local
pour que vous puissiez la lire hors ligne. Lancez <code>rustup doc</code> afin d'ouvrir la
documentation locale dans votre navigateur.</p>
<!--
Any time a type or function is provided by the standard library and you’re not
sure what it does or how to use it, use the application programming interface
(API) documentation to find out!
-->
<p>À chaque fois que vous n'êtes pas sûr de ce que fait un type ou une fonction
fournie par la bibliothèque standard ou que vous ne savez pas comment
l'utiliser, utilisez cette documentation de l'interface de programmation
applicative <em>(API)</em> pour le savoir !</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Hello, World!
-->
<h2 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h2>
<!--
Now that you’ve installed Rust, let’s write your first Rust program. It’s
traditional when learning a new language to write a little program that prints
the text `Hello, world!` to the screen, so we’ll do the same here!
-->
<p>Maintenant que vous avez installé Rust, écrivons notre premier programme Rust.
Lorsqu'on apprend un nouveau langage, il est de tradition d'écrire un petit
programme qui écrit le texte &quot;Hello, world!&quot; à l'écran, donc c'est ce que nous
allons faire !</p>
<!--
> Note: This book assumes basic familiarity with the command line. Rust makes
> no specific demands about your editing or tooling or where your code lives, so
> if you prefer to use an integrated development environment (IDE) instead of
> the command line, feel free to use your favorite IDE. Many IDEs now have some
> degree of Rust support; check the IDE’s documentation for details. Recently,
> the Rust team has been focusing on enabling great IDE support, and progress
> has been made rapidly on that front!
-->
<blockquote>
<p>Note : ce livre part du principe que vous êtes familier avec la ligne de
commande. Rust n'impose pas d'exigences sur votre éditeur, vos outils ou
l'endroit où vous mettez votre code, donc si vous préférez utiliser un
environnement de développement intégré (IDE) au lieu de la ligne de commande,
vous êtes libre d'utiliser votre IDE favori. De nombreux IDE prennent en
charge Rust à des degrés divers ; consultez la documentation de
l'IDE pour plus d'informations. Récemment, l'équipe Rust s'est attelée à
améliorer l'intégration dans les IDE et des progrès ont rapidement été faits
dans ce domaine !</p>
</blockquote>
<!--
### Creating a Project Directory
-->
<h3 id="créer-un-dossier-projet"><a class="header" href="#créer-un-dossier-projet">Créer un dossier projet</a></h3>
<!--
You’ll start by making a directory to store your Rust code. It doesn’t matter
to Rust where your code lives, but for the exercises and projects in this book,
we suggest making a *projects* directory in your home directory and keeping all
your projects there.
-->
<p>Nous allons commencer par créer un dossier pour y ranger le code Rust. Là où
vous mettez votre code n'est pas important pour Rust, mais pour les exercices et
projets de ce livre, nous vous suggérons de créer un dossier <em>projects</em> dans
votre dossier utilisateur et de ranger tous vos projets là-dedans.</p>
<!--
Open a terminal and enter the following commands to make a *projects* directory
and a directory for the “Hello, world!” project within the *projects* directory.
-->
<p>Ouvrez un terminal et écrivez les commandes suivantes pour créer un
dossier <em>projects</em> et un dossier pour le projet “Hello, world!” à l'intérieur
de ce dossier <em>projects</em>.</p>
<!--
For Linux, macOS, and PowerShell on Windows, enter this:
-->
<p>Sous Linux, macOS et PowerShell sous Windows, écrivez ceci :</p>
<!--
```console
$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
```
-->
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<!--
For Windows CMD, enter this:
-->
<p>Avec CMD sous Windows, écrivez ceci :</p>
<!--
```cmd
> mkdir "%USERPROFILE%\projects"
> cd /d "%USERPROFILE%\projects"
> mkdir hello_world
> cd hello_world
```
-->
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<!--
### Writing and Running a Rust Program
-->
<h3 id="Écrire-et-exécuter-un-programme-rust"><a class="header" href="#Écrire-et-exécuter-un-programme-rust">Écrire et exécuter un programme Rust</a></h3>
<!--
Next, make a new source file and call it *main.rs*. Rust files always end with
the *.rs* extension. If you’re using more than one word in your filename, use
an underscore to separate them. For example, use *hello_world.rs* rather than
*helloworld.rs*.
-->
<p>Ensuite, créez un nouveau fichier source et appelez-le <em>main.rs</em>. Les fichiers
Rust se terminent toujours par l'extension <em>.rs</em>. Si vous utilisez plusieurs
mots dans votre nom de fichier, utilisez un tiret bas (<code>_</code>) pour
les séparer. Par exemple, vous devriez utiliser <em>hello_world.rs</em> au lieu de
<em>helloworld.rs</em>.</p>
<!--
Now open the *main.rs* file you just created and enter the code in Listing 1-1.
-->
<p>Maintenant, ouvrez le fichier <em>main.rs</em> que vous venez de créer et entrez le
code de l'encart 1-1.</p>
<!--
<span class="filename">Filename: main.rs</span>
-->
<p><span class="filename">Fichier : main.rs</span></p>
<!--
```rust
fn main() {
    println!("Hello, world!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 1-1: A program that prints `Hello, world!`</span>
-->
<p><span class="caption">Encart 1-1 : Un programme qui affiche <code>Hello, world!</code>
</span></p>
<!--
Save the file and go back to your terminal window. On Linux or macOS, enter
the following commands to compile and run the file:
-->
<p>Enregistrez le fichier et retournez dans votre terminal. Sur Linux
ou macOS, écrivez les commandes suivantes pour compiler et exécuter le fichier :</p>
<!--
```console
$ rustc main.rs
$ ./main
Hello, world!
```
-->
<pre><code class="language-console">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<!--
On Windows, enter the command `.\main.exe` instead of `./main`:
-->
<p>Sur Windows, écrivez la commande <code>.\main.exe</code> à la place de <code>.\main</code> :</p>
<!--
```powershell
> rustc main.rs
> .\main.exe
Hello, world!
```
-->
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<!--
Regardless of your operating system, the string `Hello, world!` should print to
the terminal. If you don’t see this output, refer back to the
[“Troubleshooting”][troubleshooting]<!-- ignore -- > part of the Installation
section for ways to get help.
-->
<p>Peu importe votre système d'exploitation, la chaîne de caractères
<code>Hello, world!</code> devrait s'écrire dans votre terminal. Si cela ne s'affiche pas,
référez-vous à la partie <a href="ch01-01-installation.html#d%C3%A9pannage">&quot;Dépannage&quot;</a><!-- ignore --> du
chapitre d'installation pour vous aider.</p>
<!--
If `Hello, world!` did print, congratulations! You’ve officially written a Rust
program. That makes you a Rust programmer—welcome!
-->
<p>Si <code>Hello, world!</code> s'affiche, félicitations ! Vous avez officiellement écrit un
programme Rust. Cela fait de vous un développeur Rust — bienvenue !</p>
<!--
### Anatomy of a Rust Program
-->
<h3 id="structure-dun-programme-rust"><a class="header" href="#structure-dun-programme-rust">Structure d'un programme Rust</a></h3>
<!--
Let’s review in detail what just happened in your “Hello, world!” program.
Here’s the first piece of the puzzle:
-->
<p>Regardons en détail ce qui s'est passé dans votre programme “Hello, world!”.
Voici le premier morceau du puzzle :</p>
<!--
```rust
fn main() {

}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {

}
</code></pre></pre>
<!--
These lines define a function in Rust. The `main` function is special: it is
always the first code that runs in every executable Rust program. The first
line declares a function named `main` that has no parameters and returns
nothing. If there were parameters, they would go inside the parentheses, `()`.
-->
<p>Ces lignes définissent une fonction dans Rust. La fonction <code>main</code> est spéciale :
c'est toujours le premier code qui est exécuté dans tous les programmes
en Rust. La première ligne déclare une fonction qui s'appelle <code>main</code>, qui n'a
pas de paramètre et qui ne retourne aucune valeur. S'il y avait des paramètres,
ils seraient placés entre les parenthèses <code>()</code>.</p>
<!--
Also, note that the function body is wrapped in curly brackets, `{}`. Rust
requires these around all function bodies. It’s good style to place the opening
curly bracket on the same line as the function declaration, adding one space in
between.
-->
<p>À noter en outre que le corps de la fonction est placé entre des accolades
<code>{}</code>. Rust en a besoin autour du corps de chaque fonction. C'est une
bonne pratique d'insérer l'accolade ouvrante sur la même ligne que la
déclaration de la fonction, en ajoutant une espace entre les deux.</p>
<!--
If you want to stick to a standard style across Rust projects, you can use an
automatic formatter tool called `rustfmt` to format your code in a particular
style. The Rust team has included this tool with the standard Rust distribution,
like `rustc`, so it should already be installed on your computer! Check the
online documentation for more details.
-->
<p>Si vous souhaitez formater le code de vos projets Rust de manière standardisé,
vous pouvez utiliser un outil de formatage automatique tel que <code>rustfmt</code>.
L'équipe de Rust a intégré cet outil dans la distribution standard de Rust,
comme pour <code>rustc</code> par exemple, donc il est probablement déjà installé sur votre
ordinateur ! Consultez la documentation en ligne pour en savoir plus.</p>
<!--
Inside the `main` function is the following code:
-->
<p>À l'intérieur de la fonction <code>main</code>, nous avons le code suivant :</p>
<!--
```rust
    println!("Hello, world!");
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;Hello, world!&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
This line does all the work in this little program: it prints text to the
screen. There are four important details to notice here.
-->
<p>Cette ligne fait tout le travail dans ce petit programme : il écrit le texte à
l'écran. Il y a quatre détails importants à noter ici.</p>
<!--
First, Rust style is to indent with four spaces, not a tab.
-->
<p>Premièrement, le style de Rust est d'indenter avec quatre espaces, et non pas
avec une tabulation.</p>
<!--
Second, `println!` calls a Rust macro. If it called a function instead, it
would be entered as `println` (without the `!`). We’ll discuss Rust macros in
more detail in Chapter 19. For now, you just need to know that using a `!`
means that you’re calling a macro instead of a normal function, and that macros
don’t always follow the same rules as functions.
-->
<p>Deuxièmement, <code>println!</code> fait appel à une macro Rust. S'il appelait une
fonction à la place, cela serait écrit <code>println</code> (sans le <code>!</code>). Nous aborderons
les macros Rust plus en détail dans le chapitre 19. Pour l'instant, vous avez
juste à savoir qu'utiliser un <code>!</code> signifie que vous utilisez une macro plutôt
qu'une fonction classique. Les macros ne suivent pas toujours les mêmes règles
que les fonctions.</p>
<!--
Third, you see the `"Hello, world!"` string. We pass this string as an argument
to `println!`, and the string is printed to the screen.
-->
<p>Troisièmement, vous voyez la chaîne de caractères <code>&quot;Hello, world!&quot;</code>. Nous
envoyons cette chaîne en argument à <code>println!</code> et cette chaîne est affichée
à l'écran.</p>
<!--
Fourth, we end the line with a semicolon (`;`), which indicates that this
expression is over and the next one is ready to begin. Most lines of Rust code
end with a semicolon.
-->
<p>Quatrièmement, nous terminons la ligne avec un point-virgule (<code>;</code>), qui indique
que cette expression est terminée et que la suivante est prête à commencer. La
plupart des lignes de Rust se terminent avec un point-virgule.</p>
<!--
### Compiling and Running Are Separate Steps
-->
<h3 id="la-compilation-et-lexécution-sont-des-étapes-séparées"><a class="header" href="#la-compilation-et-lexécution-sont-des-étapes-séparées">La compilation et l'exécution sont des étapes séparées</a></h3>
<!--
You’ve just run a newly created program, so let’s examine each step in the
process.
-->
<p>Vous venez de lancer un nouveau programme fraîchement créé, donc penchons-nous
sur chaque étape du processus.</p>
<!--
Before running a Rust program, you must compile it using the Rust compiler by
entering the `rustc` command and passing it the name of your source file, like
this:
-->
<p>Avant de lancer un programme Rust, vous devez le compiler en utilisant le
compilateur Rust en entrant la commande <code>rustc</code> et en lui passant le nom de
votre fichier source, comme ceci :</p>
<!--
```console
$ rustc main.rs
```
-->
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<!--
If you have a C or C++ background, you’ll notice that this is similar to `gcc`
or `clang`. After compiling successfully, Rust outputs a binary executable.
-->
<p>Si vous avez de l'expérience en C ou en C++, vous observerez des similarités
avec <code>gcc</code> ou <code>clang</code>.
Après avoir compilé avec succès, Rust produit un binaire exécutable.</p>
<!--
On Linux, macOS, and PowerShell on Windows, you can see the executable by
entering the `ls` command in your shell. On Linux and macOS, you’ll see two
files. With PowerShell on Windows, you’ll see the same three files that you
would see using CMD.
-->
<p>Avec Linux, macOS et PowerShell sous Windows, vous pouvez voir l'exécutable en
utilisant la commande <code>ls</code> dans votre terminal. Avec Linux et macOS,
vous devriez voir deux fichiers. Avec PowerShell sous Windows, vous devriez voir
les trois mêmes fichiers que vous verriez en utilisant CMD.</p>
<!--
```console
$ ls
main  main.rs
```
-->
<pre><code class="language-console">$ ls
main  main.rs
</code></pre>
<!--
With CMD on Windows, you would enter the following:
-->
<p>Avec CMD sous Windows, vous devez saisir la commande suivante :</p>
<!--
```cmd
> dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
```
-->
<pre><code class="language-cmd">&gt; dir /B %= l'option /B demande à n'afficher que les noms de fichiers =%
main.exe
main.pdb
main.rs
</code></pre>
<!--
This shows the source code file with the *.rs* extension, the executable file
(*main.exe* on Windows, but *main* on all other platforms), and, when using
Windows, a file containing debugging information with the *.pdb* extension.
From here, you run the *main* or *main.exe* file, like this:
-->
<p>Ceci affiche le fichier de code source avec l'extension <em>.rs</em>, le fichier
exécutable (<em>main.exe</em> sous Windows, mais <em>main</em> sur toutes les autres
plateformes) et, quand on utilise Windows, un fichier qui contient des
informations de débogage avec l'extension <em>.pdb</em>. Dans ce dossier, vous pouvez
exécuter le fichier <em>main</em> ou <em>main.exe</em> comme ceci :</p>
<!--
```console
$ ./main # or .\main.exe on Windows
```
-->
<pre><code class="language-console">$ ./main # ou .\main.exe sous Windows
</code></pre>
<!--
If *main.rs* was your “Hello, world!” program, this line would print `Hello,
world!` to your terminal.
-->
<p>Si <em>main.rs</em> était votre programme “Hello, world!”, cette ligne devrait afficher
<code>Hello, world!</code> dans votre terminal.</p>
<!--
If you’re more familiar with a dynamic language, such as Ruby, Python, or
JavaScript, you might not be used to compiling and running a program as
separate steps. Rust is an *ahead-of-time compiled* language, meaning you can
compile a program and give the executable to someone else, and they can run it
even without having Rust installed. If you give someone a *.rb*, *.py*, or
*.js* file, they need to have a Ruby, Python, or JavaScript implementation
installed (respectively). But in those languages, you only need one command to
compile and run your program. Everything is a trade-off in language design.
-->
<p>Si vous connaissez un langage dynamique, comme Ruby, Python, ou JavaScript, vous
n'avez peut-être pas l'habitude de compiler puis lancer votre programme dans des
étapes séparées.
Rust est un langage à <em>compilation anticipée</em>, ce qui veut dire que
vous pouvez compiler le programme et le donner à quelqu'un d'autre, et il peut
l'exécuter sans avoir Rust d'installé. Si vous donnez à quelqu'un un fichier
<em>.rb</em>, <em>.py</em> ou <em>.js</em>, il a besoin d'avoir respectivement un interpréteur Ruby,
Python, ou Javascript d'installé. Cependant, avec ces langages, vous n'avez
besoin que d'une seule commande pour compiler et exécuter votre programme.
Dans la conception d'un langage, tout est une question de compromis.</p>
<!--
Just compiling with `rustc` is fine for simple programs, but as your project
grows, you’ll want to manage all the options and make it easy to share your
code. Next, we’ll introduce you to the Cargo tool, which will help you write
real-world Rust programs.
-->
<p>Compiler avec <code>rustc</code> peut suffire pour de petits programmes, mais au fur et à
mesure que votre programme grandit, vous allez avoir besoin de régler plus
d'options et faciliter le partage de votre code. À la page suivante, nous allons
découvrir l'outil Cargo, qui va vous aider à écrire des programmes Rust à
l'épreuve de la réalité.</p>
<!--
[troubleshooting]: ch01-01-installation.html#troubleshooting
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Hello, Cargo!
-->
<h2 id="hello-cargo"><a class="header" href="#hello-cargo">Hello, Cargo!</a></h2>
<!--
Cargo is Rust’s build system and package manager. Most Rustaceans use this tool
to manage their Rust projects because Cargo handles a lot of tasks for you,
such as building your code, downloading the libraries your code depends on, and
building those libraries. (We call the libraries that your code needs
*dependencies*.)
-->
<p>Cargo est le système de compilation et de gestion de paquets de Rust. La plupart
des Rustacés utilisent cet outil pour gérer les projets Rust, car Cargo
s'occupe de nombreuses tâches pour vous, comme compiler votre code, télécharger
les bibliothèques dont votre code dépend, et compiler ces bibliothèques. (On
appelle <em>dépendance</em> une bibliothèque nécessaire pour votre code.)</p>
<!--
The simplest Rust programs, like the one we’ve written so far, don’t have any
dependencies. So if we had built the “Hello, world!” project with Cargo, it
would only use the part of Cargo that handles building your code. As you write
more complex Rust programs, you’ll add dependencies, and if you start a project
using Cargo, adding dependencies will be much easier to do.
-->
<p>Des programmes Rust très simples, comme le petit que nous avons écrit précédemment,
n'ont pas de dépendance. Donc si nous avions compilé le projet “Hello, world!”
avec Cargo, cela n'aurait fait appel qu'à la fonctionnalité de Cargo qui
s'occupe de la compilation de votre code. Quand vous écrirez des programmes Rust
plus complexes, vous ajouterez des dépendances, et si vous créez un projet en
utilisant Cargo, l'ajout des dépendances sera plus facile à faire.</p>
<!--
Because the vast majority of Rust projects use Cargo, the rest of this book
assumes that you’re using Cargo too. Cargo comes installed with Rust if you
used the official installers discussed in the
[“Installation”][installation]<!-- ignore -- > section. If you installed Rust
through some other means, check whether Cargo is installed by entering the
following into your terminal:
-->
<p>Comme la large majorité des projets Rust utilisent Cargo, la suite de ce livre
va supposer que vous utilisez aussi Cargo. Cargo s'installe avec Rust si vous
avez utilisé l'installateur officiel présenté dans la section
<a href="ch01-01-installation.html#installation">“Installation”</a><!-- ignore -->. Si vous avez installé Rust
autrement, vérifiez que Cargo est installé en utilisant la commande suivante
dans votre terminal :</p>
<!--
```console
$ cargo --version
```
-->
<pre><code class="language-console">$ cargo --version
</code></pre>
<!--
If you see a version number, you have it! If you see an error, such as `command
not found`, look at the documentation for your method of installation to
determine how to install Cargo separately.
-->
<p>Si vous voyez un numéro de version, c'est qu'il est installé ! Si vous voyez une
erreur comme <code>Commande non trouvée</code> (ou <code>command not found</code>), alors consultez la
documentation de votre méthode d'installation pour savoir comment installer
séparément Cargo.</p>
<!--
### Creating a Project with Cargo
-->
<h3 id="créer-un-projet-avec-cargo"><a class="header" href="#créer-un-projet-avec-cargo">Créer un projet avec Cargo</a></h3>
<!--
Let’s create a new project using Cargo and look at how it differs from our
original “Hello, world!” project. Navigate back to your *projects* directory (or
wherever you decided to store your code). Then, on any operating system, run
the following:
-->
<p>Créons un nouveau projet en utilisant Cargo et analysons les différences avec
notre projet initial “Hello, world!”. Retournez dans votre dossier <em>projects</em>
(ou là où vous avez décidé d'enregistrer votre code). Ensuite, sur n'importe
quel système d'exploitation, lancez les commandes suivantes :</p>
<!--
```console
$ cargo new hello_cargo
$ cd hello_cargo
```
-->
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<!--
The first command creates a new directory called *hello_cargo*. We’ve named
our project *hello_cargo*, and Cargo creates its files in a directory of the
same name.
-->
<p>La première commande crée un nouveau dossier appelé <em>hello_cargo</em>. Nous avons
appelé notre projet <em>hello_cargo</em>, et Cargo crée ses fichiers dans un dossier
avec le même nom.</p>
<!--
Go into the *hello_cargo* directory and list the files. You’ll see that Cargo
has generated two files and one directory for us: a *Cargo.toml* file and a
*src* directory with a *main.rs* file inside.
-->
<p>Rendez-vous dans le dossier <em>hello_cargo</em> et afficher la liste des fichiers.
Vous constaterez que Cargo a généré deux fichiers et un dossier pour nous : un
fichier <em>Cargo.toml</em> et un dossier <em>src</em> avec un fichier <em>main.rs</em> à
l'intérieur.</p>
<!--
It has also initialized a new Git repository along with a *.gitignore* file.
Git files won’t be generated if you run `cargo new` within an existing Git
repository; you can override this behavior by using `cargo new --vcs=git`.
-->
<p>Il a aussi créé un nouveau dépôt Git ainsi qu'un fichier <em>.gitignore</em>. Les
fichiers de Git ne seront pas générés si vous lancez <code>cargo new</code> au sein d'un
dépôt Git ; vous pouvez désactiver ce comportement temporairement en utilisant
<code>cargo new --vcs=git</code>.</p>
<!--
> Note: Git is a common version control system. You can change `cargo new` to
> use a different version control system or no version control system by using
> the `--vcs` flag. Run `cargo new --help` to see the available options.
-->
<blockquote>
<p>Note : Git est un système de gestion de versions très répandu. Vous pouvez
changer <code>cargo new</code> pour utiliser un autre système de gestion de versions
ou ne pas en utiliser du tout en écrivant le drapeau <code>--vcs</code>.
Lancez <code>cargo new --help</code> pour en savoir plus sur les options disponibles.</p>
</blockquote>
<!--
Open *Cargo.toml* in your text editor of choice. It should look similar to the
code in Listing 1-2.
-->
<p>Ouvrez <em>Cargo.toml</em> dans votre éditeur de texte favori. Son contenu devrait
être similaire au code dans l'encart 1-2.</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<!--
```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2018"

[dependencies]
```
-->
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<!--
<span class="caption">Listing 1-2: Contents of *Cargo.toml* generated by `cargo
new`</span>
-->
<p><span class="caption">Encart 1-2 : Contenu de <em>Cargo.toml</em> généré par <code>cargo new</code></span></p>
<!--
This file is in the [*TOML*](https://toml.io)<!-- ignore -- > (*Tom’s Obvious,
Minimal Language*) format, which is Cargo’s configuration format.
-->
<p>Ce fichier est au format <a href="https://toml.io"><em>TOML</em></a><!-- ignore --> (<em>Tom’s
Obvious, Minimal Language</em>), qui est le format de configuration de Cargo.</p>
<!--
The first line, `[package]`, is a section heading that indicates that the
following statements are configuring a package. As we add more information to
this file, we’ll add other sections.
-->
<p>La première ligne, <code>[package]</code>, est un en-tête de section qui indique que les
instructions suivantes configurent un paquet. Au fur et à mesure que nous
ajouterons plus de détails à ce fichier, nous ajouterons des sections
supplémentaires.</p>
<!--
The next three lines set the configuration information Cargo needs to compile
your program: the name, the version, and the edition of Rust to use. We’ll talk
about the `edition` key in [Appendix E][appendix-e]<!-- ignore -- >.
-->
<p>Les trois lignes suivantes définissent les informations de configuration dont
Cargo a besoin pour compiler votre programme : le nom, la version, et l'édition
de Rust à utiliser. Nous aborderons la clé <code>edition</code> dans
l'<a href="appendix-05-editions.html">Annexe E</a><!-- ignore -->.</p>
<!--
The last line, `[dependencies]`, is the start of a section for you to list any
of your project’s dependencies. In Rust, packages of code are referred to as
*crates*. We won’t need any other crates for this project, but we will in the
first project in Chapter 2, so we’ll use this dependencies section then.
-->
<p>La dernière ligne, <code>[dependencies]</code>, est le début d'une section qui vous permet
de lister les dépendances de votre projet. Dans Rust, les paquets de code sont
désignés sous le nom de <em>crates</em>. Nous n'allons pas utiliser de <em>crate</em> pour ce
projet, mais nous le ferons pour le premier projet au chapitre 2 ; nous
utiliserons alors cette section à ce moment-là.</p>
<!--
Now open *src/main.rs* and take a look:
-->
<p>Maintenant, ouvrez <em>src/main.rs</em> et jetez-y un coup d'œil :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    println!("Hello, world!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
Cargo has generated a “Hello, world!” program for you, just like the one we
wrote in Listing 1-1! So far, the differences between our previous project and
the project Cargo generates are that Cargo placed the code in the *src*
directory, and we have a *Cargo.toml* configuration file in the top directory.
-->
<p>Cargo a généré un programme “Hello, world!” pour vous, exactement comme celui
que nous avons écrit dans l'encart 1-1 ! Pour le moment, les seules différences
entre notre projet précédent et le projet que Cargo a généré sont que Cargo a
placé le code dans le dossier <em>src</em>, et que nous avons un fichier de
configuration <em>Cargo.toml</em> à la racine du dossier projet.</p>
<!--
Cargo expects your source files to live inside the *src* directory. The
top-level project directory is just for README files, license information,
configuration files, and anything else not related to your code. Using Cargo
helps you organize your projects. There’s a place for everything, and
everything is in its place.
-->
<p>Cargo prévoit de stocker vos fichiers sources dans le dossier <em>src</em>. Le dossier
parent est là uniquement pour les fichiers README, pour les informations à
propos de la licence, pour les fichiers de configuration et tout ce qui n'est
pas directement relié à votre code. Utiliser Cargo vous aide à structurer vos
projets. Il y a un endroit pour tout, et tout est à sa place.</p>
<!--
If you started a project that doesn’t use Cargo, as we did with the “Hello,
world!” project, you can convert it to a project that does use Cargo. Move the
project code into the *src* directory and create an appropriate *Cargo.toml*
file.
-->
<p>Si vous commencez un projet sans utiliser Cargo, comme nous l'avons fait avec
le projet “Hello, world!”, vous pouvez le transformer en projet qui
utilise Cargo. Déplacez le code de votre projet dans un dossier <em>src</em> et créez
un fichier <em>Cargo.toml</em> adéquat.</p>
<!--
### Building and Running a Cargo Project
-->
<h3 id="compiler-et-exécuter-un-projet-cargo"><a class="header" href="#compiler-et-exécuter-un-projet-cargo">Compiler et exécuter un projet Cargo</a></h3>
<!--
Now let’s look at what’s different when we build and run the “Hello, world!”
program with Cargo! From your *hello_cargo* directory, build your project by
entering the following command:
-->
<p>Maintenant, regardons ce qu'il y a de différent quand nous compilons et
exécutons le programme “Hello, world!” avec Cargo ! À l'intérieur de votre
dossier <em>hello_cargo</em>, compilez votre projet en utilisant la commande suivante :</p>
<!--
```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```
-->
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<!--
This command creates an executable file in *target/debug/hello_cargo* (or
*target\debug\hello_cargo.exe* on Windows) rather than in your current
directory. You can run the executable with this command:
-->
<p>Cette commande crée un fichier exécutable dans <em>target/debug/hello_cargo</em> (ou
<em>target\debug\hello_cargo.exe</em> sous Windows) plutôt que de le déposer dans votre
dossier courant. Vous pouvez lancer l'exécutable avec cette commande :</p>
<!--
```console
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```
-->
<pre><code class="language-console">$ ./target/debug/hello_cargo # ou .\target\debug\hello_cargo.exe sous Windows
Hello, world!
</code></pre>
<!--
If all goes well, `Hello, world!` should print to the terminal. Running `cargo
build` for the first time also causes Cargo to create a new file at the top
level: *Cargo.lock*. This file keeps track of the exact versions of
dependencies in your project. This project doesn’t have dependencies, so the
file is a bit sparse. You won’t ever need to change this file manually; Cargo
manages its contents for you.
-->
<p>Si tout s'est bien passé, <code>Hello, world!</code> devrait s'afficher dans le terminal.
Lancer <code>cargo build</code> pour la première fois devrait aussi mener Cargo à créer
un nouveau fichier à la racine du dossier projet : <em>Cargo.lock</em>. Ce fichier
garde une trace des versions exactes des dépendances de votre
projet. Ce projet n'a pas de dépendance, donc le fichier est un peu vide. Vous
n'aurez jamais besoin de changer ce fichier manuellement ; Cargo va gérer son
contenu pour vous.</p>
<!--
We just built a project with `cargo build` and ran it with
`./target/debug/hello_cargo`, but we can also use `cargo run` to compile the
code and then run the resulting executable all in one command:
-->
<p>Nous venons de compiler un projet avec <code>cargo build</code> avant de l'exécuter avec
<code>./target/debug/hello_cargo</code>, mais nous pouvons aussi utiliser <code>cargo run</code> pour
compiler le code et ensuite lancer l'exécutable dans une seule et même
commande :</p>
<!--
```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```
-->
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!--
Notice that this time we didn’t see output indicating that Cargo was compiling
`hello_cargo`. Cargo figured out that the files hadn’t changed, so it just ran
the binary. If you had modified your source code, Cargo would have rebuilt the
project before running it, and you would have seen this output:
-->
<p>Notez que cette fois-ci, nous ne voyons pas de messages indiquant que Cargo a
compilé <code>hello_cargo</code>. Cargo a détecté que les fichiers n'avaient pas changé,
donc il a juste exécuté le binaire. Si vous aviez modifié votre code source,
Cargo aurait recompilé le projet avant de le lancer, et vous auriez eu les
messages suivants :</p>
<!--
```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!--
Cargo also provides a command called `cargo check`. This command quickly checks
your code to make sure it compiles but doesn’t produce an executable:
-->
<p>Cargo fournit aussi une commande appelée <code>cargo check</code>. Elle vérifie rapidement
votre code pour s'assurer qu'il est compilable, mais ne produit pas
d'exécutable :</p>
<!--
```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```
-->
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<!--
Why would you not want an executable? Often, `cargo check` is much faster than
`cargo build`, because it skips the step of producing an executable. If you’re
continually checking your work while writing the code, using `cargo check` will
speed up the process! As such, many Rustaceans run `cargo check` periodically
as they write their program to make sure it compiles. Then they run `cargo
build` when they’re ready to use the executable.
-->
<p>Dans quel cas n'aurions-nous pas besoin d'un exécutable ? Parfois, <code>cargo check</code>
est bien plus rapide que <code>cargo build</code>, car il saute l'étape de création de
l'exécutable. Si vous vérifiez votre travail continuellement pendant que vous
écrivez votre code, utiliser <code>cargo check</code> accélèrera le processus ! C'est
pourquoi de nombreux Rustacés utilisent périodiquement <code>cargo check</code> quand ils
écrivent leur programme afin de s'assurer qu'il compile. Ensuite, ils lancent
<code>cargo build</code> quand ils sont prêts à utiliser l'exécutable.</p>
<!--
Let’s recap what we’ve learned so far about Cargo:
-->
<p>Récapitulons ce que nous avons appris sur Cargo :</p>
<!--
* We can build a project using `cargo build`.
* We can build and run a project in one step using `cargo run`.
* We can build a project without producing a binary to check for errors using
  `cargo check`.
* Instead of saving the result of the build in the same directory as our code,
  Cargo stores it in the *target/debug* directory.
-->
<ul>
<li>Nous pouvons compiler un projet en utilisant <code>cargo build</code>.</li>
<li>Nous pouvons compiler puis exécuter un projet en une seule fois en utilisant
<code>cargo run</code>.</li>
<li>Nous pouvons compiler un projet sans produire de binaire afin de vérifier
l'existance d'erreurs en utilisant <code>cargo check</code>.</li>
<li>Au lieu d'enregistrer le résultat de la compilation dans le même dossier que
votre code, Cargo l'enregistre dans le dossier <em>target/debug</em>.</li>
</ul>
<!--
An additional advantage of using Cargo is that the commands are the same no
matter which operating system you’re working on. So, at this point, we’ll no
longer provide specific instructions for Linux and macOS versus Windows.
-->
<p>Un autre avantage d'utiliser Cargo est que les commandes sont les mêmes peu
importe le système d'exploitation que vous utilisez.
Donc à partir de maintenant, nous n'allons plus faire d'opérations spécifiques
à Linux et macOS par rapport à Windows.</p>
<!--
### Building for Release
-->
<h3 id="compiler-pour-diffuser"><a class="header" href="#compiler-pour-diffuser">Compiler pour diffuser</a></h3>
<!--
When your project is finally ready for release, you can use `cargo build
--release` to compile it with optimizations. This command will create an
executable in *target/release* instead of *target/debug*. The optimizations
make your Rust code run faster, but turning them on lengthens the time it takes
for your program to compile. This is why there are two different profiles: one
for development, when you want to rebuild quickly and often, and another for
building the final program you’ll give to a user that won’t be rebuilt
repeatedly and that will run as fast as possible. If you’re benchmarking your
code’s running time, be sure to run `cargo build --release` and benchmark with
the executable in *target/release*.
-->
<p>Quand votre projet est finalement prêt à être diffusé, vous pouvez utiliser
<code>cargo build --release</code> pour le compiler en l'optimisant. Cette commande va
créer un exécutable dans <em>target/release</em> au lieu de <em>target/debug</em>. Ces
optimisations rendent votre code Rust plus rapide à exécuter, mais l'utiliser
rallonge le temps de compilation de votre programme. C'est pourquoi il y a deux
différents profils : un pour le développement, quand vous voulez recompiler
rapidement et souvent, et un autre pour compiler le programme final qui sera
livré à un utilisateur, qui n'aura pas besoin d'être recompilé à plusieurs
reprises et qui s'exécutera aussi vite que possible. Si vous évaluez le temps
d'exécution de votre code, assurez-vous de lancer <code>cargo build --release</code> et
d'utiliser l'exécutable dans <em>target/release</em> pour vos bancs de test.</p>
<!--
### Cargo as Convention
-->
<h3 id="cargo-comme-convention"><a class="header" href="#cargo-comme-convention">Cargo comme convention</a></h3>
<!--
With simple projects, Cargo doesn’t provide a lot of value over just using
`rustc`, but it will prove its worth as your programs become more intricate.
With complex projects composed of multiple crates, it’s much easier to let
Cargo coordinate the build.
-->
<p>Pour des projets simples, Cargo n'apporte pas grand-chose par rapport à <code>rustc</code>,
mais il vous montrera son intérêt au fur et à mesure
que vos programmes deviendront plus complexes. Avec des projets complexes
composés de plusieurs <em>crates</em>, il est plus facile de laisser Cargo prendre en
charge la coordination de la compilation.</p>
<!--
Even though the `hello_cargo` project is simple, it now uses much of the real
tooling you’ll use in the rest of your Rust career. In fact, to work on any
existing projects, you can use the following commands to check out the code
using Git, change to that project’s directory, and build:
-->
<p>Même si le projet <code>hello_cargo</code> est simple, il utilise maintenant une grande
partie de l'outillage que vous rencontrerez dans votre carrière avec Rust. En
effet, pour travailler sur n'importe quel projet Rust existant, vous n'avez
qu'à saisir les commandes suivantes pour télécharger le code avec Git, vous
déplacer dans le dossier projet et compiler :</p>
<!--
```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```
-->
<pre><code class="language-console">$ git clone example.org/projet_quelconque
$ cd projet_quelconque
$ cargo build
</code></pre>
<!--
For more information about Cargo, check out [its documentation].
-->
<p>Pour plus d'informations à propos de Cargo, vous pouvez consulter <a href="https://doc.rust-lang.org/cargo/">sa
documentation</a>.</p>
<!--
[its documentation]: https://doc.rust-lang.org/cargo/
-->
<!--
## Summary
-->
<h2 id="résumé"><a class="header" href="#résumé">Résumé</a></h2>
<!--
You’re already off to a great start on your Rust journey! In this chapter,
you’ve learned how to:
-->
<p>Vous êtes déjà bien lancé dans votre périple avec Rust ! Dans ce chapitre, vous
avez appris comment :</p>
<!--
* Install the latest stable version of Rust using `rustup`
* Update to a newer Rust version
* Open locally installed documentation
* Write and run a “Hello, world!” program using `rustc` directly
* Create and run a new project using the conventions of Cargo
-->
<ul>
<li>Installer la dernière version stable de Rust en utilisant <code>rustup</code></li>
<li>Mettre à jour Rust vers une nouvelle version</li>
<li>Ouvrir la documentation installée en local</li>
<li>Écrire et exécuter un programme “Hello, world!” en utilisant directement
<code>rustc</code></li>
<li>Créer et exécuter un nouveau projet en utilisant les conventions de Cargo</li>
</ul>
<!--
This is a great time to build a more substantial program to get used to reading
and writing Rust code. So, in Chapter 2, we’ll build a guessing game program.
If you would rather start by learning how common programming concepts work in
Rust, see Chapter 3 and then return to Chapter 2.
-->
<p>C'est le moment idéal pour construire un programme plus ambitieux pour
s'habituer à lire et écrire du code Rust. Donc, au chapitre 2, nous allons
écrire un programme de <em>jeu de devinettes</em>.
Si vous préférez commencer par apprendre comment les principes de programmation
de base fonctionnent avec Rust, rendez-vous au chapitre 3, puis revenez au
chapitre 2.</p>
<!--
[installation]: ch01-01-installation.html#installation
[appendix-e]: appendix-05-editions.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Programming a Guessing Game
-->
<h1 id="programmer-le-jeu-du-plus-ou-du-moins"><a class="header" href="#programmer-le-jeu-du-plus-ou-du-moins">Programmer le jeu du plus ou du moins</a></h1>
<!--
Let’s jump into Rust by working through a hands-on project together! This
chapter introduces you to a few common Rust concepts by showing you how to use
them in a real program. You’ll learn about `let`, `match`, methods, associated
functions, using external crates, and more! In the following chapters, we’ll
explore these ideas in more detail. In this chapter, you’ll practice the
fundamentals.
-->
<p>Entrons dans le vif du sujet en travaillant ensemble sur un projet concret !
Ce chapitre présente quelques concepts couramment utilisés en Rust en vous
montrant comment les utiliser dans un véritable programme. Nous aborderons
notamment les instructions <code>let</code> et <code>match</code>, les méthodes et fonctions
associées, l'utilisation des <em>crates</em>, et bien plus encore ! Dans les chapitres
suivants, nous approfondirons ces notions. Dans ce chapitre, vous n'allez
exercer que les principes de base.</p>
<!--
We’ll implement a classic beginner programming problem: a guessing game. Here’s
how it works: the program will generate a random integer between 1 and 100. It
will then prompt the player to enter a guess. After a guess is entered, the
program will indicate whether the guess is too low or too high. If the guess is
correct, the game will print a congratulatory message and exit.
-->
<p>Nous allons coder un programme fréquemment réalisé par les débutants en
programmation : <em>le jeu du plus ou du moins</em>. Le principe de ce jeu est le
suivant : le programme va tirer au sort un nombre entre 1 et 100. Il invitera
ensuite le joueur à saisir un nombre qu'il pense deviner. Après la saisie, le
programme indiquera si le nombre saisi par le joueur est trop grand ou trop
petit. Si le nombre saisi est le bon, le jeu affichera un message de
félicitations et se fermera.</p>
<!--
## Setting Up a New Project
-->
<h2 id="mise-en-place-dun-nouveau-projet"><a class="header" href="#mise-en-place-dun-nouveau-projet">Mise en place d'un nouveau projet</a></h2>
<!--
To set up a new project, go to the *projects* directory that you created in
Chapter 1 and make a new project using Cargo, like so:
-->
<p>Pour créer un nouveau projet, rendez-vous dans le dossier <em>projects</em> que
vous avez créé au chapitre 1 et utilisez Cargo pour créer votre projet, comme
ceci :</p>
<!--
```console
$ cargo new guessing_game
$ cd guessing_game
```
-->
<pre><code class="language-console">$ cargo new jeu_du_plus_ou_du_moins
$ cd jeu_du_plus_ou_du_moins
</code></pre>
<!--
The first command, `cargo new`, takes the name of the project (`guessing_game`)
as the first argument. The second command changes to the new project’s
directory.
-->
<p>La première commande, <code>cargo new</code>, prend comme premier argument le nom de notre
projet (<code>jeu_du_plus_ou_du_moins</code>). La seconde commande nous déplace dans le
dossier de notre nouveau projet créé par Cargo.</p>
<!--
Look at the generated *Cargo.toml* file:
-->
<p>Regardons le fichier <em>Cargo.toml</em> qui a été généré :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<!--
```toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```
-->
<pre><code class="language-toml">[package]
name = &quot;jeu_du_plus_ou_du_moins&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<!--
As you saw in Chapter 1, `cargo new` generates a “Hello, world!” program for
you. Check out the *src/main.rs* file:
-->
<p>Comme vous l'avez expérimenté dans le chapitre 1, <code>cargo new</code> génère un
programme <em>“Hello, world!”</em> pour vous. Ouvrez le fichier <em>src/main.rs</em> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    println!("Hello, world!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
Now let’s compile this “Hello, world!” program and run it in the same step
using the `cargo run` command:
-->
<p>Maintenant, lançons la compilation de ce programme “Hello, world!” et
son exécution en une seule commande avec <code>cargo run</code> :</p>
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/jeu_du_plus_ou_du_moins`
Hello, world!
</code></pre>
<!--
The `run` command comes in handy when you need to rapidly iterate on a project,
as we’ll do in this game, quickly testing each iteration before moving on to
the next one.
-->
<p>Cette commande <code>run</code> est très pratique lorsqu'on souhaite itérer rapidement
sur un projet, comme c'est le cas ici, pour tester rapidement chaque
modification avant de passer à la suivante.</p>
<!--
Reopen the *src/main.rs* file. You’ll be writing all the code in this file.
-->
<p>Ouvrez à nouveau le fichier <em>src/main.rs</em>. C'est dans ce fichier que nous
écrirons la totalité de notre code.</p>
<!--
## Processing a Guess
-->
<h2 id="traitement-dun-nombre-saisi"><a class="header" href="#traitement-dun-nombre-saisi">Traitement d'un nombre saisi</a></h2>
<!--
The first part of the guessing game program will ask for user input, process
that input, and check that the input is in the expected form. To start, we’ll
allow the player to input a guess. Enter the code in Listing 2-1 into
*src/main.rs*.
-->
<p>La première partie du programme consiste à demander au joueur de saisir du
texte, à traiter cette saisie, et à vérifier que la saisie correspond au format
attendu.
Commençons par permettre au joueur de saisir son nombre. Entrez le
code de l'encart 2-1 dans le fichier <em>src/main.rs</em>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```
-->
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Devinez le nombre !&quot;);

    println!(&quot;Veuillez entrer un nombre.&quot;);

    let mut supposition = String::new();

    io::stdin()
        .read_line(&amp;mut supposition)
        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);

    println!(&quot;Votre nombre : {}&quot;, supposition);
}
</code></pre>
<!--
<span class="caption">Listing 2-1: Code that gets a guess from the user and
prints it</span>
-->
<p><span class="caption">Encart 2-1 : Code permettant de récupérer une saisie
utilisateur et de l'afficher</span></p>
<!--
This code contains a lot of information, so let’s go over it line by line. To
obtain user input and then print the result as output, we need to bring the
`io` input/output library into scope. The `io` library comes from the
standard library, known as `std`:
-->
<p>Ce code contient beaucoup d'informations, nous allons donc l'analyser petit
à petit. Pour obtenir la saisie utilisateur et ensuite l'afficher, nous avons
besoin d'importer la bibliothèque d'entrée/sortie <code>io</code> (initiales
de <em>input/output</em>) afin de pouvoir l'utiliser. La bibliothèque <code>io</code> provient de
la bibliothèque standard, connue sous le nom de <code>std</code> :</p>
<!--
```rust,ignore
use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre !&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombre : {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
By default, Rust has a few items defined in the standard library that it brings
into the scope of every program. This set is called the *prelude*, and you can
see everything in it [in the standard library documentation][prelude].
-->
<p>Par défaut, Rust importe dans la portée de tous les programmes quelques
fonctionnalités définies dans la bibliothèque standard. Cela s'appelle <em>l'étape
préliminaire (the prelude)</em>, et vous pouvez en savoir plus dans sa
<a href="https://doc.rust-lang.org/std/prelude/index.html">documentation de la bibliothèque standard</a><!-- ignore -->.</p>
<!--
If a type you want to use isn’t in the prelude, you have to bring that type
into scope explicitly with a `use` statement. Using the `std::io` library
provides you with a number of useful features, including the ability to accept
user input.
-->
<p>Si vous
voulez utiliser un type qui ne s'y trouve pas, vous devrez l'importer
explicitement avec l'instruction <code>use</code>. L'utilisation de la bibliothèque
<code>std::io</code> vous apporte de nombreuses fonctionnalités utiles, comme ici la
possibilité de récupérer une saisie utilisateur.</p>
<!--
As you saw in Chapter 1, the `main` function is the entry point into the
program:
-->
<p>Comme vous l'avez vu au chapitre 1, la fonction <code>main</code> est le point d'entrée
du programme :</p>
<!--
```rust,ignore
# use std::io;
# 
fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!(&quot;Devinez le nombre !&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombre : {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
The `fn` syntax declares a new function, the parentheses, `()`, indicate there
are no parameters, and the curly bracket, `{`, starts the body of the function.
-->
<p>Le mot clé <code>fn</code> déclare une nouvelle fonction, les parenthèses <code>()</code> indiquent
que cette fonction n'accepte aucun paramètre, et l'accolade ouvrante <code>{</code> marque
le début du corps de la fonction.</p>
<!--
As you also learned in Chapter 1, `println!` is a macro that prints a string to
the screen:
-->
<p>Comme vous l'avez également appris au chapitre 1, <code>println!</code> est une macro qui
affiche une chaîne de caractères à l'écran :</p>
<!--
```rust,ignore
# use std::io;
# 
# fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!(&quot;Devinez le nombre !&quot;);

    println!(&quot;Veuillez entrer un nombre.&quot;);
<span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombre : {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
This code is printing a prompt stating what the game is and requesting input
from the user.
-->
<p>Ce code affiche du texte qui indique le titre de notre jeu, et un autre qui
demande au joueur d'entrer un nombre.</p>
<!--
### Storing Values with Variables
-->
<h3 id="enregistrer-des-données-dans-des-variables"><a class="header" href="#enregistrer-des-données-dans-des-variables">Enregistrer des données dans des variables</a></h3>
<!--
Next, we’ll create a *variable* to store the user input, like this:
-->
<p>Ensuite, on crée une <em>variable</em> pour stocker la saisie de l'utilisateur, comme
ceci :</p>
<!--
```rust,ignore
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
    let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre !&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span>    let mut supposition = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombre : {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
Now the program is getting interesting! There’s a lot going on in this little
line. We use the `let` statement to create the variable. Here’s another example:
-->
<p>Le programme commence à devenir intéressant ! Il se passe beaucoup de choses
dans cette petite ligne. Nous utilisons l'instruction <code>let</code> pour créer la
variable. Voici un autre exemple :</p>
<!--
```rust,ignore
let apples = 5;
```
-->
<pre><code class="language-rust ignore">let pommes = 5;
</code></pre>
<!--
This line creates a new variable named `apples` and binds it to the value 5. In
Rust, variables are immutable by default. We’ll be discussing this concept in
detail in the [“Variables and Mutability”][variables-and-mutability]<!-- ignore
-- > section in Chapter 3. To make a variable mutable, we add `mut` before the
variable name:
-->
<p>Cette ligne permet de créer une nouvelle variable nommée <code>pommmes</code> et à lui
assigner la valeur 5. Par défaut en Rust, les variables sont immuables.
Nous aborderons plus en détail cette notion dans la section <a href="ch03-01-variables-and-mutability.html">“Variables et
Mutabilité”</a><!-- ignore --> au chapitre 3. Pour
rendre une variable mutable <em>(c'est-à-dire modifiable)</em>, nous ajoutons <code>mut</code>
devant le nom de la variable :</p>
<!--
```rust,ignore
let apples = 5; // immutable
let mut bananas = 5; // mutable
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pommes = 5; // immuable
let mut bananes = 5; // mutable, modifiable
<span class="boring">}
</span></code></pre></pre>
<!--
> Note: The `//` syntax starts a comment that continues until the end of the
> line. Rust ignores everything in comments. We’ll discuss comments in more
> detail in [Chapter 3][comments]<!-- ignore -- >.
-->
<blockquote>
<p>Remarque : La syntaxe <code>//</code> permet de commencer un commentaire qui s'étend
jusqu'à la fin de la ligne. Rust ignore tout ce qu'il y a dans un
commentaire. Nous verrons plus en détail les commentaires dans le
<a href="ch03-04-comments.html">chapitre 3</a><!-- ignore -->.</p>
</blockquote>
<!--
Returning to the guessing game program, you now know that `let mut guess` will
introduce a mutable variable named `guess`. The equal sign (`=`) tells Rust we
want to bind something to the variable now. On the right of the equals sign is
the value that `guess` is bound to, which is the result of calling
`String::new`, a function that returns a new instance of a `String`.
[`String`][string]<!-- ignore -- > is a string type provided by the standard
library that is a growable, UTF-8 encoded bit of text.
-->
<p>Lorsque vous revenez sur le jeu du plus ou du moins, vous comprenez donc
maintenant que la ligne <code>let mut supposition</code> permet de créer une variable
mutable nommée <code>supposition</code>. Le signe égal (<code>=</code>) indique à Rust que nous
voulons désormais lier quelquechose à la variable. A la droite du signe égal,
nous avons la valeur liée à <code>supposition</code>, qui est ici le résultat de
l'utilisation de <code>String::new</code>, qui est une fonction qui retourne une nouvelle
instance de <code>String</code>.
<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a><!-- ignore --> est un type de chaîne de caractères fourni
par la bibliothèque standard, qui est une portion de texte encodée en UTF-8 et
dont la longueur peut augmenter.</p>
<!--
The `::` syntax in the `::new` line indicates that `new` is an associated
function of the `String` type. An *associated function* is a function that’s
implemented on a type, in this case `String`. This `new` function creates a
new, empty string. You’ll find a `new` function on many types, because it’s a
common name for a function that makes a new value of some kind.
-->
<p>La syntaxe <code>::</code> dans <code>String::new()</code> indique que <code>new</code> est une fonction
associée au type <code>String</code>. Une <em>fonction associée</em> est une fonction qui est
implémentée sur un type, ici <code>String</code>. Cette fonction <code>new</code> crée une nouvelle
chaîne de caractères vide, une nouvelle <code>String</code>. Vous trouverez fréquemment
une fonction <code>new</code> sur d'autres types, car c'est un nom souvent donné à une
fonction qui crée une nouvelle valeur ou instance d'un type.</p>
<!--
In full, the `let mut guess = String::new();` line has created a mutable
variable that is currently bound to a new, empty instance of a `String`. Whew!
-->
<p>En définitif, la ligne <code>let mut supposition = String::new();</code> crée une nouvelle
variable mutable qui contient une nouvelle chaîne de caractères vide, une
instance de <code>String</code>. Ouf !</p>
<!--
### Receiving User Input
-->
<h3 id="recueillir-la-saisie-utilisateur"><a class="header" href="#recueillir-la-saisie-utilisateur">Recueillir la saisie utilisateur</a></h3>
<!--
Recall that we included the input/output functionality from the standard
library with `use std::io;` on the first line of the program. Now we’ll call
the `stdin` function from the `io` module, which will allow us to handle user
input:
-->
<p>Rappelez-vous que nous avons importé les fonctionnalités d'entrée/sortie de la
bibliothèque standard avec <code>use std::io;</code> à la première ligne de notre
programme. Nous allons maintenant appeler la fonction <code>stdin</code> du module <code>io</code>,
qui va nous permettre de traiter la saisie utilisateur :</p>
<!--
```rust,ignore
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
    io::stdin()
        .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre !&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut supposition)
<span class="boring">        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombre : {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
If we hadn’t imported the `io` library with `use std::io` at the beginning of
the program, we could still use the function by writing this function call as
`std::io::stdin`. The `stdin` function returns an instance of
[`std::io::Stdin`][iostdin]<!-- ignore -- >, which is a type that represents a
handle to the standard input for your terminal.
-->
<p>Si nous n'avions pas importé la bibliothèque <code>io</code> avec <code>use std::io</code> au début
du programme, on aurait toujours pu utiliser la fonction en écrivant l'appel à
la fonction de cette manière : <code>std::io::stdin</code>. La fonction <code>stdin</code> retourne
une instance de <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, qui est un type qui
représente une référence abstraite <em>(handle)</em> vers l'entrée standard du
terminal dans lequel vous avez lancé le programme.</p>
<!--
Next, the line `.read_line(&mut guess)` calls the [`read_line`][read_line]<!--
ignore -- > method on the standard input handle to get input from the user.
We’re also passing `&mut guess` as the argument to `read_line` to tell it what
string to store the user input in. The full job of `read_line` is to take
whatever the user types into standard input and append that into a string
(without overwriting its contents), so we therefore pass that string as an
argument. The string argument needs to be mutable so the method can change the
string’s content.
-->
<p>Ensuite, la ligne <code>.read_line(&amp;mut supposition)</code> appelle la méthode
<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> sur l'entrée standard afin d'obtenir
la saisie utilisateur.
On passons aussi <code>&amp;mut supposition</code> en argument de <code>read_line</code> pour lui
indiquer dans quelle chaîne de caractère il faut stocker la saisie utilisateur.
Le but final de <code>read_line</code> est de récupérer tout ce que l'utilisateur écrit
dans l'entrée standard et de l'ajouter à la fin d'une chaîne de caractères
(sans écraser son contenu) ; c'est pourquoi nous passons cette chaîne de
caractères en argument. Cet argument doit être mutable pour que <code>read_line</code>
puisse en modifier le contenu.</p>
<!--
The `&` indicates that this argument is a *reference*, which gives you a way to
let multiple parts of your code access one piece of data without needing to
copy that data into memory multiple times. References are a complex feature,
and one of Rust’s major advantages is how safe and easy it is to use
references. You don’t need to know a lot of those details to finish this
program. For now, all you need to know is that like variables, references are
immutable by default. Hence, you need to write `&mut guess` rather than
`&guess` to make it mutable. (Chapter 4 will explain references more
thoroughly.)
-->
<p>Le <code>&amp;</code> indique que cet argument est une <em>référence</em>, ce qui permet de laisser
plusieurs morceaux de votre code accéder à une même donnée sans avoir besoin
de copier ces données dans la mémoire plusieurs fois. Les références sont une
fonctionnalité complexe, et un des avantages majeurs de Rust est qu'il rend sûr
et simple l'utilisation des références. Il n'est pas nécessaire de trop
s'apesantir sur les références pour terminer ce programme.
Pour l'instant, tout ce que vous devez savoir est que comme les variables, les
références sont immuables par défaut.
D'où la nécessité d'écrire <code>&amp;mut supposition</code> au lieu de <code>&amp;supposition</code> pour la
rendre mutable. (Le chapitre 4 expliquera plus en détail les références.)</p>
<!--
### Handling Potential Failure with the `Result` Type
-->
<h3 id="gérer-les-erreurs-potentielles-avec-le-type-result"><a class="header" href="#gérer-les-erreurs-potentielles-avec-le-type-result">Gérer les erreurs potentielles avec le type <code>Result</code></a></h3>
<!--
We’re still working on this line of code. Although we’re now discussing a third
line of text, it’s still part of a single logical line of code. The next part
is this method:
-->
<p>Nous avons encore du travail sur cette ligne de code. Même si nous allons
rajouter une troisième ligne de code, elle ne fait partie que d'une seule ligne
de code. Cette nouvelle partie rajoute cette méthode :</p>
<!--
```rust,ignore
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
        .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre !&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span>        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
<span class="boring">
</span><span class="boring">    println!(&quot;Votre nombre : {}&quot;, supposition);
</span><span class="boring">}
</span></code></pre>
<!--
We could have written this code as:
-->
<p>Nous aurions pu écrire ce code de cette manière :</p>
<!--
```rust,ignore
io::stdin().read_line(&mut guess).expect("Failed to read line");
```
-->
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut supposition).expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</code></pre>
<!--
However, one long line is difficult to read, so it’s best to divide it. It’s
often wise to introduce a newline and other whitespace to help break up long
lines when you call a method with the `.method_name()` syntax. Now let’s
discuss what this line does.
-->
<p>Cependant, une longue ligne de code n'est pas toujours facile à lire, c'est donc
une bonne pratique de la diviser. Il est parfois utile d'ajouter une nouvelle
ligne et des espaces afin de désagréger les longues lignes lorsque vous
appelerez une méthode, comme ici avec la syntaxe <code>.nom_de_la_methode()</code>.
Maintenant, voyons à quoi sert cette ligne.</p>
<!--
As mentioned earlier, `read_line` puts whatever the user enters into the string
we pass to it, but it also returns a value—in this case, an
[`io::Result`][ioresult]<!-- ignore -- >. Rust has a number of types named
`Result` in its standard library: a generic [`Result`][result]<!-- ignore -- >
as well as specific versions for submodules, such as `io::Result`. The `Result`
types are [*enumerations*][enums]<!-- ignore -- >, often referred to as *enums*,
which can have a fixed set of possibilites known as *variants*. Enums are often
used with `match`, a conditional that makes it convenient to execute different
code based on which variant an enum value is when the conditional is evaluated.
-->
<p>Comme expliqué précédemment, <code>read_line</code> stocke dans la variable qu'on lui
passe en argument tout ce que l'utilisateur a saisi, mais cette fonction
retourne aussi une valeur − dans notre cas, de type
<a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->. Il existe plusieurs types nommés
<code>Result</code> dans la bibliothèque standard de Rust : un type générique
<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a><!-- ignore --> ainsi que des déclinaisons spécifiques à
des sous-modules, comme <code>io::Result</code>. Les types <code>Result</code> sont des
<a href="ch06-00-enums.html"><em>énumérations</em></a><!-- ignore -->, aussi appelées <em>enums</em>, qui peuvent
avoir un certain nombre de valeurs prédéfinies que l'on appelle <em>variantes</em>.
Les énumérations sont souvent utilisées avec <code>match</code>, une structure
conditionelle qui facilite l'exécution d'un code différent en fonction de la
variante dans l'énumération au moment de son évaluation.</p>
<!--
Chapter 6 will cover enums in more detail. The purpose of these `Result` types
is to encode error-handling information.
-->
<p>Le chapitre 6 explorera les énumérations plus en détail. La raison d'être du
type <code>Result</code> est de coder des informations pour la gestion des erreurs.</p>
<!--
`Result`’s variants are `Ok` or `Err`. The `Ok` variant indicates the operation
was successful, and inside `Ok` is the successfully generated value. The `Err`
variant means the operation failed, and `Err` contains information about how or
why the operation failed.
-->
<p>Les variantes de <code>Result</code> sont <code>Ok</code> ou <code>Err</code>. La variante <code>Ok</code> signifie que
l'opération a fonctionné, et à l'intérieur de <code>Ok</code> se trouve la valeur générée
avec succès. La variante <code>Err</code> signifie que l'opération a échoué, et <code>Err</code>
contient les informations décrivant comment ou pourquoi l'opération a échoué.</p>
<!--
Values of the `Result` type, like values of any type, have methods defined on
them. An instance of `io::Result` has an [`expect` method][expect]<!-- ignore
-- > that you can call. If this instance of `io::Result` is an `Err` value,
`expect` will cause the program to crash and display the message that you
passed as an argument to `expect`. If the `read_line` method returns an `Err`,
it would likely be the result of an error coming from the underlying operating
system. If this instance of `io::Result` is an `Ok` value, `expect` will take
the return value that `Ok` is holding and return just that value to you so you
can use it. In this case, that value is the number of bytes in the user’s input.
-->
<p>Les valeurs du type <code>Result</code>, comme pour tous les types, ont des méthodes
qui leur sont associées. Par exemple, une instance de <code>io::Result</code> a une
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect">méthode <code>expect</code></a><!-- ignore --> que vous pouvez utiliser. Si cette
instance de <code>io::Result</code> a pour valeur la variante <code>Err</code>, l'appel à <code>expect</code>
fera planter le programme et affichera le message que vous avez passé en
argument de <code>expect</code>. Si l'appel à <code>read_line</code> retourne une variante <code>Err</code>, ce
sera probablement dû à une erreur du système d'exploitation. Si en revanche
<code>read_line</code> a pour valeur la variante <code>Ok</code>, <code>expect</code> récupèrera le
contenu du <code>Ok</code>, qui est le résultat de l'opération, et vous le retournera afin
que vous puissiez l'utiliser. Dans notre exemple, ce résultat est le nombre
d'octets de la saisie utilisateur.</p>
<!--
If you don’t call `expect`, the program will compile, but you’ll get a warning:
-->
<p>Si on n'appelle pas <code>expect</code>, le programme compilera, mais avec un
avertissement :</p>
<!--
```console
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  -- > src/main.rs:10:5
   |
10 |     io::stdin().read_line(&mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
```
-->
<pre><code class="language-console">$ cargo build
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut supposition);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `jeu_du_plus_ou_du_moins` (bin &quot;jeu_du_plus_ou_du_moins&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<!--
Rust warns that you haven’t used the `Result` value returned from `read_line`,
indicating that the program hasn’t handled a possible error.
-->
<p>Rust nous prévient que l'on ne fait rien du <code>Result</code> que nous fournit
<code>read_line</code>, et que par conséquent notre programme ne gère pas une erreur
potentielle.</p>
<!--
The right way to suppress the warning is to actually write error handling, but
in our case we just want to crash this program when a problem occurs, so we can
use `expect`. You’ll learn about recovering from errors in [Chapter
9][recover]<!-- ignore -->.
<p>--&gt;</p>
<p>La meilleure façon de masquer cet avertissement est de réellement écrire le
code permettant de gérer l'erreur, mais dans notre cas on a seulement besoin de
faire planter le programme si un problème survient, on utilise donc <code>expect</code>.
Nous verrons dans le <a href="ch09-02-recoverable-errors-with-result.html">chapitre 9</a><!-- ignore --> comment gérer
correctement les erreurs.</p>
<!--
### Printing Values with `println!` Placeholders
-->
<h3 id="afficher-des-valeurs-grâce-aux-espaces-réservés-de-println"><a class="header" href="#afficher-des-valeurs-grâce-aux-espaces-réservés-de-println">Afficher des valeurs grâce aux espaces réservés de <code>println!</code></a></h3>
<!--
Aside from the closing curly bracket, there’s only one more line to discuss in
the code so far:
-->
<p>Mis à part l'accolade fermante, il ne nous reste plus qu'une seule ligne à
étudier dans le code que nous avons pour l'instant :</p>
<!--
```rust,ignore
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
    println!("You guessed: {}", guess);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre !&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</span><span class="boring">
</span>    println!(&quot;Votre nombre : {}&quot;, supposition);
<span class="boring">}
</span></code></pre>
<!--
This line prints the string that now contains the user’s input. The `{}` set of
curly brackets is a placeholder: think of `{}` as little crab pincers that hold
a value in place. You can print more than one value using curly brackets: the
first set of curly brackets holds the first value listed after the format
string, the second set holds the second value, and so on. Printing multiple
values in one call to `println!` would look like this:
-->
<p>Cette ligne affiche la chaîne de caractères qui contient maintenant ce que
l'utilisateur a saisi. La paire d'accolades <code>{}</code> représente un espace réservé :
imaginez qu'il s'agit de pinces de crabes qui gardent la place d'une valeur.
Vous pouvez afficher plusieurs valeurs en utilisant des accolades : la première
paire d'accolades affichera la première valeur listée après la chaîne de
formatage, la deuxième paire d'accolades affichera la deuxième valeur, et ainsi
de suite. Pour afficher plusieurs valeurs en appelant <code>println!</code> une seule
fois, on ferait comme ceci :</p>
<!--
```rust
let x = 5;
let y = 10;

println!("x = {} and y = {}", x, y);
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {} et y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<!--
This code would print `x = 5 and y = 10`.
-->
<p>Ce code afficherait <code>x = 5 et y = 10</code>.</p>
<!--
### Testing the First Part
-->
<h3 id="test-de-la-première-partie"><a class="header" href="#test-de-la-première-partie">Test de la première partie</a></h3>
<!--
Let’s test the first part of the guessing game. Run it using `cargo run`:
-->
<p>Pour tester notre début de programme, lançons-le à l'aide de la commande
<code>cargo run</code> :</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -- >
-->
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```
-->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombre !
Veuillez entrer un nombre.
6
Votre nombre : 6
</code></pre>
<!--
At this point, the first part of the game is done: we’re getting input from the
keyboard and then printing it.
-->
<p>À ce stade, la première partie de notre programme est terminée : nous avons
récupéré la saisie du clavier et nous l'affichons à l'écran.</p>
<!--
## Generating a Secret Number
-->
<h2 id="générer-le-nombre-secret"><a class="header" href="#générer-le-nombre-secret">Générer le nombre secret</a></h2>
<!--
Next, we need to generate a secret number that the user will try to guess. The
secret number should be different every time so the game is fun to play more
than once. We’ll use a random number between 1 and 100 so the game isn’t too
difficult. Rust doesn’t yet include random number functionality in its standard
library. However, the Rust team does provide a [`rand` crate][randcrate] with
said functionality.
-->
<p>Maintenant, il nous faut générer un nombre secret que notre joueur va devoir
deviner. Ce nombre devra être différent à chaque fois pour qu'on puisse
s'amuser à y jouer plusieurs fois. Nous allons tirer au sort un nombre compris
entre 1 et 100 pour que le jeu ne soit pas trop difficile. Rust n'embarque pas
pour l'instant de fonctionnalité de génération de nombres aléatoires dans sa
bibliothèque standard. Cependant, l'équipe de Rust propose une
<a href="https://crates.io/crates/rand"><em>crate</em> <code>rand</code></a> qui offre la possibilité de le faire.</p>
<!--
### Using a Crate to Get More Functionality
-->
<h3 id="Étendre-les-fonctionnalités-de-rust-avec-une-crate"><a class="header" href="#Étendre-les-fonctionnalités-de-rust-avec-une-crate">Étendre les fonctionnalités de Rust avec une <em>crate</em></a></h3>
<!--
Remember that a crate is a collection of Rust source code files. The project
we’ve been building is a *binary crate*, which is an executable. The `rand`
crate is a *library crate*, which contains code intended to be used in other
programs, and can’t be executed on its own.
-->
<p>Souvenez-vous, une <em>crate</em> est un ensemble de fichiers de code source Rust. Le
projet sur lequel nous travaillons est une <em>crate</em> binaire, qui est un programme
exécutable. La <em>crate</em> <code>rand</code> est une <em>crate de bibliothèque</em>, qui contient du
code qui peut être utilisé dans d'autres programmes, et qui ne peut pas être
exécuté tout seul.</p>
<!--
Cargo’s coordination of external crates is where Cargo really shines. Before we
can write code that uses `rand`, we need to modify the *Cargo.toml* file to
include the `rand` crate as a dependency. Open that file now and add the
following line to the bottom beneath the `[dependencies]` section header that
Cargo created for you. Be sure to specify `rand` exactly as we have here, with
this version number, or the code examples in this tutorial may not work.
-->
<p>La coordination des <em>crates</em> externes est un domaine dans lequel Cargo excelle.
Avant d'écrire le code qui utilisera <code>rand</code>, il nous faut éditer le fichier
<em>Cargo.toml</em> pour y spécifier <code>rand</code> en tant que dépendance. Ouvrez donc
maintenant ce fichier et ajoutez la ligne suivante à la fin, en dessous de
l'en-tête de section <code>[dependencies]</code> que Cargo a créé pour vous. Assurez-vous
de spécifier <code>rand</code> exactement comme dans le bout de code suivant, avec ce
numéro de version, ou sinon les exemples de code de ce tutoriel pourraient ne
pas fonctionner.</p>
<!--
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-- >
-->
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<!--
```toml
rand = "0.8.3"
```
-->
<pre><code class="language-toml">rand = &quot;0.8.3&quot;
</code></pre>
<!--
In the *Cargo.toml* file, everything that follows a header is part of that
section that continues until another section starts. In `[dependencies]` you
tell Cargo which external crates your project depends on and which versions of
those crates you require. In this case, we specify the `rand` crate with the
semantic version specifier `0.8.3`. Cargo understands [Semantic
Versioning][semver]<!-- ignore -- > (sometimes called *SemVer*), which is a
standard for writing version numbers. The number `0.8.3` is actually shorthand
for `^0.8.3`, which means any version that is at least `0.8.3` but below
`0.9.0`. Cargo considers these versions to have public APIs compatible with
version `0.8.3`, and this specification ensures you’ll get the latest patch
release that will still compile with the code in this chapter. Any version
`0.9.0` or greater is not guaranteed to have the same API as what the following
examples use.
-->
<p>Dans le fichier <em>Cargo.toml</em>, tout ce qui suit une en-tête fait partie de cette
section, et ce jusqu'à ce qu'une autre section débute. Dans <code>[dependencies]</code>,
vous indiquez à Cargo de quelles <em>crates</em> externes votre
projet dépend, et de quelle version de ces <em>crates</em> vous avez besoin.
Dans notre cas, on ajoute comme dépendance la crate <code>rand</code> avec la version
sémantique <code>0.8.3</code>. Cargo arrive à interpréter le
<a href="http://semver.org">versionnage sémantique</a><!-- ignore --> (aussi appelé <em>SemVer</em>), qui
est une convention d'écriture de numéros de version. En réalité, <code>0.8.3</code> est
une abréviation pour <code>^0.8.3</code>, ce qui signifie “toute version ultérieure ou
égale à <code>0.8.3</code> mais strictement antérieure à <code>0.9.0</code>”. Cargo considère que ces
versions ont des API publiques compatibles avec la version <code>0.8.3</code>, et cette
indication garantit que vous obtiendrez la dernière version de correction qui
compilera encore avec le code de ce chapitre. Il n'est pas garanti que les
versions <code>0.9.0</code> et ultérieures aient la même API que celle utilisée dans les
exemples suivants.</p>
<!--
Now, without changing any of the code, let’s build the project, as shown in
Listing 2-2.
-->
<p>Maintenant, sans apporter le moindre changement au code, lançons une compilation
du projet, comme dans l'encart 2-2 :</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo clean
cargo build -- >
-->
<!--
```console
$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  Downloaded getrandom v0.2.2
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.10
  Downloaded rand_chacha v0.3.0
  Downloaded rand_core v0.6.2
   Compiling rand_core v0.6.2
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
```
-->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  Downloaded getrandom v0.2.2
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.10
  Downloaded rand_chacha v0.3.0
  Downloaded rand_core v0.6.2
   Compiling rand_core v0.6.2
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<!--
<span class="caption">Listing 2-2: The output from running `cargo build` after
adding the rand crate as a dependency</span>
-->
<p><span class="caption">Encart 2-2 : Résultat du lancement de <code>cargo build</code> après
avoir ajouté la <em>crate</em> <code>rand</code> comme dépendance</span></p>
<!--
You may see different version numbers (but they will all be compatible with the
code, thanks to SemVer!), different lines (depending on the operating system),
and the lines may be in a different order.
-->
<p>Il est possible que vous ne voyiez pas exactement les mêmes numéros de version,
(mais ils seront compatibles avec votre code, grâce au <em>versionnage
sémantique</em> !), différentes lignes (en fonction de votre système
d'exploitation), et les lignes ne seront pas forcément affichées dans le même
ordre.</p>
<!--
When we include an external dependency, Cargo fetches the latest versions of
everything that dependency needs from the *registry*, which is a copy of data
from [Crates.io][cratesio]. Crates.io is where people in the Rust ecosystem
post their open source Rust projects for others to use.
-->
<p>Lorsque nous ajoutons une dépendance externe, Cargo récupère la dernière
version de tout dont la dépendance nécessite depuis le <em>registre</em>, qui est une
copie des données de <a href="https://crates.io/">Crates.io</a>. Crates.io est là où les
développeurs de l'écosystème Rust publient leurs projets open source afin de
les rendre disponibles aux autres.</p>
<!--
After updating the registry, Cargo checks the `[dependencies]` section and
downloads any crates listed that aren’t already downloaded. In this case,
although we only listed `rand` as a dependency, Cargo also grabbed other crates
that `rand` depends on to work. After downloading the crates, Rust compiles
them and then compiles the project with the dependencies available.
-->
<p>Une fois le registre mis à jour, Cargo lit la section <code>[dependencies]</code> et se
charge de télécharger les <em>crates</em> qui y sont listés que vous n'avez pas encore
téléchargé. Dans notre cas, bien que nous n'ayons spécifié qu'une seule
dépendance, <code>rand</code>, Cargo a aussi téléchargé d'autres <em>crates</em> dont dépend
<code>rand</code> pour fonctionner. Une fois le téléchargement terminé des <em>crates</em>, Rust
les compile, puis compile notre projet avec les dépendances disponibles.</p>
<!--
If you immediately run `cargo build` again without making any changes, you
won’t get any output aside from the `Finished` line. Cargo knows it has already
downloaded and compiled the dependencies, and you haven’t changed anything
about them in your *Cargo.toml* file. Cargo also knows that you haven’t changed
anything about your code, so it doesn’t recompile that either. With nothing to
do, it simply exits.
-->
<p>Si vous relancez tout de suite <code>cargo build</code> sans changer quoi que ce soit, vous
n'obtiendrez rien d'autre que la ligne <code>Finished</code>. Cargo sait qu'il a déjà
téléchargé et compilé les dépendances, et que vous n'avez rien changé dans votre
fichier <em>Cargo.toml</em>. Cargo sait aussi que vous n'avez rien changé dans votre
code, donc il ne le recompile pas non plus. Étant donné qu'il n'a rien à faire,
Cargo se termine tout simplement.</p>
<!--
If you open up the *src/main.rs* file, make a trivial change, and then save it
and build again, you’ll only see two lines of output:
-->
<p>Si vous ouvrez le fichier <em>src/main.rs</em>, faites un changement très simple,
enregistrez le fichier, et relancez la compilation, vous verrez s'afficher
uniquement deux lignes :</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -- >
-->
<!--
```console
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
```
-->
<pre><code class="language-console">$ cargo build
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<!--
These lines show Cargo only updates the build with your tiny change to the
*src/main.rs* file. Your dependencies haven’t changed, so Cargo knows it can
reuse what it has already downloaded and compiled for those.
-->
<p>Ces lignes nous informent que Cargo a recompilé uniquement à cause de notre
petit changement dans le fichier <em>src/main.rs</em>. Les dépendances n'ayant pas
changé, Cargo sait qu'il peut simplement réutiliser ce qu'il a déjà téléchargé
et compilé précédemment.</p>
<!--
#### Ensuring Reproducible Builds with the *Cargo.lock* File
-->
<h4 id="assurer-la-reproductibilité-des-compilations-avec-le-fichier-cargolock"><a class="header" href="#assurer-la-reproductibilité-des-compilations-avec-le-fichier-cargolock">Assurer la reproductibilité des compilations avec le fichier <em>Cargo.lock</em></a></h4>
<!--
Cargo has a mechanism that ensures you can rebuild the same artifact every time
you or anyone else builds your code: Cargo will use only the versions of the
dependencies you specified until you indicate otherwise. For example, say that
next week version 0.8.4 of the `rand` crate comes out, and that version
contains an important bug fix, but it also contains a regression that will
break your code. To handle this, Rust creates the *Cargo.lock* file the first
time you run `cargo build`, so we now have this in the *guessing_game*
directory.
-->
<p>Cargo embarque une fonctionnalité qui garantie que vous pouvez recompiler le
même artéfact à chaque fois que vous ou quelqu'un d'autre compile votre code :
Cargo va utiliser uniquement les versions de dépendances que vous avez
utilisées jusqu'à ce que vous indiquiez le contraire.
Par exemple, immaginons que la semaine prochaine, la version 0.8.4 de la
<em>crate</em> <code>rand</code> est publiée, et qu'elle apporte une correction importante, mais
aussi qu'elle produit une régression qui va casser votre code. Pour éviter cela,
Rust crée le fichier <em>Cargo.lock</em> la première fois que vous utilisez
<code>cargo build</code>, donc nous l'avons désormais dans le dossier
<em>jeu_du_plus_ou_du_moins</em>.</p>
<!--
When you build a project for the first time, Cargo figures out all the
versions of the dependencies that fit the criteria and then writes them to
the *Cargo.lock* file. When you build your project in the future, Cargo will
see that the *Cargo.lock* file exists and use the versions specified there
rather than doing all the work of figuring out versions again. This lets you
have a reproducible build automatically. In other words, your project will
remain at `0.8.3` until you explicitly upgrade, thanks to the *Cargo.lock*
file.
-->
<p>Quand vous compilez un projet pour la
première fois, Cargo détermine toutes les versions de dépendances qui
correspondent à vos critères et les écrit dans le fichier <em>Cargo.lock</em>. Quand
vous recompilerez votre projet plus tard, Cargo verra que le fichier
<em>Cargo.lock</em> existe et utilisera les versions précisées à l'intérieur au lieu
de recommencer à déterminer toutes les versions demandées.
Ceci vous permet d'avoir automatiquement des compilations reproductibles.
En d'autres termes, votre projet va rester sur la version <code>0.8.3</code> jusqu'à ce
que vous le mettiez à jour explicitement, grâce au fichier <em>Cargo.lock</em>.</p>
<!--
#### Updating a Crate to Get a New Version
-->
<h4 id="mettre-à-jour-une-crate-vers-sa-nouvelle-version"><a class="header" href="#mettre-à-jour-une-crate-vers-sa-nouvelle-version">Mettre à jour une <em>crate</em> vers sa nouvelle version</a></h4>
<!--
When you *do* want to update a crate, Cargo provides the command `update`,
which will ignore the *Cargo.lock* file and figure out all the latest versions
that fit your specifications in *Cargo.toml*. Cargo will then write those
versions to the *Cargo.lock* file. Otherwise, by default, Cargo will only look
for versions greater than `0.8.3` and less than `0.9.0`. If the `rand` crate
has released the two new versions `0.8.4` and `0.9.0` you would see the
following if you ran `cargo update`:
-->
<p>Lorsque vous souhaitez réellement mettre à jour une <em>crate</em>, Cargo vous fournit
la commande <code>update</code>, qui va ignorer le fichier <em>Cargo.lock</em> et va rechercher
toutes les versions qui correspondent à vos critères dans <em>Cargo.toml</em>. Cargo
va ensuite écrire ces versions dans le fichier <em>Cargo.lock</em>. Sinon par défaut,
Cargo va rechercher uniquement les versions plus grandes que <code>0.8.3</code> et
inférieures à <code>0.9.0</code>. Si la <em>crate</em> <code>rand</code> a été publiée en deux nouvelles
versions <code>0.8.4</code> et <code>0.9.0</code>, alors vous verrez ceci si vous lancez
<code>cargo update</code> :</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -- >
-->
<!--
```console
$ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -> v0.8.4
```
-->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -&gt; v0.8.4
</code></pre>
<!--
Cargo ignores the `0.9.0` releaese. At this point, you would also notice a
change in your *Cargo.lock* file noting that the version of the `rand` crate
you are now using is `0.8.4`. To use `rand` version `0.9.0` or any version in
the `0.9.x` series, you’d have to update the *Cargo.toml* file to look like
this instead:
-->
<p>Cargo ignore la version <code>0.9.0</code>. À partir de ce moment, vous pouvez aussi
constater un changement dans le fichier <em>Cargo.lock</em> indiquant que la version
de la <em>crate</em> <code>rand</code> que vous utilisez maintenant est la <code>0.8.4</code>. Pour utiliser
<code>rand</code> en version <code>0.9.0</code> ou toute autre version dans la série des <code>0.9.x</code>, il
vous faut mettre à jour le fichier <em>Cargo.toml</em> comme ceci :</p>
<!--
```toml
[dependencies]
rand = "0.9.0"
```
-->
<pre><code class="language-toml">[dependencies]
rand = &quot;0.9.0&quot;
</code></pre>
<!--
The next time you run `cargo build`, Cargo will update the registry of crates
available and reevaluate your `rand` requirements according to the new version
you have specified.
-->
<p>La prochaine fois que vous lancerez <code>cargo build</code>, Cargo mettra à jour son
registre de <em>crates</em> disponibles et réévaluera vos exigences vis-à-vis de <code>rand</code>
selon la nouvelle version que vous avez spécifiée.</p>
<!--
There’s a lot more to say about [Cargo][doccargo]<!-- ignore -- > and [its
ecosystem][doccratesio]<!-- ignore -- > which we’ll discuss in Chapter 14, but
for now, that’s all you need to know. Cargo makes it very easy to reuse
libraries, so Rustaceans are able to write smaller projects that are assembled
from a number of packages.
-->
<p>Il y a encore plus à dire à propos de <a href="http://doc.crates.io">Cargo</a><!-- ignore --> et de
<a href="http://doc.crates.io/crates-io.html">son écosystème</a><!-- ignore --> que nous aborderons au chapitre 14,
mais pour l'instant, c'est tout ce qu'il vous faut savoir. Cargo
facilite la réutilisation des bibliothèques, pour que les Rustacés soient
capables d'écrire des petits projets issus d'un assemblage d'un certain
nombre de paquets.</p>
<!--
### Generating a Random Number
-->
<h3 id="générer-un-nombre-aléatoire"><a class="header" href="#générer-un-nombre-aléatoire">Générer un nombre aléatoire</a></h3>
<!--
Let’s start using `rand` to generate a number to guess. The next step is to
update *src/main.rs*, as shown in Listing 2-3.
-->
<p>Commençons désormais à utiliser <code>rand</code> pour générer un nombre à deviner. La
prochaine étape est de modifier <em>src/main.rs</em> comme dans l'encart 2-3.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```
-->
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Devinez le nombre !&quot;);

    let nombre_secret = rand::thread_rng().gen_range(1..101);

    println!(&quot;Le nombre secret est : {}&quot;, nombre_secret);

    println!(&quot;Veuillez entrer un nombre.&quot;);

    let mut supposition = String::new();

    io::stdin()
        .read_line(&amp;mut supposition)
        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);

        println!(&quot;Votre nombre : {}&quot;, supposition);
}
</code></pre>
<!--
<span class="caption">Listing 2-3: Adding code to generate a random
number</span>
-->
<p><span class="caption">Encart 2-3 : Ajout du code pour générer un nombre
aléatoire</span></p>
<!--
First, we add the line `use rand::Rng`. The `Rng` trait defines methods that
random number generators implement, and this trait must be in scope for us to
use those methods. Chapter 10 will cover traits in detail.
-->
<p>D'abord, nous avons ajouté la ligne <code>use rand::Rng</code>. Le <em>trait</em> <code>Rng</code> définit
les méthodes implémentées par les générateurs de nombres aléatoires, et ce
<em>trait</em> doit être accessible à notre code pour qu'on puisse utiliser ces
méthodes. Le chapitre 10 expliquera plus en détail les <em>traits</em>.</p>
<!--
Next, we’re adding two lines in the middle. In the first line, we call the
`rand::thread_rng` function that gives us the particular random number
generator that we’re going to use: one that is local to the current thread of
execution and seeded by the operating system. Then we call the `gen_range`
method on the random number generator. This method is defined by the `Rng`
trait that we brought into scope with the `use rand::Rng` statement. The
`gen_range` method takes a range expression as an argument and generates a
random number in the range. The kind of range expression we’re using here takes
the form `start..end` and is inclusive on the lower bound but exclusive on the
upper bound, so we need to specify `1..101` to request a number between 1 and
100. Alternatively, we could pass the range `1..=100`, which is equivalent.
-->
<p>Ensuite, nous ajoutons deux lignes au milieu. A la première ligne, nous
appelons la fonction <code>rand::thread_rng</code> qui nous fournit le générateur de
nombres aléatoires particulier que nous allons utiliser : il est propre au fil
d'exécution courant et généré par le système d'exploitation. Ensuite, nous
appelons la méthode <code>gen_range</code> sur le générateur de nombres aléatoires. Cette
méthode est définie par le <em>trait</em> <code>Rng</code> que nous avons importé avec
l'instruction <code>use rand::Rng</code>. La méthode <code>gen_range</code> prend une expression
d'intervalle en paramètre et génère un nombre aléatoire au sein de
l'intervalle. Le genre d'expression d'intervalle utilisé ici est de la forme
<code>début..fin</code> et inclut la borne inférieure mais exclut la borne supérieure,
nous avons donc besoin de préciser <code>1..101</code> pour demander un nombre entre 1
et 100. De manière équivalente, nous pourrions également passer l'intervalle
fermé <code>1..=100</code></p>
<!--
> Note: You won’t just know which traits to use and which methods and functions
> to call from a crate, so each crate has documentation with instructions for
> using it. Another neat feature of Cargo is that running the `cargo doc
> --open` command will build documentation provided by all of your dependencies
> locally and open it in your browser. If you’re interested in other
> functionality in the `rand` crate, for example, run `cargo doc --open` and
> click `rand` in the sidebar on the left.
-->
<blockquote>
<p>Remarque : vous ne pourrez pas deviner quels <em>traits</em>, méthodes et
fonctions utiliser avec une <em>crate</em>, donc chaque <em>crate</em> a une documentation
qui donne des indications sur son utilisation. Une autre fonctionnalité
intéressante de Cargo est que vous pouvez utiliser la commande
<code>cargo doc --open</code>, qui va construire localement la documentation intégrée
par toutes vos dépendances et va l'ouvrir dans votre navigateur. Si vous vous
intéressez à d'autres fonctionnalités de la <em>crate</em> <code>rand</code>, par exemple, vous
pouvez lancer <code>cargo doc --open</code> et cliquer sur <code>rand</code> dans la barre latérale
sur la gauche.</p>
</blockquote>
<!--
The second new line prints the secret number. This is useful while we’re
developing the program to be able to test it, but we’ll delete it from the
final version. It’s not much of a game if the program prints the answer as soon
as it starts!
-->
<p>La seconde nouvelle ligne affiche le nombre secret. C'est pratique lors du
développement pour pouvoir le tester, mais nous l'enlèverons dans la version
finale. Ce n'est pas vraiment un jeu si le programme affiche la réponse dès
qu'il démarre !</p>
<!--
Try running the program a few times:
-->
<p>Essayez de lancer le programme plusieurs fois :</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-- >
-->
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
```
-->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombre !
Le nombre secret est : 7
Veuillez entrer un nombre.
4
Votre nombre : 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombre !
Le nombre secret est : 83
Veuillez entrer un nombre.
5
Votre nombre : 5
</code></pre>
<!--
You should get different random numbers, and they should all be numbers between
1 and 100. Great job!
-->
<p>Vous devriez obtenir des nombres aléatoires différents, et ils devraient être
tous compris entre 1 et 100. Beau travail !</p>
<!--
## Comparing the Guess to the Secret Number
-->
<h2 id="comparer-le-nombre-saisi-au-nombre-secret"><a class="header" href="#comparer-le-nombre-saisi-au-nombre-secret">Comparer le nombre saisi au nombre secret</a></h2>
<!--
Now that we have user input and a random number, we can compare them. That step
is shown in Listing 2-4. Note that this code won’t compile quite yet, as we
will explain.
-->
<p>Maintenant que nous avons une saisie utilisateur et un nombre aléatoire, nous
pouvons les comparer. Cette étape est écrite dans l'encart 2-4. Sachez toutefois
que le code ne se compile pas encore, nous allons l'expliquer par la suite.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1..101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // -- partie masquée ici --
<span class="boring">    println!(&quot;Devinez le nombre !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret est : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</span>
    println!(&quot;Votre nombre : {}&quot;, supposition);

    match supposition.cmp(&amp;nombre_secret) {
        Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
        Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
        Ordering::Equal =&gt; println!(&quot;Vous avez gagné !&quot;),
    }
}
</code></pre>
<!--
<span class="caption">Listing 2-4: Handling the possible return values of
comparing two numbers</span>
-->
<p><span class="caption">Encart 2-4 : Traitement des valeurs possibles saisies en
comparant les deux nombres</span></p>
<!--
First we add another `use` statement, bringing a type called
`std::cmp::Ordering` into scope from the standard library. The `Ordering` type
is another enum and has the variants `Less`, `Greater`, and `Equal`. These are
the three outcomes that are possible when you compare two values.
-->
<p>Premièrement, nous ajoutons une autre instruction <code>use</code>, qui importe
<code>std::cmp::Ordering</code> à portée de notre code depuis la bibliothèque standard.
Le type <code>Ordering</code> est une autre énumération et a les variantes <code>Less</code>
<em>(inférieur)</em>, <code>Greater</code> <em>(supérieur)</em> et <code>Equal</code> <em>(égal)</em>. Ce sont les trois
issues possibles lorsqu'on compare deux valeurs.</p>
<!--
Then we add five new lines at the bottom that use the `Ordering` type. The
`cmp` method compares two values and can be called on anything that can be
compared. It takes a reference to whatever you want to compare with: here it’s
comparing the `guess` to the `secret_number`. Then it returns a variant of the
`Ordering` enum we brought into scope with the `use` statement. We use a
[`match`][match]<!-- ignore -- > expression to decide what to do next based on
which variant of `Ordering` was returned from the call to `cmp` with the values
in `guess` and `secret_number`.
-->
<p>Ensuite, nous ajoutons cinq nouvelles lignes à la fin qui utilisent le type
<code>Ordering</code>. La méthode <code>cmp</code> compare deux valeurs et peut être appelée sur
tout ce qui peut être comparé. Elle prend en paramètre une référence de ce qu'on
veut comparer : ici, nous voulons comparer <code>supposition</code> et <code>nombre_secret</code>.
Ensuite, cela retourne une variante de l'énumération <code>Ordering</code> que nous avons
importée avec l'instruction <code>use</code>. Nous utilisons une expression
<a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> pour décider quoi faire ensuite en fonction de
quelle variante de <code>Ordering</code> a été retournée à l'appel de <code>cmp</code> avec
<code>supposition</code> et <code>nombre_secret</code>.</p>
<!--
A `match` expression is made up of *arms*. An arm consists of a *pattern* to
match against, and the code that should be run if the value given to `match`
fits that arm’s pattern. Rust takes the value given to `match` and looks
through each arm’s pattern in turn. Patterns and the `match` construct are
powerful Rust features that let you express a variety of situations your code
might encounter and make sure that you handle them all. These features will be
covered in detail in Chapter 6 and Chapter 18, respectively.
-->
<p>Une expression <code>match</code> est composée de <em>branches</em>. Une branche est constituée
d'un <em>motif (pattern)</em> avec lequel elle doit correspondre et du code qui sera
exécuté si la valeur donnée au <code>match</code> correspond bien au motif de cette
branche. Rust prend la valeur donnée à <code>match</code> et la compare au motif de chaque
branche à tour de rôle. Les motifs et la structure de contrôle <code>match</code> sont des
fonctionnalités puissantes de Rust qui vous permettent de décrire une multitude
de scénarios que votre code peut rencontrer et de s'assurer que vous les gérez
toutes. Ces fonctionnalités seront expliquées plus en détail respectivement
dans le chapitre 6 et le chapitre 18.</p>
<!--
Let’s walk through an example with the `match` expression we use here. Say that
the user has guessed 50 and the randomly generated secret number this time is
38. When the code compares 50 to 38, the `cmp` method will return
`Ordering::Greater`, because 50 is greater than 38. The `match` expression gets
the `Ordering::Greater` value and starts checking each arm’s pattern. It looks
at the first arm’s pattern, `Ordering::Less`, and sees that the value
`Ordering::Greater` does not match `Ordering::Less`, so it ignores the code in
that arm and moves to the next arm. The next arm’s pattern is
`Ordering::Greater`, which *does* match `Ordering::Greater`! The associated
code in that arm will execute and print `Too big!` to the screen. The `match`
expression ends because it has no need to look at the last arm in this scenario.
-->
<p>Voyons un exemple avec l'expression <code>match</code> que nous avons utilisé ici. Disons
que l'utilisateur a saisi le nombre 50 et que le nombre secret généré
aléatoirement a cette fois-ci comme valeur 38. Quand le code compare 50 à 38,
la méthode <code>cmp</code> va retourner <code>Ordering::Greater</code>, car 50 est plus grand
que 38. L'expression <code>match</code> obtient la valeur <code>Ordering::Greater</code> et commence
à vérifier le motif de chaque branche. Elle consulte le motif de la première
branche, <code>Ordering::Less</code> et remarque que la valeur <code>Ordering::Greater</code> ne
correspond pas au motif <code>Ordering::Less</code> ; elle ignore donc le code de cette
branche et passe à la suivante. Le motif de la branche suivante est
<code>Ordering::Greater</code>, qui correspond à <code>Ordering::Greater</code> ! Le code associé à
cette branche va être exécuté et va afficher à l'écran <code>C'est moins !</code>.
L'expression <code>match</code> se termine ensuite, car elle n'a pas besoin de consulter
les autres branches de ce scénario.</p>
<!--
However, the code in Listing 2-4 won’t compile yet. Let’s try it:
-->
<p>Cependant, notre code dans l'encart 2-4 ne compile pas encore. Essayons de le
faire :</p>
<!--
```console
$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  -- > src/main.rs:22:21
   |
22 |     match guess.cmp(&secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&String`
              found reference `&{integer}`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` due to previous error
```
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match supposition.cmp(&amp;nombre_secret) {
   |                           ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `jeu_du_plus_ou_du_moins` due to previous error
</code></pre>
<!--
The core of the error states that there are *mismatched types*. Rust has a
strong, static type system. However, it also has type inference. When we wrote
`let mut guess = String::new()`, Rust was able to infer that `guess` should be
a `String` and didn’t make us write the type. The `secret_number`, on the other
hand, is a number type. A few of Rust’s number types can have a value between 1
and 100: `i32`, a 32-bit number; `u32`, an unsigned 32-bit number; `i64`, a
64-bit number; as well as others. Unless otherwise speceified, Rust defaults to
an `i32`, which is the type of `secret_number` unless you add type information
elsewhere that would cause Rust to infer a different numerical type. The reason
for the error is that Rust cannot compare a string and a number type.
-->
<p>Le message d'erreur nous indique que nous sommes dans un cas de types non
compatibles <em>(mismatched types)</em>. Rust a un système de types fort et statique.
Cependant, il a aussi une fonctionnalité d'inférence de type. Quand nous avons
écrit <code>let mut supposition = String::new()</code>, Rust a pu en déduire que
<code>supposition</code> devait être une <code>String</code> et ne nous a pas demandé d'écrire le
type. D'autre part, <code>nombre_secret</code> est d'un type de nombre. Quelques types de
nombres de Rust peuvent avoir une valeur entre 1 et 100 : <code>i32</code>, un nombre
entier encodé sur 32 bits ; <code>u32</code>, un nombre entier de 32 bits non signé
(positif ou nul) ; <code>i64</code>, un nombre entier encodé sur 64 bits ; parmi tant
d'autres. Rust utilise par défaut un <code>i32</code>, qui est le type de <code>nombre_secret</code>,
à moins que vous précisiez quelque part une information de type qui amènerait
Rust à inférer un type de nombre différent. La raison de cette erreur est que
Rust ne peut pas comparer une chaîne de caractères à un nombre.</p>
<!--
Ultimately, we want to convert the `String` the program reads as input into a
real number type so we can compare it numerically to the secret number. We do so
by adding this line to the `main` function body:
-->
<p>Au bout du compte, nous voulons convertir la <code>String</code> que le programme récupère
de la saisie utilisateur en un nombre, pour qu'on puisse la comparer
numériquement au nombre secret. Nous allons faire ceci en ajoutant cette ligne
supplémentaire dans le corps de la fonction <code>main</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1..101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret est : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span>    // -- partie masquée ici --

    let mut supposition = String::new();

    io::stdin()
        .read_line(&amp;mut supposition)
        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);

    let supposition: u32 = supposition.trim().parse().expect(&quot;Veuillez entrer un nombre !&quot;);

    println!(&quot;Votre nombre : {}&quot;, supposition);

    match supposition.cmp(&amp;nombre_secret) {
        Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
        Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
        Ordering::Equal =&gt; println!(&quot;Vous avez gagné !&quot;),
    }
<span class="boring">}
</span></code></pre>
<!--
The line is:
-->
<p>La nouvelle ligne est :</p>
<!--
```rust,ignore
let guess: u32 = guess.trim().parse().expect("Please type a number!");
```
-->
<pre><code class="language-rust ignore">let supposition: u32 = supposition.trim().parse().expect(&quot;Veuillez entrer un nombre !&quot;);
</code></pre>
<!--
We create a variable named `guess`. But wait, doesn’t the program already have
a variable named `guess`? It does, but helpfully Rust allows us to *shadow* the
previous value of `guess` with a new one. Shadowing lets us reuse the `guess`
variable name rather than forcing us to create two unique variables, such as
`guess_str` and `guess` for example. We’ll cover this in more detail in Chapter
3, but for now know that this feature is often used when you want to convert a
value from one type to another type.
-->
<p>Nous créons une variable qui s'appelle <code>supposition</code>. Mais attendez, le
programme n'a-t-il pas déjà une variable qui s'appelle <code>supposition</code> ?
C'est le cas, mais heureusement Rust nous permet de <em>masquer</em> la valeur
précédente de <code>supposition</code> avec une nouvelle.
Le masquage <em>(shadowing)</em> nous permet de réutiliser le nom de variable
<code>supposition</code>, plutôt que de nous forcer à créer deux variables distinctes,
telles que <code>supposition_str</code> et <code>supposition</code> par exemple.
Nous verrons cela plus en détails au chapitre 3, mais pour le moment cette
fonctionnalité est souvent utilisée dans des situations où on veut convertir
une valeur d'un type à un autre.</p>
<!--
We bind this new variable to the expression `guess.trim().parse()`. The `guess`
in the expression refers to the original `guess` variable that contained the
input as a string. The `trim` method on a `String` instance will eliminate any
whitespace at the beginning and end, which we must do to be able to compare the
string to the `u32`, which can only contain numerical data. The user must press
<span class="keystroke">enter</span> to satisfy `read_line` and input their
guess, which adds a newline character to the string. For example, if the user
types <span class="keystroke">5</span> and presses <span
class="keystroke">enter</span>, `guess` looks like this: `5\n`. The `\n`
represents “newline”. (On Windows, pressing <span
class="keystroke">enter</span> results in a carriage return and a newline,
`\r\n`). The `trim` method eliminates `\n` or `\r\n`, resulting in just `5`.
-->
<p>Nous lions cette nouvelle variable à l'expression <code>supposition.trim().parse()</code>.
Le <code>supposition</code> dans l'expression se réfère à la variable <code>supposition</code>
initiale qui contenait la saisie utilisateur en tant que chaîne de caractères.
<code>String</code> contenant la saisie utilisateur. La méthode <code>trim</code> sur une instance
de <code>String</code> va enlever les espaces et autres <em>whitespaces</em> au début et à la
fin, ce que nous devons faire pour comparer la chaîne au <code>u32</code>, qui ne peut
être constitué que de chiffres. L'utilisateur doit appuyer sur
<span class="keystroke">entrée</span> pour mettre fin à <code>read_line</code> et
récupérer leur supposition, ce qui va rajouter un caractère de fin de ligne à
la chaîne de caractères. Par exemple, si l'utilisateur écrit
<span class="keystroke">5</span> et appuie sur <span class="keystroke">entrée
</span>, <code>supposition</code> aura alors cette valeur : <code>5\n</code>.
Le <code>\n</code> représente une fin de ligne (à noter que sur Windows, appuyer sur
<span class="keystroke">entrée</span> résulte en un retour chariot suivi d'une
fin de ligne, <code>\r\n</code>). La méthode <code>trim</code> enlève <code>\n</code> et <code>\r\n</code>, il ne reste donc
plus que <code>5</code>.</p>
<!--
The [`parse` method on strings][parse]<!-- ignore -- > parses a string into some
kind of number. Because this method can parse a variety of number types, we
need to tell Rust the exact number type we want by using `let guess: u32`. The
colon (`:`) after `guess` tells Rust we’ll annotate the variable’s type. Rust
has a few built-in number types; the `u32` seen here is an unsigned, 32-bit
integer. It’s a good default choice for a small positive number. You’ll learn
about other number types in Chapter 3. Additionally, the `u32` annotation in
this example program and the comparison with `secret_number` means that Rust
will infer that `secret_number` should be a `u32` as well. So now the
comparison will be between two values of the same type!
-->
<p>La <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">méthode <code>parse</code> des chaînes de caractères</a><!-- ignore --> interprète
une chaîne de caractères en une sorte de nombre. Comme cette méthode peut
interpréter plusieurs types de nombres, nous devons indiquer à Rust le type
exact de nombre que nous voulons en utilisant <code>let supposition: u32</code>.
Le deux-points (<code>:</code>) après <code>supposition</code> indique à Rust que nous voulons
préciser le type de la variable.
Rust embarque quelques types de nombres ; le <code>u32</code> utilisé ici est un
entier non signé sur 32 bits.
C'est un bon choix par défaut pour un petit nombre positif.
Vous découvrirez d'autres types de nombres dans le chapitre 3.
De plus, l'annotation <code>u32</code> dans ce programme d'exemple et la
comparaison avec <code>nombre_secret</code> permet à Rust d'en déduire que <code>nombre_secret</code>
doit être lui aussi un <code>u32</code>. Donc maintenant, la comparaison se fera
entre deux valeurs du même type !</p>
<!--
The `parse` method will only work on characters that can logically be converted
into numbers and so can easily cause errors. If, for example, the string
contained `A👍%`, there would be no way to convert that to a number. Because it
might fail, the `parse` method returns a `Result` type, much as the `read_line`
method does (discussed earlier in [“Handling Potential Failure with the
`Result` Type”](#handling-potential-failure-with-the-result-type)<!-- ignore
-- >). We’ll treat this `Result` the same way by using the `expect` method
again. If `parse` returns an `Err` `Result` variant because it couldn’t create
a number from the string, the `expect` call will crash the game and print the
message we give it. If `parse` can successfully convert the string to a number,
it will return the `Ok` variant of `Result`, and `expect` will return the
number that we want from the `Ok` value.
-->
<p>La méthode <code>parse</code> va fonctionner uniquement sur des caractères qui peuvent
être logiquement convertis en nombres et donc peut facilement mener à une
erreur. Si par exemple, le texte contient <code>A👍%</code>, il ne sera pas possible de le
convertir en nombre. Comme elle peut échouer, la méthode <code>parse</code> retourne un
type <code>Result</code>, comme celui que la méthode <code>read_line</code> retourne (comme nous
l'avons vu plus tôt dans <a href="ch02-00-guessing-game-tutorial.html#g%C3%A9rer-les-erreurs-potentielles-avec-le-type-result">“Gérer les erreurs potentielles avec le type
<code>Result</code>”</a><!-- ignore-->).
Nous allons gérer ce <code>Result</code> de la même manière, avec à nouveau la méthode
<code>expect</code>. Si <code>parse</code> retourne une variante <code>Err</code> de <code>Result</code> car elle ne peut
pas créer un nombre à partir de la chaîne de caractères, l'appel à
<code>expect</code> va faire planter le jeu et va afficher le message que nous lui avons
passé en paramètre. Si <code>parse</code> arrive à convertir la chaîne de caractères en
nombre, alors elle retournera la variante <code>Ok</code> de <code>Result</code>, et <code>expect</code> va
retourner le nombre qu'il nous faut qui est stocké dans la variante <code>Ok</code>.</p>
<!--
Let’s run the program now!
-->
<p>Exécutons ce programme, maintenant !</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-- >
-->
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombre !
Le nombre secret est : 58
Veuillez entrer un nombre.
  76
Votre nombre : 76
C'est moins !
</code></pre>
<!--
Nice! Even though spaces were added before the guess, the program still figured
out that the user guessed 76. Run the program a few times to verify the
different behavior with different kinds of input: guess the number correctly,
guess a number that is too high, and guess a number that is too low.
-->
<p>Très bien !
Même si des espaces ont été ajoutées avant la supposition, le programme a quand
même compris que l'utilisateur a saisi 76. Lancez le programme plusieurs
fois pour vérifier qu'il se comporte correctement avec différentes saisies :
devinez le nombre correctement, saisissez un nombre qui est trop grand, et
saisissez un nombre qui est trop petit.</p>
<!--
We have most of the game working now, but the user can make only one guess.
Let’s change that by adding a loop!
-->
<p>La majeure partie du jeu fonctionne désormais, mais l'utilisateur ne peut faire
qu'une seule supposition. Corrigeons cela en ajoutant une boucle !</p>
<!--
## Allowing Multiple Guesses with Looping
-->
<h2 id="permettre-plusieurs-suppositions-avec-les-boucles"><a class="header" href="#permettre-plusieurs-suppositions-avec-les-boucles">Permettre plusieurs suppositions avec les boucles</a></h2>
<!--
The `loop` keyword creates an infinite loop. We’ll add a loop to give users
more chances at guessing the number:
-->
<p>Le mot-clé <code>loop</code> crée une boucle infinie. Nous allons ajouter une boucle pour
donner aux utilisateurs plus de chances de deviner le nombre :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1..101);
# 
    // --snip--

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        // --snip--

# 
#         let mut guess = String::new();
# 
#         io::stdin()
#             .read_line(&mut guess)
#             .expect("Failed to read line");
# 
#         let guess: u32 = guess.trim().parse().expect("Please type a number!");
# 
#         println!("You guessed: {}", guess);
# 
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => println!("You win!"),
        }
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span>    // -- partie masquée ici --

    println!(&quot;Le nombre secret est : {}&quot;, nombre_secret);

    loop {
        println!(&quot;Veuillez entrer un nombre.&quot;);

        // -- partie masquée ici --

<span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut supposition)
</span><span class="boring">            .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">        let supposition: u32 = supposition.trim().parse().expect(&quot;Veuillez entrer un nombre !&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Votre nombre : {}&quot;, supposition);
</span><span class="boring">
</span>        match supposition.cmp(&amp;nombre_secret) {
            Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
            Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
            Ordering::Equal =&gt; println!(&quot;Vous avez gagné !&quot;),
        }
    }
}
</code></pre>
<!--
As you can see, we’ve moved everything from the guess input prompt onward into
a loop. Be sure to indent the lines inside the loop another four spaces each
and run the program again. The program will now ask for another guess forever,
which actually introduces a new problem. It doesn’t seem like the user can quit!
-->
<p>Comme vous pouvez le remarquer, nous avons déplacé dans une boucle tout le code
de l'invite à entrer le nombre. Assurez-vous d'indenter correctement les lignes
dans la boucle avec quatre nouvelles espaces pour chacune, et lancez à nouveau
le programme. Le programme va désormais demander un nombre à l'infini, ce qui
est un nouveau problème. Il n'est pas possible pour l'utilisateur de
l'arrêter !</p>
<!--
The user could always interrupt the program by using the keyboard shortcut
<span class="keystroke">ctrl-c</span>. But there’s another way to escape this
insatiable monster, as mentioned in the `parse` discussion in [“Comparing the
Guess to the Secret Number”](#comparing-the-guess-to-the-secret-number)<!--
ignore -- >: if the user enters a non-number answer, the program will crash. We
can take advantage of that to allow the user to quit, as shown here:
-->
<p>L'utilisateur pourrait quand même interrompre le programme en utilisant le
raccourci clavier <span class="keystroke">ctrl-c</span>.
Mais il y a une autre façon d'échapper à ce monstre insatiable, comme nous
l'avons abordé dans la partie <a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">“Comparer le nombre saisi au nombre
secret”</a><!-- ignore --> : si
l'utilisateur saisit quelque chose qui n'est pas un nombre, le programme va
planter. Nous pouvons procéder ainsi pour permettre à l'utilisateur de quitter,
comme ci-dessous :</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-- >
-->
<!-- markdownlint-disable -->
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<!-- markdownlint-restore -->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombre !
Le nombre secret est : 59
Veuillez entrer un nombre.
45
Votre nombre : 45
C'est plus !
Veuillez entrer un nombre.
60
Votre nombre : 60
C'est moins !
Veuillez entrer un nombre.
59
Votre nombre : 59
Vous avez gagné !
Veuillez entrer un nombre.
quitter
thread 'main' panicked at 'Veuillez entrer un nombre !: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: Run with `RUST_BACKTRACE=1` for a backtrace
</code></pre>
<!--
Typing `quit` will quit the game, but as you’ll notice so will entering any
other non-number input. This is suboptimal to say the least; we want the game
to also stop when the correct number is guessed.
-->
<p>Taper <code>quitter</code> va bien fermer le jeu, mais comme vous pouvez le remarquer,
toute autre saisie qui n'est pas un nombre le ferait aussi. Ce mécanisme laisse
franchement à désirer ; nous voudrions que le jeu s'arrête aussi lorsque le bon
nombre est deviné.</p>
<!--
### Quitting After a Correct Guess
-->
<h3 id="arrêter-le-programme-après-avoir-gagné"><a class="header" href="#arrêter-le-programme-après-avoir-gagné">Arrêter le programme après avoir gagné</a></h3>
<!--
Let’s program the game to quit when the user wins by adding a `break` statement:
-->
<p>Faisons en sorte que le jeu s'arrête quand le joueur gagne en ajoutant
l'instruction <code>break</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1..101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     loop {
#         println!("Please input your guess.");
# 
#         let mut guess = String::new();
# 
#         io::stdin()
#             .read_line(&mut guess)
#             .expect("Failed to read line");
# 
#         let guess: u32 = guess.trim().parse().expect("Please type a number!");
# 
#         println!("You guessed: {}", guess);
# 
        // --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret est : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut supposition)
</span><span class="boring">            .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">        let supposition: u32 = supposition.trim().parse().expect(&quot;Veuillez entrer un nombre !&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Votre nombre : {}&quot;, supposition);
</span><span class="boring">
</span>        // -- partie masquée ici --

        match supposition.cmp(&amp;nombre_secret) {
            Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
            Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Vous avez gagné !&quot;);
                break;
            }
        }
    }
}
</code></pre>
<!--
Adding the `break` line after `You win!` makes the program exit the loop when
the user guesses the secret number correctly. Exiting the loop also means
exiting the program, because the loop is the last part of `main`.
-->
<p>Ajouter la ligne <code>break</code> après <code>Vous avez gagné !</code> fait sortir le programme de
la boucle quand le joueur a correctement deviné le nombre secret. Et quitter la
boucle veut aussi dire terminer le programme, car ici la boucle est la dernière
partie de <code>main</code>.</p>
<!--
### Handling Invalid Input
-->
<h3 id="gérer-les-saisies-invalides"><a class="header" href="#gérer-les-saisies-invalides">Gérer les saisies invalides</a></h3>
<!--
To further refine the game’s behavior, rather than crashing the program when
the user inputs a non-number, let’s make the game ignore a non-number so the
user can continue guessing. We can do that by altering the line where `guess`
is converted from a `String` to a `u32`, as shown in Listing 2-5.
-->
<p>Pour améliorer le comportement du jeu, plutôt que de faire planter le programme
quand l'utilisateur saisit quelque chose qui n'est pas un nombre, faisons en
sorte que le jeu ignore ce qui n'est pas un nombre afin que l'utilisateur puisse
continuer à essayer de deviner. Nous pouvons faire ceci en modifiant la ligne où
<code>supposition</code> est converti d'une <code>String</code> en un <code>u32</code>, comme dans l'encart 2-5 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1..101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     loop {
#         println!("Please input your guess.");
# 
#         let mut guess = String::new();
# 
        // --snip--

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        // --snip--
# 
#         match guess.cmp(&secret_number) {
#             Ordering::Less => println!("Too small!"),
#             Ordering::Greater => println!("Too big!"),
#             Ordering::Equal => {
#                 println!("You win!");
#                 break;
#             }
#         }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret est : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span>        // -- partie masquée ici --

        io::stdin()
            .read_line(&amp;mut supposition)
            .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);

        let supposition: u32 = match supposition.trim().parse() {
            Ok(nombre) =&gt; nombre,
            Err(_) =&gt; continue,
        };

        println!(&quot;Votre nombre : {}&quot;, supposition);

        // -- partie masquée ici --
<span class="boring">
</span><span class="boring">        match supposition.cmp(&amp;nombre_secret) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Vous avez gagné !&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 2-5: Ignoring a non-number guess and asking for
another guess instead of crashing the program</span>
-->
<p><span class="caption">Encart 2-5 : Ignorer une saisie qui n'est pas un nombre
et demander un nouveau nombre plutôt que de faire planter le programme</span></p>
<!--
We switch from an `expect` call to a `match` expression to move from crashing
on an error to handling the error. Remember that `parse` returns a `Result`
type and `Result` is an enum that has the variants `Ok` or `Err`. We’re using a
`match` expression here, as we did with the `Ordering` result of the `cmp`
method.
-->
<p>Nous remplaçons un appel à <code>expect</code> par une expression <code>match</code> pour passer
d'une erreur qui fait planter le programme à une erreur proprement gérée.
N'oubliez pas que <code>parse</code> retourne un type <code>Result</code> et que <code>Result</code> est une
énumération qui a pour variantes <code>Ok</code> ou <code>Err</code>. Nous utilisons ici une
expression <code>match</code> comme nous l'avons déjà fait avec le résultat de type
<code>Ordering</code> de la méthode <code>cmp</code>.</p>
<!--
If `parse` is able to successfully turn the string into a number, it will
return an `Ok` value that contains the resulting number. That `Ok` value will
match the first arm’s pattern, and the `match` expression will just return the
`num` value that `parse` produced and put inside the `Ok` value. That number
will end up right where we want it in the new `guess` variable we’re creating.
-->
<p>Si <code>parse</code> arrive à convertir la chaîne de caractères en nombre, cela va
retourner la variante <code>Ok</code> qui contient le nombre qui en résulte. Cette variante
va correspondre au motif de la première branche, et l'expression <code>match</code> va
simplement retourner la valeur de <code>nombre</code> que <code>parse</code> a trouvée et qu'elle a
mise dans la variante <code>Ok</code>.
Ce nombre va se retrouver là où nous en avons besoin,
dans la variable <code>supposition</code> que nous sommes en train de créer.</p>
<!--
If `parse` is *not* able to turn the string into a number, it will return an
`Err` value that contains more information about the error. The `Err` value
does not match the `Ok(num)` pattern in the first `match` arm, but it does
match the `Err(_)` pattern in the second arm. The underscore, `_`, is a
catchall value; in this example, we’re saying we want to match all `Err`
values, no matter what information they have inside them. So the program will
execute the second arm’s code, `continue`, which tells the program to go to the
next iteration of the `loop` and ask for another guess. So, effectively, the
program ignores all errors that `parse` might encounter!
-->
<p>Si <code>parse</code> n'arrive <em>pas</em> à convertir la chaîne de caractères en nombre, elle
va retourner la variante <code>Err</code> qui contient plus d'informations sur l'erreur. La
variante <code>Err</code> ne correspond pas au motif <code>Ok(nombre)</code> de la première branche,
mais elle correspond au motif <code>Err(_)</code> de la seconde branche. Le tiret bas,
<code>_</code>, est une valeur passe-partout ; dans notre exemple, nous disons
que nous voulons correspondre à toutes les valeurs de <code>Err</code>, peu importe quelle
information elles ont à l'intérieur d'elles-mêmes. Donc le programme va exécuter
le code de la seconde branche, <code>continue</code>, qui indique au programme de se rendre
à la prochaine itération de <code>loop</code> et de demander un nouveau nombre. Ainsi, le
programme ignore toutes les erreurs que <code>parse</code> pourrait rencontrer !</p>
<!--
Now everything in the program should work as expected. Let’s try it:
-->
<p>Maintenant, le programme devrait fonctionner correctement. Essayons-le :</p>
<!--
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-- >
-->
<!--
```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/jeu_du_plus_ou_du_moins`
Devinez le nombre !
Le nombre secret est : 61
Veuillez entrer un nombre.
10
Votre nombre : 10
C'est plus !
Veuillez entrer un nombre.
99
Votre nombre : 99
C'est moins !
Veuillez entrer un nombre.
foo
Veuillez entrer un nombre.
61
Votre nombre : 61
Vous avez gagné !
</code></pre>
<!--
Awesome! With one tiny final tweak, we will finish the guessing game. Recall
that the program is still printing the secret number. That worked well for
testing, but it ruins the game. Let’s delete the `println!` that outputs the
secret number. Listing 2-6 shows the final code.
-->
<p>Super ! Avec notre petite touche finale, nous avons fini notre jeu du plus ou du
moins. Rappelez-vous que le programme affiche toujours le nombre secret. C'était
pratique pour les tests, mais cela gâche le jeu. Supprimons le <code>println!</code> qui
affiche le nombre secret. L'encart 2-6 représente le code final.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..101);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```
-->
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Devinez le nombre !&quot;);

    let nombre_secret = rand::thread_rng().gen_range(1..101);

    loop {
        println!(&quot;Veuillez entrer un nombre.&quot;);

        let mut supposition = String::new();

        io::stdin()
            .read_line(&amp;mut supposition)
            .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);

        let supposition: u32 = match supposition.trim().parse() {
            Ok(nombre) =&gt; nombre,
            Err(_) =&gt; continue,
        };

        println!(&quot;Votre nombre : {}&quot;, supposition);

        match supposition.cmp(&amp;nombre_secret) {
            Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
            Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Vous avez gagné !&quot;);
                break;
            }
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 2-6: Complete guessing game code</span>
-->
<p><span class="caption">Encart 2-6 : Code complet du jeu du plus ou du moins
</span></p>
<!--
## Summary
-->
<h2 id="résumé-1"><a class="header" href="#résumé-1">Résumé</a></h2>
<!--
At this point, you’ve successfully built the guessing game. Congratulations!
-->
<p>Si vous êtes arrivé jusqu'ici, c'est que vous avez construit avec succès le jeu
du plus ou du moins. Félicitations !</p>
<!--
This project was a hands-on way to introduce you to many new Rust concepts:
`let`, `match`, functions, the use of external crates, and more. In the next
few chapters, you’ll learn about these concepts in more detail. Chapter 3
covers concepts that most programming languages have, such as variables, data
types, and functions, and shows how to use them in Rust. Chapter 4 explores
ownership, a feature that makes Rust different from other languages. Chapter 5
discusses structs and method syntax, and Chapter 6 explains how enums work.
-->
<p>Ce projet était une mise en pratique pour vous initier à de nombreux concepts de
Rust : <code>let</code>, <code>match</code>, les méthodes, les fonctions associées, l'utilisation de
<em>crates</em> externes, et bien plus. Dans les prochains chapitres, vous allez en
apprendre plus sur ces concepts. Le chapitre 3 va traiter des concepts utilisés
par la plupart des langages de programmation, comme les variables, les types de
données, et les fonctions, et vous montrera comment les utiliser avec Rust. Le
chapitre 4 expliquera la possession <em>(ownership)</em>, qui est une fonctionnalité
qui distingue Rust des autres langages. Le chapitre 5 abordera les structures et
les syntaxes des méthodes, et le chapitre 6 expliquera comment les énumérations
fonctionnent.</p>
<!--
[prelude]: ../std/prelude/index.html
[variables-and-mutability]: ch03-01-variables-and-mutability.html#variables-and-mutability
[comments]: ch03-04-comments.html
[string]: ../std/string/struct.String.html
[iostdin]: ../std/io/struct.Stdin.html
[read_line]: ../std/io/struct.Stdin.html#method.read_line
[ioresult]: ../std/io/type.Result.html
[result]: ../std/result/enum.Result.html
[enums]: ch06-00-enums.html
[expect]: ../std/result/enum.Result.html#method.expect
[recover]: ch09-02-recoverable-errors-with-result.html
[randcrate]: https://crates.io/crates/rand
[semver]: http://semver.org
[cratesio]: https://crates.io/
[doccargo]: http://doc.crates.io
[doccratesio]: http://doc.crates.io/crates-io.html
[match]: ch06-02-match.html
[parse]: ../std/primitive.str.html#method.parse
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Common Programming Concepts
-->
<h1 id="les-concepts-courants-de-programmation"><a class="header" href="#les-concepts-courants-de-programmation">Les concepts courants de programmation</a></h1>
<!--
This chapter covers concepts that appear in almost every programming language
and how they work in Rust. Many programming languages have much in common at
their core. None of the concepts presented in this chapter are unique to Rust,
but we’ll discuss them in the context of Rust and explain the conventions
around using these concepts.
-->
<p>Ce chapitre explique des concepts qui apparaissent dans presque tous les
langages de programmation, et la manière dont ils fonctionnent en Rust. De
nombreux langages sont basés sur des concepts communs. Les concepts présentés
dans ce chapitre ne sont pas spécifiques à Rust, mais nous les appliquerons
à Rust et nous expliquerons les conventions qui leur sont liées.</p>
<!--
Specifically, you’ll learn about variables, basic types, functions, comments,
and control flow. These foundations will be in every Rust program, and learning
them early will give you a strong core to start from.
-->
<p>Plus précisément, vous allez apprendre les concepts de variables, les types de
base, les fonctions, les commentaires, et les structures de contrôle. Ces
notions fondamentales seront présentes dans tous les programmes Rust, et les
apprendre dès le début vous procurera de solides bases pour débuter.</p>
<!--
> #### Keywords
>
> The Rust language has a set of *keywords* that are reserved for use by
> the language only, much as in other languages. Keep in mind that you cannot
> use these words as names of variables or functions. Most of the keywords have
> special meanings, and you’ll be using them to do various tasks in your Rust
> programs; a few have no current functionality associated with them but have
> been reserved for functionality that might be added to Rust in the future. You
> can find a list of the keywords in [Appendix A][appendix_a]<!-- ignore -- >.
-->
<blockquote>
<h4 id="mots-clés"><a class="header" href="#mots-clés">Mots-clés</a></h4>
<p>Le langage Rust possède un ensemble de <em>mots-clés</em> qui ont été réservés pour
l'usage exclusif du langage, tout comme le font d'autres langages. Gardez à
l'esprit que vous ne pouvez pas utiliser ces mots pour des noms de variables
ou de fonctions. La plupart des mots-clés ont une signification spéciale, et
vous les utiliserez pour réaliser de différentes tâches dans vos programmes
Rust ; quelques-uns n'ont aucune fonctionnalité active pour le moment, mais
ont été réservés pour être ajoutés plus tard à Rust.
Vous pouvez trouver la liste de ces mots-clés dans
<a href="appendix-01-keywords.html">l'annexe A</a><!-- ignore -->.</p>
</blockquote>
<!--
[appendix_a]: appendix-01-keywords.md
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Variables and Mutability
-->
<h2 id="les-variables-et-la-mutabilité"><a class="header" href="#les-variables-et-la-mutabilité">Les variables et la mutabilité</a></h2>
<!--
As mentioned in the [“Storing Values with
Variables”][storing-values-with-variables]<!-- ignore -- > section, by default
variables are immutable. This is one of many nudges Rust gives you to write
your code in a way that takes advantage of the safety and easy concurrency that
Rust offers. However, you still have the option to make your variables mutable.
Let’s explore how and why Rust encourages you to favor immutability and why
sometimes you might want to opt out.
-->
<p>Tel qu'abordé au <a href="ch02-00-guessing-game-tutorial.html">chapitre 2</a><!-- ignore -->,
par défaut, les variables sont <em>immuables</em>. C'est un des nombreux coups de pouce
de Rust pour écrire votre code de façon à garantir la sécurité et la concurrence
sans problème. Cependant, vous avez quand même la possibilité de rendre vos
variables mutables <em>(modifiables)</em>. Explorons comment et pourquoi Rust vous
encourage à favoriser l'immuabilité, et pourquoi parfois vous pourriez choisir
d'y renoncer.</p>
<!--
When a variable is immutable, once a value is bound to a name, you can’t change
that value. To illustrate this, let’s generate a new project called *variables*
in your *projects* directory by using `cargo new variables`.
-->
<p>Lorsqu'une variable est immuable, cela signifie qu'une fois qu'une valeur est
liée à un nom, vous ne pouvez pas changer cette valeur. À titre d'illustration,
générons un nouveau projet appelé <em>variables</em> dans votre dossier <em>projects</em> en
utilisant <code>cargo new variables</code>.</p>
<!--
Then, in your new *variables* directory, open *src/main.rs* and replace its
code with the following code. This code won’t compile just yet, we'll first
examine the immutability error.
-->
<p>Ensuite, dans votre nouveau dossier <em>variables</em>, ouvrez <em>src/main.rs</em> et
remplacez son code par le code suivant. Ce code ne se compile pas pour le
moment, nous allons commencer par étudier l'erreur d'immutabilité.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;La valeur de x est : {}&quot;, x);
    x = 6;
    println!(&quot;La valeur de x est : {}&quot;, x);
}
</code></pre>
<!--
Save and run the program using `cargo run`. You should receive an error
message, as shown in this output:
-->
<p>Sauvegardez et lancez le programme en utilisant <code>cargo run</code>. Vous devriez
avoir un message d'erreur comme celui-ci :</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 -- > src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!(&quot;La valeur de x est : {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
</code></pre>
<!--
This example shows how the compiler helps you find errors in your programs.
Compiler errors can be frustrating, but really they only mean your program
isn’t safely doing what you want it to do yet; they do *not* mean that you’re
not a good programmer! Experienced Rustaceans still get compiler errors.
-->
<p>Cet exemple montre comment le compilateur vous aide à trouver les erreurs dans
vos programmes. Les erreurs de compilation peuvent s'avérer frustrantes, mais
elles signifient en réalité que, pour le moment, votre programme n'est pas en
train de faire ce que vous voulez qu'il fasse en toute sécurité ; elles ne
signifient <em>pas</em> que vous êtes un mauvais développeur ! Même les Rustacés
expérimentés continuent d'avoir des erreurs de compilation.</p>
<!--
The error message indicates that the cause of the error is that you `` cannot
assign twice to immutable variable `x` ``, because you tried to assign a second
value to the immutable `x` variable.
-->
<p>Ce message d'erreur indique que la cause du problème est qu'il est
<code>impossible d'assigner à deux reprises la variable immuable `x`</code>
(<code>cannot assign twice to immutable variable `x`</code>).</p>
<!--
It’s important that we get compile-time errors when we attempt to change a
value that’s designated as immutable because this very situation can lead to
bugs. If one part of our code operates on the assumption that a value will
never change and another part of our code changes that value, it’s possible
that the first part of the code won’t do what it was designed to do. The cause
of this kind of bug can be difficult to track down after the fact, especially
when the second piece of code changes the value only *sometimes*. The Rust
compiler guarantees that when you state a value won’t change, it really won’t
change, so you don’t have to keep track of it yourself. Your code is thus
easier to reason through.
-->
<p>Il est important que nous obtenions des erreurs au moment de la compilation
lorsque nous essayons de changer une valeur qui a été déclarée comme immuable,
car cette situation particulière peut donner lieu à des bogues. Si une partie
de notre code part du principe qu'une valeur ne changera jamais et qu'une autre
partie de notre code modifie cette valeur, il est possible que la première
partie du code ne fasse pas ce pour quoi elle a été conçue. La cause de ce
genre de bogue peut être difficile à localiser après coup, en particulier
lorsque la seconde partie du code ne modifie que <em>parfois</em> cette valeur. Le
compilateur Rust garantit que lorsque vous déclarez qu'une valeur ne change
pas, il ne va jamais changer, donc vous n'avez pas à en vous soucier. Votre
code est ainsi plus facile à maîtriser.</p>
<!--
But mutability can be very useful, and can make code more convenient to write.
Variables are immutable only by default; as you did in Chapter 2, you can make
them mutable by adding `mut` in front of the variable name. Adding `mut` also
conveys intent to future readers of the code by indicating that other parts of
the code will be changing this variable’s value.
-->
<p>Mais la mutabilité peut s'avérer très utile, et peut faciliter la rédaction du
code. Les variables sont immuables par défaut ; mais comme vous l'avez fait au
chapitre 2, vous pouvez les rendre mutables en ajoutant <code>mut</code> devant le nom de
la variable. L'ajout de <code>mut</code> va aussi signaler l'intention aux futurs lecteurs
de ce code que d'autres parties du code vont modifier la valeur de cette
variable.</p>
<!--
For example, let’s change *src/main.rs* to the following:
-->
<p>Par exemple, modifions <em>src/main.rs</em> ainsi :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;La valeur de x est : {}&quot;, x);
    x = 6;
    println!(&quot;La valeur de x est : {}&quot;, x);
}
</code></pre></pre>
<!--
When we run the program now, we get this:
-->
<p>Lorsque nous exécutons le programme, nous obtenons :</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
La valeur de x est : 5
La valeur de x est : 6
</code></pre>
<!--
We’re allowed to change the value that `x` binds to from `5` to `6` when `mut`
is used. There are multiple trade-offs to consider in addition to the
prevention of bugs. For example, in cases where you’re using large data
structures, mutating an instance in place may be faster than copying and
returning newly allocated instances. With smaller data structures, creating new
instances and writing in a more functional programming style may be easier to
think through, so lower performance might be a worthwhile penalty for gaining
that clarity.
-->
<p>En utilisant <code>mut</code>, nous avons permis à la valeur de <code>x</code> de passer de <code>5</code> à
<code>6</code>. Il y a d'autres compromis à envisager, en plus de la prévention des
bogues. Par exemple, dans le cas où vous utiliseriez des grosses structures de
données, muter une instance déjà existante peut être plus rapide que copier et
retourner une instance nouvellement allouée. Avec des structures de données
plus petites, créer de nouvelles instances avec un style de programmation
fonctionnelle peut rendre le code plus facile à comprendre, donc il peut valoir
le coup de sacrifier un peu de performance pour que le code gagne en clarté.</p>
<!--
### Constants
-->
<h3 id="les-constantes"><a class="header" href="#les-constantes">Les constantes</a></h3>
<!--
Like immutable variables, *constants* are values that are bound to a name and
are not allowed to change, but there are a few differences between constants
and variables.
-->
<p>Comme les variables immuables, les <em>constantes</em> sont des valeurs qui sont liées
à un nom et qui ne peuvent être modifiées, mais il y a quelques différences
entre les constantes et les variables.</p>
<!--
First, you aren’t allowed to use `mut` with constants. Constants aren’t just
immutable by default—they’re always immutable. You declare constants using the
`const` keyword instead of the `let` keyword, and the type of the value *must*
be annotated. We’re about to cover types and type annotations in the next
section, [“Data Types,”][data-types]<!-- ignore -- > so don’t worry about the
details right now. Just know that you must always annotate the type.
-->
<p>D'abord, vous ne pouvez pas utiliser <code>mut</code> avec les constantes. Les constantes
ne sont pas seulement immuables par défaut − elles sont toujours immuables. On
déclare les constantes en utilisant le mot-clé <code>const</code> à la place du mot-clé
<code>let</code>, et le type de la valeur <em>doit</em> être indiqué. Nous allons aborder les
types et les annotations de types dans la prochaine section, <a href="ch03-02-data-types.html#les-types-de-donn%C3%A9es">“Les types de
données”</a><!-- ignore -->, donc ne vous souciez pas des détails pour
le moment. Sachez seulement que vous devez toujours indiquer le type.</p>
<!--
Constants can be declared in any scope, including the global scope, which makes
them useful for values that many parts of code need to know about.
-->
<p>Les constantes peuvent être déclarées à n'importe quel endroit du code, y
compris la portée globale, ce qui les rend très utiles pour des valeurs que de
nombreuses parties de votre code ont besoin de connaître.</p>
<!--
The last difference is that constants may be set only to a constant expression,
not the result of a value that could only be computed at runtime.
-->
<p>La dernière différence est que les constantes ne peuvent être définies que par
une expression constante, et non pas le résultat d'une valeur qui ne pourrait
être calculée qu'à l'exécution.</p>
<!--
Here’s an example of a constant declaration:
-->
<p>Voici un exemple d'une déclaration de constante :</p>
<!--
```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const TROIS_HEURES_EN_SECONDES: u32 = 60 * 60 * 3;
<span class="boring">}
</span></code></pre></pre>
<!--
The constant’s name is `THREE_HOURS_IN_SECONDS` and its value is set to the
result of multiplying 60 (the number of seconds in a minute) by 60 (the number
of minutes in an hour) by 3 (the number of hours we want to count in this
program). Rust’s naming convention for constants is to use all uppercase with
underscores between words. The compiler is able to evaluate a limited set of
operations at compile time, which lets us choose to write out this value in a
way that’s easier to understand and verify, rather than setting this constant
to the value 10,800. See the [Rust Reference’s section on constant
evaluation][const-eval] for more information on what operations can be used
when declaring constants.
-->
<p>Le nom de la constante est <code>TROIS_HEURES_EN_SECONDES</code> et sa valeur est définie
comme étant le résultat de la multiplication de 60 (le nombre de secondes dans
une minute) par 60 (le nombre de minutes dans une heure) par 3 (le nombre
d'heures que nous voulons calculer dans ce programme).
En Rust, la convention de nommage des constantes est de les écrire tout en
majuscule avec des tirets bas entre les mots. Le compilateur peut calculer un
certain nombre d'opérationss à la compilation, ce qui nous permet d'écrire
cette valeur de façon à la comprendre plus facilement et à la vérifier, plutôt
que de définir cette valeur à 10 800. Vous pouvez consulter la <a href="https://doc.rust-lang.org/reference/const_eval.html">section de la
référence Rust à propos des évaluations des constantes</a> pour en
savoir plus sur les opérations qui peuvent être utilisées pour déclarer des
constantes.</p>
<!--
Constants are valid for the entire time a program runs, within the scope they
were declared in. This property makes constants useful for values in your
application domain that multiple parts of the program might need to know about,
such as the maximum number of points any player of a game is allowed to earn or
the speed of light.
-->
<p>Les constantes sont valables pendant toute la durée d'exécution du programme
au sein de la portée dans laquelle elles sont déclarées. Cette caractéristique
rends les constantes très utiles lorsque plusieurs parties du programme doivent
connaître certaines valeurs, comme par exemple le nombre maximum de points
qu'un joueur est autorisé à gagner ou encore la vitesse de la lumière.</p>
<!--
Naming hardcoded values used throughout your program as constants is useful in
conveying the meaning of that value to future maintainers of the code. It also
helps to have only one place in your code you would need to change if the
hardcoded value needed to be updated in the future.
-->
<p>Déclarer des valeurs codées en dur et utilisées tout le long de votre programme
en tant que constantes est utile pour faire comprendre la signification de ces
valeurs dans votre code aux futurs développeurs. Cela permet également de
n'avoir qu'un seul endroit de votre code à modifier si cette valeur codée en dur
doit être mise à jour à l'avenir.</p>
<!--
### Shadowing
-->
<h3 id="le-masquage"><a class="header" href="#le-masquage">Le masquage</a></h3>
<!--
As you saw in the guessing game tutorial in [Chapter
2][comparing-the-guess-to-the-secret-number]<!-- ignore -- >, you can declare a
new variable with the same name as a previous variable. Rustaceans say that the
first variable is *shadowed* by the second, which means that the second
variable’s value is what the program sees when the variable is used. We can
shadow a variable by using the same variable’s name and repeating the use of
the `let` keyword as follows:
-->
<p>Comme nous l'avons vu dans le <a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">Chapitre
2</a><!-- ignore -->, on peut déclarer
une nouvelle variable avec le même nom qu'une variable précédente. Les Rustacés
disent que la première variable est <em>masquée</em> par la seconde, ce qui signifie
que la valeur de la seconde variable sera ce que le programme verra lorsque
nous utiliserons cette variable. Nous pouvons créer un masque d'une variable en
utilisant le même nom de variable et en réutilisant le mot-clé <code>let</code> comme
ci-dessous :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!(&quot;La valeur de x dans la portée interne est : {}&quot;, x);
    }

    println!(&quot;La valeur de x est : {}&quot;, x);
}
</code></pre></pre>
<!--
This program first binds `x` to a value of `5`. Then it shadows `x` by
repeating `let x =`, taking the original value and adding `1` so the value of
`x` is then `6`. Then, within an inner scope, the third `let` statement also
shadows `x`, multiplying the previous value by `2` to give `x` a value of `12`.
When that scope is over, the inner shadowing ends and `x` returns to being `6`.
When we run this program, it will output the following:
-->
<p>Au début, ce programme lie <code>x</code> à la valeur <code>5</code>. Puis il crée un masque de <code>x</code>
en répétant <code>let x =</code>, en récupérant la valeur d'origine et lui ajoutant <code>1</code> :
la valeur de <code>x</code> est désormais <code>6</code>. Ensuite, à l'intérieur de la portée interne,
la troisième instruction <code>let</code> crée un autre masque de <code>x</code>, en récupérant la
précédente valeur et en la multipliant par <code>2</code> pour donner à <code>x</code> la valeur
finale de <code>12</code>. Dès que nous sortons de cette portée, le masque prends fin, et
<code>x</code> revient à la valeur <code>6</code>. Lorsque nous exécutons ce programme, nous obtenons
ceci :</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
La valeur de x dans la portée interne est : 12
La valeur de x est : 6
</code></pre>
<!--
Shadowing is different from marking a variable as `mut`, because we’ll get a
compile-time error if we accidentally try to reassign to this variable without
using the `let` keyword. By using `let`, we can perform a few transformations
on a value but have the variable be immutable after those transformations have
been completed.
-->
<p>Créer un masque est différent que de marquer une variable comme étant <code>mut</code>,
car à moins d'utiliser une nouvelle fois le mot-clé <code>let</code>, nous obtiendrons une
erreur de compilation si nous essayons de réassigner cette variable par
accident. Nous pouvons effectuer quelques transformations sur une valeur en
utilisant <code>let</code>, mais faire en sorte que la variable soit immuable après que ces
transformations ont été appliquées.</p>
<!--
The other difference between `mut` and shadowing is that because we’re
effectively creating a new variable when we use the `let` keyword again, we can
change the type of the value but reuse the same name. For example, say our
program asks a user to show how many spaces they want between some text by
inputting space characters, and then we want to store that input as a number:
-->
<p>Comme nous créons une nouvelle variable lorsque nous utilisons le mot-clé <code>let</code>
une nouvelle fois, l'autre différence entre le <code>mut</code> et la création d'un masque
est que cela nous permet de changer le type de la valeur, mais en réutilisant
le même nom. Par exemple, imaginons un programme qui demande à l'utilisateur
le nombre d'espaces qu'il souhaite entre deux portions de texte en saisissant
des espaces, et ensuite nous voulons stocker cette saisie sous forme de
nombre :</p>
<!--
```rust
# fn main() {
    let spaces = "   ";
    let spaces = spaces.len();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let espaces = &quot;   &quot;;
    let espaces = espaces.len();
<span class="boring">}
</span></code></pre></pre>
<!--
The first `spaces` variable is a string type and the second `spaces` variable
is a number type. Shadowing thus spares us from having to come up with
different names, such as `spaces_str` and `spaces_num`; instead, we can reuse
the simpler `spaces` name. However, if we try to use `mut` for this, as shown
here, we’ll get a compile-time error:
-->
<p>La première variable <code>espaces</code> est du type chaîne de caractères <em>(string)</em> et
la seconde variable <code>espaces</code> est du type nombre. L'utilisation du masquage
nous évite ainsi d'avoir à trouver des noms différents, comme <code>espaces_str</code> et
<code>espaces_num</code> ; nous pouvons plutôt simplement réutiliser le nom <code>espaces</code>.
Cependant, si nous essayons d'utiliser <code>mut</code> pour faire ceci, comme ci-dessous,
nous avons une erreur de compilation :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let mut spaces = "   ";
    spaces = spaces.len();
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let mut espaces = &quot;   &quot;;
    espaces = espaces.len();
<span class="boring">}
</span></code></pre>
<!--
The error says we’re not allowed to mutate a variable’s type:
-->
<p>L'erreur indique que nous ne pouvons pas muter le type d'une variable :</p>
<!--
```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 -- > src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     espaces = espaces.len();
  |               ^^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` due to previous error
</code></pre>
<!--
Now that we’ve explored how variables work, let’s look at more data types they
can have.
-->
<p>Maintenant que nous avons découvert comment fonctionnent les variables, étudions
les types de données qu'elles peuvent prendre.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[data-types]: ch03-02-data-types.html#data-types
[storing-values-with-variables]: ch02-00-guessing-game-tutorial.html#storing-values-with-variables
[const-eval]: ../reference/const_eval.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Data Types
-->
<h2 id="les-types-de-données"><a class="header" href="#les-types-de-données">Les types de données</a></h2>
<!--
Every value in Rust is of a certain *data type*, which tells Rust what kind of
data is being specified so it knows how to work with that data. We’ll look at
two data type subsets: scalar and compound.
-->
<p>Chaque valeur en Rust est d'un <em>type</em> bien déterminé, qui indique à Rust quel
genre de données il manipule pour qu'il sache comment traiter ces données.
Nous allons nous intéresser à deux catégories de types de données : les
scalaires et les composés.</p>
<!--
Keep in mind that Rust is a *statically typed* language, which means that it
must know the types of all variables at compile time. The compiler can usually
infer what type we want to use based on the value and how we use it. In cases
when many types are possible, such as when we converted a `String` to a numeric
type using `parse` in the [“Comparing the Guess to the Secret
Number”][comparing-the-guess-to-the-secret-number]<!-- ignore -- > section in
Chapter 2, we must add a type annotation, like this:
-->
<p>Gardez à l'esprit que Rust est un langage <em>statiquement typé</em>, ce qui signifie
qu'il doit connaître les types de toutes les variables au moment de la
compilation. Le compilateur peut souvent déduire quel type utiliser en se basant
sur la valeur et sur la façon dont elle est utilisée. Dans les cas où plusieurs
types sont envisageables, comme lorsque nous avons converti une chaîne de
caractères en un type numérique en utilisant <code>parse</code> dans la section
<a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">“Comparer le nombre saisi au nombre
secret”</a><!-- ignore -->
du chapitre 2, nous devons ajouter une annotation de type, comme ceci :</p>
<!--
```rust
let guess: u32 = "42".parse().expect("Not a number!");
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let supposition: u32 = &quot;42&quot;.parse().expect(&quot;Ce n'est pas un nombre !&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
If we don’t add the type annotation here, Rust will display the following
error, which means the compiler needs more information from us to know which
type we want to use:
-->
<p>Si nous n'ajoutons pas l'annotation de type ici, Rust affichera l'erreur
suivante, signifiant que le compilateur a besoin de plus d'informations pour
déterminer quel type nous souhaitons utiliser :</p>
<!--
```console
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 -- > src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^ consider giving `guess` a type

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
```
-->
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let supposition = &quot;42&quot;.parse().expect(&quot;Ce n'est pas un nombre !&quot;);
  |         ^^^^^^^^^^^ consider giving `supposition` a type

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
</code></pre>
<!--
You’ll see different type annotations for other data types.
-->
<p>Vous découvrirez différentes annotations de type au fur et à mesure que nous
aborderons les autres types de données.</p>
<!--
### Scalar Types
-->
<h3 id="types-scalaires"><a class="header" href="#types-scalaires">Types scalaires</a></h3>
<!--
A *scalar* type represents a single value. Rust has four primary scalar types:
integers, floating-point numbers, Booleans, and characters. You may recognize
these from other programming languages. Let’s jump into how they work in Rust.
-->
<p>Un type <em>scalaire</em> représente une seule valeur. Rust possède quatre types
principaux de scalaires : les entiers, les nombres à virgule flottante, les
booléens et les caractères. Vous les connaissez sûrement d'autres langages de
programmation. Regardons comment ils fonctionnent avec Rust.</p>
<!--
#### Integer Types
-->
<h4 id="types-de-nombres-entiers"><a class="header" href="#types-de-nombres-entiers">Types de nombres entiers</a></h4>
<!--
An *integer* is a number without a fractional component. We used one integer
type in Chapter 2, the `u32` type. This type declaration indicates that the
value it’s associated with should be an unsigned integer (signed integer types
start with `i`, instead of `u`) that takes up 32 bits of space. Table 3-1 shows
the built-in integer types in Rust. We can use any of these variants to declare
the type of an integer value.
-->
<p>Un <em>entier</em> est un nombre sans partie décimale. Nous avons utilisé un entier
précédemment dans le chapitre 2, le type <code>u32</code>. Cette déclaration de type
indique que la valeur à laquelle elle est associée doit être un entier non signé
encodé sur 32 bits dans la mémoire (les entiers pouvant prendre des valeurs
négatives commencent par un <code>i</code> (comme <em>integer</em> : “entier”), plutôt que par un
<code>u</code> comme <em>unsigned</em> : “non signé”). Le tableau 3-1 montre les types
d'entiers intégrés au langage. Nous pouvons utiliser chacune de ces variantes
pour déclarer le type d'une valeur entière.</p>
<!--
<span class="caption">Table 3-1: Integer Types in Rust</span>
-->
<p><span class="caption">Tableau 3-1 : les types d'entiers en Rust</span></p>
<!--
| Length  | Signed  | Unsigned |
|---------|---------|----------|
| 8-bit   | `i8`    | `u8`     |
| 16-bit  | `i16`   | `u16`    |
| 32-bit  | `i32`   | `u32`    |
| 64-bit  | `i64`   | `u64`    |
| 128-bit | `i128`  | `u128`   |
| arch    | `isize` | `usize`  |
-->
<table><thead><tr><th>Taille</th><th>Signé</th><th>Non signé</th></tr></thead><tbody>
<tr><td>8 bits</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16 bits</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32 bits</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64 bits</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128 bits</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>archi</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<!--
Each variant can be either signed or unsigned and has an explicit size.
*Signed* and *unsigned* refer to whether it’s possible for the number to be
negative—in other words, whether the number needs to have a sign with it
(signed) or whether it will only ever be positive and can therefore be
represented without a sign (unsigned). It’s like writing numbers on paper: when
the sign matters, a number is shown with a plus sign or a minus sign; however,
when it’s safe to assume the number is positive, it’s shown with no sign.
Signed numbers are stored using [two’s
complement](https://en.wikipedia.org/wiki/Two%27s_complement)<!-- ignore -- >
representation.
-->
<p>Chaque variante peut être signée ou non signée et possède une taille explicite.
<em>Signé</em> et <em>non signé</em> veut dire respectivement que le nombre peut prendre ou
non des valeurs négatives — en d'autres termes, si l'on peut lui attribuer un
signe (signé) ou s'il sera toujours positif et que l'on peut donc le représenter
sans signe (non signé). C'est comme écrire des nombres sur du papier : quand le
signe est important, le nombre est écrit avec un signe plus ou un signe moins ;
en revanche, quand le nombre est forcément positif, on peut l'écrire sans son
signe. Les nombres signés sont stockés en utilisant le <a href="https://fr.wikipedia.org/wiki/Compl%C3%A9ment_%C3%A0_deux">complément à
deux</a><!-- ignore -->.</p>
<!--
Each signed variant can store numbers from -(2<sup>n - 1</sup>) to 2<sup>n -
1</sup> - 1 inclusive, where *n* is the number of bits that variant uses. So an
`i8` can store numbers from -(2<sup>7</sup>) to 2<sup>7</sup> - 1, which equals
-128 to 127. Unsigned variants can store numbers from 0 to 2<sup>n</sup> - 1,
so a `u8` can store numbers from 0 to 2<sup>8</sup> - 1, which equals 0 to 255.
-->
<p>Chaque variante signée peut stocker des nombres allant de −(2<sup><em>n</em> − 1</sup>)
à 2<sup><em>n</em> − 1</sup> − 1 inclus, où <em>n</em> est le nombre de bits que cette
variante utilise.
Un <code>i8</code> peut donc stocker des nombres allant de −(2<sup>7</sup>) à
2<sup>7</sup> − 1, c'est-à-dire de −128 à 127. Les variantes non signées peuvent
stocker des nombres de 0 à 2<sup><em>n</em></sup> − 1, donc un <code>u8</code> peut stocker
des nombres allant de 0 à 2<sup>8</sup> − 1, c'est-à-dire de 0 à 255.</p>
<!--
Additionally, the `isize` and `usize` types depend on the architecture of the
computer your program is running on, which is denoted in the table as "arch":
64 bits if you’re on a 64-bit architecture and 32 bits if you’re on a 32-bit
architecture.
-->
<p>De plus, les types <code>isize</code> et <code>usize</code> dépendent de l'architecture de
l'ordinateur sur lequel votre programme va s'exécuter, d'où la ligne &quot;archi&quot; :
64 bits si vous utilisez une architecture 64 bits, ou 32 bits si vous utilisez
une architecture 32 bits.</p>
<!--
You can write integer literals in any of the forms shown in Table 3-2. Note
that number literals that can be multiple numeric types allow a type suffix,
such as `57u8`, to designate the type. Number literals can also use `_` as a
visual separator to make the number easier to read, such as `1_000`, which will
have the same value as if you had specified `1000`.
-->
<p>Vous pouvez écrire des littéraux d'entiers dans chacune des formes décrites dans
le tableau 3-2. Notez qu'un littéral numérique peut être de différent type
numérique autorisent l'utilisation un suffixe de type, comme <code>57u8</code>, afin de
préciser leur type. Les nombres littéraux peuvent aussi utiliser <code>_</code> comme
séparateur visuel afin de les rendre plus lisible, comme par exemple <code>1_000</code>,
qui a la même valeur que si vous aviez renseigné <code>1000</code>.</p>
<!--
<span class="caption">Table 3-2: Integer Literals in Rust</span>
-->
<p><span class="caption">Tableau 3-2 : les littéraux d'entiers en Rust</span></p>
<!--
| Number literals  | Example       |
|------------------|---------------|
| Decimal          | `98_222`      |
| Hex              | `0xff`        |
| Octal            | `0o77`        |
| Binary           | `0b1111_0000` |
| Byte (`u8` only) | `b'A'`        |
-->
<table><thead><tr><th>Littéral numérique</th><th>Exemple</th></tr></thead><tbody>
<tr><td>Décimal</td><td><code>98_222</code></td></tr>
<tr><td>Hexadécimal</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binaire</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Octet (<code>u8</code> seulement)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<!--
So how do you know which type of integer to use? If you’re unsure, Rust’s
defaults are generally good places to start: integer types default to `i32`.
The primary situation in which you’d use `isize` or `usize` is when indexing
some sort of collection.
-->
<p>Comment pouvez-vous déterminer le type d'entier à utiliser ? Si vous n'êtes pas
sûr, les choix par défaut de Rust sont généralement de bons choix : le type
d'entier par défaut est le <code>i32</code>. La principale utilisation d'un <code>isize</code> ou d'un
<code>usize</code> est lorsque l'on indexe une quelconque collection.</p>
<!--
> ##### Integer Overflow
>
> Let’s say you have a variable of type `u8` that can hold values between 0 and
> 255. If you try to change the variable to a value outside of that range, such
> as 256, *integer overflow* will occur, which can result in one of two
> behaviors. When you’re compiling in debug mode, Rust includes checks for
> integer overflow that cause your program to *panic* at runtime if this
> behavior occurs. Rust uses the term panicking when a program exits with an
> error; we’ll discuss panics in more depth in the [“Unrecoverable Errors with
> `panic!`”][unrecoverable-errors-with-panic]<!-- ignore -- > section in Chapter
> 9.
>
> When you’re compiling in release mode with the `--release` flag, Rust does
> *not* include checks for integer overflow that cause panics. Instead, if
> overflow occurs, Rust performs *two’s complement wrapping*. In short, values
> greater than the maximum value the type can hold “wrap around” to the minimum
> of the values the type can hold. In the case of a `u8`, the value 256 becomes
> 0, the value 257 becomes 1, and so on. The program won’t panic, but the
> variable will have a value that probably isn’t what you were expecting it to
> have. Relying on integer overflow’s wrapping behavior is considered an error.
>
> To explicitly handle the possibility of overflow, you can use these families
> of methods provided by the standard library for primitive numeric types:
>
> - Wrap in all modes with the `wrapping_*` methods, such as `wrapping_add`
> - Return the `None` value if there is overflow with the `checked_*` methods
> - Return the value and a boolean indicating whether there was overflow with
>   the `overflowing_*` methods
> - Saturate at the value’s minimum or maximum values with `saturating_*`
>   methods
-->
<blockquote>
<h5 id="dépassement-dentier"><a class="header" href="#dépassement-dentier">Dépassement d'entier</a></h5>
<p>Imaginons que vous avez une variable de type <code>u8</code> qui peut stocker des
valeurs entre 0 et 255. Si vous essayez de changer la variable pour une valeur
en dehors de cet intervalle, comme 256, vous aurez un dépassement d'entier
<em>(integer overflow)</em>, qui peut se compter de deux manière. Lorsque vous
compilez en mode débogage, Rust embarque des vérifications pour détecter les
cas de dépassements d'entiers qui pourraient faire <em>paniquer</em> votre programme
à l'exécution si ce phénomène se produit. Rust utilise le terme <em>paniquer</em>
quand un programme se termine avec une erreur ; nous verrons plus en détail
les <em>paniques</em> dans une section du <a href="ch09-01-unrecoverable-errors-with-panic.html">chapitre
9</a><!-- ignore -->.</p>
<p>Lorsque vous compilez en mode publication <em>(release)</em> avec le drapeau
<code>--release</code>, Rust ne va <em>pas</em> vérifier les potentiels dépassements d'entiers
qui peuvent faire paniquer le programme. En revanche, en cas de dépassement,
Rust va effectuer un <em>rebouclage du complément à deux</em>. Pour faire simple, les
valeurs supérieures à la valeur maximale du type seront “rebouclées” depuis la
valeur minimale que le type peut stocker. Dans cas d'un <code>u8</code>, la valeur 256
devient 0, la valeur 257 devient 1, et ainsi de suite. Le programme ne va
paniquer, mais la variable va avoir une valeur qui n'est probablement pas ce
que vous attendez à avoir. Se fier au comportement du rebouclage lors du
dépassement d'entier est considéré comme une faute.</p>
<p>Pour gérer explicitement le dépassement, vous pouvez utiliser les familles
de méthodes suivantes qu'offrent la bibliothèque standard sur les types de
nombres primitifs :</p>
<ul>
<li>Enveloppez les opérations avec les méthodes <code>wrapping_*</code>, comme par exemple
<code>wrapping_add</code></li>
<li>Retourner la valeur <code>None</code> s'il y a un dépassement avec des méthodes
<code>checked_*</code></li>
<li>Retourner la valeur et un booléen qui indique s'il y a eu un dépassement
avec des méthodes <code>overflowing_*</code></li>
<li>Saturer à la valeur minimale ou maximale avec des méthodes <code>saturating_*</code></li>
</ul>
</blockquote>
<!--
#### Floating-Point Types
-->
<h4 id="types-de-nombres-à-virgule-flottante"><a class="header" href="#types-de-nombres-à-virgule-flottante">Types de nombres à virgule flottante</a></h4>
<!--
Rust also has two primitive types for *floating-point numbers*, which are
numbers with decimal points. Rust’s floating-point types are `f32` and `f64`,
which are 32 bits and 64 bits in size, respectively. The default type is `f64`
because on modern CPUs it’s roughly the same speed as `f32` but is capable of
more precision. All floating-point types are signed.
-->
<p>Rust possède également deux types primitifs pour les <em>nombres à virgule
flottante</em> (ou <em>flottants</em>), qui sont des nombres avec des décimales. Les types
de flottants en Rust sont les <code>f32</code> et les <code>f64</code>, qui ont respectivement une
taille en mémoire de 32 bits et 64 bits. Le type par défaut est le <code>f64</code> car sur
les processeurs récents ce type est quasiment aussi rapide qu'un <code>f32</code> mais est
plus précis. Tous les flottants ont un signe.</p>
<!--
Here’s an example that shows floating-point numbers in action:
-->
<p>Voici un exemple montrant l'utilisation de nombres à virgule flottante :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Ficher : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<!--
Floating-point numbers are represented according to the IEEE-754 standard. The
`f32` type is a single-precision float, and `f64` has double precision.
-->
<p>Les nombres à virgule flottante sont représentés selon la norme IEEE-754. Le
type <code>f32</code> est un flottant à simple précision, et le <code>f64</code> est à double
précision.</p>
<!--
#### Numeric Operations
-->
<h4 id="les-opérations-numériques"><a class="header" href="#les-opérations-numériques">Les opérations numériques</a></h4>
<!--
Rust supports the basic mathematical operations you’d expect for all of the
number types: addition, subtraction, multiplication, division, and remainder.
Integer division rounds down to the nearest integer. The following code shows
how you’d use each numeric operation in a `let` statement:
-->
<p>Rust offre les opérations mathématiques de base dont vous auriez besoin pour
tous les types de nombres : addition, soustraction, multiplication, division et
modulo. Les divisions d'entiers arrondissent le résultat à l'entier le plus
près. Le code suivant montre comment utiliser chacune des opérations numériques
avec une instruction <code>let</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // remainder
    let remainder = 43 % 5;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    // addition
    let somme = 5 + 10;

    // soustraction
    let difference = 95.5 - 4.3;

    // multiplication
    let produit = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let arrondi = 2 / 3; // retournera 0

    // modulo
    let reste = 43 % 5;
}
</code></pre></pre>
<!--
Each expression in these statements uses a mathematical operator and evaluates
to a single value, which is then bound to a variable. [Appendix B][appendix_b]<!-- ignore -- > contains a
list of all operators that Rust provides.
-->
<p>Chaque expression de ces instructions utilise un opérateur mathématique et
calcule une valeur unique, qui est ensuite attribuée à une variable. <a href="appendix-02-operators.html">L'annexe B</a><!-- ignore -->
présente une liste de tous les opérateurs que Rust fournit.</p>
<!--
#### The Boolean Type
-->
<h4 id="le-type-booléen"><a class="header" href="#le-type-booléen">Le type booléen</a></h4>
<!--
As in most other programming languages, a Boolean type in Rust has two possible
values: `true` and `false`. Booleans are one byte in size. The Boolean type in
Rust is specified using `bool`. For example:
-->
<p>Comme dans la plupart des langages de programmation, un type booléen a deux
valeurs possibles en Rust : <code>true</code> (vrai) et <code>false</code> (faux). Les booléens
prennent un octet en mémoire. Le type booléen est désigné en utilisant <code>bool</code>.
Par exemple :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // avec une annotation de type explicite
}
</code></pre></pre>
<!--
The main way to use Boolean values is through conditionals, such as an `if`
expression. We’ll cover how `if` expressions work in Rust in the [“Control
Flow”][control-flow]<!-- ignore -- > section.
-->
<p>Les valeurs booléennes sont principalement utilisées par les structures
conditionnelles, comme l'expression <code>if</code>. Nous aborderons le fonctionnement
de <code>if</code> en Rust dans la section
<a href="ch03-05-control-flow.html#les-structures-de-contr%C3%B4le">“Les structures de contrôle”</a><!-- ignore -->.</p>
<!--
#### The Character Type
-->
<h4 id="le-type-caractère"><a class="header" href="#le-type-caractère">Le type caractère</a></h4>
<!--
Rust’s `char` type is the language’s most primitive alphabetic type. Here's
some examples of declaring `char` values:
-->
<p>Le type <code>char</code> (comme <em>character</em>) est le type de caractère le plus
rudimentaire. Voici quelques exemples de déclaration de valeurs de type
<code>char</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'ℤ';
    let chat_aux_yeux_de_coeur = '😻';
}
</code></pre></pre>
<!--
Note that we specify `char` literals with single quotes, as opposed to string
literals, which use double quotes. Rust’s `char` type is four bytes in size and
represents a Unicode Scalar Value, which means it can represent a lot more than
just ASCII. Accented letters; Chinese, Japanese, and Korean characters; emoji;
and zero-width spaces are all valid `char` values in Rust. Unicode Scalar
Values range from `U+0000` to `U+D7FF` and `U+E000` to `U+10FFFF` inclusive.
However, a “character” isn’t really a concept in Unicode, so your human
intuition for what a “character” is may not match up with what a `char` is in
Rust. We’ll discuss this topic in detail in [“Storing UTF-8 Encoded Text with
Strings”][strings]<!-- ignore -- > in Chapter 8.
-->
<p>Notez que nous renseignons un litéral <code>char</code> avec des guillemets simples,
contrairement aux littéraux de chaîne de caractères, qui nécéssite des doubles
guillemets. Le type <code>char</code> de Rust prend quatre octets en mémoire et représente
une valeur scalaire Unicode, ce qui veut dire que cela représente plus de
caractères que l'ASCII. Les lettres accentuées ; les caractères chinois,
japonais et coréens ; les emoji ; les espaces de largeur nulle ont tous une
valeur pour <code>char</code> avec Rust. Les valeurs scalaires Unicode vont de <code>U+0000</code> à
<code>U+D7FF</code> et de <code>U+E000</code> à <code>U+10FFFF</code> inclus. Cependant, le concept de
“caractère” n'est pas clairement défini par Unicode, donc votre notion de
“caractère” peut ne pas correspondre à ce qu'est un <code>char</code> en Rust. Nous
aborderons ce sujet plus en détail au <a href="ch08-02-strings.html">chapitre 8</a><!-- ignore -->.</p>
<!--
### Compound Types
-->
<h3 id="les-types-composés"><a class="header" href="#les-types-composés">Les types composés</a></h3>
<!--
*Compound types* can group multiple values into one type. Rust has two
primitive compound types: tuples and arrays.
-->
<p>Les <em>types composés</em> peuvent regrouper plusieurs valeurs dans un seul type. Rust
a deux types composés de base : les <em>tuples</em> et les tableaux <em>(arrays)</em>.</p>
<!--
#### The Tuple Type
-->
<h4 id="le-type-tuple"><a class="header" href="#le-type-tuple">Le type <em>tuple</em></a></h4>
<!--
A tuple is a general way of grouping together a number of values with a variety
of types into one compound type. Tuples have a fixed length: once declared,
they cannot grow or shrink in size.
-->
<p>Un <em>tuple</em> est une manière générale de regrouper plusieurs valeurs
de types différents en un seul type composé. Les tuples ont une taille fixée :
à partir du moment où ils ont été déclarés, on ne peut pas y ajouter ou enlever
des valeurs.</p>
<!--
We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple don’t have to be the same. We’ve added optional
type annotations in this example:
-->
<p>Nous créons un <em>tuple</em> en écrivant une liste séparée par des virgules entre des
parenthèses. Chaque emplacement dans le tuple a un type, et les types de chacune
des valeurs dans le tuple n'ont pas forcément besoin d'être les mêmes.
Nous avons ajouté des annotations de type dans cet exemple, mais c'est
optionnel :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<!--
The variable `tup` binds to the entire tuple, because a tuple is considered a
single compound element. To get the individual values out of a tuple, we can
use pattern matching to destructure a tuple value, like this:
-->
<p>La variable <code>tup</code> est liée à tout le tuple, car un tuple est considéré
comme étant un unique élément composé. Pour obtenir un élément précis de ce
tuple, nous pouvons utiliser un filtrage par motif <em>(pattern matching)</em> pour
déstructurer ce tuple, comme ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;La valeur de y est : {}&quot;, y);
}
</code></pre></pre>
<!--
This program first creates a tuple and binds it to the variable `tup`. It then
uses a pattern with `let` to take `tup` and turn it into three separate
variables, `x`, `y`, and `z`. This is called *destructuring*, because it breaks
the single tuple into three parts. Finally, the program prints the value of
`y`, which is `6.4`.
-->
<p>Le programme commence par créer un tuple et il l'assigne à la variable <code>tup</code>.
Il utilise ensuite un motif avec <code>let</code> pour prendre <code>tup</code> et le scinder en
trois variables distinctes : <code>x</code>, <code>y</code>, et <code>z</code>.
On appelle cela <em>déstructurer</em>, car il divise le tuple en trois parties.
Puis finalement, le programme affiche la valeur de <code>y</code>, qui est <code>6.4</code>.</p>
<!--
We can also access a tuple element directly by using a period (`.`) followed by
the index of the value we want to access. For example:
-->
<p>Nous pouvons aussi accéder directement à chaque élément du tuple en utilisant
un point (<code>.</code>) suivi de l'indice de la valeur que nous souhaitons obtenir. Par
exemple :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let cinq_cents = x.0;

    let six_virgule_quatre = x.1;

    let un = x.2;
}
</code></pre></pre>
<!--
This program creates the tuple `x` and then makes new variables for each
element by using their respective indices. As with most programming languages,
the first index in a tuple is 0.
-->
<p>Ce programme crée le tuple <code>x</code> puis crée une nouvelle variable pour
chaque élément en utilisant leur indices respectifs. Comme dans de nombreux
langages de programmation, le premier indice d'un tuple est 0.</p>
<!--
The tuple without any values, `()`, is a special type that has only one value,
also written `()`. The type is called the *unit type* and the value is called
the *unit value*. Expressions implicitly return the unit value if they don’t
return any other value.
-->
<p>Le tuple sans aucune valeur, <code>()</code>, est un type spécial qui a une seule et unique
valeur, qui s'écrit aussi <code>()</code>. Ce type est aussi appelé le <em>type unité</em> et la
valeur est appelée <em>valeur unité</em>. Les expressions retournent implicitement la
valeur unité si elles ne retournent aucune autre valeur.</p>
<!--
#### The Array Type
-->
<h4 id="le-type-tableau"><a class="header" href="#le-type-tableau">Le type tableau</a></h4>
<!--
Another way to have a collection of multiple values is with an *array*. Unlike
a tuple, every element of an array must have the same type. Unlike arrays in
some other languages, arrays in Rust have a fixed length.
-->
<p>Un autre moyen d'avoir une collection de plusieurs valeurs est d'utiliser
un <em>tableau</em>. Contrairement aux tuples, chaque élément d'un tableau doit être du
même type. Contrairement aux tableaux de certains autres langages, les tableaux
de Rust ont une taille fixe.</p>
<!--
We write the values in an array as a comma-separated list inside square
brackets:
-->
<p>Nous écrivons les valeurs dans un tableau via une liste entre des crochets,
séparée par des virgules :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<!--
Arrays are useful when you want your data allocated on the stack rather than
the heap (we will discuss the stack and the heap more in [Chapter
4][stack-and-heap]<!-- ignore -- >) or when you want to ensure you always have a
fixed number of elements. An array isn’t as flexible as the vector type,
though. A vector is a similar collection type provided by the standard library
that *is* allowed to grow or shrink in size. If you’re unsure whether to use an
array or a vector, chances are you should use a vector. [Chapter
8][vectors]<!-- ignore -- > discusses vectors in more detail.
-->
<p>Les tableaux sont utiles quand vous voulez que vos données soient allouées sur
la pile <em>(stack)</em> plutôt que sur le tas <em>(heap)</em> (nous expliquerons la pile et
le tas au chapitre 4) ou lorsque vous voulez vous assurer que vous avez toujours
un nombre fixe d'éléments. Cependant, un tableau n'est pas aussi flexible qu'un
vecteur <em>(vector)</em>. Un vecteur est un type de collection de données similaire
qui est fourni par la bibliothèque standard qui, lui, peut grandir ou rétrécir
en taille. Si vous ne savez pas si vous devez utiliser un tableau ou un
vecteur, il y a de fortes chances que vous devriez utiliser un vecteur. Le
<a href="ch08-01-vectors.html">chapitre 8</a><!-- ignore --> expliquera les vecteurs.</p>
<!--
However, arrays are more useful when you know the number of elements will not
need to change. For example, if you were using the names of the month in a
program, you would probably use an array rather than a vector because you know
it will always contain 12 elements:
-->
<p>Toutefois, les tableaux s'avèrent plus utiles lorsque vous savez que le nombre
d'éléments n'aura pas besoin de changer. Par exemple, si vous utilisez les noms
des mois dans un programme, vous devriez probablement utiliser un tableau
plutôt qu'un vecteur car vous savez qu'il contient toujours 12 éléments :</p>
<!--
```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mois = [&quot;Janvier&quot;, &quot;Février&quot;, &quot;Mars&quot;, &quot;Avril&quot;, &quot;Mai&quot;, &quot;Juin&quot;, &quot;Juillet&quot;,
            &quot;Août&quot;, &quot;Septembre&quot;, &quot;Octobre&quot;, &quot;Novembre&quot;, &quot;Décembre&quot;];
<span class="boring">}
</span></code></pre></pre>
<!--
You write an array’s type using square brackets with the type of each element,
a semicolon, and then the number of elements in the array, like so:
-->
<p>Vous pouvez écrire le type d'un tableau en utilisant des crochets et entre ces
crochets y ajouter le type de chaque élément, un point-virgule, et ensuite le
nombre d'éléments dans le tableau, comme ceci :</p>
<!--
```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<!--
Here, `i32` is the type of each element. After the semicolon, the number `5`
indicates the array contains five elements.
-->
<p>Ici, <code>i32</code> est le type de chaque élément. Après le point-virgule, le nombre <code>5</code>
indique que le tableau contient cinq éléments.</p>
<!--
You can also initialize an array to contain the same value for each element by
specifying the initial value, followed by a semicolon, and then the length of
the array in square brackets, as shown here:
-->
<p>Vous pouvez initialiser un tableau pour qu'il contienne toujours la même valeur
pour chaque élément, vous pouvez préciser la valeur initiale, suivie par un
point-virgule, et ensuite la taille du tableau, le tout entre crochets, comme
ci-dessous :</p>
<!--
```rust
let a = [3; 5];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<!--
The array named `a` will contain `5` elements that will all be set to the value
`3` initially. This is the same as writing `let a = [3, 3, 3, 3, 3];` but in a
more concise way.
-->
<p>Le tableau <code>a</code> va contenir <code>5</code> éléments qui auront tous la valeur
initiale <code>3</code>. C'est la même chose que d'écrire <code>let a = [3, 3, 3, 3, 3];</code> mais
de manière plus concise.</p>
<!--
##### Accessing Array Elements
-->
<h5 id="accéder-aux-éléments-dun-tableau"><a class="header" href="#accéder-aux-éléments-dun-tableau">Accéder aux éléments d'un tableau</a></h5>
<!--
An array is a single chunk of memory of a known, fixed size that can be
allocated on the stack. You can access elements of an array using indexing,
like this:
-->
<p>Un tableau est un simple bloc de mémoire de taille connue et fixe, qui peut être
alloué sur la pile. Vous pouvez accéder aux éléments d'un tableau en utilisant
l'indexation, comme ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let premier = a[0];
    let second = a[1];
}
</code></pre></pre>
<!--
In this example, the variable named `first` will get the value `1`, because
that is the value at index `[0]` in the array. The variable named `second` will
get the value `2` from index `[1]` in the array.
-->
<p>Dans cet exemple, la variable qui s'appelle <code>premier</code> aura la valeur <code>1</code>, car
c'est la valeur à l'indice <code>[0]</code> dans le tableau. La variable <code>second</code>
récupèrera la valeur <code>2</code> depuis l'indice <code>[1]</code> du tableau.</p>
<!--
##### Invalid Array Element Access
-->
<h5 id="accès-incorrect-à-un-élément-dun-tableau"><a class="header" href="#accès-incorrect-à-un-élément-dun-tableau">Accès incorrect à un élément d'un tableau</a></h5>
<!--
Let's see what happens if you try to access an element of an array that is past
the end of the array. Say you run this code, similar to the guessing game in
Chapter 2, to get an array index from the user:
-->
<p>Découvrons ce qui se passe quand vous essayez d'accéder à un élément d'un
tableau qui se trouve après la fin du tableau ? Imaginons que vous exécutiez le
code suivant, similaire au jeu du plus ou du moins du chapitre 2, pour demander
un indice de tableau à l'utilisateur :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,panics
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!(
        "The value of the element at index {} is: {}",
        index, element
    );
}
```
-->
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;Veuillez entrer un indice de tableau.&quot;);

    let mut indice = String::new();

    io::stdin()
        .read_line(&amp;mut indice)
        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);

    let indice: usize = indice
        .trim()
        .parse()
        .expect(&quot;L'indice entré n'est pas un nombre&quot;);

    let element = a[indice];

    println!(
        &quot;La valeur de l'élément d'indice {} est : {}&quot;,
        indice, element
    );
}
</code></pre>
<!--
This code compiles successfully. If you run this code using `cargo run` and
enter 0, 1, 2, 3, or 4, the program will print out the corresponding value at
that index in the array. If you instead enter a number past the end of the
array, such as 10, you’ll see output like this:
-->
<p>Ce code compile avec succès. Si vous exécutez ce code avec <code>cargo run</code> et que
vous entrez 0, 1, 2, 3 ou 4, le programme affichera la valeur correspondante à
cet indice dans le tableau. Si au contraire, vous entrez un indice après la fin
du tableau tel que 10, ceci s'affichera :</p>
<!--
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-- >

```console
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
The program resulted in a *runtime* error at the point of using an invalid
value in the indexing operation. The program exited with an error message and
didn’t execute the final `println!` statement. When you attempt to access an
element using indexing, Rust will check that the index you’ve specified is less
than the array length. If the index is greater than or equal to the length,
Rust will panic. This check has to happen at runtime, especially in this case,
because the compiler can’t possibly know what value a user will enter when they
run the code later.
-->
<p>Le programme a rencontré une erreur <em>à l'exécution</em>, au moment d'utiliser une
valeur invalide comme indice. Le programme s'est arrêté avec un message d'erreur
et n'a pas exécuté la dernière instruction <code>println!</code>. Quand vous essayez
d'accéder à un élément en utilisant l'indexation, Rust va vérifier que l'indice
que vous avez demandé est plus petit que la taille du tableau. Si l'indice est
supérieur ou égal à la taille du tableau, Rust va <em>paniquer</em>. Cette vérification
doit avoir lieu à l'exécution, surtout dans ce cas, parce que le compilateur ne
peut pas deviner la valeur qu'entrera l'utilisateur quand il exécutera le code
plus tard.</p>
<!--
This is an example of Rust’s memory safety principles in action. In many
low-level languages, this kind of check is not done, and when you provide an
incorrect index, invalid memory can be accessed. Rust protects you against this
kind of error by immediately exiting instead of allowing the memory access and
continuing. Chapter 9 discusses more of Rust’s error handling.
-->
<p>C'est un exemple de mise en pratique des principes de sécurité de la mémoire par
Rust. Dans de nombreux langages de bas niveau, ce genre de vérification n'est
pas effectuée, et quand vous utilisez un indice incorrect, de la mémoire
invalide peut être récupérée. Rust vous protège de ce genre d'erreur en quittant
immédiatement l'exécution au lieu de permettre l'accès en mémoire et continuer
son déroulement. Le chapitre 9 expliquera la gestion d'erreurs de Rust.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[control-flow]: ch03-05-control-flow.html#control-flow
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[stack-and-heap]: ch04-01-what-is-ownership.html#the-stack-and-the-heap
[vectors]: ch08-01-vectors.html
[unrecoverable-errors-with-panic]: ch09-01-unrecoverable-errors-with-panic.html
[wrapping]: ../std/num/struct.Wrapping.html
[appendix_b]: appendix-02-operators.md
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Functions
-->
<h2 id="les-fonctions"><a class="header" href="#les-fonctions">Les fonctions</a></h2>
<!--
Functions are prevalent in Rust code. You’ve already seen one of the most
important functions in the language: the `main` function, which is the entry
point of many programs. You’ve also seen the `fn` keyword, which allows you to
declare new functions.
-->
<p>Les fonctions sont très utilisées dans le code Rust. Vous avez déjà vu l'une des
fonctions les plus importantes du langage : la fonction <code>main</code>, qui est le point
d'entrée de beaucoup de programmes. Vous avez aussi vu le mot-clé <code>fn</code>, qui vous
permet de déclarer des nouvelles fonctions.</p>
<!--
Rust code uses *snake case* as the conventional style for function and variable
names, in which all letters are lowercase and underscores separate words.
Here’s a program that contains an example function definition:
-->
<p>Le code Rust utilise le <em>snake case</em> comme convention de style de nom des
fonctions et des variables, toutes les lettres sont en minuscule et on utilise
des tirets bas pour séparer les mots. Voici un programme qui est un exemple de
définition de fonction :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    une_autre_fonction();
}

fn une_autre_fonction() {
    println!(&quot;Une autre fonction.&quot;);
}
</code></pre></pre>
<!--
We define a function in Rust by entering `fn` followed by a function name and a
set of parentheses. The curly brackets tell the compiler where the function
body begins and ends.
-->
<p>Nous définissons une fonction avec Rust en saisissant <code>fn</code> suivi par un nom de
fonction ainsi qu'une paire de parenthèses. Les accolades indiquent au
compilateur où le corps de la fonction commence et où il se termine.</p>
<!--
We can call any function we’ve defined by entering its name followed by a set
of parentheses. Because `another_function` is defined in the program, it can be
called from inside the `main` function. Note that we defined `another_function`
*after* the `main` function in the source code; we could have defined it before
as well. Rust doesn’t care where you define your functions, only that they’re
defined somewhere.
-->
<p>Nous pouvons appeler n'importe quelle fonction que nous avons définie en
utilisant son nom, suivi d'une paire de parenthèses. Comme <code>une_autre_fonction</code>
est définie dans le programme, elle peut être appelée à l'intérieur de la
fonction <code>main</code>. Remarquez que nous avons défini <code>une_autre_fonction</code> <em>après</em>
la fonction <code>main</code> dans le code source ; nous aurions aussi pu la définir avant.
Rust ne se soucie pas de l'endroit où vous définissez vos fonctions, du moment
qu'elles sont bien définies quelque part.</p>
<!--
Let’s start a new binary project named *functions* to explore functions
further. Place the `another_function` example in *src/main.rs* and run it. You
should see the following output:
-->
<p>Créons un nouveau projet de binaire qui s'appellera <em>functions</em> afin d'en
apprendre plus sur les fonctions. Ajoutez l'exemple <code>une_autre_fonction</code> dans le
<em>src/main.rs</em> et exécutez-le. Vous devriez avoir ceci :</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Another function.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Une autre fonction.
</code></pre>
<!--
The lines execute in the order in which they appear in the `main` function.
First, the “Hello, world!” message prints, and then `another_function` is
called and its message is printed.
-->
<p>Les lignes s'exécutent dans l'ordre dans lequel elles apparaissent dans la
fonction <code>main</code>. D'abord, le message <code>Hello, world!</code> est écrit, et ensuite
<code>une_autre_fonction</code> est appelée et son message est affiché.</p>
<!--
### Parameters
-->
<h3 id="les-paramètres"><a class="header" href="#les-paramètres">Les paramètres</a></h3>
<!--
We can define functions to have *parameters*, which are special variables that
are part of a function’s signature. When a function has parameters, you can
provide it with concrete values for those parameters. Technically, the concrete
values are called *arguments*, but in casual conversation, people tend to use
the words *parameter* and *argument* interchangeably for either the variables
in a function’s definition or the concrete values passed in when you call a
function.
-->
<p>Nous pouvons définir des fonctions avec des <em>paramètres</em>, qui sont des
variables spéciales qui font partie de la signature de la fonction. Quand une
fonction a des paramètres, vous pouvez lui fournir des valeurs concrètes avec
ces paramètres. Techniquement, ces valeurs concrètes sont appelées des
<em>arguments</em>, mais dans une conversation courante, on a tendance à
confondre les termes <em>paramètres</em> et <em>arguments</em> pour désigner soit les
variables dans la définition d'une fonction, soit les valeurs concrètes passées
quand on appelle une fonction.</p>
<!--
In this version of `another_function` we add a parameter:
-->
<p>Dans cette version de <code>une_autre_fonction</code>, nous ajoutons un paramètre :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    une_autre_fonction(5);
}

fn une_autre_fonction(x: i32) {
    println!(&quot;La valeur de x est : {}&quot;, x);
}
</code></pre></pre>
<!--
Try running this program; you should get the following output:
-->
<p>En exécutant ce programme, vous devriez obtenir ceci :</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
La valeur de x est : 5
</code></pre>
<!--
The declaration of `another_function` has one parameter named `x`. The type of
`x` is specified as `i32`. When we pass `5` in to `another_function`, the
`println!` macro puts `5` where the pair of curly brackets were in the format
string.
-->
<p>La déclaration de <code>une_autre_fonction</code> a un paramètre nommé <code>x</code>. Le type de
<code>x</code> a été déclaré comme <code>i32</code>. Quand nous passons <code>5</code> à <code>une_autre_fonction</code>, la
macro <code>println!</code> place <code>5</code> là où la paire d'accolades <code>{}</code> a été placée dans la
chaîne de formatage.</p>
<!--
In function signatures, you *must* declare the type of each parameter. This is
a deliberate decision in Rust’s design: requiring type annotations in function
definitions means the compiler almost never needs you to use them elsewhere in
the code to figure out what type you mean.
-->
<p>Dans la signature d'une fonction, vous <em>devez</em> déclarer le type de chaque
paramètre. C'est un choix délibéré de conception de Rust : exiger l'annotation
de type dans la définition d'une fonction fait en sorte que le compilateur n'a
presque plus besoin que vous les utilisiez autre part pour qu'il comprenne avec
quel type vous souhaitez travailler.</p>
<!--
When defining multiple parameters, separate the parameter declarations with
commas, like this:
-->
<p>Lorsque vous définissez plusieurs paramètres, séparez les paramètres avec des
virgules, comme ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    afficher_mesure_avec_unite(5, 'h');
}

fn afficher_mesure_avec_unite(valeur: i32, unite: char) {
    println!(&quot;La mesure est : {}{}&quot;, valeur, unite);
}
</code></pre></pre>
<!--
This example creates a function named `print_labeled_measurement` with two
parameters. The first parameter is named `value` and is an `i32`. The second is
named `unit_label` and is type `char`. The function then prints text containing
both the `value` and the `unit_label`.
-->
<p>Cet exemple crée la fonction <code>afficher_mesure_avec_unite</code> qui a deux paramètres.
Le premier paramètre s'appelle <code>valeur</code> et est un <code>i32</code>. Le second, <code>nom_unite</code>,
est de type <code>char</code>. La fonction affiche ensuite le texte qui contient les
valeurs de <code>valeur</code> et de <code>nom_unite</code>.</p>
<!--
Let’s try running this code. Replace the program currently in your *functions*
project’s *src/main.rs* file with the preceding example and run it using `cargo
run`:
-->
<p>Essayons d'exécuter ce code. Remplacez le programme présent actuellement dans
votre fichier <em>src/main.rs</em> de votre projet <em>functions</em> par l'exemple précédent
et lancez-le en utilisant <code>cargo run</code> :</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
La mesure est : 5h
</code></pre>
<!--
Because we called the function with `5` as the value for `value` and `'h'` as
the value for `unit_label`, the program output contains those values.
-->
<p>Comme nous avons appelé la fonction avec la valeur <code>5</code> pour <code>valeur</code> et <code>'h'</code>
pour <code>nom_unite</code>, la sortie de ce programme contient ces valeurs.</p>
<!--
### Statements and Expressions
-->
<h3 id="instructions-et-expressions"><a class="header" href="#instructions-et-expressions">Instructions et expressions</a></h3>
<!--
Function bodies are made up of a series of statements optionally ending in an
expression. So far, the functions we've covered haven't included an ending
expression, but you have seen an expression as part of a statement. Because
Rust is an expression-based language, this is an important distinction to
understand. Other languages don’t have the same distinctions, so let’s look at
what statements and expressions are and how their differences affect the bodies
of functions.
-->
<p>Les corps de fonctions sont constitués d'une série d'instructions qui se
termine éventuellement par une expression. Jusqu'à présent, les fonctions que
nous avons vu n'avaient pas d'expression à la fin, mais vous avez déjà vu une
expression faire partie d'une instruction. Comme Rust est un langage basé sur
des expressions, il est important de faire la distinction. D'autres langages ne
font pas de telles distinctions, donc penchons-nous sur ce que sont les
instructions et les expressions et comment leurs différences influent sur le
corps des fonctions.</p>
<!--
*Statements* are instructions that perform some action and do not return a
value. *Expressions* evaluate to a resulting value. Let’s look at some examples.
-->
<p>Les <em>instructions</em> effectuent des actions et ne retournent aucune valeur.
Les <em>expressions</em> sont évaluées pour retourner une valeur comme résultat.
Voyons quelques exemples.</p>
<!--
We’ve actually already used statements and expressions. Creating a variable and
assigning a value to it with the `let` keyword is a statement. In Listing 3-1,
`let y = 6;` is a statement.
-->
<p>Nous avons déjà utilisé des instructions et des expressions. La création d'une
variable en lui assignant une valeur avec le mot-clé <code>let</code> est une instruction.
Dans l'encart 3-1, <code>let y = 6;</code> est une instruction.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let y = 6;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<!-- markdownlint-disable -->
<!--
<span class="caption">Listing 3-1: A `main` function declaration containing one statement</span>
-->
<!-- markdownlint-restore -->
<p><span class="caption">Encart 3-1 : une fonction <code>main</code> qui contient une
instruction</span></p>
<!--
Function definitions are also statements; the entire preceding example is a
statement in itself.
-->
<p>La définition d'une fonction est aussi une instruction ; l'intégralité de
l'exemple précédent est une instruction à elle toute seule.</p>
<!--
Statements do not return values. Therefore, you can’t assign a `let` statement
to another variable, as the following code tries to do; you’ll get an error:
-->
<p>Une instruction ne retourne pas de valeur. Ainsi, vous ne pouvez pas assigner
le résultat d'une instruction <code>let</code> à une autre variable, comme le code suivant
essaye de le faire, car vous obtiendrez une erreur :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = (let y = 6);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}
</code></pre>
<!--
When you run this program, the error you’ll get looks like this:
-->
<p>Quand vous exécutez ce programme, l'erreur que vous obtenez devrait ressembler à
ceci :</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0658]: `let` expressions in this position are experimental
 -- > src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information
  = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`

error: expected expression, found statement (`let`)
 -- > src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement

warning: unnecessary parentheses around assigned value
 -- > src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^^^^^^^^^^^ help: remove these parentheses
  |
  = note: `#[warn(unused_parens)]` on by default

For more information about this error, try `rustc --explain E0658`.
warning: `functions` (bin "functions") generated 1 warning
error: could not compile `functions` due to 2 previous errors; 1 warning emitted
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0658]: `let` expressions in this position are experimental
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information
  = help: you can write `matches!(&lt;expr&gt;, &lt;pattern&gt;)` instead of `let &lt;pattern&gt; = &lt;expr&gt;`

error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^^^^^^^^^^^ help: remove these parentheses
  |
  = note: `#[warn(unused_parens)]` on by default

For more information about this error, try `rustc --explain E0658`.
warning: `functions` (bin &quot;functions&quot;) generated 1 warning
error: could not compile `functions` due to 2 previous errors; 1 warning emitted
</code></pre>
<!--
The `let y = 6` statement does not return a value, so there isn’t anything for
`x` to bind to. This is different from what happens in other languages, such as
C and Ruby, where the assignment returns the value of the assignment. In those
languages, you can write `x = y = 6` and have both `x` and `y` have the value
`6`; that is not the case in Rust.
-->
<p>L'instruction <code>let y = 6</code> ne retourne pas de valeur, donc cela ne peut pas
devenir une valeur de <code>x</code>. Ceci est différent d'autres langages, comme le C ou
Ruby, où l'assignation retourne la valeur de l'assignation. Dans ces
langages, vous pouvez écrire <code>x = y = 6</code> et avoir ainsi <code>x</code> et <code>y</code> qui ont
chacun la valeur <code>6</code> ; cela n'est pas possible avec Rust.</p>
<!--
Expressions evaluate to a value and make up most of the rest of the code that
you’ll write in Rust. Consider a math operation, such as `5 + 6`, which is an
expression that evaluates to the value `11`. Expressions can be part of
statements: in Listing 3-1, the `6` in the statement `let y = 6;` is an
expression that evaluates to the value `6`. Calling a function is an
expression. Calling a macro is an expression. A new scope block created with
curly brackets is an expression, for example:
-->
<p>Les expressions sont calculées en tant que valeur et seront ce que vous écrirez
le plus en Rust (hormis les instructions). Prenez une opération mathématique,
comme <code>5 + 6</code>, qui est une expression qui s'évalue à la valeur <code>11</code>. Les
expressions peuvent faire partie d'une instruction : dans l'encart 3-1, le <code>6</code>
dans l'instruction <code>let y = 6;</code> est une expression qui s'évalue à la valeur <code>6</code>.
L'appel de fonction est aussi une expression. L'appel de macro est une
expression. Un nouveau bloc de portée que nous créons avec des accolades est
une expression, par exemple :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;La valeur de y est : {}&quot;, y);
}
</code></pre></pre>
<!--
This expression:
-->
<p>L'expression suivante…</p>
<!--
```rust,ignore
{
    let x = 3;
    x + 1
}
```
-->
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<!--
is a block that, in this case, evaluates to `4`. That value gets bound to `y`
as part of the `let` statement. Note that the `x + 1` line doesn't have a
semicolon at the end, unlike most of the lines you’ve seen so far. Expressions
do not include ending semicolons. If you add a semicolon to the end of an
expression, you turn it into a statement, and it will then not return a value.
Keep this in mind as you explore function return values and expressions next.
-->
<p>… est un bloc qui, dans ce cas, s'évalue à <code>4</code>. Cette valeur est assignée à <code>y</code>
dans le cadre de l'instruction <code>let</code>. Remarquez la ligne <code>x + 1</code> ne se termine
pas par un point-virgule, ce qui est différent de la plupart des lignes que
vous avez vues jusque là. Les expressions n'ont pas de point-virgule de fin de
ligne. Si vous ajoutez un point-virgule à la fin de l'expression, vous la
transformez en instruction, et elle ne va donc pas retourner de valeur. Gardez
ceci à l'esprit quand nous aborderons prochainement les valeurs de retour des
fonctions ainsi que les expressions.</p>
<!--
### Functions with Return Values
-->
<h3 id="les-fonctions-qui-retournent-des-valeurs"><a class="header" href="#les-fonctions-qui-retournent-des-valeurs">Les fonctions qui retournent des valeurs</a></h3>
<!--
Functions can return values to the code that calls them. We don’t name return
values, but we do declare their type after an arrow (`->`). In Rust, the return
value of the function is synonymous with the value of the final expression in
the block of the body of a function. You can return early from a function by
using the `return` keyword and specifying a value, but most functions return
the last expression implicitly. Here’s an example of a function that returns a
value:
-->
<p>Les fonctions peuvent retourner des valeurs au code qui les appelle.
Nous ne nommons pas les valeurs de retour, mais nous devons déclarer
leur type après une flèche (<code>-&gt;</code>). En Rust, la valeur de retour de la fonction
est la même que la valeur de l'expression finale dans le corps de la fonction.
Vous pouvez sortir prématurément d'une fonction en utilisant le mot-clé <code>return</code>
et en précisant la valeur de retour, mais la plupart des fonctions vont
retourner implicitement la dernière expression.
Voici un exemple d'une fonction qui retourne une valeur :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn cinq() -&gt; i32 {
    5
}

fn main() {
    let x = cinq();

    println!(&quot;La valeur de x est : {}&quot;, x);
}
</code></pre></pre>
<!--
There are no function calls, macros, or even `let` statements in the `five`
function—just the number `5` by itself. That’s a perfectly valid function in
Rust. Note that the function’s return type is specified too, as `-> i32`. Try
running this code; the output should look like this:
-->
<p>Il n'y a pas d'appel de fonction, de macro, ni même d'instruction <code>let</code> dans la
fonction <code>cinq</code> — uniquement le nombre <code>5</code> tout seul. C'est une fonction
parfaitement valide avec Rust. Remarquez que le type de retour de la fonction a
été précisé aussi, avec <code>-&gt; i32</code>. Essayez d'exécuter ce code ; le résultat
devrait ressembler à ceci :</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
La valeur de x est : 5
</code></pre>
<!--
The `5` in `five` is the function’s return value, which is why the return type
is `i32`. Let’s examine this in more detail. There are two important bits:
first, the line `let x = five();` shows that we’re using the return value of a
function to initialize a variable. Because the function `five` returns a `5`,
that line is the same as the following:
-->
<p>Le <code>5</code> dans <code>cinq</code> est la valeur de retour de la fonction, ce qui explique le
type de retour de <code>i32</code>. Regardons cela plus en détail. Il y a deux éléments
importants : premièrement, la ligne <code>let x = cinq();</code> dit que nous utilisons
la valeur de retour de la fonction pour initialiser la variable. Comme la
fonction <code>cinq</code> retourne un <code>5</code>, cette ligne revient à faire ceci :</p>
<!--
```rust
let x = 5;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<!--
Second, the `five` function has no parameters and defines the type of the
return value, but the body of the function is a lonely `5` with no semicolon
because it’s an expression whose value we want to return.
-->
<p>Deuxièmement, la fonction <code>cinq</code> n'a pas de paramètre et déclare le type de
valeur de retour, mais le corps de la fonction est un simple <code>5</code> sans
point-virgule car c'est une expression dont nous voulons retourner la valeur.</p>
<!--
Let’s look at another example:
-->
<p>Regardons un autre exemple :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = plus_un(5);

    println!(&quot;La valeur de x est : {}&quot;, x);
}

fn plus_un(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<!--
Running this code will print `The value of x is: 6`. But if we place a
semicolon at the end of the line containing `x + 1`, changing it from an
expression to a statement, we’ll get an error.
-->
<p>Exécuter ce code va afficher <code>La valeur de x est : 6</code>. Mais si nous ajoutons un
point-virgule à la fin de la ligne qui contient <code>x + 1</code>, ce qui la transforme
d'une expression à une instruction, nous obtenons une erreur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_un(5);

    println!(&quot;La valeur de x est : {}&quot;, x);
}

fn plus_un(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<!--
Compiling this code produces an error, as follows:
-->
<p>Compiler ce code va produire une erreur, comme ci-dessous :</p>
<!--
```console
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 -- > src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -> i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_un(x: i32) -&gt; i32 {
  |    -------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` due to previous error
</code></pre>
<!--
The main error message, “mismatched types,” reveals the core issue with this
code. The definition of the function `plus_one` says that it will return an
`i32`, but statements don’t evaluate to a value, which is expressed by `()`,
the unit type. Therefore, nothing is returned, which contradicts the function
definition and results in an error. In this output, Rust provides a message to
possibly help rectify this issue: it suggests removing the semicolon, which
would fix the error.
-->
<p>Le message d'erreur principal, “mismatched types” <em>(types inadéquats)</em> donne le
cœur du problème de ce code. La définition de la fonction <code>plus_un</code> dit qu'elle
va retourner un <code>i32</code>, mais les instructions ne retournent pas de valeur, ceci
est donc représenté par <code>()</code>, le type unité. Par conséquent, rien n'est
retourné, ce qui contredit la définition de la fonction et provoque une erreur.
Rust affiche un message qui peut aider à corriger ce problème : il suggère
d'enlever le point-virgule, ce qui va résoudre notre problème.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Comments
-->
<h2 id="les-commentaires"><a class="header" href="#les-commentaires">Les commentaires</a></h2>
<!--
All programmers strive to make their code easy to understand, but sometimes
extra explanation is warranted. In these cases, programmers leave *comments* in
their source code that the compiler will ignore but people reading the source
code may find useful.
-->
<p>Tous les développeurs s'efforcent de rendre leur code facile à comprendre, mais
parfois il est nécessaire d'écrire des explications supplémentaires. Dans ce
cas, les développeurs laissent des <em>commentaires</em> dans leur code source que le
compilateur va ignorer mais qui peuvent être utiles pour les personnes qui
lisent le code source.</p>
<!--
Here’s a simple comment:
-->
<p>Voici un simple commentaire :</p>
<!--
```rust
// hello, world
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hello, world
<span class="boring">}
</span></code></pre></pre>
<!--
In Rust, the idiomatic comment style starts a comment with two slashes, and the
comment continues until the end of the line. For comments that extend beyond a
single line, you’ll need to include `//` on each line, like this:
-->
<p>Avec Rust, les commentaires classiques commencent avec deux barres obliques et
continuent jusqu'à la fin de la ligne. Pour les commentaires qui font plus
d'une seule ligne, vous aurez besoin d'ajouter <code>//</code> sur chaque ligne, comme
ceci :</p>
<!--
```rust
// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Donc ici on fait quelque chose de compliqué, tellement long que nous avons
// besoin de plusieurs lignes de commentaires pour le faire ! Heureusement,
// ce commentaire va expliquer ce qui se passe.
<span class="boring">}
</span></code></pre></pre>
<!--
Comments can also be placed at the end of lines containing code:
-->
<p>Les commentaires peuvent aussi être aussi ajoutés à la fin d'une ligne qui
contient du code :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre_chanceux = 7; // Je me sens chanceux aujourd'hui
}
</code></pre></pre>
<!--
But you’ll more often see them used in this format, with the comment on a
separate line above the code it’s annotating:
-->
<p>Mais parfois, vous pourrez les voir utilisés de cette manière, avec le
commentaire sur une ligne séparée au-dessus du code qu'il annote :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Je me sens chanceux aujourd'hui
    let nombre_chanceux = 7;
}
</code></pre></pre>
<!--
Rust also has another kind of comment, documentation comments, which we’ll
discuss in the “Publishing a Crate to Crates.io” section of Chapter 14.
-->
<p>Rust a aussi un autre type de commentaire, les commentaires de documentation,
que nous aborderons au chapitre 14.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Control Flow
-->
<h2 id="les-structures-de-contrôle"><a class="header" href="#les-structures-de-contrôle">Les structures de contrôle</a></h2>
<!--
The ability to run some code depending on if a condition is true, or run some
code repeatedly while a condition is true, are basic building blocks in most
programming languages. The most common constructs that let you control the flow
of execution of Rust code are `if` expressions and loops.
-->
<p>Pouvoir exécuter ou non du code si une condition est vérifiée, ou exécuter du
code de façon répétée tant qu'une condition est vérifiée, sont des
constructions élémentaires dans la plupart des langages de programmation. Les
structures de contrôle les plus courantes en Rust sont les expressions <code>if</code> et
les boucles.</p>
<!--
### `if` Expressions
-->
<h3 id="les-expressions-if"><a class="header" href="#les-expressions-if">Les expressions <code>if</code></a></h3>
<!--
An `if` expression allows you to branch your code depending on conditions. You
provide a condition and then state, “If this condition is met, run this block
of code. If the condition is not met, do not run this block of code.”
-->
<p>Une expression <code>if</code> vous permet de diviser votre code en fonction de conditions.
Vous précisez une condition et vous choisissez ensuite : “Si cette condition est
remplie, alors exécuter ce bloc de code. Si la condition n'est pas remplie,
ne pas exécuter ce bloc de code.”</p>
<!--
Create a new project called *branches* in your *projects* directory to explore
the `if` expression. In the *src/main.rs* file, input the following:
-->
<p>Créez un nouveau projet appelé <em>branches</em> dans votre dossier <em>projects</em> pour
découvrir les expressions <code>if</code>. Dans le fichier <em>src/main.rs</em>, écrivez ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre = 3;

    if nombre &lt; 5 {
        println!(&quot;La condition est vérifiée&quot;);
    } else {
        println!(&quot;La condition n'est pas vérifiée&quot;);
    }
}
</code></pre></pre>
<!--
All `if` expressions start with the keyword `if`, followed by a condition. In
this case, the condition checks whether or not the variable `number` has a
value less than 5. We place block of code to execute if the condition is true
immediately after the condition inside curly brackets. Blocks of code
associated with the conditions in `if` expressions are sometimes called *arms*,
just like the arms in `match` expressions that we discussed in the [“Comparing
the Guess to the Secret Number”][comparing-the-guess-to-the-secret-number]<!--
ignore -- > section of Chapter 2.
-->
<p>Une expression <code>if</code> commence par le mot-clé <code>if</code>, suivi d'une condition.
Dans notre cas, la condition vérifie si oui ou non la variable <code>nombre</code> a une
valeur inférieure à 5. Nous ajoutons un bloc de code à exécuter si la condition
est vérifiée immédiatement après la condition entre des accolades. Les blocs de
code associés à une condition dans une expression <code>if</code> sont parfois appelés des
<em>branches</em>, exactement comme les branches dans les expressions <code>match</code> que nous
avons vu dans la section <a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">“Comparer le nombre saisi au nombre
secret”</a><!-- ignore --> du
chapitre 2.</p>
<!--
Optionally, we can also include an `else` expression, which we chose
to do here, to give the program an alternative block of code to execute should
the condition evaluate to false. If you don’t provide an `else` expression and
the condition is false, the program will just skip the `if` block and move on
to the next bit of code.
-->
<p>Éventuellement, vous pouvez aussi ajouter une expression <code>else</code>, ce que nous
avons fait ici, pour préciser un bloc alternatif de code qui sera exécuté dans
le cas où la condition est fausse (elle n'est pas vérifiée). Si
vous ne renseignez pas d'expression <code>else</code> et que la condition n'est pas
vérifiée, le programme va simplement sauter le bloc de <code>if</code> et passer au
prochain morceau de code.</p>
<!--
Try running this code; you should see the following output:
-->
<p>Essayez d'exécuter ce code ; vous verrez ceci :</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
La condition est vérifiée
</code></pre>
<!--
Let’s try changing the value of `number` to a value that makes the condition
`false` to see what happens:
-->
<p>Essayons de changer la valeur de <code>nombre</code> pour une valeur qui rend la condition
non vérifiée pour voir ce qui se passe :</p>
<!--
```rust,ignore
# fn main() {
    let number = 7;
# 
#     if number < 5 {
#         println!("condition was true");
#     } else {
#         println!("condition was false");
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let nombre = 7;
<span class="boring">
</span><span class="boring">    if nombre &lt; 5 {
</span><span class="boring">        println!(&quot;La condition est vérifiée&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;La condition n'est pas vérifiée&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Run the program again, and look at the output:
-->
<p>Exécutez à nouveau le programme, et regardez le résultat :</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
La condition n'est pas vérifiée
</code></pre>
<!--
It’s also worth noting that the condition in this code *must* be a `bool`. If
the condition isn’t a `bool`, we’ll get an error. For example, try running the
following code:
-->
<p>Il est aussi intéressant de noter que la condition dans ce code <em>doit</em> être un
<code>bool</code>. Si la condition n'est pas un <code>bool</code>, nous aurons une erreur. Par
exemple, essayez d'exécuter le code suivant :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let nombre = 3;

    if nombre {
        println!(&quot;Le nombre était trois&quot;);
    }
}
</code></pre>
<!--
The `if` condition evaluates to a value of `3` this time, and Rust throws an
error:
-->
<p>La condition <code>if</code> vaut <code>3</code> cette fois, et Rust lève une erreur :</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 -- > src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if nombre {
  |        ^^^^^^ expected bool, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<!--
The error indicates that Rust expected a `bool` but got an integer. Unlike
languages such as Ruby and JavaScript, Rust will not automatically try to
convert non-Boolean types to a Boolean. You must be explicit and always provide
`if` with a Boolean as its condition. If we want the `if` code block to run
only when a number is not equal to `0`, for example, we can change the `if`
expression to the following:
-->
<p>Cette erreur explique que Rust attendait un <code>bool</code> mais a obtenu un entier
<em>(integer)</em>. Contrairement à des langages comme Ruby et JavaScript, Rust
ne va pas essayer de convertir automatiquement les types non booléens en
booléens. Vous devez être précis et toujours fournir un booléen à la condition
d'un <code>if</code>. Si nous voulons que le bloc de code du <code>if</code> soit exécuté quand le
nombre est différent de <code>0</code>, par exemple, nous pouvons changer l'expression <code>if</code>
par la suivante :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier: src/main.rs</span></p>
<!--
```rust
fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre = 3;

    if nombre != 0 {
        println!(&quot;Le nombre valait autre chose que zéro&quot;);
    }
}
</code></pre></pre>
<!--
Running this code will print `number was something other than zero`.
-->
<p>Exécuter ce code va bien afficher <code>Le nombre valait autre chose que zéro</code>.</p>
<!--
#### Handling Multiple Conditions with `else if`
-->
<h4 id="gérer-plusieurs-conditions-avec-else-if"><a class="header" href="#gérer-plusieurs-conditions-avec-else-if">Gérer plusieurs conditions avec <code>else if</code></a></h4>
<!--
You can use multiple conditions by combining `if` and `else` in an `else if`
expression. For example:
-->
<p>Vous pouvez utiliser plusieurs conditions en combinant <code>if</code> et <code>else</code> dans une
expression <code>else if</code>. Par exemple :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre = 6;

    if nombre % 4 == 0 {
        println!(&quot;Le nombre est divisible par 4&quot;);
    } else if nombre % 3 == 0 {
        println!(&quot;Le nombre est divisible par 3&quot;);
    } else if nombre % 2 == 0 {
        println!(&quot;Le nombre est divisible par 2&quot;);
    } else {
        println!(&quot;Le nombre n'est pas divisible par 4, 3 ou 2&quot;);
    }
}
</code></pre></pre>
<!--
This program has four possible paths it can take. After running it, you should
see the following output:
-->
<p>Ce programme peut choisir entre quatre chemins différents. Après l'avoir
exécuté, vous devriez voir le résultat suivant :</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
Le nombre est divisible par 3
</code></pre>
<!--
When this program executes, it checks each `if` expression in turn and executes
the first body for which the condition holds true. Note that even though 6 is
divisible by 2, we don’t see the output `number is divisible by 2`, nor do we
see the `number is not divisible by 4, 3, or 2` text from the `else` block.
That’s because Rust only executes the block for the first true condition, and
once it finds one, it doesn’t even check the rest.
-->
<p>Quand ce programme s'exécute, il vérifie chaque expression <code>if</code> à tour de rôle
et exécute le premier bloc dont la condition est vérifiée. Notez que même si 6
est divisible par 2, nous ne voyons pas le message <code>Le nombre est divisible par 2</code>, ni le message <code>Le nombre n'est pas divisible par 4, 3 ou 2</code> du bloc <code>else</code>.
C'est parce que Rust n'exécute que le bloc de la première condition vérifiée,
et dès lors qu'il en a trouvé une, il ne va pas chercher à vérifier les
suivantes.</p>
<!--
Using too many `else if` expressions can clutter your code, so if you have more
than one, you might want to refactor your code. Chapter 6 describes a powerful
Rust branching construct called `match` for these cases.
-->
<p>Utiliser trop d'expressions <code>else if</code> peut encombrer votre code, donc si vous
en avez plus d'une, vous devriez envisager de remanier votre code. Le chapitre 6
présente une construction puissante appelée <code>match</code> pour de tels cas.</p>
<!--
#### Using `if` in a `let` Statement
-->
<h4 id="utiliser-if-dans-une-instruction-let"><a class="header" href="#utiliser-if-dans-une-instruction-let">Utiliser <code>if</code> dans une instruction <code>let</code></a></h4>
<!--
Because `if` is an expression, we can use it on the right side of a `let`
statement to assign the outcome to a variable, as in Listing 3-2.
-->
<p>Comme <code>if</code> est une expression, nous pouvons l'utiliser à droite d'une
instruction <code>let</code> pour assigner le résultat à une variable, comme dans l'encart
3-2.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let nombre = if condition { 5 } else { 6 };

    println!(&quot;La valeur du nombre est : {}&quot;, nombre);
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-2: Assigning the result of an `if` expression
to a variable</span>
-->
<p><span class="caption">Encart 3-2 : assigner le résultat d'une expression <code>if</code> à
une variable</span></p>
<!--
The `number` variable will be bound to a value based on the outcome of the `if`
expression. Run this code to see what happens:
-->
<p>La variable <code>nombre</code> va avoir la valeur du résultat de l'expression <code>if</code>.
Exécutez ce code pour découvrir ce qui va se passer :</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
La valeur du nombre est : 5
</code></pre>
<!--
Remember that blocks of code evaluate to the last expression in them, and
numbers by themselves are also expressions. In this case, the value of the
whole `if` expression depends on which block of code executes. This means the
values that have the potential to be results from each arm of the `if` must be
the same type; in Listing 3-2, the results of both the `if` arm and the `else`
arm were `i32` integers. If the types are mismatched, as in the following
example, we’ll get an error:
-->
<p>Souvenez-vous que les blocs de code s'exécutent jusqu'à la dernière expression
qu'ils contiennent, et que les nombres tout seuls sont aussi des expressions.
Dans notre cas, la valeur de toute l'expression <code>if</code> dépend de quel bloc de code
elle va exécuter. Cela veut dire que chaque valeur qui peut être le résultat de
chaque branche du <code>if</code> doivent être du même type ; dans l'encart 3-2, les
résultats des branches <code>if</code> et <code>else</code> sont tous deux des entiers <code>i32</code>. Si
les types ne sont pas identiques, comme dans l'exemple suivant, nous allons
obtenir une erreur :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {}", number);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let nombre = if condition { 5 } else { &quot;six&quot; };

    println!(&quot;La valeur du nombre est : {}&quot;, nombre);
}
</code></pre>
<!--
When we try to compile this code, we’ll get an error. The `if` and `else` arms
have value types that are incompatible, and Rust indicates exactly where to
find the problem in the program:
-->
<p>Lorsque nous essayons de compiler ce code, nous obtenons une erreur. Les
branches <code>if</code> et <code>else</code> ont des types de valeurs qui ne sont pas compatibles, et
Rust indique exactement où trouver le problème dans le programme :</p>
<!--
```console
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 -- > src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found `&str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let nombre = if condition { 5 } else { &quot;six&quot; };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<!--
The expression in the `if` block evaluates to an integer, and the expression in
the `else` block evaluates to a string. This won’t work because variables must
have a single type, and Rust needs to know at compile time what type the
`number` variable is, definitively. Knowing the type of `number` lets the
compiler verify the type is valid everywhere we use `number`. Rust wouldn’t be
able to do that if the type of `number` was only determined at runtime; the
compiler would be more complex and would make fewer guarantees about the code
if it had to keep track of multiple hypothetical types for any variable.
-->
<p>L'expression dans le bloc <code>if</code> donne un entier, et l'expression dans le bloc
<code>else</code> donne une chaîne de caractères. Ceci ne fonctionne pas car les variables
doivent avoir un seul type, et Rust a besoin de savoir de quel type est la
variable <code>nombre</code> au moment de la compilation. Savoir le type de <code>nombre</code>
permet au compilateur de vérifier que le type est valable n'importe où nous
utilisons <code>nombre</code>. Rust ne serait pas capable de faire cela si le type de
<code>nombre</code> était déterminé uniquement à l'exécution ; car le compilateur
deviendrait plus complexe et nous donnerait moins de garanties sur le code s'il
devait prendre en compte tous les types hypothétiques pour une variable.</p>
<!--
### Repetition with Loops
-->
<h3 id="les-répétitions-avec-les-boucles"><a class="header" href="#les-répétitions-avec-les-boucles">Les répétitions avec les boucles</a></h3>
<!--
It’s often useful to execute a block of code more than once. For this task,
Rust provides several *loops*, which will run through the code inside the loop
body to the end and then start immediately back at the beginning. To
experiment with loops, let’s make a new project called *loops*.
-->
<p>Il est parfois utile d'exécuter un bloc de code plus d'une seule fois. Dans ce
but, Rust propose plusieurs types de <em>boucles</em>, qui parcourt le code à
l'intérieur du corps de la boucle jusqu'à la fin et recommence immédiatement du
début. Pour tester les boucles, créons un nouveau projet appelé <em>loops</em>.</p>
<!--
Rust has three kinds of loops: `loop`, `while`, and `for`. Let’s try each one.
-->
<p>Rust a trois types de boucles : <code>loop</code>, <code>while</code>, et <code>for</code>. Essayons chacune
d'elles.</p>
<!--
#### Repeating Code with `loop`
-->
<h4 id="répéter-du-code-avec-loop"><a class="header" href="#répéter-du-code-avec-loop">Répéter du code avec <code>loop</code></a></h4>
<!--
The `loop` keyword tells Rust to execute a block of code over and over again
forever or until you explicitly tell it to stop.
-->
<p>Le mot-clé <code>loop</code> demande à Rust d'exécuter un bloc de code encore et encore
jusqu'à l'infini ou jusqu'à ce que vous lui demandiez explicitement de
s'arrêter.</p>
<!--
As an example, change the *src/main.rs* file in your *loops* directory to look
like this:
-->
<p>Par exemple, changez le fichier <em>src/main.rs</em> dans votre dossier <em>loops</em> comme
ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
fn main() {
    loop {
        println!("again!");
    }
}
```
-->
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;À nouveau !&quot;);
    }
}
</code></pre>
<!--
When we run this program, we’ll see `again!` printed over and over continuously
until we stop the program manually. Most terminals support the keyboard shortcut
<span class="keystroke">ctrl-c</span> to interrupt a program that is stuck in
a continual loop. Give it a try:
-->
<p>Quand nous exécutons ce programme, nous voyons <code>À nouveau !</code> s'afficher encore
et encore en continu jusqu'à ce qu'on arrête le programme manuellement. La
plupart des terminaux utilisent un raccourci clavier, <span class="keystroke">
ctrl-c</span>, pour arrêter un programme qui est bloqué dans une boucle infinie.
Essayons cela :</p>
<!--
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-- >
-->
<!--
```console
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
À nouveau !
À nouveau !
À nouveau !
À nouveau !
^CÀ nouveau !
</code></pre>
<!--
The symbol `^C` represents where you pressed <span class="keystroke">ctrl-c
</span>. You may or may not see the word `again!` printed after the `^C`,
depending on where the code was in the loop when it received the interrupt
signal.
-->
<p>Le symbole <code>^C</code> représente le moment où vous avez appuyé sur
<span class="keystroke">ctrl-c</span>. Vous devriez voir ou non le texte
<code>À nouveau !</code> après le <code>^C</code>, en fonction de là où la boucle en était dans votre
code quand elle a reçu le signal d'arrêt.</p>
<!--
Fortunately, Rust also provides a way to break out of a loop using code. You
can place the `break` keyword within the loop to tell the program when to stop
executing the loop. Recall that we did this in the guessing game in the
[“Quitting After a Correct Guess”][quitting-after-a-correct-guess]<!-- ignore
-- > section of Chapter 2 to exit the program when the user won the game by
guessing the correct number.
-->
<p>Heureusement, Rust fournit aussi un autre moyen de sortir d'une boucle en
utilisant du code. Vous pouvez ajouter le mot-clé <code>break</code> à l'intérieur de la boucle
pour demander au programme d'arrêter la boucle. Souvenez-vous que nous avions
fait ceci dans le jeu de devinettes, dans la section <a href="ch02-00-guessing-game-tutorial.html#arr%C3%AAter-le-programme-apr%C3%A8s-avoir-gagn%C3%A9">“Arrêter le programme
après avoir gagné”</a><!-- ignore --> du chapitre 2
afin de quitter le programme quand l'utilisateur gagne le jeu en devinant le
bon nombre.</p>
<!--
We also used `continue` in the guessing game, which in a loop tells the program
to skip over any remaining code in this iteration of the loop and go to the
next iteration.
-->
<p>Nous avons également <code>continue</code> dans le jeu du plus ou du moins, qui dans une
boucle demande au programme de sauter le code restant dans cette iteration de
la boucle et passer directement à la prochaine itération.</p>
<!--
If you have loops within loops, `break` and `continue` apply to the innermost
loop at that point. You can optionally specify a *loop label* on a loop that we
can then use with `break` or `continue` to specify that those keywords apply to
the labeled loop instead of the innermost loop. Here’s an example with two
nested loops:
-->
<p>Si vous avez des boucles imbriquées dans d'autres boucles, <code>break</code> et <code>continue</code>
s'appliquent uniquement à la boucle au plus bas niveau. Si vous en avez besoin,
vous pouvez associer une <em>etiquette de boucle</em> à une boucle que nous pouvons
ensuite utiliser en association avec <code>break</code> ou <code>continue</code> pour préciser que
ces mot-clés s'appliquent sur la boucle correspondant à l'étiquette plutôt qu'à
la boucle la plus proche possible. Voici un exemple avec deux boucles
imbriquées :</p>
<!--
```rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut compteur = 0;
    'increment: loop {
        println!(&quot;compteur = {}&quot;, compteur);
        let mut restant = 10;

        loop {
            println!(&quot;restant = {}&quot;, restant);
            if restant == 9 {
                break;
            }
            if compteur == 2 {
                break 'increment;
            }
            restant -= 1;
        }

        compteur += 1;
    }
    println!(&quot;Fin du compteur = {}&quot;, compteur);
}
</code></pre></pre>
<!--
The outer loop has the label `'counting_up`, and it will count up from 0 to 2.
The inner loop without a label counts down from 10 to 9. The first `break` that
doesn’t specify a label will exit the inner loop only. The `break
'counting_up;` statement will exit the outer loop. This code prints:
-->
<p>La boucle la plus à l'extérieur a l'étiquette <code>increment</code>, et elle va
incrémenter de 0 à 2. La boucle à l'intérieur n'a pas d'étiquette et va
décrementer de 10 à 9. Le premier <code>break</code> qui ne précise pas d'étiquette va
arrêter uniquement la boucle interne. L'instruction <code>break 'increment;</code> va
arrêter la boucle la plus à l'extérieur. Ce code va afficher :</p>
<!--
```console
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
```
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
compteur = 0
restant = 10
restant = 9
compteur = 1
restant = 10
restant = 9
compteur = 2
restant = 10
Fin du compteur = 2
</code></pre>
<!--
#### Returning Values from Loops
-->
<h4 id="retourner-des-valeurs-dune-boucle"><a class="header" href="#retourner-des-valeurs-dune-boucle">Retourner des valeurs d'une boucle</a></h4>
<!--
One of the uses of a `loop` is to retry an operation you know might fail, such
as checking whether a thread has completed its job. You might also need to pass
the result of that operation out of the loop to the rest of your code. To do
this, you can add the value you want returned after the `break` expression you
use to stop the loop; that value will be returned out of the loop so you can
use it, as shown here:
-->
<p>L'une des utilisations d'une boucle <code>loop</code> est de réessayer une opération qui
peut échouer, comme vérifier si une tâche a terminé son travail. Vous aurez
aussi peut-être besoin de passer le résultat de l'opération au reste de votre
code à l'extérieur de cette boucle. Pour ce faire, vous pouvez ajouter la
valeur que vous voulez retourner après l'expression <code>break</code> que vous utilisez
pour stopper la boucle ; cette valeur sera retournée à l'extérieur de la boucle
pour que vous puissiez l'utiliser, comme ci-dessous :</p>
<!--
```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut compteur = 0;

    let resultat = loop {
        compteur += 1;

        if compteur == 10 {
            break compteur * 2;
        }
    };

    println!(&quot;Le résultat est {}&quot;, resultat);
}
</code></pre></pre>
<!--
Before the loop, we declare a variable named `counter` and initialize it to
`0`. Then we declare a variable named `result` to hold the value returned from
the loop. On every iteration of the loop, we add `1` to the `counter` variable,
and then check whether the counter is equal to `10`. When it is, we use the
`break` keyword with the value `counter * 2`. After the loop, we use a
semicolon to end the statement that assigns the value to `result`. Finally, we
print the value in `result`, which in this case is 20.
-->
<p>Avant la boucle, nous déclarons une variable avec le nom <code>compteur</code> et nous
l'initialisons à <code>0</code>. Ensuite, nous déclarons une variable <code>resultat</code> pour
stocker la valeur retournée de la boucle. À chaque itération de la boucle, nous
ajoutons <code>1</code> à la variable <code>compteur</code>, et ensuite nous vérifions si le compteur
est égal à <code>10</code>. Lorsque c'est le cas, nous utilisons le mot-clé <code>break</code> avec la
valeur <code>compteur * 2</code>. Après la boucle, nous utilisons un point-virgule pour
terminer l'instruction qui assigne la valeur à <code>resultat</code>. Enfin, nous
affichons la valeur de <code>resultat</code>, qui est 20 dans ce cas-ci.</p>
<!--
#### Conditional Loops with `while`
-->
<h4 id="les-boucles-conditionnelles-avec-while"><a class="header" href="#les-boucles-conditionnelles-avec-while">Les boucles conditionnelles avec <code>while</code></a></h4>
<!--
A program will often need to evaluate a condition within a loop. While the
condition is true, the loop runs. When the condition ceases to be true, the
program calls `break`, stopping the loop. It's possible to implement behavior
like this using a combination of `loop`, `if`, `else`, and `break`; you could
try that now in a program, if you’d like. However, this pattern is so common
that Rust has a built-in language construct for it, called a `while` loop. In
Listing 3-3, we use `while` to loop the program three times, counting down each
time, and then, after the loop, print a message and exit.
-->
<p>Un programme a souvent besoin d'évaluer une condition dans une boucle.
Tant que la condition est vraie, la boucle tourne. Quand la condition arrête
d'être vraie, le programme appelle <code>break</code>, ce qui arrête la boucle. Il est
possible d'implémenter un comportement comme celui-ci en combinant <code>loop</code>,
<code>if</code>, <code>else</code> et <code>break</code> ; vous pouvez essayer de le faire, si vous voulez.
Cependant, cette utilisation est si fréquente que Rust a une construction pour
cela, intégrée dans le langage, qui s'appelle une boucle <code>while</code>. Dans l'encart
3-3, nous utilisons <code>while</code> pour boucler trois fois, en décrémentant à chaque
fois, et ensuite, après la boucle, il va afficher un message et se fermer.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut nombre = 3;

    while nombre != 0 {
        println!(&quot;{} !&quot;, nombre);

        nombre -= 1;
    }

    println!(&quot;DÉCOLLAGE !!!&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-3: Using a `while` loop to run code while a
condition holds true</span>
-->
<p><span class="caption">Encart 3-3: utiliser une boucle <code>while</code> pour exécuter du
code tant qu'une condition est vraie</span></p>
<!--
This construct eliminates a lot of nesting that would be necessary if you used
`loop`, `if`, `else`, and `break`, and it’s clearer. While a condition holds
true, the code runs; otherwise, it exits the loop.
-->
<p>Cette construction élimine beaucoup d'imbrications qui seraient nécessaires si
vous utilisiez <code>loop</code>, <code>if</code>, <code>else</code> et <code>break</code>, et c'est aussi plus clair. Tant
que la condition est vraie, le code est exécuté ; sinon, il quitte la boucle.</p>
<!--
#### Looping Through a Collection with `for`
-->
<h4 id="boucler-dans-une-collection-avec-for"><a class="header" href="#boucler-dans-une-collection-avec-for">Boucler dans une collection avec <code>for</code></a></h4>
<!--
You can choose to use the `while` construct to loop over the elements of a
collection, such as an array. For example, the loop in Listing 3-4 prints each
element in the array `a`.
-->
<p>Vous pouvez choisir d'utiliser la construction <code>while</code> pour itérer sur les
éléments d'une collection, comme les tableaux. Par exemple, la boucle dans
l'encart 3-4 affiche chaque élément présent dans le tableau <code>a</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut indice = 0;

    while indice &lt; 5 {
        println!(&quot;La valeur est : {}&quot;, a[indice]);

        indice += 1;
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-4: Looping through each element of a collection
using a `while` loop</span>
-->
<p><span class="caption">Encart 3-4 : itération sur les éléments d'une collection
en utilisant une boucle <code>while</code></span></p>
<!--
Here, the code counts up through the elements in the array. It starts at index
`0`, and then loops until it reaches the final index in the array (that is,
when `index < 5` is no longer true). Running this code will print every element
in the array:
-->
<p>Ici, le code parcourt le tableau élément par élément.
Il commence à l'indice <code>0</code>, et ensuite boucle jusqu'à ce qu'il atteigne l'indice
final du tableau (ce qui correspond au moment où la condition <code>index &lt; 5</code> n'est
plus vraie). Exécuter ce code va afficher chaque élément du tableau :</p>
<!--
```console
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
```
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
La valeur est : 10
La valeur est : 20
La valeur est : 30
La valeur est : 40
La valeur est : 50
</code></pre>
<!--
All five array values appear in the terminal, as expected. Even though `index`
will reach a value of `5` at some point, the loop stops executing before trying
to fetch a sixth value from the array.
-->
<p>Les cinq valeurs du tableau s'affichent toutes dans le terminal, comme attendu.
Même si <code>indice</code> va atteindre la valeur <code>5</code> à un moment, la boucle arrêtera de
s'exécuter avant d'essayer de récupérer une sixième valeur du tableau.</p>
<!--
However, this approach is error prone; we could cause the program to panic if
the index value or test condition are incorrect. For example, if you changed
the definition of the `a` array to have four elements but forgot to update the
condition to `while index < 4`, the code would panic. It’s also slow, because
the compiler adds runtime code to perform the conditional check of whether the
index is within the bounds of the array on every iteration through the loop.
-->
<p>Cependant, cette approche pousse à l'erreur ; nous pourrions faire paniquer le
programme si la valeur de l'indice est trop grand ou que la condition du test
est incorrecte. Par exemple, si vous changez la définition du tableau <code>a</code> pour
avoir quatre éléments, mais que nous oublions de modifier la condition dans
<code>while indice &lt; 4</code>, le code paniquera. De plus, c'est lent, car le compilateur
ajoute du code pour effectuer à l'exécution la vérification que l'indice est
compris dans les limites du tableau, et cela à chaque itération de la boucle.</p>
<!--
As a more concise alternative, you can use a `for` loop and execute some code
for each item in a collection. A `for` loop looks like the code in Listing 3-5.
-->
<p>Pour une alternative plus concise, vous pouvez utiliser une boucle <code>for</code> et
exécuter du code pour chaque élément dans une collection. Une boucle <code>for</code>
s'utilise comme dans le code de l'encart 3-5.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {}", element);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!(&quot;La valeur est : {}&quot;, element);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-5: Looping through each element of a collection
using a `for` loop</span>
-->
<p><span class="caption">Encart 3-5 : itérer sur chaque élément d'une collection
en utilisant une boucle <code>for</code></span></p>
<!--
When we run this code, we’ll see the same output as in Listing 3-4. More
importantly, we’ve now increased the safety of the code and eliminated the
chance of bugs that might result from going beyond the end of the array or not
going far enough and missing some items.
-->
<p>Lorsque nous exécutons ce code, nous obtenons les mêmes messages que dans
l'encart 3-4. Mais ce qui est plus important, c'est que nous avons amélioré la
sécurité de notre code et éliminé le risque de bogues qui pourraient survenir
si on dépassait la fin du tableau, ou si on n'allait pas jusqu'au bout
et qu'on ratait quelques éléments.</p>
<!--
Using the `for` loop, you wouldn’t need to remember to change any other code if
you changed the number of values in the array, as you would with the method
used in Listing 3-4.
-->
<p>En utilisant la boucle <code>for</code>, vous n'aurez pas à vous rappeler de changer le
code si vous changez le nombre de valeurs dans le tableau, comme vous devriez
le faire dans la méthode utilisée dans l'encart 3-4.</p>
<!--
The safety and conciseness of `for` loops make them the most commonly used loop
construct in Rust. Even in situations in which you want to run some code a
certain number of times, as in the countdown example that used a `while` loop
in Listing 3-3, most Rustaceans would use a `for` loop. The way to do that
would be to use a `Range`, provided by the standard library, which generates
all numbers in sequence starting from one number and ending before another
number.
-->
<p>La sécurité et la concision de la boucle <code>for</code> en font la construction de boucle
la plus utilisée avec Rust. Même dans des situations dans lesquelles vous
voudriez exécuter du code plusieurs fois, comme l'exemple du décompte qui
utilisait une boucle <code>while</code> dans l'encart 3-3, la plupart des Rustacés
utiliseraient une boucle <code>for</code>. Il faut pour cela utiliser un intervalle
<code>Range</code>, fourni par la bibliothèque standard pour générer dans l'ordre tous les
nombres compris entre un certain nombre et un autre nombre.</p>
<!--
Here’s what the countdown would look like using a `for` loop and another method
we’ve not yet talked about, `rev`, to reverse the range:
-->
<p>Voici ce que le décompte aurait donné en utilisant une boucle <code>for</code> et une autre
méthode que nous n'avons pas encore vue, <code>rev</code>, qui inverse l'intervalle :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    for nombre in (1..4).rev() {
        println!(&quot;{} !&quot;, nombre);
    }
    println!(&quot;DÉCOLLAGE !!!&quot;);
}
</code></pre></pre>
<!--
This code is a bit nicer, isn’t it?
-->
<p>Ce code est un peu plus sympa, non ?</p>
<!--
## Summary
-->
<h2 id="résumé-2"><a class="header" href="#résumé-2">Résumé</a></h2>
<!--
You made it! That was a sizable chapter: you learned about variables, scalar
and compound data types, functions, comments, `if` expressions, and loops!
To practice with the concepts discussed in this chapter, try building
programs to do the following:
-->
<p>Vous y êtes arrivé ! C'était un chapitre important : vous avez appris les
variables, les types scalaires et composés, les fonctions, les commentaires, les
expressions <code>if</code>, et les boucles !
Pour pratiquer un peu les concepts abordés dans ce chapitre, voici quelques
programmes que vous pouvez essayer de créer :</p>
<!--
* Convert temperatures between Fahrenheit and Celsius.
* Generate the nth Fibonacci number.
* Print the lyrics to the Christmas carol “The Twelve Days of Christmas,”
  taking advantage of the repetition in the song.
-->
<ul>
<li>Convertir des températures entre les degrés Fahrenheit et Celsius.</li>
<li>Générer le <em>n</em>-ième nombre de Fibonacci.</li>
<li>Afficher les paroles de la chanson de Noël <em>The Twelve Days of Christmas</em> en
profitant de l'aspect répétitif de la chanson.</li>
</ul>
<!--
When you’re ready to move on, we’ll talk about a concept in Rust that *doesn’t*
commonly exist in other programming languages: ownership.
-->
<p>Quand vous serez prêt à aller plus loin, nous aborderons une notion de Rust
qui n'existe <em>pas</em> dans les autres langages de programmation : la possession
<em>(ownership)</em>.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[quitting-after-a-correct-guess]:
ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Understanding Ownership
-->
<h1 id="comprendre-la-possession"><a class="header" href="#comprendre-la-possession">Comprendre la possession</a></h1>
<!--
Ownership is Rust’s most unique feature, and it enables Rust to make memory
safety guarantees without needing a garbage collector. Therefore, it’s
important to understand how ownership works in Rust. In this chapter, we’ll
talk about ownership as well as several related features: borrowing, slices,
and how Rust lays data out in memory.
-->
<p>La possession (<em>ownership</em>) est la fonctionnalité la plus remarquable de Rust,
et elle permet à Rust de garantir la sécurité de la mémoire sans avoir besoin
d'un ramasse-miettes (<em>garbage collector</em>). Par conséquent, il est important de
comprendre comment la possession fonctionne en Rust. Dans ce chapitre, nous
aborderons la possession, ainsi que d'autres fonctionnalités associées :
l'emprunt, les <em>slices</em> et la façon dont Rust agence les données en mémoire.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## What Is Ownership?
-->
<h2 id="quest-ce-que-la-possession-"><a class="header" href="#quest-ce-que-la-possession-">Qu'est-ce que la possession ?</a></h2>
<!--
Rust’s central feature is *ownership*. Although the feature is straightforward
to explain, it has deep implications for the rest of the language.
-->
<p>La principale spécificité de Rust est <em>la possession</em>. Bien que cette
fonctionnalité soit simple à expliquer, elle a de profondes conséquences sur le
reste du langage.</p>
<!--
All programs have to manage the way they use a computer’s memory while running.
Some languages have garbage collection that constantly looks for no longer used
memory as the program runs; in other languages, the programmer must explicitly
allocate and free the memory. Rust uses a third approach: memory is managed
through a system of ownership with a set of rules that the compiler checks at
compile time. None of the ownership features slow down your program while it’s
running.
-->
<p>Tous les programmes doivent gérer la façon dont ils utilisent la mémoire
lorsqu'ils s'exécutent. Certains langages ont un ramasse-miettes qui scrute
constamment la mémoire qui n'est plus utilisée pendant qu'il s'exécute ; dans
d'autres langages, le développeur doit explicitement allouer et libérer la
mémoire. Rust adopte une troisième approche : la mémoire est gérée avec un
système de possession qui repose sur un jeu de règles que le compilateur vérifie
au moment de la compilation. Aucune des fonctionnalités de possession ne
ralentit votre programme à l'exécution.</p>
<!--
Because ownership is a new concept for many programmers, it does take some time
to get used to. The good news is that the more experienced you become with Rust
and the rules of the ownership system, the more you’ll be able to naturally
develop code that is safe and efficient. Keep at it!
-->
<p>Comme la possession est un nouveau principe pour de nombreux développeurs,
cela prend un certain temps pour s'y familiariser. La bonne nouvelle est que
plus vous devenez expérimenté avec Rust et ses règles de possession, plus vous
développerez naturellement du code sûr et efficace. Gardez bien cela à
l'esprit !</p>
<!--
When you understand ownership, you’ll have a solid foundation for understanding
the features that make Rust unique. In this chapter, you’ll learn ownership by
working through some examples that focus on a very common data structure:
strings.
-->
<p>Lorsque vous comprendrez la possession, vous aurez des bases solides pour
comprendre les fonctionnalités qui font la particularité de Rust. Dans ce
chapitre, vous allez apprendre la possession en pratiquant avec plusieurs
exemples qui se concentrent sur une structure de données très courante : les
chaînes de caractères.</p>
<!--
> ### The Stack and the Heap
>
> In many programming languages, you don’t have to think about the stack and
> the heap very often. But in a systems programming language like Rust, whether
> a value is on the stack or the heap has more of an effect on how the language
> behaves and why you have to make certain decisions. Parts of ownership will
> be described in relation to the stack and the heap later in this chapter, so
> here is a brief explanation in preparation.
>
> Both the stack and the heap are parts of memory that are available to your
> code to use at runtime, but they are structured in different ways. The stack
> stores values in the order it gets them and removes the values in the
> opposite order. This is referred to as *last in, first out*. Think of a stack
> of plates: when you add more plates, you put them on top of the pile, and
> when you need a plate, you take one off the top. Adding or removing plates
> from the middle or bottom wouldn’t work as well! Adding data is called
> *pushing onto the stack*, and removing data is called *popping off the stack*.
>
> All data stored on the stack must have a known, fixed size. Data with an
> unknown size at compile time or a size that might change must be stored on
> the heap instead. The heap is less organized: when you put data on the heap,
> you request a certain amount of space. The memory allocator finds an empty
> spot in the heap that is big enough, marks it as being in use, and returns a
> *pointer*, which is the address of that location. This process is called
> *allocating on the heap* and is sometimes abbreviated as just *allocating*.
> Pushing values onto the stack is not considered allocating. Because the
> pointer is a known, fixed size, you can store the pointer on the stack, but
> when you want the actual data, you must follow the pointer.
>
> Think of being seated at a restaurant. When you enter, you state the number of
> people in your group, and the staff finds an empty table that fits everyone
> and leads you there. If someone in your group comes late, they can ask where
> you’ve been seated to find you.
>
> Pushing to the stack is faster than allocating on the heap because the
> allocator never has to search for a place to store new data; that
> location is always at the top of the stack. Comparatively, allocating space
> on the heap requires more work, because the allocator must first find
> a big enough space to hold the data and then perform bookkeeping to prepare
> for the next allocation.
>
> Accessing data in the heap is slower than accessing data on the stack because
> you have to follow a pointer to get there. Contemporary processors are faster
> if they jump around less in memory. Continuing the analogy, consider a server
> at a restaurant taking orders from many tables. It’s most efficient to get
> all the orders at one table before moving on to the next table. Taking an
> order from table A, then an order from table B, then one from A again, and
> then one from B again would be a much slower process. By the same token, a
> processor can do its job better if it works on data that’s close to other
> data (as it is on the stack) rather than farther away (as it can be on the
> heap). Allocating a large amount of space on the heap can also take time.
>
> When your code calls a function, the values passed into the function
> (including, potentially, pointers to data on the heap) and the function’s
> local variables get pushed onto the stack. When the function is over, those
> values get popped off the stack.
>
> Keeping track of what parts of code are using what data on the heap,
> minimizing the amount of duplicate data on the heap, and cleaning up unused
> data on the heap so you don’t run out of space are all problems that ownership
> addresses. Once you understand ownership, you won’t need to think about the
> stack and the heap very often, but knowing that managing heap data is why
> ownership exists can help explain why it works the way it does.
-->
<blockquote>
<h3 id="la-pile-et-le-tas"><a class="header" href="#la-pile-et-le-tas">La pile et le tas</a></h3>
<p>Dans de nombreux langages, il n'est pas nécessaire de se préoccuper de la
pile (<em>stack</em>) et du tas (<em>heap</em>). Mais dans un langage de programmation
système comme Rust, qu'une donnée soit sur la pile ou sur le tas influe
sur le comportement du langage et explique pourquoi nous devons faire certains
choix. Nous décrirons plus loin dans ce chapitre comment la possession
fonctionne vis-à-vis de la pile et du tas, voici donc une brève explication au
préalable.</p>
<p>La pile et le tas sont tous les deux des emplacements de la mémoire qui
sont à disposition de votre code lors de son exécution, mais sont organisés de
façon différente. La pile enregistre les valeurs dans l'ordre qu'elle les
reçoit et enlève les valeurs dans l'autre sens. C'est ce que l'on appelle le
principe de <em>dernier entré, premier sorti</em>. C'est comme une pile d'assiettes :
quand vous ajoutez des nouvelles assiettes, vous les déposez sur le dessus de
la pile, et quand vous avez besoin d'une assiette, vous en prenez une sur le
dessus. Ajouter ou enlever des assiettes au milieu ou en bas ne serait pas
aussi efficace ! Ajouter une donnée sur la pile se dit <em>empiler</em> et en retirer
une se dit <em>dépiler</em>.</p>
<p>Toutes les données stockées dans la pile doivent avoir une taille connue et
fixe. Les données avec une taille inconnue au moment de la compilation ou une
taille qui peut changer doivent plutôt être stockées sur le tas. Le tas est
moins bien organisé : lorsque vous ajoutez des données sur le tas, vous
demandez une certaine quantité d'espace mémoire. Le gestionnaire de mémoire va
trouver un emplacement dans le tas qui est suffisamment grand, va le marquer
comme étant en cours d'utilisation, et va retourner un <em>pointeur</em>, qui est
l'adresse de cet emplacement. Cette procédure est appelée <em>allocation sur le
tas</em>, ce qu'on abrège parfois en <em>allocation</em> tout court. L'ajout de valeurs
sur la pile n'est pas considéré comme une allocation. Comme le pointeur a une
taille connue et fixe, on peut stocker ce pointeur sur la pile, mais quand on
veut la vraie donnée, il faut suivre le pointeur.</p>
<p>C'est comme si vous vouliez manger au restaurant. Quand vous entrez, vous
indiquez le nombre de personnes dans votre groupe, et le personnel trouve une
table vide qui peut recevoir tout le monde, et vous y conduit. Si quelqu'un
dans votre groupe arrive en retard, il peut leur demander où vous êtes assis
pour vous rejoindre.</p>
<p>Empiler sur la pile est plus rapide qu'allouer sur le tas car le gestionnaire
ne va jamais avoir besoin de chercher un emplacement pour y stocker les
nouvelles données ; il le fait toujours au sommet de la pile. En comparaison,
allouer de la place sur le tas demande plus de travail, car le gestionnaire
doit d'abord trouver un espace assez grand pour stocker les données et mettre
à jour son suivi pour préparer la prochaine allocation.</p>
<p>Accéder à des données dans le tas est plus lent que d'accéder aux données sur
la pile car nous devons suivre un pointeur pour les obtenir. Les processeurs
modernes sont plus rapides s'ils se déplacent moins dans la mémoire. Pour
continuer avec notre analogie, imaginez un serveur dans un restaurant qui
prend les commandes de nombreuses tables. C'est plus efficace de récupérer
toutes les commandes à une seule table avant de passer à la table suivante.
Prendre une commande à la table A, puis prendre une commande à la table B,
puis ensuite une autre à la table A, puis une autre à la table B serait un
processus bien plus lent. De la même manière, un processeur sera plus efficace
dans sa tâche s'il travaille sur des données qui sont proches les unes des
autres (comme c'est le cas sur la pile) plutôt que si elles sont plus
éloignées (comme cela peut être le cas sur le tas). Allouer une grande
quantité de mémoire sur le tas peut aussi prendre beaucoup de temps.</p>
<p>Quand notre code utilise une fonction, les valeurs passées à la fonction
(incluant, potentiellement, des pointeurs de données sur le tas) et les
variables locales à la fonction sont déposées sur la pile. Quand l'utilisation
de la fonction est terminée, ces données sont retirées de la pile.</p>
<p>La possession nous aide à ne pas nous préoccuper de faire attention à quelles
parties du code utilisent quelles données sur le tas, de minimiser la
quantité de données en double sur le tas, ou encore de veiller à libérer les
données inutilisées sur le tas pour que nous ne soyons pas à court d'espace.
Quand vous aurez compris la possession, vous n'aurez plus besoin de vous
préoccuper de la pile et du tas très souvent, mais savoir que la possession
existe pour gérer les données du tas peut vous aider à comprendre pourquoi
elle fonctionne de cette manière.</p>
</blockquote>
<!--
### Ownership Rules
-->
<h3 id="les-règles-de-la-possession"><a class="header" href="#les-règles-de-la-possession">Les règles de la possession</a></h3>
<!--
First, let’s take a look at the ownership rules. Keep these rules in mind as we
work through the examples that illustrate them:
-->
<p>Tout d'abord, définissons les règles de la possession. Gardez à l'esprit ces
règles pendant que nous travaillons sur des exemples qui les illustrent :</p>
<!--
* Each value in Rust has a variable that’s called its *owner*.
* There can only be one owner at a time.
* When the owner goes out of scope, the value will be dropped.
-->
<ul>
<li>Chaque valeur en Rust a une variable qui s'appelle son <em>propriétaire</em>.</li>
<li>Il ne peut y avoir qu'un seul propriétaire à la fois.</li>
<li>Quand le propriétaire sortira de la portée, la valeur sera supprimée.</li>
</ul>
<!--
### Variable Scope
-->
<h3 id="portée-de-la-variable"><a class="header" href="#portée-de-la-variable">Portée de la variable</a></h3>
<!--
We’ve walked through an example of a Rust program already in Chapter 2. Now
that we’re past basic syntax, we won’t include all the `fn main() {` code in
examples, so if you’re following along, you’ll have to put the following
examples inside a `main` function manually. As a result, our examples will be a
bit more concise, letting us focus on the actual details rather than
boilerplate code.
-->
<p>Nous avons déjà vu un exemple de programme Rust au chapitre 2. Maintenant
que nous avons vu la syntaxe Rust de base, nous n'allons plus ajouter tout le
code du style <code>fn main() {</code> dans les exemples, donc si vous voulez reproduire
les exemples, vous devrez les mettre manuellement dans une fonction <code>main</code>. Par
conséquent, nos exemples seront plus concis, nous permettant de nous concentrer
sur les détails de la situation plutôt que sur du code normalisé.</p>
<!--
As a first example of ownership, we’ll look at the *scope* of some variables. A
scope is the range within a program for which an item is valid. Let’s say we
have a variable that looks like this:
-->
<p>Pour le premier exemple de possession, nous allons analyser la <em>portée</em> de
certaines variables. Une portée est une zone dans un programme dans laquelle un
élément est en vigueur. Imaginons que nous ayons la variable suivante :</p>
<!--
```rust
let s = "hello";
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The variable `s` refers to a string literal, where the value of the string is
hardcoded into the text of our program. The variable is valid from the point at
which it’s declared until the end of the current *scope*. Listing 4-1 has
comments annotating where the variable `s` is valid.
-->
<p>La variable <code>s</code> fait référence à un littéral de chaîne de caractères, où la
valeur de la chaîne est codée en dur dans notre programme. La variable est en
vigueur à partir du moment où elle est déclarée jusqu'à la fin de la <em>portée</em>
actuelle. L'encart 4-1 a des commentaires pour indiquer quand la variable <code>s</code>
est en vigueur :</p>
<!--
```rust
# fn main() {
    {                      // s is not valid here, it’s not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {                    // s n'est pas en vigueur ici, elle n'est pas encore déclarée
        let s = &quot;hello&quot;; // s est en vigueur à partir de ce point

        // on fait des choses avec s ici
    }                    // cette portée est maintenant terminée, et s n'est plus en vigueur
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-1: A variable and the scope in which it is
valid</span>
-->
<p><span class="caption">Encart 4-1 : Une variable et la portée dans laquelle elle
est en vigueur.</span></p>
<!--
In other words, there are two important points in time here:
-->
<p>Autrement dit, il y a ici deux étapes importantes :</p>
<!--
* When `s` comes *into scope*, it is valid.
* It remains valid until it goes *out of scope*.
-->
<ul>
<li>Quand <code>s</code> rentre <em>dans la portée</em>, elle est en vigueur.</li>
<li>Cela reste ainsi jusqu'à ce qu'elle <em>sorte de la portée</em>.</li>
</ul>
<!--
At this point, the relationship between scopes and when variables are valid is
similar to that in other programming languages. Now we’ll build on top of this
understanding by introducing the `String` type.
-->
<p>Pour le moment, la relation entre les portées et les conditions pour lesquelles
les variables sont en vigueur sont similaires à d'autres langages de
programmation. Maintenant, nous allons aller plus loin en y ajoutant le type
<code>String</code>.</p>
<!--
### The `String` Type
-->
<h3 id="le-type-string"><a class="header" href="#le-type-string">Le type <code>String</code></a></h3>
<!--
To illustrate the rules of ownership, we need a data type that is more complex
than the ones we covered in the [“Data Types”][data-types]<!-- ignore -- >
section of Chapter 3. The types covered previously are all a known size, can be
stored on the stack and popped off the stack when their scope is over, and can
be quickly and trivially copied to make a new, independent instance if another
part of code needs to use the same value in a different scope. But we want to
look at data that is stored on the heap and explore how Rust knows when to
clean up that data.
-->
<p>Pour illustrer les règles de la possession, nous avons besoin d'un type de
donnée qui est plus complexe que ceux que nous avons rencontrés dans la section
<a href="ch03-02-data-types.html">“Types de données”</a><!-- ignore --> du chapitre 3. Les types que
nous avons vus précédemment ont tous une taille connue et peuvent être stockés
sur la pile ainsi que retirés de la pile lorsque la portée n'en a plus besoin,
et peuvent aussi être rapidement et facilement afin de constituer une nouvelle
instance indépendante si une utrre partie du code a besoin d'utiliser la même
valeur dans une portée différente. Mais nous voulons expérimenter le stockage
de données sur le tas et découvrir comment Rust sait quand il doit nettoyer ces
données.</p>
<!--
We’ll use `String` as the example here and concentrate on the parts of `String`
that relate to ownership. These aspects also apply to other complex data types,
whether they are provided by the standard library or created by you. We’ll
discuss `String` in more depth in Chapter 8.
-->
<p>Nous allons utiliser ici <code>String</code> pour l'exemple et nous concentrer sur les
caractéristiques de <code>String</code> qui sont liées à la possession. Ces aspects
s'appliquent également à d'autres types de données complexes, qu'ils soient
fournis par la bibliothèque standard ou qu'ils soient créés par vous. Nous
verrons <code>String</code> plus en détail dans le chapitre 8.</p>
<!--
We’ve already seen string literals, where a string value is hardcoded into our
program. String literals are convenient, but they aren’t suitable for every
situation in which we may want to use text. One reason is that they’re
immutable. Another is that not every string value can be known when we write
our code: for example, what if we want to take user input and store it? For
these situations, Rust has a second string type, `String`. This type manages
data allocated on the heap and as such is able to store an amount of text that
is unknown to us at compile time. You can create a `String` from a string
literal using the `from` function, like so:
-->
<p>Nous avons déjà vu les littéraux de chaînes de caractères, quand une valeur de
chaîne est codée en dur dans notre programme. Les littéraux de chaînes sont
pratiques, mais ils ne conviennent pas toujours à tous les cas où on veut
utiliser du texte. Une des raisons est qu'ils sont immuables. Une autre raison
est qu'on ne connaît pas forcément le contenu des chaînes de caractères quand
nous écrivons notre code : par exemple, comment faire si nous voulons récupérer
du texte saisi par l'utilisateur et l'enregistrer ? Pour ces cas-ci, Rust a un
second type de chaîne de caractères, <code>String</code>. Ce type gère ses données sur le
tas et est ainsi capable de stocker une quantité de texte qui nous est inconnue
au moment de la compilation. Vous pouvez créer une <code>String</code> à partir d'un
littéral de chaîne de caractères en utilisant la fonction <code>from</code>, comme ceci :</p>
<!--
```rust
let s = String::from("hello");
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
The double colon (`::`) is an operator that allows us to namespace this
particular `from` function under the `String` type rather than using some sort
of name like `string_from`. We’ll discuss this syntax more in the [“Method
Syntax”][method-syntax]<!-- ignore -- > section of Chapter 5 and when we talk
about namespacing with modules in [“Paths for Referring to an Item in the
Module Tree”][paths-module-tree]<!-- ignore -- > in Chapter 7.
-->
<p>Le double deux-points (<code>::</code>) est un opérateur qui nous permet d'appeler cette
fonction spécifique dans l'espace de nom du type <code>String</code> plutôt que d'utiliser
un nom comme <code>string_from</code>. Nous verrons cette syntaxe plus en détail dans la
section <a href="ch05-03-method-syntax.html">“Syntaxe de méthode”</a><!-- ignore --> du chapitre 5 et
lorsque nous aborderons les espaces de noms dans la section
<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Les chemins pour désigner un élément dans l'arborescence de
module”</a><!-- ignore --> du chapitre 7.</p>
<!--
This kind of string *can* be mutated:
-->
<p>Ce type de chaîne de caractères <em>peut</em> être mutable :</p>
<!--
```rust
# fn main() {
    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() appends a literal to a String

    println!("{}", s); // This will print `hello, world!`
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    s.push_str(&quot;, world!&quot;); // push_str() ajoute un littéral de chaîne dans une String
    
    println!(&quot;{}&quot;, s); // Cela va afficher `hello, world!`
<span class="boring">}
</span></code></pre></pre>
<!--
So, what’s the difference here? Why can `String` be mutated but literals
cannot? The difference is how these two types deal with memory.
-->
<p>Donc, quelle est la différence ici ? Pourquoi <code>String</code> peut être mutable, mais
pourquoi les littéraux de chaînes ne peuvent pas l'être ? La différence
se trouve dans la façon dont ces deux types travaillent avec la mémoire.</p>
<!--
### Memory and Allocation
-->
<h3 id="mémoire-et-allocation"><a class="header" href="#mémoire-et-allocation">Mémoire et allocation</a></h3>
<!--
In the case of a string literal, we know the contents at compile time, so the
text is hardcoded directly into the final executable. This is why string
literals are fast and efficient. But these properties only come from the string
literal’s immutability. Unfortunately, we can’t put a blob of memory into the
binary for each piece of text whose size is unknown at compile time and whose
size might change while running the program.
-->
<p>Dans le cas d'un littéral de chaîne de caractères, nous connaissons le contenu
au moment de la compilation donc le texte est codé en dur directement dans
l'exécutable final. Voilà pourquoi ces littéraux de chaînes de caractères sont
performants et rapides. Mais ces caractéristiques viennent de leur immuabilité.
Malheureusement, on ne peut pas accorder une grosse région de mémoire dans le
binaire pour chaque morceau de texte qui n'a pas de taille connue au moment de
la compilation et dont la taille pourrait changer pendant l'exécution de ce
programme.</p>
<!--
With the `String` type, in order to support a mutable, growable piece of text,
we need to allocate an amount of memory on the heap, unknown at compile time,
to hold the contents. This means:
-->
<p>Avec le type <code>String</code>, pour nous permettre d'avoir un texte mutable et qui peut
s'agrandir, nous devons allouer une quantité de mémoire sur le tas, inconnue
au moment de la compilation, pour stocker le contenu. Cela signifie que :</p>
<!--
* The memory must be requested from the memory allocator at runtime.
* We need a way of returning this memory to the allocator when we’re
  done with our `String`.
-->
<ul>
<li>La mémoire doit être demandée auprès du gestionnaire de mémoire lors de
l'exécution.</li>
<li>Nous avons besoin d'un moyen de rendre cette mémoire au gestionnaire lorsque
nous aurons fini d'utiliser notre <code>String</code>.</li>
</ul>
<!--
That first part is done by us: when we call `String::from`, its implementation
requests the memory it needs. This is pretty much universal in programming
languages.
-->
<p>Nous nous occupons de ce premier point : quand nous appelons <code>String::from</code>, son
implémentation demande la mémoire dont elle a besoin. C'est pratiquement
toujours ainsi dans la majorité des langages de programmation.</p>
<!--
However, the second part is different. In languages with a *garbage collector
(GC)*, the GC keeps track and cleans up memory that isn’t being used anymore,
and we don’t need to think about it. Without a GC, it’s our responsibility to
identify when memory is no longer being used and call code to explicitly return
it, just as we did to request it. Doing this correctly has historically been a
difficult programming problem. If we forget, we’ll waste memory. If we do it
too early, we’ll have an invalid variable. If we do it twice, that’s a bug too.
We need to pair exactly one `allocate` with exactly one `free`.
-->
<p>Cependant, le deuxième point est différent. Dans des langages avec un
<em>ramasse-miettes</em>, le ramasse-miettes surveille et nettoie la mémoire qui n'est
plus utilisée, sans que nous n'ayons à nous en préoccuper. Sans un
ramasse-miettes, c'est de notre responsabilité d'identifier quand cette mémoire
n'est plus utilisée et d'appeler du code pour explicitement la libérer, comme
nous l'avons fait pour la demander auparavant. Historiquement, faire ceci
correctement a toujours été une difficulté pour les développeurs. Si nous
oublions de le faire, nous allons gaspiller de la mémoire. Si nous le faisons
trop tôt, nous allons avoir une variable invalide. Si nous le faisons deux fois,
cela produit aussi un bogue. Nous devons associer exactement un <code>allocate</code> avec
exactement un <code>free</code>.</p>
<!--
Rust takes a different path: the memory is automatically returned once the
variable that owns it goes out of scope. Here’s a version of our scope example
from Listing 4-1 using a `String` instead of a string literal:
-->
<p>Rust prend un chemin différent : la mémoire est automatiquement libérée dès
que la variable qui la possède sort de la portée. Voici une version de notre
exemple de portée de l'encart 4-1 qui utilise une <code>String</code> plutôt qu'un littéral
de chaîne de caractères :</p>
<!--
```rust
# fn main() {
    {
        let s = String::from("hello"); // s is valid from this point forward

        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let s = String::from(&quot;hello&quot;); // s est en vigueur à partir de ce point
    
        // on fait des choses avec s ici
    }                                  // cette portée est désormais terminée, et s
                                       // n'est plus en vigueur maintenant
<span class="boring">}
</span></code></pre></pre>
<!--
There is a natural point at which we can return the memory our `String` needs
to the allocator: when `s` goes out of scope. When a variable goes out of
scope, Rust calls a special function for us. This function is called
[`drop`][drop]<!-- ignore -- >, and it’s where the author of `String` can put
the code to return the memory. Rust calls `drop` automatically at the closing
curly bracket.
-->
<p>Il y a un moment naturel où nous devons rendre la mémoire de notre
<code>String</code> au gestionnaire : quand <code>s</code> sort de la portée. Quand une variable sort
de la portée, Rust appelle une fonction spéciale pour nous. Cette fonction
s'appelle <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore -->, et c'est dans celle-ci que l'auteur de
<code>String</code> a pu mettre le code pour libérer la mémoire. Rust appelle
automatiquement <code>drop</code> à l'accolade fermante <code>}</code>.</p>
<!--
> Note: In C++, this pattern of deallocating resources at the end of an item’s
> lifetime is sometimes called *Resource Acquisition Is Initialization (RAII)*.
> The `drop` function in Rust will be familiar to you if you’ve used RAII
> patterns.
-->
<blockquote>
<p>Remarque : en C++, cette façon de libérer des ressources à la fin de la
durée de vie d'un élément est parfois appelée <em>l'acquisition d'une ressource
est une initialisation (RAII)</em>. La fonction <code>drop</code> de Rust vous sera familière
si vous avez déjà utilisé des techniques de RAII.</p>
</blockquote>
<!--
This pattern has a profound impact on the way Rust code is written. It may seem
simple right now, but the behavior of code can be unexpected in more
complicated situations when we want to have multiple variables use the data
we’ve allocated on the heap. Let’s explore some of those situations now.
-->
<p>Cette façon de faire a un impact profond sur la façon dont le code Rust est
écrit. Cela peut sembler simple dans notre cas, mais le comportement du code
peut être surprenant dans des situations plus compliquées où nous voulons
avoir plusieurs variables utilisant des données que nous avons affectées sur le
tas. Examinons une de ces situations dès à présent.</p>
<!--
#### Ways Variables and Data Interact: Move
-->
<h4 id="les-interactions-entre-les-variables-et-les-données--le-déplacement"><a class="header" href="#les-interactions-entre-les-variables-et-les-données--le-déplacement">Les interactions entre les variables et les données : le déplacement</a></h4>
<!--
Multiple variables can interact with the same data in different ways in Rust.
Let’s look at an example using an integer in Listing 4-2.
-->
<p>Plusieurs variables peuvent interagir avec les mêmes données de différentes
manières en Rust. Regardons un exemple avec un entier dans l'encart 4-2 :</p>
<!--
```rust
# fn main() {
    let x = 5;
    let y = x;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-2: Assigning the integer value of variable `x`
to `y`</span>
-->
<p><span class="caption">Encart 4-2 : Assigner l'entier de la variable <code>x</code> à <code>y</code>
</span></p>
<!--
We can probably guess what this is doing: “bind the value `5` to `x`; then make
a copy of the value in `x` and bind it to `y`.” We now have two variables, `x`
and `y`, and both equal `5`. This is indeed what is happening, because integers
are simple values with a known, fixed size, and these two `5` values are pushed
onto the stack.
-->
<p>Nous pouvons probablement deviner ce que ce code fait : “Assigner la valeur <code>5</code>
à <code>x</code> ; ensuite faire une copie de cette valeur de <code>x</code> et l'assigner à <code>y</code>.”
Nous avons maintenant deux variables, <code>x</code> et <code>y</code>, et chacune vaut <code>5</code>. C'est
effectivement ce qui se passe, car les entiers sont des valeurs simples avec une
taille connue et fixée, et ces deux valeurs <code>5</code> sont stockées sur la pile.</p>
<!--
Now let’s look at the `String` version:
-->
<p>Maintenant, essayons une nouvelle version avec <code>String</code> :</p>
<!--
```rust
# fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<!--
This looks very similar to the previous code, so we might assume that the way
it works would be the same: that is, the second line would make a copy of the
value in `s1` and bind it to `s2`. But this isn’t quite what happens.
-->
<p>Cela ressemble beaucoup au code précédent, donc nous allons supposer que cela
fonctionne pareil que précédemment : ainsi, la seconde ligne va faire une copie
de la valeur de <code>s1</code> et l'assigner à <code>s2</code>. Mais ce n'est pas tout à fait ce
qu'il se passe.</p>
<!--
Take a look at Figure 4-1 to see what is happening to `String` under the
covers. A `String` is made up of three parts, shown on the left: a pointer to
the memory that holds the contents of the string, a length, and a capacity.
This group of data is stored on the stack. On the right is the memory on the
heap that holds the contents.
-->
<p>Regardons l'illustration 4-1 pour découvrir ce qui arrive à <code>String</code> sous le
capot. Une <code>String</code> est constituée de trois éléments, présents sur la gauche :
un pointeur vers la mémoire qui contient le contenu de la chaîne de caractères,
une taille, et une capacité. Ce groupe de données est stocké sur la pile. À
droite, nous avons la mémoire sur le tas qui contient les données.</p>
<!-- markdownlint-disable -->
<!--
<img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="Une string en mémoire" src="img/trpl04-01.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-1: Representation in memory of a `String`
holding the value `"hello"` bound to `s1`</span>
-->
<p><span class="caption">Illustration 4-1 : Représentation en mémoire d'une
<code>String</code> qui contient la valeur <code>&quot;hello&quot;</code> assignée à <code>s1</code>.</span></p>
<!--
The length is how much memory, in bytes, the contents of the `String` is
currently using. The capacity is the total amount of memory, in bytes, that the
`String` has received from the allocator. The difference between length
and capacity matters, but not in this context, so for now, it’s fine to ignore
the capacity.
-->
<p>La taille est la quantité de mémoire, en octets, que le contenu de la <code>String</code>
utilise actuellement. La capacité est la quantité totale de mémoire, en octets,
que la <code>String</code> a reçue du gestionnaire. La différence entre la taille et la
capacité est importante, mais pas pour notre exemple, donc pour l'instant, ce
n'est pas grave d'ignorer la capacité.</p>
<!--
When we assign `s1` to `s2`, the `String` data is copied, meaning we copy the
pointer, the length, and the capacity that are on the stack. We do not copy the
data on the heap that the pointer refers to. In other words, the data
representation in memory looks like Figure 4-2.
-->
<p>Quand nous assignons <code>s1</code> à <code>s2</code>, les données de la <code>String</code> sont copiées, ce
qui veut dire que nous copions le pointeur, la taille et la capacité qui sont
stockés sur la pile. Nous ne copions pas les données stockées sur le tas
auxquelles le pointeur se réfère. Autrement dit, la représentation des données
dans la mémoire ressemble à l'illustration 4-2.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 et s2 qui pointent vers la même valeur" src="img/trpl04-02.svg"
class="center" style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-2: Representation in memory of the variable `s2`
that has a copy of the pointer, length, and capacity of `s1`</span>
-->
<p><span class="caption">Illustration 4-2 : Représentation en mémoire de la
variable <code>s2</code> qui a une copie du pointeur, de la taille et de la capacité de
<code>s1</code></span></p>
<!--
The representation does *not* look like Figure 4-3, which is what memory would
look like if Rust instead copied the heap data as well. If Rust did this, the
operation `s2 = s1` could be very expensive in terms of runtime performance if
the data on the heap were large.
-->
<p>Cette représentation <em>n'est pas</em> comme l'illustration 4-3, qui représenterait la
mémoire si Rust avait aussi copié les données sur le tas. Si Rust faisait ceci,
l'opération <code>s2 = s1</code> pourrait potentiellement être très coûteuse en termes de
performances d'exécution si les données sur le tas étaient volumineuses.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 et s2 à deux endroits" src="img/trpl04-03.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-3: Another possibility for what `s2 = s1` might
do if Rust copied the heap data as well</span>
-->
<p><span class="caption">Illustration 4-3 : Une autre possibilité de ce que
pourrait faire <code>s2 = s1</code> si Rust copiait aussi les données du tas</span></p>
<!--
Earlier, we said that when a variable goes out of scope, Rust automatically
calls the `drop` function and cleans up the heap memory for that variable. But
Figure 4-2 shows both data pointers pointing to the same location. This is a
problem: when `s2` and `s1` go out of scope, they will both try to free the
same memory. This is known as a *double free* error and is one of the memory
safety bugs we mentioned previously. Freeing memory twice can lead to memory
corruption, which can potentially lead to security vulnerabilities.
-->
<p>Précédemment, nous avons dit que quand une variable sortait de la portée, Rust
appelait automatiquement la fonction <code>drop</code> et nettoyait la mémoire sur le tas
allouée pour cette variable. Mais l'illustration 4-2 montre que les deux
pointeurs de données pointeraient au même endroit. C'est un problème : quand
<code>s2</code> et <code>s1</code> sortent de la portée, elles vont essayer toutes les deux de
libérer la même mémoire. C'est ce qu'on appelle une erreur de <em>double
libération</em> et c'est un des bogues de sécurité de mémoire que nous avons
mentionnés précédemment. Libérer la mémoire deux fois peut mener à des
corruptions de mémoire, ce qui peut potentiellement mener à des vulnérabilités
de sécurité.</p>
<!--
To ensure memory safety, there’s one more detail to what happens in this
situation in Rust. After `let s2 = s1`, Rust considers `s1` to no longer be
valid. Therefore, Rust doesn’t need to free anything when `s1` goes out of
scope. Check out what happens when you try to use `s1` after `s2` is created;
it won’t work:
-->
<p>Pour garantir la sécurité de la mémoire, il y a un autre petit détail qui se
produit dans cette situation avec Rust. Après <code>let s2 = s1</code>, Rust considère que
<code>s1</code> n'est plus en vigueur. Par conséquent, Rust n'a pas besoin de libérer quoi
que ce soit lorsque <code>s1</code> sort de la portée. Regardez ce qu'il se passe quand
vous essayez d'utiliser <code>s1</code> après que <code>s2</code> est créé, cela ne va pas
fonctionner :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;

    println!(&quot;{}, world!&quot;, s1);
<span class="boring">}
</span></code></pre>
<!--
You’ll get an error like this because Rust prevents you from using the
invalidated reference:
-->
<p>Vous allez avoir une erreur comme celle-ci, car Rust vous défend d'utiliser la
référence qui n'est plus en vigueur :</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 -- > src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;hello&quot;);
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
If you’ve heard the terms *shallow copy* and *deep copy* while working with
other languages, the concept of copying the pointer, length, and capacity
without copying the data probably sounds like making a shallow copy. But
because Rust also invalidates the first variable, instead of being called a
shallow copy, it’s known as a *move*. In this example, we would say that
`s1` was *moved* into `s2`. So what actually happens is shown in Figure 4-4.
-->
<p>Si vous avez déjà entendu parler de <em>copie superficielle</em> et de <em>copie
profonde</em> en utilisant d'autres langages, l'idée de copier le pointeur, la
taille et la capacité sans copier les données peut vous faire penser à de la
copie superficielle. Mais comme Rust neutralise aussi la première variable, au
lieu d'appeler cela une copie superficielle, on appelle cela un <em>déplacement</em>.
Ici, nous pourrions dire que <code>s1</code> a été <em>déplacé</em> dans <code>s2</code>. Donc ce qui se
passe réellement est décrit par l'illustration 4-4.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 déplacé dans s2" src="img/trpl04-04.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-4: Representation in memory after `s1` has been
invalidated</span>
-->
<p><span class="caption">Illustration 4-4 : Représentation de la mémoire après que
<code>s1</code> a été neutralisée</span></p>
<!--
That solves our problem! With only `s2` valid, when it goes out of scope, it
alone will free the memory, and we’re done.
-->
<p>Cela résout notre problème ! Avec seulement <code>s2</code> en vigueur, quand elle
sortira de la portée, elle seule va libérer la mémoire, et c'est tout.</p>
<!--
In addition, there’s a design choice that’s implied by this: Rust will never
automatically create “deep” copies of your data. Therefore, any *automatic*
copying can be assumed to be inexpensive in terms of runtime performance.
-->
<p>De plus, cela signifie qu'il y a eu un choix de conception : Rust ne va jamais
créer automatiquement de copie “profonde” de vos données. Par conséquent, toute
copie <em>automatique</em> peut être considérée comme peu coûteuse en termes de
performances d'exécution.</p>
<!--
#### Ways Variables and Data Interact: Clone
-->
<h4 id="les-interactions-entre-les-variables-et-les-données--le-clonage"><a class="header" href="#les-interactions-entre-les-variables-et-les-données--le-clonage">Les interactions entre les variables et les données : le clonage</a></h4>
<!--
If we *do* want to deeply copy the heap data of the `String`, not just the
stack data, we can use a common method called `clone`. We’ll discuss method
syntax in Chapter 5, but because methods are a common feature in many
programming languages, you’ve probably seen them before.
-->
<p>Si nous <em>voulons</em> faire une copie profonde des données sur le tas d'une
<code>String</code>, et pas seulement des données sur la pile, nous pouvons utiliser une
méthode commune qui s'appelle <code>clone</code>. Nous aborderons la syntaxe des méthodes
au chapitre 5, mais comme les méthodes sont des outils courants dans de
nombreux langages, vous les avez probablement utilisées auparavant.</p>
<!--
Here’s an example of the `clone` method in action:
-->
<p>Voici un exemple d'utilisation de la méthode <code>clone</code> :</p>
<!--
```rust
# fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1.clone();

    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<!--
This works just fine and explicitly produces the behavior shown in Figure 4-3,
where the heap data *does* get copied.
-->
<p>Cela fonctionne très bien et c'est ainsi que vous pouvez reproduire le
comportement décrit dans l'illustration 4-3, où les données du tas sont copiées.</p>
<!--
When you see a call to `clone`, you know that some arbitrary code is being
executed and that code may be expensive. It’s a visual indicator that something
different is going on.
-->
<p>Quand vous voyez un appel à <code>clone</code>, vous savez que du code arbitraire est
exécuté et que ce code peut être coûteux. C'est un indicateur visuel qu'il se
passe quelque chose de différent.</p>
<!--
#### Stack-Only Data: Copy
-->
<h4 id="données-uniquement-sur-la-pile--la-copie"><a class="header" href="#données-uniquement-sur-la-pile--la-copie">Données uniquement sur la pile : la copie</a></h4>
<!--
There’s another wrinkle we haven’t talked about yet. This code using integers –
part of which was shown in Listing 4-2 – works and is valid:
-->
<p>Il y a un autre détail dont on n'a pas encore parlé. Le code suivant utilise
des entiers - on en a vu une partie dans l'encart 4-2 - il fonctionne et
est correct :</p>
<!--
```rust
# fn main() {
    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<!--
But this code seems to contradict what we just learned: we don’t have a call to
`clone`, but `x` is still valid and wasn’t moved into `y`.
-->
<p>Mais ce code semble contredire ce que nous venons d'apprendre : nous n'avons
pas appelé <code>clone</code>, mais <code>x</code> est toujours en vigueur et n'a pas été déplacé
dans <code>y</code>.</p>
<!--
The reason is that types such as integers that have a known size at compile
time are stored entirely on the stack, so copies of the actual values are quick
to make. That means there’s no reason we would want to prevent `x` from being
valid after we create the variable `y`. In other words, there’s no difference
between deep and shallow copying here, so calling `clone` wouldn’t do anything
different from the usual shallow copying and we can leave it out.
-->
<p>La raison est que les types comme les entiers ont une taille connue au moment de
la compilation et sont entièrement stockés sur la pile, donc la copie des
vraies valeurs est rapide à faire. Cela signifie qu'il n'y a pas de raison que
nous voudrions neutraliser <code>x</code> après avoir créé la variable <code>y</code>. En d'autres
termes, il n'y a pas ici de différence entre la copie superficielle et profonde,
donc appeler <code>clone</code> ne ferait rien d'autre qu'une copie superficielle classique
et on peut s'en passer.</p>
<!--
Rust has a special annotation called the `Copy` trait that we can place on
types like integers that are stored on the stack (we’ll talk more about traits
in Chapter 10). If a type implements the `Copy` trait, an older variable is
still usable after assignment. Rust won’t let us annotate a type with the
`Copy` trait if the type, or any of its parts, has implemented the `Drop`
trait. If the type needs something special to happen when the value goes out of
scope and we add the `Copy` annotation to that type, we’ll get a compile-time
error. To learn about how to add the `Copy` annotation to your type to
implement the trait, see [“Derivable Traits”][derivable-traits]<!-- ignore -- >
in Appendix C.
-->
<p>Rust a une annotation spéciale appelée le trait <code>Copy</code> que nous pouvons utiliser
sur des types comme les entiers qui sont stockés sur la pile (nous verrons les
traits dans le chapitre 10). Si un type implémente le trait <code>Copy</code>, l'ancienne
variable sera toujours utilisable après avoir été affectée. Rust ne nous
autorisera pas à annoter un type avec le trait <code>Copy</code> si ce type, ou un de ses
éléments, a implémenté le trait <code>Drop</code>. Si ce type a besoin que quelque chose de
spécial se produise quand la valeur sort de la portée et que nous ajoutons
l'annotation <code>Copy</code> sur ce type, nous aurons une erreur au moment de la
compilation. Pour savoir comment ajouter l'annotation <code>Copy</code> sur votre type pour
implémenter le trait, référez-vous à
<a href="appendix-03-derivable-traits.html">l'annexe C</a><!-- ignore --> sur les traits dérivables.</p>
<!--
So what types implement the `Copy` trait? You can check the documentation for
the given type to be sure, but as a general rule, any group of simple scalar
values can implement `Copy`, and nothing that requires allocation or is some
form of resource can implement `Copy`. Here are some of the types that
implement `Copy`:
-->
<p>Donc, quels sont les types qui implémentent le trait <code>Copy</code> ? Vous pouvez
regarder dans la documentation pour un type donné pour vous en assurer, mais de
manière générale, tout groupe de valeur scalaire peut implémenter <code>Copy</code>, et
tout ce qui ne nécessite pas d'allocation de mémoire ou tout autre forme de
ressource qui implémente <code>Copy</code>. Voici quelques types qui implémentent <code>Copy</code> :</p>
<!--
* All the integer types, such as `u32`.
* The Boolean type, `bool`, with values `true` and `false`.
* All the floating point types, such as `f64`.
* The character type, `char`.
* Tuples, if they only contain types that also implement `Copy`. For example,
  `(i32, i32)` implements `Copy`, but `(i32, String)` does not.
-->
<ul>
<li>Tous les types d'entiers, comme <code>u32</code>.</li>
<li>Le type booléen, <code>bool</code>, avec les valeurs <code>true</code> et <code>false</code>.</li>
<li>Tous les types de flottants, comme <code>f64</code>.</li>
<li>Le type de caractère, <code>char</code>.</li>
<li>Les tuples, mais uniquement s'ils contiennent des types qui implémentent
aussi <code>Copy</code>. Par exemple, le <code>(i32, i32)</code> implémente <code>Copy</code>, mais pas
<code>(i32, String)</code>.</li>
</ul>
<!--
### Ownership and Functions
-->
<h3 id="la-possession-et-les-fonctions"><a class="header" href="#la-possession-et-les-fonctions">La possession et les fonctions</a></h3>
<!--
The semantics for passing a value to a function are similar to those for
assigning a value to a variable. Passing a variable to a function will move or
copy, just as assignment does. Listing 4-3 has an example with some annotations
showing where variables go into and out of scope.
-->
<p>La syntaxe pour passer une valeur à une fonction est similaire à celle pour
assigner une valeur à une variable. Passer une variable à une fonction va la
déplacer ou la copier, comme l'assignation. L'encart 4-3 est un exemple avec
quelques commentaires qui montrent où les variables rentrent et sortent de la
portée :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
  let s = String::from(&quot;hello&quot;);  // s rentre dans la portée.

  prendre_possession(s);  // La valeur de s est déplacée dans la fonction…
                          // … et n'est plus en vigueur à partir d'ici

  let x = 5;              // x rentre dans la portée.

  creer_copie(x);         // x va être déplacée dans la fonction,
                          // mais i32 est Copy, donc on peut
                          // utiliser x ensuite.

} // Ici, x sort de la portée, puis ensuite s. Mais puisque la valeur de s a
// été déplacée, il ne se passe rien de spécial.

fn prendre_possession(texte: String) { // texte rentre dans la portée.
  println!(&quot;{}&quot;, texte);
} // Ici, texte sort de la portée et `drop` est appelé. La mémoire est libérée.

fn creer_copie(entier: i32) { // entier rentre dans la portée.
  println!(&quot;{}&quot;, entier);
} // Ici, entier sort de la portée. Il ne se passe rien de spécial.
</code></pre></pre>
<!--
<span class="caption">Listing 4-3: Functions with ownership and scope
annotated</span>
-->
<p><span class="caption">Encart 4-3 : Les fonctions avec les possessions et les
portées qui sont commentées</span></p>
<!--
If we tried to use `s` after the call to `takes_ownership`, Rust would throw a
compile-time error. These static checks protect us from mistakes. Try adding
code to `main` that uses `s` and `x` to see where you can use them and where
the ownership rules prevent you from doing so.
-->
<p>Si on essayait d'utiliser <code>s</code> après l'appel à <code>prendre_possession</code>, Rust
déclencherait une erreur à la compilation. Ces vérifications statiques
nous protègent des erreurs. Essayez d'ajouter du code au <code>main</code> qui utilise <code>s</code>
et <code>x</code> pour découvrir lorsque vous pouvez les utiliser et lorsque les règles de
la possession vous empêchent de le faire.</p>
<!--
### Return Values and Scope
-->
<h3 id="les-valeurs-de-retour-et-les-portées"><a class="header" href="#les-valeurs-de-retour-et-les-portées">Les valeurs de retour et les portées</a></h3>
<!--
Returning values can also transfer ownership. Listing 4-4 is an example with
similar annotations to those in Listing 4-3.
-->
<p>Retourner des valeurs peut aussi transférer leur possession. L'encart 4-4 est un
exemple avec des annotations similaires à celles de l'encart 4-3 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("yours"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
  let s1 = donne_possession();     // donne_possession déplace sa valeur de
                                   // retour dans s1

  let s2 = String::from(&quot;hello&quot;);  // s2 rentre dans la portée

  let s3 = prend_et_rend(s2);      // s2 est déplacée dans
                                   // prend_et_rend, qui elle aussi
                                   // déplace sa valeur de retour dans s3.
} // Ici, s3 sort de la portée et est éliminée. s2 a été déplacée donc il ne se
  // passe rien. s1 sort aussi de la portée et est éliminée.

fn donne_possession() -&gt; String {      // donne_possession va déplacer sa
                                       // valeur de retour dans la
                                       // fonction qui l'appelle.

  let texte = String::from(&quot;yours&quot;);   // texte rentre dans la portée.

  texte                                // texte est retournée et
                                       // est déplacée vers le code qui
                                       // l'appelle.
}

// Cette fonction va prendre une String et en retourne aussi une.
fn prend_et_rend(texte: String) -&gt; String { // texte rentre dans la portée.

  texte  // texte est retournée et déplacée vers le code qui l'appelle.
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-4: Transferring ownership of return
values</span>
-->
<p><span class="caption">Encart 4-4 : Transferts de possession des valeurs de
retour</span></p>
<!--
The ownership of a variable follows the same pattern every time: assigning a
value to another variable moves it. When a variable that includes data on the
heap goes out of scope, the value will be cleaned up by `drop` unless the data
has been moved to be owned by another variable.
-->
<p>La possession d'une variable suit toujours le même schéma à chaque fois :
assigner une valeur à une autre variable la déplace. Quand une variable qui
contient des données sur le tas sort de la portée, la valeur sera nettoyée
avec <code>drop</code> à moins que la donnée ait été déplacée pour être possédée par une
autre variable.</p>
<!--
Taking ownership and then returning ownership with every function is a bit
tedious. What if we want to let a function use a value but not take ownership?
It’s quite annoying that anything we pass in also needs to be passed back if we
want to use it again, in addition to any data resulting from the body of the
function that we might want to return as well.
-->
<p>Il est un peu fastidieux de prendre la possession puis ensuite de retourner la
possession à chaque fonction. Et qu'est-ce qu'il se passe si nous voulons
qu'une fonction utilise une valeur, mais n'en prenne pas possession ? C'est
assez pénible que tout ce que nous passons doit être retourné si nous voulons
l'utiliser à nouveau, en plus de toutes les données qui découlent du corps
de la fonction que nous voulons aussi récupérer.</p>
<!--
It’s possible to return multiple values using a tuple, as shown in Listing 4-5.
-->
<p>Il est possible de retourner plusieurs valeurs à l'aide d'un tuple, comme ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, taille) = calculer_taille(s1);

    println!(&quot;La taille de '{}' est {}.&quot;, s2, taille);
}

fn calculer_taille(s: String) -&gt; (String, usize) {
    let taille = s.len(); // len() retourne la taille d'une String.

    (s, taille)
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-5: Returning ownership of parameters</span>
-->
<p><span class="caption">Encart 4-5 : Retourner la possession des paramètres</span></p>
<!--
But this is too much ceremony and a lot of work for a concept that should be
common. Luckily for us, Rust has a feature for this concept, called
*references*.
-->
<p>Mais c'est trop laborieux et beaucoup de travail pour un principe qui devrait
être banal. Heureusement pour nous, Rust a une fonctionnalité pour ce principe,
c'est ce qu'on appelle les <em>références</em>.</p>
<!-- markdownlint-disable -->
<!--
[data-types]: ch03-02-data-types.html#data-types
[derivable-traits]: appendix-03-derivable-traits.html
[method-syntax]: ch05-03-method-syntax.html#method-syntax
[paths-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
[drop]: ../std/ops/trait.Drop.html#tymethod.drop
-->
<!-- markdownlint-restore -->
<div style="break-before: page; page-break-before: always;"></div><!--
## References and Borrowing
-->
<h2 id="les-références-et-lemprunt"><a class="header" href="#les-références-et-lemprunt">Les références et l'emprunt</a></h2>
<!--
The issue with the tuple code in Listing 4-5 is that we have to return the
`String` to the calling function so we can still use the `String` after the
call to `calculate_length`, because the `String` was moved into
`calculate_length`.
-->
<p>La difficulté avec le code du tuple à la fin de la section précédente est que
nous avons besoin de retourner la <code>String</code> au code appelant pour qu'il puisse
continuer à utiliser la <code>String</code> après l'appel à <code>calculer_taille</code>, car la
<code>String</code> a été déplacée dans <code>calculer_taille</code>.</p>
<!--
Here is how you would define and use a `calculate_length` function that has a
reference to an object as a parameter instead of taking ownership of the
value:
-->
<p>Voici comment définir et utiliser une fonction <code>calculer_taille</code> qui prend une
<em>référence</em> à un objet en paramètre plutôt que de prendre possession de la
valeur :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let long = calculer_taille(&amp;s1);

    println!(&quot;La taille de '{}' est {}.&quot;, s1, long);
}

fn calculer_taille(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<!--
First, notice that all the tuple code in the variable declaration and the
function return value is gone. Second, note that we pass `&s1` into
`calculate_length` and, in its definition, we take `&String` rather than
`String`.
-->
<p>Premièrement, on peut observer que tout le code des <em>tuples</em> dans la déclaration
des variables et dans la valeur de retour de la fonction a été enlevé.
Deuxièmement, remarquez que nous passons <code>&amp;s1</code> à <code>calculer_taille</code>, et que dans
sa définition, nous utilisons <code>&amp;String</code> plutôt que <code>String</code>.</p>
<!--
These ampersands are *references*, and they allow you to refer to some value
without taking ownership of it. Figure 4-5 shows a diagram.
-->
<p>Ces esperluettes sont des <em>références</em>, et elles permettent de vous référer à
une valeur sans en prendre possession. L'illustration 4-5 nous montre cela dans
un schéma.</p>
<!-- markdownlint-disable -->
<!--
<img alt="&String s pointing at String s1" src="img/trpl04-05.svg" class="center" />
-->
<!-- markdownlint-restore -->
<p><img alt="&String s qui pointe vers la String s1" src="img/trpl04-05.svg"
class="center" /></p>
<!--
<span class="caption">Figure 4-5: A diagram of `&String s` pointing at `String
s1`</span>
-->
<p><span class="caption">Illustration 4-5 : Un schéma de la <code>&amp;String s</code> qui pointe
vers la <code>String s1</code></span></p>
<!--
> Note: The opposite of referencing by using `&` is *dereferencing*, which is
> accomplished with the dereference operator, `*`. We’ll see some uses of the
> dereference operator in Chapter 8 and discuss details of dereferencing in
> Chapter 15.
-->
<blockquote>
<p>Remarque : l'opposé de la création de références avec <code>&amp;</code> est le
<em>déréférencement</em>, qui s'effectue avec l'opérateur de déréférencement, <code>*</code>.
Nous allons voir quelques utilisations de l'opérateur de déréférencement dans
le chapitre 8 et nous aborderons les détails du déréférencement dans le
chapitre 15.</p>
</blockquote>
<!--
Let’s take a closer look at the function call here:
-->
<p>Regardons de plus près l'appel à la fonction :</p>
<!--
```rust
# fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);
# 
#     println!("The length of '{}' is {}.", s1, len);
# }
# 
# fn calculate_length(s: &String) -> usize {
#     s.len()
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);

    let long = calculer_taille(&amp;s1);
<span class="boring">
</span><span class="boring">    println!(&quot;La taille de '{}' est {}.&quot;, s1, long);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculer_taille(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}
</span></code></pre></pre>
<!--
The `&s1` syntax lets us create a reference that *refers* to the value of `s1`
but does not own it. Because it does not own it, the value it points to will
not be dropped when the reference stops being used.
-->
<p>La syntaxe <code>&amp;s1</code> nous permet de créer une référence qui se <em>réfère</em> à la valeur
de <code>s1</code> mais n'en prend pas possession. Et comme elle ne la possède pas, la
valeur vers laquelle elle pointe ne sera pas libérée quand cette référence
ne sera plus utilisée.</p>
<!--
Likewise, the signature of the function uses `&` to indicate that the type of
the parameter `s` is a reference. Let’s add some explanatory annotations:
-->
<p>De la même manière, la signature de la fonction utilise <code>&amp;</code> pour indiquer que
le type du paramètre <code>s</code> est une référence. Ajoutons quelques commentaires
explicatifs :</p>
<!--
```rust
# fn main() {
#     let s1 = String::from("hello");
# 
#     let len = calculate_length(&s1);
# 
#     println!("The length of '{}' is {}.", s1, len);
# }
# 
fn calculate_length(s: &String) -> usize { // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because it does not have ownership of what
  // it refers to, nothing happens.
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from(&quot;hello&quot;);
</span><span class="boring">
</span><span class="boring">    let long = calculer_taille(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!(&quot;La taille de '{}' est {}.&quot;, s1, long);
</span><span class="boring">}
</span><span class="boring">
</span>fn calculer_taille(s: &amp;String) -&gt; usize { // s est une référence à une String
  s.len()
} // Ici, s sort de la portée. Mais comme elle ne prend pas possession de ce
  // à quoi elle fait référence, il ne se passe rien.
</code></pre></pre>
<!--
The scope in which the variable `s` is valid is the same as any function
parameter’s scope, but we don’t drop what the reference points to when `s`
stops being used because we don’t have ownership. When functions have
references as parameters instead of the actual values, we won’t need to return
the values in order to give back ownership, because we never had ownership.
-->
<p>La portée dans laquelle la variable <code>s</code> est en vigueur est la même que toute
portée d'un paramètre de fonction, mais nous ne libérons pas ce sur quoi cette
référence pointe quand <code>s</code> n'est plus utilisé, car nous n'en prenons pas
possession. Lorsque les fonctions ont des références en paramètres au lieu des
valeurs réelles, nous n'avons pas besoin de retourner les valeurs pour les
rendre, car nous n'en avons jamais pris possession.</p>
<!--
We call the action of creating a reference *borrowing*. As in real life, if a
person owns something, you can borrow it from them. When you’re done, you have
to give it back.
-->
<p>Nous appelons <em>l'emprunt</em> l'action de créer une référence. Comme dans la vie
réelle, quand un objet appartient à quelqu'un, vous pouvez le lui emprunter. Et
quand vous avez fini, vous devez le lui rendre.</p>
<!--
So what happens if we try to modify something we’re borrowing? Try the code in
Listing 4-6. Spoiler alert: it doesn’t work!
-->
<p>Donc qu'est-ce qui se passe si nous essayons de modifier quelque chose que nous
empruntons ? Essayez le code dans l'encart 4-6. Attention, spoiler : cela ne
fonctionne pas !</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from(&quot;hello&quot;);

    changer(&amp;s);
}

fn changer(texte: &amp;String) {
    texte.push_str(&quot;, world&quot;);
}
</code></pre>
<!--
<span class="caption">Listing 4-6: Attempting to modify a borrowed value</span>
-->
<p><span class="caption">Entrée 4-6 : Tentative de modification d'une valeur
empruntée.</span></p>
<!--
Here’s the error:
-->
<p>Voici l'erreur :</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference
 -- > src/main.rs:8:5
  |
7 | fn change(some_string: &String) {
  |                        ------- help: consider changing this to be a mutable reference: `&mut String`
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*texte` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn changer(texte: &amp;String) {
  |                   ------- help: consider changing this to be a mutable reference: `&amp;mut String`
8 |     texte.push_str(&quot;, world&quot;);
  |     ^^^^^ `texte` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
Just as variables are immutable by default, so are references. We’re not
allowed to modify something we have a reference to.
-->
<p>Comme les variables sont immuables par défaut, les références le sont aussi.
Nous ne sommes pas autorisés à modifier une chose quand nous avons une référence
vers elle.</p>
<!--
### Mutable References
-->
<h3 id="les-références-mutables"><a class="header" href="#les-références-mutables">Les références mutables</a></h3>
<!--
We can fix the error in the code from Listing 4-6 with just a few small tweaks:
-->
<p>Nous pouvons résoudre l'erreur du code de l'encart 4-6 avec quelques petite
modification :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    changer(&amp;mut s);
}

fn changer(texte: &amp;mut String) {
    texte.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<!--
First, we had to change `s` to be `mut`. Then we had to create a mutable
reference with `&mut s` where we call the `change` function, and update the
function signature to accept a mutable reference with `some_string: &mut
String`. This makes it very clear that the `change` function will mutate the
value it borrows.
-->
<p>D'abord, nous avons dû préciser que <code>s</code> est <code>mut</code>. Ensuite, nous avons dû
créer une référence mutable avec <code>&amp;mut s</code> où nous appelons la fonction <code>change</code>
et nous avons modifié la signature pour accepter de prendre une référence
mutable avec <code>texte: &amp;mut String</code>. Cela précise clairement que la fonction
<code>change</code> va faire muter la valeur qu'elle emprunte.</p>
<!--
But mutable references have one big restriction: you can have only one mutable
reference to a particular piece of data at a time. This code will fail:
-->
<p>Mais les références mutables ont une grosse contrainte : vous ne pouvez avoir
qu'une seule référence mutable pour chaque donnée au même moment. Le code
suivant va échouer :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}
</span></code></pre>
<!--
Here’s the error:
-->
<p>Voici l'erreur :</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 -- > src/main.rs:5:14
  |
4 |     let r1 = &mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
This error says that this code is invalid because we cannot borrow `s` as
mutable more than once at a time. The first mutable borrow is in `r1` and must
last until it’s used in the `println!`, but between the creation of that
mutable reference and its usage, we tried to create another mutable reference
in `r2` that borrows the same data as `r1`.
-->
<p>Cette erreur nous explique que ce code est invalide car nous ne pouvons pas
emprunter <code>s</code> de manière mutable plus d'une fois au même moment. Le premier
emprunt mutable est dans <code>r1</code> et doit perdurer jusqu'à ce qu'il soit utilisé
dans le <code>println!</code>, mais pourtant entre la création de cette référence mutable
et son utilisation, nous avons essayé de créer une autre référence mutable dans
<code>r2</code> qui emprunte la même donnée que dans <code>r1</code>.</p>
<!--
The restriction preventing multiple mutable references to the same data at the
same time allows for mutation but in a very controlled fashion. It’s something
that new Rustaceans struggle with, because most languages let you mutate
whenever you’d like.
-->
<p>La limitation qui empêche d'avoir plusieurs références mutables vers la même
donnée au même moment autorise les mutations, mais de manière très contrôlée.
C'est quelque chose que les nouveaux Rustacés ont du mal à surmonter, car la
plupart des langages vous permettent de modifier les données quand vous le
voulez.</p>
<!--
The benefit of having this restriction is that Rust can prevent data races at
compile time. A *data race* is similar to a race condition and happens when
these three behaviors occur:
-->
<p>L'avantage d'avoir cette contrainte est que Rust peut empêcher les accès
concurrents au moment de la compilation. Un <em>accès concurrent</em> est une situation
de concurrence qui se produit lorsque ces trois facteurs se combinent :</p>
<!--
* Two or more pointers access the same data at the same time.
* At least one of the pointers is being used to write to the data.
* There’s no mechanism being used to synchronize access to the data.
-->
<ul>
<li>Deux pointeurs ou plus accèdent à la même donnée au même moment.</li>
<li>Au moins un des pointeurs est utilisé pour écrire dans cette donnée.</li>
<li>On n'utilise aucun mécanisme pour synchroniser l'accès aux données.</li>
</ul>
<!--
Data races cause undefined behavior and can be difficult to diagnose and fix
when you’re trying to track them down at runtime; Rust prevents this problem
from happening because it won’t even compile code with data races!
-->
<p>L'accès concurrent provoque des comportements indéfinis et rend difficile le
diagnostic et la résolution de problèmes lorsque vous essayez de les reproduire
au moment de l'exécution ; Rust évite ce problème parce qu'il ne va pas compiler
du code avec des accès concurrents !</p>
<!--
As always, we can use curly brackets to create a new scope, allowing for
multiple mutable references, just not *simultaneous* ones:
-->
<p>Comme d'habitude, nous pouvons utiliser des accolades pour créer une nouvelle
portée, pour nous permettre d'avoir plusieurs références mutables, mais pas
<em>en même temps</em> :</p>
<!--
```rust
# fn main() {
    let mut s = String::from("hello");

    {
        let r1 = &mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &mut s;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    {
        let r1 = &amp;mut s;
    } // r1 sort de la portée ici, donc nous pouvons créer une nouvelle référence
      // sans problèmes.

    let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<!--
A similar rule exists for combining mutable and immutable references. This code
results in an error:
-->
<p>Une règle similaire existe pour combiner les références immuables et mutables.
Ce code va mener à une erreur :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    let r3 = &mut s; // BIG PROBLEM

    println!("{}, {}, and {}", r1, r2, r3);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // sans problème
    let r2 = &amp;s; // sans problème
    let r3 = &amp;mut s; // GROS PROBLEME
    
    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
<span class="boring">}
</span></code></pre>
<!--
Here’s the error:
-->
<p>Voici l'erreur :</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 -- > src/main.rs:6:14
  |
4 |     let r1 = &s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &s; // no problem
6 |     let r3 = &mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 | 
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // sans problème
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // sans problème
6 |     let r3 = &amp;mut s; // GROS PROBLEME
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
Whew! We *also* cannot have a mutable reference while we have an immutable one.
Users of an immutable reference don’t expect the values to suddenly change out
from under them! However, multiple immutable references are okay because no one
who is just reading the data has the ability to affect anyone else’s reading of
the data.
-->
<p>Ouah ! Nous ne pouvons pas <em>non plus</em> avoir une référence mutable pendant que
nous en avons une autre immuable. Les utilisateurs d'une référence immuable ne
s'attendent pas à ce que sa valeur change soudainement ! Cependant,
l'utilisation de plusieurs références immuables ne pose pas de problème, car
simplement lire une donnée ne va pas affecter la lecture de la donnée par les
autres.</p>
<!--
Note that a reference’s scope starts from where it is introduced and continues
through the last time that reference is used. For instance, this code will
compile because the last usage of the immutable references, the `println!`,
occurs before the mutable reference is introduced:
-->
<p>Notez bien que la portée d'une référence commence dès qu'elle est introduite et
se poursuit jusqu'au dernier endroit où cette référence est utilisée. Par
exemple, le code suivant va se compiler car la dernière utilisation de la
référence immuable, le <code>println!</code>, est située avant l'introduction de la
référence mutable :</p>
<!--
```rust,edition2018
# fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    println!("{} and {}", r1, r2);
    // variables r1 and r2 will not be used after this point

    let r3 = &mut s; // no problem
    println!("{}", r3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // sans problème
    let r2 = &amp;s; // sans problème
    println!(&quot;{} et {}&quot;, r1, r2);
    //les variables r1 et r2 ne seront plus utilisés à partir d'ici
    
    let r3 = &amp;mut s; // sans problème
    println!(&quot;{}&quot;, r3);
<span class="boring">}
</span></code></pre></pre>
<!--
The scopes of the immutable references `r1` and `r2` end after the `println!`
where they are last used, which is before the mutable reference `r3` is
created. These scopes don’t overlap, so this code is allowed. The ability of
the compiler to tell that a reference is no longer being used at a point before
the end of the scope is called Non-Lexical Lifetimes (NLL for short), and you
can read more about it in [The Edition Guide][nll].
-->
<p>Les portées des références immuables <code>r1</code> et <code>r2</code> se terminent après le
<code>println!</code> où elles sont utilisées pour la dernière fois, c'est-à-dire avant que
la référence mutable <code>r3</code> soit créée. Ces portées ne se chevauchent pas, donc ce
code est autorisé. La capacité du compilateur à dire si une référence n'est plus
utilisée à un endroit avant la fin de la portée s'appelle en Anglais les
<em>Non-Lexical Lifetimes</em> (ou NLL), et vous pouvez en apprendre plus dans le
<a href="https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html">Guide de l'édition</a>.</p>
<!--
Even though borrowing errors may be frustrating at times, remember that it’s
the Rust compiler pointing out a potential bug early (at compile time rather
than at runtime) and showing you exactly where the problem is. Then you don’t
have to track down why your data isn’t what you thought it was.
-->
<p>Même si ces erreurs d'emprunt peuvent parfois être frustrantes, n'oubliez pas
que le compilateur de Rust nous signale un bogue potentiel en avance (au moment
de la compilation plutôt que l'exécution) et vous montre où se situe exactement
le problème. Ainsi, vous n'avez pas à chercher pourquoi vos données ne
correspondent pas à ce que vous pensiez qu'elles devraient être.</p>
<!--
### Dangling References
-->
<h3 id="les-références-pendouillantes"><a class="header" href="#les-références-pendouillantes">Les références pendouillantes</a></h3>
<!--
In languages with pointers, it’s easy to erroneously create a *dangling
pointer*, a pointer that references a location in memory that may have been
given to someone else, by freeing some memory while preserving a pointer to
that memory. In Rust, by contrast, the compiler guarantees that references will
never be dangling references: if you have a reference to some data, the
compiler will ensure that the data will not go out of scope before the
reference to the data does.
-->
<p>Avec les langages qui utilisent les pointeurs, il est facile de créer par erreur
un <em>pointeur pendouillant</em> (<em>dangling pointer</em>), qui est un pointeur qui pointe
vers un emplacement mémoire qui a été donné à quelqu'un d'autre, en libérant de
la mémoire tout en conservant un pointeur vers cette mémoire. En revanche, avec
Rust, le compilateur garantit que les références ne seront jamais des références
pendouillantes : si nous avons une référence vers une donnée, le compilateur va
s'assurer que cette donnée ne va pas sortir de la portée avant que la référence
vers cette donnée en soit elle-même sortie.</p>
<!--
Let’s try to create a dangling reference, which Rust will prevent with a
compile-time error:
-->
<p>Essayons de créer une référence pendouillante, ce que Rust va empêcher avec une
erreur au moment de la compilation :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_vers_rien = pendouille();
}

fn pendouille() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<!--
Here’s the error:
-->
<p>Voici l'erreur :</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 -- > src/main.rs:5:16
  |
5 | fn dangle() -> &String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -> &'static String {
  |                ^^^^^^^^

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn pendouille() -&gt; &amp;String {
  |                    ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn pendouille() -&gt; &amp;'static String {
  |                    ^^^^^^^^

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
This error message refers to a feature we haven’t covered yet: lifetimes. We’ll
discuss lifetimes in detail in Chapter 10. But, if you disregard the parts
about lifetimes, the message does contain the key to why this code is a problem:
-->
<p>Ce message d'erreur fait référence à une fonctionnalité que nous n'avons pas
encore vue : les <em>durées de vie</em>. Nous aborderons les durées de vie dans le
chapitre 10. Mais, si vous mettez de côté les parties qui parlent de durées de
vie, le message explique pourquoi le code pose problème :</p>
<!--
```text
this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
```
-->
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
</code></pre>
<p>Ce qui peut se traduire par :</p>
<pre><code class="language-text">Le type de retour de cette fonction contient une valeur empruntée, mais il n'y a
plus aucune valeur qui peut être empruntée.
</code></pre>
<!--
Let’s take a closer look at exactly what’s happening at each stage of our
`dangle` code:
-->
<p>Regardons de plus près ce qui se passe exactement à chaque étape de notre code
de <code>pendouille</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let reference_to_nothing = dangle();
# }
# 
fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_vers_rien = pendouille();
</span><span class="boring">}
</span><span class="boring">
</span>fn pendouille() -&gt; &amp;String { // pendouille retourne une référence vers une String

  let s = String::from(&quot;hello&quot;); // s est une nouvelle String

  &amp;s // nous retournons une référence vers la String, s
} // Ici, s sort de la portée, et est libéré. Sa mémoire disparaît.
  // Attention, danger !
</code></pre>
<!--
Because `s` is created inside `dangle`, when the code of `dangle` is finished,
`s` will be deallocated. But we tried to return a reference to it. That means
this reference would be pointing to an invalid `String`. That’s no good! Rust
won’t let us do this.
-->
<p>Comme <code>s</code> est créé dans <code>pendouille</code>, lorsque le code de <code>pendouille</code> est
terminé, la variable <code>s</code> sera désallouée. Mais nous avons essayé de retourner
une référence vers elle. Cela veut dire que cette référence va pointer vers une
<code>String</code> invalide. Ce n'est pas bon ! Rust ne nous laissera pas faire cela.</p>
<!--
The solution here is to return the `String` directly:
-->
<p>Ici la solution est de renvoyer la <code>String</code> directement :</p>
<!--
```rust
# fn main() {
#     let string = no_dangle();
# }
# 
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string = ne_pendouille_pas();
</span><span class="boring">}
</span><span class="boring">
</span>fn ne_pendouille_pas() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
</code></pre></pre>
<!--
This works without any problems. Ownership is moved out, and nothing is
deallocated.
-->
<p>Cela fonctionne sans problème. La possession est transférée à la valeur de
retour de la fonction, et rien n'est désalloué.</p>
<!--
### The Rules of References
-->
<h3 id="les-règles-de-référencement"><a class="header" href="#les-règles-de-référencement">Les règles de référencement</a></h3>
<!--
Let’s recap what we’ve discussed about references:
-->
<p>Récapitulons ce que nous avons vu à propos des références :</p>
<!--
* At any given time, you can have *either* one mutable reference *or* any
  number of immutable references.
* References must always be valid.
-->
<ul>
<li>À un instant donné, vous pouvez avoir <em>soit</em> une référence mutable, <em>soit</em> un
nombre quelconque de références immuables.</li>
<li>Les références doivent toujours être en vigueur.</li>
</ul>
<!--
Next, we’ll look at a different kind of reference: slices.
-->
<p>Ensuite, nous aborderons un autre type de référence : les <em>slices</em>.</p>
<!--
[nll]: https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## The Slice Type
-->
<h2 id="le-type-slice"><a class="header" href="#le-type-slice">Le type slice</a></h2>
<!--
Another data type that does not have ownership is the *slice*. Slices let you
reference a contiguous sequence of elements in a collection rather than the
whole collection.
-->
<p>Un autre type de donnée qui ne prend pas possession est la <em>slice</em>. Une slice
vous permet d'obtenir une référence vers une séquence continue d'éléments d'une
collection plutôt que toute la collection.</p>
<!--
Here’s a small programming problem: write a function that takes a string and
returns the first word it finds in that string. If the function doesn’t find a
space in the string, the whole string must be one word, so the entire string
should be returned.
-->
<p>Voici un petit problème de programmation : écrire une fonction qui prend une
chaîne de caractères et retourne le premier mot qu'elle trouve dans cette
chaîne. Si la fonction ne trouve pas d'espace dans la chaîne, cela veut dire
que la chaîne est en un seul mot, donc la chaîne en entier doit être retournée.</p>
<!--
Let’s think about the signature of this function:
-->
<p>Imaginons la signature de cette fonction :</p>
<!--
```rust,ignore
fn first_word(s: &String) -> ?
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;String) -&gt; ?
</code></pre>
<!--
This function, `first_word`, has a `&String` as a parameter. We don’t want
ownership, so this is fine. But what should we return? We don’t really have a
way to talk about *part* of a string. However, we could return the index of the
end of the word. Let’s try that, as shown in Listing 4-7.
-->
<p>Cette fonction, <code>premier_mot</code>, prend un <code>&amp;String</code> comme paramètre. Nous ne
voulons pas en prendre possession, donc c'est ce qu'il nous faut. Mais que
devons-nous retourner ? Nous n'avons aucun moyen de désigner une <em>partie</em>
d'une chaîne de caractères. Cependant, nous pouvons retourner l'indice de la
fin du mot. Essayons cela, dans l'encart 4-7 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn premier_mot(s: &amp;String) -&gt; usize {
    let octets = s.as_bytes();

    for (i, &amp;element) in octets.iter().enumerate() {
        if element == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-7: The `first_word` function that returns a
byte index value into the `String` parameter</span>
-->
<p><span class="caption">Encart 4-7 : La fonction <code>premier_mot</code> qui retourne
l'indice d'un octet provenant du paramètre <code>String</code></span></p>
<!--
Because we need to go through the `String` element by element and check whether
a value is a space, we’ll convert our `String` to an array of bytes using the
`as_bytes` method:
-->
<p>Comme nous avons besoin de parcourir la <code>String</code> élément par élément et de
vérifier si la valeur est une espace, nous convertissons notre <code>String</code> en un
tableau d'octets en utilisant la méthode <code>as_bytes</code> :</p>
<!--
```rust,ignore
# fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
# 
#     s.len()
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span>    let octets = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
Next, we create an iterator over the array of bytes using the `iter` method:
-->
<p>Ensuite, nous créons un itérateur sur le tableau d'octets en utilisant la
méthode <code>iter</code> :</p>
<!--
```rust,ignore
# fn first_word(s: &String) -> usize {
#     let bytes = s.as_bytes();
# 
    for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
# 
#     s.len()
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;element) in octets.iter().enumerate() {
<span class="boring">        if element == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
We’ll discuss iterators in more detail in Chapter 13. For now, know that `iter`
is a method that returns each element in a collection and that `enumerate`
wraps the result of `iter` and returns each element as part of a tuple instead.
The first element of the tuple returned from `enumerate` is the index, and the
second element is a reference to the element. This is a bit more convenient
than calculating the index ourselves.
-->
<p>Nous aborderons plus en détail les itérateurs dans le chapitre 13. Pour le
moment, sachez que <code>iter</code> est une méthode qui retourne chaque élément d'une
collection, et que <code>enumerate</code> transforme le résultat de <code>iter</code> pour retourner
plutôt chaque élément comme un tuple. Le premier élément du tuple retourné par
<code>enumerate</code> est l'indice, et le second élément est une référence vers l'élément.
C'est un peu plus pratique que de calculer les indices par nous-mêmes.</p>
<!--
Because the `enumerate` method returns a tuple, we can use patterns to
destructure that tuple. We’ll be discussing patterns more in Chapter 6. So in
the `for` loop, we specify a pattern that has `i` for the index in the tuple
and `&item` for the single byte in the tuple. Because we get a reference to the
element from `.iter().enumerate()`, we use `&` in the pattern.
-->
<p>Comme la méthode <code>enumerate</code> retourne un tuple, nous pouvons utiliser des
motifs pour déstructurer ce tuple. Nous verrons les motifs au chapitre 6. Donc
dans la boucle <code>for</code>, nous précisons un motif qui indique que nous définissons
<code>i</code> pour l'indice au sein du tuple et <code>&amp;element</code> pour l'octet dans le tuple.
Comme nous obtenons une référence vers l'élément avec <code>.iter().enumerate()</code>,
nous utilisons <code>&amp;</code> dans le motif.</p>
<!--
Inside the `for` loop, we search for the byte that represents the space by
using the byte literal syntax. If we find a space, we return the position.
Otherwise, we return the length of the string by using `s.len()`:
-->
<p>Au sein de la boucle <code>for</code>, nous recherchons l'octet qui représente l'espace en
utilisant la syntaxe de littéral d'octet. Si nous trouvons une espace, nous
retournons sa position. Sinon, nous retournons la taille de la chaîne en
utilisant <code>s.len()</code> :</p>
<!--
```rust,ignore
# fn first_word(s: &String) -> usize {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span>        if element == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
We now have a way to find out the index of the end of the first word in the
string, but there’s a problem. We’re returning a `usize` on its own, but it’s
only a meaningful number in the context of the `&String`. In other words,
because it’s a separate value from the `String`, there’s no guarantee that it
will still be valid in the future. Consider the program in Listing 4-8 that
uses the `first_word` function from Listing 4-7.
-->
<p>Nous avons maintenant une façon de trouver l'indice de la fin du premier mot
dans la chaîne de caractères, mais il y a un problème. Nous retournons un
<code>usize</code> tout seul, mais il n'a du sens que lorsqu'il est lié au <code>&amp;String</code>.
Autrement dit, comme il a une valeur séparée de la <code>String</code>, il n'y a pas de
garantie qu'il restera toujours valide dans le futur. Imaginons le programme
dans l'encart 4-8 qui utilise la fonction <code>premier_mot</code> de l'encart 4-7 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# fn first_word(s: &String) -> usize {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
# 
#     s.len()
# }
# 
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""

    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let mot = premier_mot(&amp;s); // la variable mot aura 5 comme valeur.

    s.clear(); // ceci vide la String, elle vaut maintenant &quot;&quot;.

    // mot a toujours la valeur 5 ici, mais il n'y a plus de chaîne qui donne
    // du sens à la valeur 5. mot est maintenant complètement invalide !
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-8: Storing the result from calling the
`first_word` function and then changing the `String` contents</span>
-->
<p><span class="caption">Encart 4-8 : On stocke le résultat de l'appel à la
fonction <code>premier_mot</code> et ensuite on change le contenu de la <code>String</code></span></p>
<!--
This program compiles without any errors and would also do so if we used `word`
after calling `s.clear()`. Because `word` isn’t connected to the state of `s`
at all, `word` still contains the value `5`. We could use that value `5` with
the variable `s` to try to extract the first word out, but this would be a bug
because the contents of `s` have changed since we saved `5` in `word`.
-->
<p>Ce programme se compile sans aucune erreur et le ferait toujours si nous
utilisions <code>mot</code> après avoir appelé <code>s.clear()</code>. Comme <code>mot</code> n'est pas du tout
lié à <code>s</code>, <code>mot</code> contient toujours la valeur <code>5</code>. Nous pourrions utiliser cette
valeur <code>5</code> avec la variable <code>s</code> pour essayer d'en extraire le premier mot, mais
cela serait un bogue, car le contenu de <code>s</code> a changé depuis que nous avons
enregistré <code>5</code> dans <code>mot</code>.</p>
<!--
Having to worry about the index in `word` getting out of sync with the data in
`s` is tedious and error prone! Managing these indices is even more brittle if
we write a `second_word` function. Its signature would have to look like this:
-->
<p>Se préoccuper en permanence que l'indice présent dans <code>mot</code> ne soit plus
synchronisé avec les données présentes dans <code>s</code> est fastidieux et source
d'erreur ! La gestion de ces indices est encore plus risquée si nous écrivons
une fonction <code>second_mot</code>. Sa signature ressemblerait à ceci :</p>
<!--
```rust,ignore
fn second_word(s: &String) -> (usize, usize) {
```
-->
<pre><code class="language-rust ignore">fn second_mot(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<!--
Now we’re tracking a starting *and* an ending index, and we have even more
values that were calculated from data in a particular state but aren’t tied to
that state at all. We now have three unrelated variables floating around that
need to be kept in sync.
-->
<p>Maintenant, nous avons un indice de début <em>et</em> un indice de fin, donc nous avons
encore plus de valeurs qui sont calculées à partir d'une donnée dans un état
donné, mais qui ne sont pas liées du tout à l'état de cette donnée. Nous avons
maintenant trois variables isolées qui ont besoin d'être maintenues à jour.</p>
<!--
Luckily, Rust has a solution to this problem: string slices.
-->
<p>Heureusement, Rust a une solution pour ce problème : les <em>slices</em> de chaînes de
caractères.</p>
<!--
### String Slices
-->
<h3 id="les-slices-de-chaînes-de-caractères"><a class="header" href="#les-slices-de-chaînes-de-caractères">Les slices de chaînes de caractères</a></h3>
<!--
A *string slice* is a reference to part of a `String`, and it looks like this:
-->
<p>Une <em>slice de chaîne de caractères</em> (ou <em>slice de chaîne</em>) est une référence à
une partie d'une <code>String</code>, et ressemble à ceci :</p>
<!--
```rust
# fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello world&quot;);

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<!--
This is similar to taking a reference to the whole `String` but with the extra
`[0..5]` bit. Rather than a reference to the entire `String`, it’s a reference
to a portion of the `String`.
-->
<p>Cela ressemble à une référence pour toute la <code>String</code>, mais avec la partie
<code>[0..5]</code> en plus. Plutôt que d'être une référence vers toute la <code>String</code>, c'est
une référence vers une partie de la <code>String</code>.</p>
<!--
We can create slices using a range within brackets by specifying
`[starting_index..ending_index]`, where `starting_index` is the first position
in the slice and `ending_index` is one more than the last position in the
slice. Internally, the slice data structure stores the starting position and
the length of the slice, which corresponds to `ending_index` minus
`starting_index`. So in the case of `let world = &s[6..11];`, `world` would be
a slice that contains a pointer to the byte at index 6 of `s` with a length
value of 5.
-->
<p>Nous pouvons créer des slices en utilisant un intervalle entre crochets en
spécifiant <code>[indice_debut..indice_fin]</code>, où <code>indice_debut</code> est la position du
premier octet de la slice et <code>indice_fin</code> est la position juste après le dernier
octet de la slice. En interne, la structure de données de la slice stocke la
position de départ et la longueur de la slice, ce qui correspond à <code>indice_fin</code>
moins <code>indice_debut</code>. Donc dans le cas de <code>let world = &amp;s[6..11];</code>, <code>world</code> est
une slice qui contient un pointeur vers le sixième octet de <code>s</code> et une longueur
de 5.</p>
<!--
Figure 4-6 shows this in a diagram.
-->
<p>L'illustration 4-6 montre ceci dans un schéma.</p>
<!-- markdownlint-disable -->
<!--
<img alt="world containing a pointer to the byte at index 6 of String s and a length 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="world contient un pointeur vers l'octet d'indice 6 de la String s et
une longueur de 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-6: String slice referring to part of a
`String`</span>
-->
<p><span class="caption">Illustration 4-6 : Une slice de chaîne qui pointe vers
une partie d'une <code>String</code></span></p>
<!--
With Rust’s `..` range syntax, if you want to start at index zero, you can drop
the value before the two periods. In other words, these are equal:
-->
<p>Avec la syntaxe d'intervalle <code>..</code> de Rust, si vous voulez commencer à l'indice
zéro, vous pouvez ne rien mettre avant les deux points. Autrement dit, ces deux
cas sont identiques :</p>
<!--
```rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<!--
By the same token, if your slice includes the last byte of the `String`, you
can drop the trailing number. That means these are equal:
-->
<p>De la même manière, si votre slice contient le dernier octet de la <code>String</code>,
vous pouvez ne rien mettre à la fin. Cela veut dire que ces deux cas sont
identiques :</p>
<!--
```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let taille = s.len();

let slice = &amp;s[3..taille];
let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<!--
You can also drop both values to take a slice of the entire string. So these
are equal:
-->
<p>Vous pouvez aussi ne mettre aucune limite pour créer une slice de toute la
chaîne de caractères. Ces deux cas sont donc identiques :</p>
<!--
```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let taille = s.len();

let slice = &amp;s[0..taille];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<!--
> Note: String slice range indices must occur at valid UTF-8 character
> boundaries. If you attempt to create a string slice in the middle of a
> multibyte character, your program will exit with an error. For the purposes
> of introducing string slices, we are assuming ASCII only in this section; a
> more thorough discussion of UTF-8 handling is in the [“Storing UTF-8 Encoded
> Text with Strings”][strings]<!-- ignore -- > section of Chapter 8.
-->
<blockquote>
<p>Remarque : Les indices de l'intervalle d'une slice de chaîne doivent toujours
se trouver dans les zones acceptables de séparation des caractères encodés en
UTF-8. Si vous essayez de créer une slice de chaîne qui s'arrête au milieu
d'un caractère encodé sur plusieurs octets, votre programme va se fermer avec
une erreur. Afin de simplifier l'explication des slices de chaînes, nous
utiliserons uniquement l'ASCII dans cette section ; nous verrons la gestion
d'UTF-8 dans la section <a href="ch08-02-strings.html">“Stocker du texte encodé en UTF-8 avec les chaînes de
caractères”</a><!-- ignore --> du chapitre 8.</p>
</blockquote>
<!--
With all this information in mind, let’s rewrite `first_word` to return a
slice. The type that signifies “string slice” is written as `&str`:
-->
<p>Maintenant que nous savons tout cela, essayons de réécrire <code>premier_mot</code> pour
qu'il retourne une slice. Le type pour les slices de chaînes de caractères
s'écrit <code>&amp;str</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn premier_mot(s: &amp;String) -&gt; &amp;str {
    let octets = s.as_bytes();

    for (i, &amp;element) in octets.iter().enumerate() {
        if element == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
We get the index for the end of the word in the same way as we did in Listing
4-7, by looking for the first occurrence of a space. When we find a space, we
return a string slice using the start of the string and the index of the space
as the starting and ending indices.
-->
<p>Nous récupérons l'indice de la fin du mot de la même façon que nous l'avions
fait dans l'encart 4-7, en cherchant la première occurrence d'une espace.
Lorsque nous trouvons une espace, nous retournons une slice de chaîne en
utilisant le début de la chaîne de caractères et l'indice de l'espace comme
indices de début et de fin respectivement.</p>
<!--
Now when we call `first_word`, we get back a single value that is tied to the
underlying data. The value is made up of a reference to the starting point of
the slice and the number of elements in the slice.
-->
<p>Désormais, quand nous appelons <code>premier_mot</code>, nous récupérons une unique valeur
qui est liée à la donnée de base. La valeur se compose d'une référence vers le
point de départ de la slice et du nombre d'éléments dans la slice.</p>
<!--
Returning a slice would also work for a `second_word` function:
-->
<p>Retourner une slice fonctionnerait aussi pour une fonction <code>second_mot</code> :</p>
<!--
```rust,ignore
fn second_word(s: &String) -> &str {
```
-->
<pre><code class="language-rust ignore">fn second_mot(s: &amp;String) -&gt; &amp;str {
</code></pre>
<!--
We now have a straightforward API that’s much harder to mess up, because the
compiler will ensure the references into the `String` remain valid. Remember
the bug in the program in Listing 4-8, when we got the index to the end of the
first word but then cleared the string so our index was invalid? That code was
logically incorrect but didn’t show any immediate errors. The problems would
show up later if we kept trying to use the first word index with an emptied
string. Slices make this bug impossible and let us know we have a problem with
our code much sooner. Using the slice version of `first_word` will throw a
compile-time error:
-->
<p>Nous avons maintenant une API simple qui est bien plus difficile à mal utiliser,
puisque le compilateur va s'assurer que les références dans la <code>String</code> seront
toujours en vigueur. Vous souvenez-vous du bogue du programme de l'encart 4-8,
lorsque nous avions un indice vers la fin du premier mot mais qu'ensuite nous
avions vidé la chaîne de caractères et que notre indice n'était plus valide ? Ce
code était logiquement incorrect, mais ne montrait pas immédiatement une erreur.
Les problèmes apparaîtront plus tard si nous essayons d'utiliser l'indice du
premier mot avec une chaîne de caractères qui a été vidée. Les slices rendent ce
bogue impossible et nous signalent bien plus tôt que nous avons un problème avec
notre code. Utiliser la version avec la slice de <code>premier_mot</code> va causer une
erreur de compilation :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn first_word(s: &String) -> &str {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &s[0..i];
#         }
#     }
# 
#     &s[..]
# }
# 
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {}", word);
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn premier_mot(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let mot = premier_mot(&amp;s);

    s.clear(); // Erreur !

    println!(&quot;Le premier mot est : {}&quot;, mot);
}
</code></pre>
<!--
Here’s the compiler error:
-->
<p>Voici l'erreur du compilateur :</p>
<!--
```console
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  -- > src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let mot = premier_mot(&amp;s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // Erreur !
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!(&quot;Le premier mot est : {}&quot;, mot);
   |                                         --- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<!--
Recall from the borrowing rules that if we have an immutable reference to
something, we cannot also take a mutable reference. Because `clear` needs to
truncate the `String`, it needs to get a mutable reference. The `println!`
after the call to `clear` uses the reference in `word`, so the immutable
reference must still be active at that point. Rust disallows the mutable
reference in `clear` and the immutable reference in `word` from existing at the
same time, and compilation fails. Not only has Rust made our API easier to use,
but it has also eliminated an entire class of errors at compile time!
-->
<p>Rappelons-nous que d'après les règles d'emprunt, si nous avons une référence
immuable vers quelque chose, nous ne pouvons pas avoir une référence mutable
en même temps. Étant donné que <code>clear</code> a besoin de modifier la <code>String</code>, il a
besoin d'une référence mutable. Le <code>println!</code> qui a lieu après l'appel à <code>clear</code>
utilise la référence à <code>mot</code>, donc la référence immuable sera toujours en
vigueur à cet endroit. Rust interdit la référence mutable dans <code>clear</code> et la
référence immuable pour <code>mot</code> au même moment, et la compilation échoue. Non
seulement Rust a simplifié l'utilisation de notre API, mais il a
aussi éliminé une catégorie entière d'erreurs au moment de la compilation !</p>
<!--
#### String Literals Are Slices
-->
<h4 id="les-littéraux-de-chaîne-de-caractères-sont-aussi-des-slices"><a class="header" href="#les-littéraux-de-chaîne-de-caractères-sont-aussi-des-slices">Les littéraux de chaîne de caractères sont aussi des slices</a></h4>
<!--
Recall that we talked about string literals being stored inside the binary. Now
that we know about slices, we can properly understand string literals:
-->
<p>Rappelez-vous lorsque nous avons appris que les littéraux de chaîne de
caractères étaient enregistrés dans le binaire. Maintenant que nous connaissons
les slices, nous pouvons désormais comprendre les littéraux de chaîne.</p>
<!--
```rust
let s = "Hello, world!";
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The type of `s` here is `&str`: it’s a slice pointing to that specific point of
the binary. This is also why string literals are immutable; `&str` is an
immutable reference.
-->
<p>Ici, le type de <code>s</code> est un <code>&amp;str</code> : c'est une slice qui pointe vers un endroit
précis du binaire. C'est aussi la raison pour laquelle les littéraux de chaîne
sont immuables ; <code>&amp;str</code> est une référence immuable.</p>
<!--
#### String Slices as Parameters
-->
<h4 id="les-slices-de-chaînes-de-caractères-en-paramètres"><a class="header" href="#les-slices-de-chaînes-de-caractères-en-paramètres">Les slices de chaînes de caractères en paramètres</a></h4>
<!--
Knowing that you can take slices of literals and `String` values leads us to
one more improvement on `first_word`, and that’s its signature:
-->
<p>Savoir que l'on peut utiliser des slices de littéraux et de <code>String</code> nous incite
à apporter une petite amélioration à <code>premier_mot</code>, dont voici la signature :</p>
<!--
```rust,ignore
fn first_word(s: &String) -> &str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;String) -&gt; &amp;str {
</code></pre>
<!--
A more experienced Rustacean would write the signature shown in Listing 4-9
instead because it allows us to use the same function on both `&String` values
and `&str` values.
-->
<p>Un Rustacé plus expérimenté écrirait plutôt la signature de l'encart 4-9, car
cela nous permet d'utiliser la même fonction sur les <code>&amp;String</code> et aussi les
<code>&amp;str</code> :</p>
<!--
```rust,ignore
fn first_word(s: &str) -> &str {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &s[0..i];
#         }
#     }
# 
#     &s[..]
# }
# 
# fn main() {
#     let my_string = String::from("hello world");
# 
#     // `first_word` works on slices of `String`s, whether partial or whole
#     let word = first_word(&my_string[0..6]);
#     let word = first_word(&my_string[..]);
#     // `first_word` also works on references to `String`s, which are equivalent
#     // to whole slices of `String`s
#     let word = first_word(&my_string);
# 
#     let my_string_literal = "hello world";
# 
#     // `first_word` works on slices of string literals, whether partial or whole
#     let word = first_word(&my_string_literal[0..6]);
#     let word = first_word(&my_string_literal[..]);
# 
#     // Because string literals *are* string slices already,
#     // this works too, without the slice syntax!
#     let word = first_word(my_string_literal);
# }
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ma_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // `premier_mot` fonctionne avec les slices de `String`, que ce soit sur
</span><span class="boring">    // une partie ou sur sur son intégralité
</span><span class="boring">    let mot = premier_mot(&amp;ma_string[0..6]);
</span><span class="boring">    let mot = premier_mot(&amp;ma_string[..]);
</span><span class="boring">
</span><span class="boring">    // `premier_mot` fonctionne également sur des références vers des `String`,
</span><span class="boring">    // qui sont équivalentes à des slices de toute la `String`
</span><span class="boring">    let mot = premier_mot(&amp;ma_string);
</span><span class="boring">
</span><span class="boring">    let mon_litteral_de_chaine = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // `premier_mot` fonctionne avec les slices de littéraux de chaîne, qu'elles
</span><span class="boring">    // soient partielles ou intégrales
</span><span class="boring">    let mot = premier_mot(&amp;mon_litteral_de_chaine[0..6]);
</span><span class="boring">    let mot = premier_mot(&amp;mon_litteral_de_chaine[..]);
</span><span class="boring">
</span><span class="boring">    // Comme les littéraux de chaîne *sont* déjà des slices de chaînes,
</span><span class="boring">    // cela fonctionne aussi, sans la syntaxe de slice !
</span><span class="boring">    let mot = premier_mot(mon_litteral_de_chaine);
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 4-9: Improving the `first_word` function by using
a string slice for the type of the `s` parameter</span>
-->
<p><span class="caption">Encart 4-9 : Amélioration de la fonction <code>premier_mot</code> en
utilisant une slice de chaîne de caractères comme type du paramètre <code>s</code></span></p>
<!--
If we have a string slice, we can pass that directly. If we have a `String`, we
can pass a slice of the `String` or a reference to the `String`. This
flexibility takes advantage of *deref coercions*, a feature we will cover in
the [“Implicit Deref Coercions with Functions and
Methods”][deref-coercions]<!--ignore-- > section of Chapter 15. Defining a
function to take a string slice instead of a reference to a `String` makes our
API more general and useful without losing any functionality:
-->
<p>Si nous avons une slice de chaîne, nous pouvons la passer en argument
directement. Si nous avons une <code>String</code>, nous pouvons envoyer une référence ou
une slice de la <code>String</code>. Cette flexibilité nous est offerte par
l'<em>extrapolation de déréferencement</em>, une fonctionnalité que nous allons
découvrir dans <a href="ch15-02-deref.html">une section du Chapitre 15</a><!--ignore-->.
Définir une fonction qui prend une slice de chaîne plutôt qu'une référence à
une <code>String</code> rend notre API plus générique et plus utile sans perdre aucune
fonctionnalité :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# fn first_word(s: &str) -> &str {
#     let bytes = s.as_bytes();
# 
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &s[0..i];
#         }
#     }
# 
#     &s[..]
# }
# 
fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn premier_mot(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let ma_string = String::from(&quot;hello world&quot;);

    // `premier_mot` fonctionne avec les slices de `String`, que ce soit sur
    // une partie ou sur sur son intégralité
    let mot = premier_mot(&amp;ma_string[0..6]);
    let mot = premier_mot(&amp;ma_string[..]);

    // `premier_mot` fonctionne également sur des références vers des `String`,
    // qui sont équivalentes à des slices de toute la `String`
    let mot = premier_mot(&amp;ma_string);

    let mon_litteral_de_chaine = &quot;hello world&quot;;

    // `premier_mot` fonctionne avec les slices de littéraux de chaîne, qu'elles
    // soient partielles ou intégrales
    let mot = premier_mot(&amp;mon_litteral_de_chaine[0..6]);
    let mot = premier_mot(&amp;mon_litteral_de_chaine[..]);

    // Comme les littéraux de chaîne *sont* déjà des slices de chaînes,
    // cela fonctionne aussi, sans la syntaxe de slice !
    let mot = premier_mot(mon_litteral_de_chaine);
}
</code></pre></pre>
<!--
### Other Slices
-->
<h3 id="les-autres-slices"><a class="header" href="#les-autres-slices">Les autres slices</a></h3>
<!--
String slices, as you might imagine, are specific to strings. But there’s a
more general slice type, too. Consider this array:
-->
<p>Les slices de chaînes de caractères, comme vous pouvez l'imaginer, sont
spécifiques aux chaînes de caractères. Mais il existe aussi un type de slice
plus générique. Imaginons ce tableau de données :</p>
<!--
```rust
let a = [1, 2, 3, 4, 5];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<!--
Just as we might want to refer to a part of a string, we might want to refer
to part of an array. We’d do so like this:
-->
<p>Tout comme nous pouvons nous référer à une partie d'une chaîne de caractères,
nous pouvons nous référer à une partie d'un tableau. Nous pouvons le faire comme
ceci :</p>
<!--
```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}
</span></code></pre></pre>
<!--
This slice has the type `&[i32]`. It works the same way as string slices do, by
storing a reference to the first element and a length. You’ll use this kind of
slice for all sorts of other collections. We’ll discuss these collections in
detail when we talk about vectors in Chapter 8.
-->
<p>Cette slice est de type <code>&amp;[i32]</code>. Elle fonctionne de la même manière que les
slices de chaînes de caractères, en enregistrant une référence vers le premier
élément et une longueur. Vous utiliserez ce type de slice pour tous les autres
types de collections. Nous aborderons ces collections en détail quand nous
verrons les vecteurs au chapitre 8.</p>
<!--
## Summary
-->
<h2 id="résumé-3"><a class="header" href="#résumé-3">Résumé</a></h2>
<!--
The concepts of ownership, borrowing, and slices ensure memory safety in Rust
programs at compile time. The Rust language gives you control over your memory
usage in the same way as other systems programming languages, but having the
owner of data automatically clean up that data when the owner goes out of scope
means you don’t have to write and debug extra code to get this control.
-->
<p>Les concepts de possession, d'emprunt et de slices garantissent la sécurité de
la mémoire dans les programmes Rust au moment de la compilation. Le langage Rust
vous donne le contrôle sur l'utilisation de la mémoire comme tous les autres
langages de programmation système, mais le fait que celui qui possède des
données nettoie automatiquement ces données quand il sort de la portée vous
permet de ne pas avoir à écrire et déboguer du code en plus pour avoir cette
fonctionnalité.</p>
<!--
Ownership affects how lots of other parts of Rust work, so we’ll talk about
these concepts further throughout the rest of the book. Let’s move on to
Chapter 5 and look at grouping pieces of data together in a `struct`.
-->
<p>La possession influe sur de nombreuses autres fonctionnalités de Rust, c'est
pourquoi nous allons encore parler de ces concepts plus loin dans le livre.
Passons maintenant au chapitre 5 et découvrons comment regrouper des données
ensemble dans une <code>struct</code>.</p>
<!--
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[deref-coercions]: ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods
-->
<div style="break-before: page; page-break-before: always;"></div><!-- # Using Structs to Structure Related Data -->
<h1 id="utiliser-les-structures-pour-structurer-des-données-apparentées"><a class="header" href="#utiliser-les-structures-pour-structurer-des-données-apparentées">Utiliser les structures pour structurer des données apparentées</a></h1>
<!--
A *struct*, or *structure*, is a custom data type that lets you name and
package together multiple related values that make up a meaningful group. If
you’re familiar with an object-oriented language, a *struct* is like an
object’s data attributes. In this chapter, we’ll compare and contrast tuples
with structs. We’ll demonstrate how to define and instantiate structs. We’ll
discuss how to define associated functions, especially the kind of associated
functions called *methods*, to specify behavior associated with a struct type.
Structs and enums (discussed in Chapter 6) are the building blocks for creating
new types in your program’s domain to take full advantage of Rust’s compile
time type checking.
-->
<p>Une <em>struct</em>, ou <em>structure</em>, est un type de données personnalisé qui vous
permet de nommer et de rassembler plusieurs valeurs associées qui forment
un groupe cohérent.
Si vous êtes familier avec un langage orienté objet, une structure est en
quelque sorte l'ensemble des attributs d'un objet.
Dans ce chapitre, nous comparerons les tuples avec les structures. Nous verrons
comment définir les fonctions associées, en particulier le type de fonctions
associées que l'on appelle les <em>méthodes</em>, dans le but d'implémenter un
comportement associé au type d'une structure.
Les structures et les énumérations (traitées au chapitre 6) sont les fondements
de la création de nouveaux types au sein de votre programme pour tirer
pleinement parti des vérifications de types effectuées par Rust à la
compilation.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Defining and Instantiating Structs
-->
<h2 id="définir-et-instancier-des-structures"><a class="header" href="#définir-et-instancier-des-structures">Définir et instancier des structures</a></h2>
<!--
Structs are similar to tuples, which were discussed in [“The Tuple
Type”][tuples]<!-- ignore -- > section. Like tuples, the pieces of a struct can
be different types. Unlike with tuples, you’ll name each piece of data so it’s
clear what the values mean. As a result of these names, structs are more
flexible than tuples: you don’t have to rely on the order of the data to
specify or access the values of an instance.
-->
<p>Les structures sont similaires aux tuples, qu'on a vus dans <a href="ch03-02-data-types.html">une section du
chapitre 3</a><!-- ignore -->. Comme pour
les tuples, les éléments d'une structure peuvent être de différents types.
Contrairement aux tuples, on doit nommer chaque élément des données afin de
clarifier le rôle de chaque valeur. Grâce à ces noms, les structures sont plus
flexibles que les tuples : on n'a pas à utiliser l'ordre des données pour
spécifier ou accéder aux valeurs d'une instance.</p>
<!--
To define a struct, we enter the keyword `struct` and name the entire struct. A
struct’s name should describe the significance of the pieces of data being
grouped together. Then, inside curly brackets, we define the names and types of
the pieces of data, which we call *fields*. For example, Listing 5-1 shows a
struct that stores information about a user account.
-->
<p>Pour définir une structure, on tape le mot-clé <code>struct</code> et on donne un nom à
toute la structure. Le nom d'une structure devrait décrire l'utilisation des
éléments des données regroupés. Ensuite, entre des accolades, on définit le nom
et le type de chaque élément des données, qu'on appelle un <em>champ</em>. Par exemple,
l'encart 5-1 montre une structure qui stocke des informations à propos d'un
compte d'utilisateur.</p>
<!--
```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Utilisateur {
    actif: bool,
    pseudo: String,
    email: String,
    nombre_de_connexions: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-1: A `User` struct definition</span>
-->
<p><span class="caption">Encart 5-1 : la définition d'une structure
<code>Utilisateur</code></span></p>
<!--
To use a struct after we’ve defined it, we create an *instance* of that struct
by specifying concrete values for each of the fields. We create an instance by
stating the name of the struct and then add curly brackets containing `key:
value` pairs, where the keys are the names of the fields and the values are the
data we want to store in those fields. We don’t have to specify the fields in
the same order in which we declared them in the struct. In other words, the
struct definition is like a general template for the type, and instances fill
in that template with particular data to create values of the type. For
example, we can declare a particular user as shown in Listing 5-2.
-->
<p>Pour utiliser une structure après l'avoir définie, on crée une <em>instance</em> de
cette structure en indiquant des valeurs concrètes pour chacun des champs.
On crée une instance en indiquant le nom de la structure puis en ajoutant des
accolades qui contiennent des paires de <code>clé: valeur</code>, où les clés sont les noms
des champs et les valeurs sont les données que l'on souhaite stocker dans ces
champs. Nous n'avons pas à préciser les champs dans le même ordre qu'on les a
déclarés dans la structure. En d'autres termes, la définition de la structure
décrit un gabarit pour le type, et les instances remplissent ce gabarit avec des
données précises pour créer des valeurs de ce type. Par exemple, nous pouvons
déclarer un utilisateur précis comme dans l'encart 5-2.</p>
<!--
```rust
# struct User {
#     active: bool,
#     username: String,
#     email: String,
#     sign_in_count: u64,
# }
# 
# fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    actif: bool,
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let utilisateur1 = Utilisateur {
        email: String::from(&quot;quelquun@example.com&quot;),
        pseudo: String::from(&quot;pseudoquelconque123&quot;),
        actif: true,
        nombre_de_connexions: 1,
    };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-2: Creating an instance of the `User`
struct</span>
-->
<p><span class="caption">Encart 5-2 : création d'une instance de la structure
<code>Utilisateur</code></span></p>
<!--
To get a specific value from a struct, we can use dot notation. If we wanted
just this user’s email address, we could use `user1.email` wherever we wanted
to use this value. If the instance is mutable, we can change a value by using
the dot notation and assigning into a particular field. Listing 5-3 shows how
to change the value in the `email` field of a mutable `User` instance.
-->
<p>Pour obtenir une valeur spécifique depuis une structure, on utilise la notation
avec le point. Si nous voulions seulement l'adresse e-mail de cet utilisateur,
on pourrait utiliser <code>utilisateur1.email</code> partout où on voudrait utiliser cette
valeur. Si l'instance est mutable, nous pourrions changer une valeur en
utilisant la notation avec le point et assigner une valeur à ce champ en
particulier. L'encart 5-3 montre comment changer la valeur du champ <code>email</code>
d'une instance mutable de <code>Utilisateur</code>.</p>
<!--
```rust
# struct User {
#     active: bool,
#     username: String,
#     email: String,
#     sign_in_count: u64,
# }
# 
# fn main() {
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    actif: bool,
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let mut utilisateur1 = Utilisateur {
        email: String::from(&quot;quelquun@example.com&quot;),
        pseudo: String::from(&quot;pseudoquelconque123&quot;),
        actif: true,
        nombre_de_connexions: 1,
    };
    
    utilisateur1.email = String::from(&quot;unautremail@example.com&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-3: Changing the value in the `email` field of a
`User` instance</span>
-->
<p><span class="caption">Encart 5-3 : changement de la valeur du champ <code>email</code>
d'une instance de <code>Utilisateur</code></span></p>
<!--
Note that the entire instance must be mutable; Rust doesn’t allow us to mark
only certain fields as mutable. As with any expression, we can construct a new
instance of the struct as the last expression in the function body to
implicitly return that new instance.
-->
<p>À noter que l'instance tout entière doit être mutable ; Rust ne nous permet pas
de marquer seulement certains champs comme mutables. Comme pour toute
expression, nous pouvons construire une nouvelle instance de la structure comme
dernière expression du corps d'une fonction pour retourner implicitement cette
nouvelle instance.</p>
<!--
Listing 5-4 shows a `build_user` function that returns a `User` instance with
the given email and username. The `active` field gets the value of `true`, and
the `sign_in_count` gets a value of `1`.
-->
<p>L'encart 5-4 montre une fonction <code>creer_utilisateur</code> qui retourne une instance
de <code>Utilisateur</code> avec l'adresse e-mail et le pseudo fournis. Le champ <code>actif</code>
prend la valeur <code>true</code> et le <code>nombre_de_connexions</code> prend la valeur <code>1</code>.</p>
<!--
```rust
# struct User {
#     active: bool,
#     username: String,
#     email: String,
#     sign_in_count: u64,
# }
# 
fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
# 
# fn main() {
#     let user1 = build_user(
#         String::from("someone@example.com"),
#         String::from("someusername123"),
#     );
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    actif: bool,
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn creer_utilisateur(email: String, pseudo: String) -&gt; Utilisateur {
    Utilisateur {
        email: email,
        pseudo: pseudo,
        actif: true,
        nombre_de_connexions: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let utilisateur1 = creer_utilisateur(
</span><span class="boring">        String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">        String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-4: A `build_user` function that takes an email
and username and returns a `User` instance</span>
-->
<p><span class="caption">Encart 5-4 : une fonction <code>creer_utilisateur</code> qui prend
en entrée une adresse e-mail et un pseudo et retourne une instance de
<code>Utilisateur</code></span></p>
<!--
It makes sense to name the function parameters with the same name as the struct
fields, but having to repeat the `email` and `username` field names and
variables is a bit tedious. If the struct had more fields, repeating each name
would get even more annoying. Luckily, there’s a convenient shorthand!
-->
<p>Il est logique de nommer les paramètres de fonction avec le même nom que les
champs de la structure, mais devoir répéter les noms de variables et de champs
<code>email</code> et <code>pseudo</code> est un peu pénible. Si la structure avait plus de champs,
répéter chaque nom serait encore plus fatigant. Heureusement, il existe un
raccourci pratique !</p>
<!--
### Using the Field Init Shorthand when Variables and Fields Have the Same Name
-->
<h3 id="utiliser-le-raccourci-dinitialisation-des-champs-lorsque-les-variables-et-les-champs-ont-le-même-nom"><a class="header" href="#utiliser-le-raccourci-dinitialisation-des-champs-lorsque-les-variables-et-les-champs-ont-le-même-nom">Utiliser le raccourci d'initialisation des champs lorsque les variables et les champs ont le même nom</a></h3>
<!--
Because the parameter names and the struct field names are exactly the same in
Listing 5-4, we can use the *field init shorthand* syntax to rewrite
`build_user` so that it behaves exactly the same but doesn’t have the
repetition of `email` and `username`, as shown in Listing 5-5.
-->
<p>Puisque les noms des paramètres et les noms de champs de la structure sont
exactement les mêmes dans l'encart 5-4, on peut utiliser la syntaxe de
<em>raccourci d'initialisation des champs</em> pour réécrire <code>creer_utilisateur</code> de
sorte qu'elle se comporte exactement de la même façon sans avoir à répéter
<code>email</code> et <code>pseudo</code>, comme le montre l'encart 5-5.</p>
<!--
```rust
# struct User {
#     active: bool,
#     username: String,
#     email: String,
#     sign_in_count: u64,
# }
# 
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
# 
# fn main() {
#     let user1 = build_user(
#         String::from("someone@example.com"),
#         String::from("someusername123"),
#     );
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    actif: bool,
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn creer_utilisateur(email: String, pseudo: String) -&gt; Utilisateur {
    Utilisateur {
        email,
        pseudo,
        actif: true,
        nombre_de_connexions: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let utilisateur1 = creer_utilisateur(
</span><span class="boring">        String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">        String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-5: A `build_user` function that uses field init
shorthand because the `email` and `username` parameters have the same name as
struct fields</span>
-->
<p><span class="caption">Encart 5-5 : une fonction <code>creer_utilisateur</code> qui utilise
le raccourci d'initialisation des champs parce que les paramètres <code>email</code> et
<code>pseudo</code> ont le même nom que les champs de la structure</span></p>
<!--
Here, we’re creating a new instance of the `User` struct, which has a field
named `email`. We want to set the `email` field’s value to the value in the
`email` parameter of the `build_user` function. Because the `email` field and
the `email` parameter have the same name, we only need to write `email` rather
than `email: email`.
-->
<p>Ici, on crée une nouvelle instance de la structure <code>Utilisateur</code>, qui possède
un champ nommé <code>email</code>. On veut donner au champ <code>email</code> la valeur du paramètre
<code>email</code> de la fonction <code>creer_utilisateur</code>. Comme le champ <code>email</code> et le
paramètre <code>email</code> ont le même nom, on a uniquement besoin d'écrire <code>email</code>
plutôt que <code>email: email</code>.</p>
<!--
### Creating Instances From Other Instances With Struct Update Syntax
-->
<h3 id="créer-des-instances-à-partir-dautres-instances-avec-la-syntaxe-de-mise-à-jour-de-structure"><a class="header" href="#créer-des-instances-à-partir-dautres-instances-avec-la-syntaxe-de-mise-à-jour-de-structure">Créer des instances à partir d'autres instances avec la syntaxe de mise à jour de structure</a></h3>
<!--
It’s often useful to create a new instance of a struct that uses most of an old
instance’s values but changes some. You can do this using *struct update
syntax*.
-->
<p>Il est souvent utile de créer une nouvelle instance de structure qui utilise la
plupart des valeurs d'une ancienne instance tout en en changeant certaines. Vous
pouvez utiliser pour cela la <em>syntaxe de mise à jour de structure</em>.</p>
<!--
First, Listing 5-6 shows how we create a new `User` instance in `user2` without
the update syntax. We set a new value for `email` but otherwise use the same
values from `user1` that we created in Listing 5-2.
-->
<p>Tout d'abord, l'encart 5-6 nous montre comment créer une nouvelle instance de
<code>Utilisateur</code> dans <code>utilisateur2</code> sans la syntaxe de mise à jour de structure.
On donne de nouvelles valeurs à <code>email</code> et <code>pseudo</code> mais on utilise pour les
autres champs les mêmes valeurs que dans <code>utilisateur1</code> qu'on a créé à
l'encart 5-2.</p>
<!--
```rust
# struct User {
#     active: bool,
#     username: String,
#     email: String,
#     sign_in_count: u64,
# }
# 
# fn main() {
#     let user1 = User {
#         email: String::from("someone@example.com"),
#         username: String::from("someusername123"),
#         active: true,
#         sign_in_count: 1,
#     };
# 
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    actif: bool,
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let utilisateur1 = Utilisateur {
</span><span class="boring">        email: String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">        pseudo: String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">        actif: true,
</span><span class="boring">        nombre_de_connexions: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let utilisateur2 = Utilisateur {
        actif: utilisateur1.actif,
        pseudo: utilisateur1.email,
        email: String::from(&quot;quelquundautre@example.com&quot;),
        nombre_de_connexions: utilisateur1.nombre_de_connexions,
    };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-6: Creating a new `User` instance using one of
the values from `user1`</span>
-->
<p><span class="caption">Encart 5-6 : création d'une nouvelle instance de
<code>Utilisateur</code> en utilisant une des valeurs de <code>utilisateur1</code>.</span></p>
<!--
Using struct update syntax, we can achieve the same effect with less code, as
shown in Listing 5-7. The syntax `..` specifies that the remaining fields not
explicitly set should have the same value as the fields in the given instance.
-->
<p>En utilisant la syntaxe de mise à jour de structure, on peut produire le même
résultat avec moins de code, comme le montre l'encart 5-7. La syntaxe <code>..</code>
indique que les autres champs auxquels on ne donne pas explicitement de valeur
devraient avoir la même valeur que dans l'instance précisée.</p>
<!--
```rust
# struct User {
#     active: bool,
#     username: String,
#     email: String,
#     sign_in_count: u64,
# }
# 
# fn main() {
#     let user1 = User {
#         email: String::from("someone@example.com"),
#         username: String::from("someusername123"),
#         active: true,
#         sign_in_count: 1,
#     };
# 
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Utilisateur {
</span><span class="boring">    actif: bool,
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let utilisateur1 = Utilisateur {
</span><span class="boring">        email: String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">        pseudo: String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">        actif: true,
</span><span class="boring">        nombre_de_connexions: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let utilisateur2 = Utilisateur {
        email: String::from(&quot;quelquundautre@example.com&quot;),
        ..utilisateur1
    };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-7: Using struct update syntax to set a new
`email` value for a `User` instance but use the rest of the values from
`user1`</span>
-->
<p><span class="caption">Encart 5-7 : utilisation de la syntaxe de mise à jour de
structure pour assigner de nouvelles valeurs à <code>email</code> d'une nouvelle instance
de <code>Utilisateur</code> tout en utilisant les autres valeurs de <code>utilisateur1</code></span></p>
<!--
The code in Listing 5-7 also creates an instance in `user2` that has a
different value for `email` but has the same values for the `username`,
`active`, and `sign_in_count` fields from `user1`. The `..user1` must come last
to specify that any remaining fields should get their values from the
corresponding fields in `user1`, but we can choose to specify values for as
many fields as we want in any order, regardless of the order of the fields in
the struct’s definition.
-->
<p>Le code dans l'encart 5-7 crée aussi une instance dans <code>utilisateur2</code> qui a une
valeur différente pour <code>email</code>, mais qui as les mêmes valeurs pour les champs
<code>pseudo</code>, <code>actif</code> et <code>nombre_de_connexions</code> que <code>utilisateur1</code>. Le
<code>..utilisateur1</code> doit être inséré à la fin pour préciser que tous les champs
restants obtiendrons les valeurs des champs correspondants de <code>utilisateur1</code>,
mais nous pouvons renseigner les valeurs des champs dans n'importe quel ordre,
peu importe leur position dans la définition de la structure.</p>
<!--
Note that the struct update syntax is like assignment with `=` because it moves
the data, just as we saw in the [“Ways Variables and Data Interact: Move”
section][move]<!-- ignore -- >. In this example, we can no longer use `user1`
after creating `user2` because the `String` in the `username` field of `user1`
was moved into `user2`. If we had given `user2` new `String` values for both
`email` and `username`, and thus only used the `active` and `sign_in_count`
values from `user1`, then `user1` would still be valid after creating `user2`.
The types of `active` and `sign_in_count` are types that implement the `Copy`
trait, so the behavior we discussed in the [“Stack-Only Data: Copy”
section][copy]<!-- ignore -- > would apply.
-->
<p>Veuillez notez que la syntaxe de la mise à jour de structure ressemble à une
assignation avec un <code>=</code> car elle déplace les données, comme nous l'avons vu dans
<a href="ch04-01-what-is-ownership.html">une des sections au chapitre 4</a><!-- ignore -->. Dans cet exemple, nous
ne pouvons plus utiliser <code>utilisateur1</code> après avoir créé <code>utilisateur2</code> car la
<code>String</code> dans le champ <code>pseudo</code> de <code>utilisateur1</code> a été déplacée dans
<code>utilisateur2</code>. Si nous avions donné des nouvelles valeurs pour chacune des
<code>String</code> <code>email</code> et <code>pseudo</code>, et que par conséquent nous aurions déplacé
uniquement les valeurs de <code>actif</code> et de <code>nombre_de_connexions</code> à partir de
<code>utilisateur1</code>, alors <code>utilisateur1</code> restera en vigueur après avoir créé
<code>utilisateur2</code>. Les types de <code>actif</code> et de <code>nombre_de_connexions</code> sont de types
qui implémentent le trait <code>Copy</code>, donc le comportement décris dans <a href="ch04-01-what-is-ownership.html">la section
à propos de copy</a><!-- ignore --> aura lieu ici.</p>
<!--
### Using Tuple Structs without Named Fields to Create Different Types
-->
<h3 id="utilisation-de-structures-tuples-sans-champ-nommé-pour-créer-des-types-différents"><a class="header" href="#utilisation-de-structures-tuples-sans-champ-nommé-pour-créer-des-types-différents">Utilisation de structures tuples sans champ nommé pour créer des types différents</a></h3>
<!--
You can also define structs that look similar to tuples, called *tuple
structs*. Tuple structs have the added meaning the struct name provides but
don’t have names associated with their fields; rather, they just have the types
of the fields. Tuple structs are useful when you want to give the whole tuple a
name and make the tuple be a different type from other tuples, and naming each
field as in a regular struct would be verbose or redundant.
-->
<p>On peut aussi définir des structures qui ressemblent à des tuples, appelées
<em>structures tuples</em>. La signification d'une structure tuple est donnée par son
nom. En revanche, ses champs ne sont pas nommés ; on ne précise que leurs types.
Les structures tuples servent lorsqu'on veut donner un nom à un tuple pour qu'il
ait un type différent des autres tuples, mais que nommer chaque champ comme dans
une structure classique serait trop verbeux ou redondant.</p>
<!--
To define a tuple struct, start with the `struct` keyword and the struct name
followed by the types in the tuple. For example, here are definitions and
usages of two tuple structs named `Color` and `Point`:
-->
<p>La définition d'une structure tuple commence par le mot-clé <code>struct</code> et le nom
de la structure suivis des types des champs du tuple. Par exemple, voici une
définition et une utilisation de deux structures tuples nommées <code>Couleur</code> et
<code>Point</code> :</p>
<!--
```rust
# fn main() {
    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);

    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Couleur(i32, i32, i32);
    struct Point(i32, i32, i32);

    let noir = Couleur(0, 0, 0);
    let origine = Point(0, 0, 0);
<span class="boring">}
</span></code></pre></pre>
<!--
Note that the `black` and `origin` values are different types, because they’re
instances of different tuple structs. Each struct you define is its own type,
even though the fields within the struct have the same types. For example, a
function that takes a parameter of type `Color` cannot take a `Point` as an
argument, even though both types are made up of three `i32` values. Otherwise,
tuple struct instances behave like tuples: you can destructure them into their
individual pieces, you can use a `.` followed by the index to access an
individual value, and so on.
-->
<p>Notez que les valeurs <code>noir</code> et <code>origine</code> sont de types différents parce que ce
sont des instances de structures tuples différentes. Chaque structure que l'on
définit constitue son propre type, même si les champs au sein de la structure
ont les mêmes types. Par exemple, une fonction qui prend un paramètre de type
<code>Couleur</code> ne peut pas prendre un argument de type <code>Point</code> à la place, bien que
ces deux types soient tous les deux constitués de trois valeurs <code>i32</code>. Mis à
part cela, les instances de stuctures tuples se comportent comme des tuples : on
peut les déstructurer en éléments individuels, on peut utiliser un <code>.</code> suivi de
l'indice pour accéder individuellement à une valeur, et ainsi de suite.</p>
<!--
### Unit-Like Structs Without Any Fields
-->
<h3 id="les-structures-unité-sans-champs"><a class="header" href="#les-structures-unité-sans-champs">Les structures unité sans champs</a></h3>
<!--
You can also define structs that don’t have any fields! These are called
*unit-like structs* because they behave similarly to `()`, the unit type that
we mentioned in [“The Tuple Type”][tuples]<!-- ignore -- > section. Unit-like
structs can be useful in situations in which you need to implement a trait on
some type but don’t have any data that you want to store in the type itself.
We’ll discuss traits in Chapter 10. Here’s an example of declaring and
instantiating a unit struct named `AlwaysEqual`:
-->
<p>On peut aussi définir des structures qui n'ont pas de champs ! Cela s'appelle
des <em>structures unité</em> parce qu'elles se comportent d'une façon analogue au type
unité, <code>()</code>, que nous avons vu dans <a href="ch03-02-data-types.html">la section sur les
tuples</a><!-- ignore -->. Les structures unité sont utiles lorsqu'on doit
implémenter un trait sur un type mais qu'on n'a aucune donnée à stocker dans le
type en lui-même. Nous aborderons les traits au chapitre 10. Voici un exemple
de déclaration et d'instanciation d'une structure unité <code>ToujoursEgal</code> :</p>
<!--
```rust
# fn main() {
    struct AlwaysEqual;

    let subject = AlwaysEqual;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct ToujoursEgal;

    let sujet = ToujoursEgal;
<span class="boring">}
</span></code></pre></pre>
<!--
To define `AlwaysEqual`, we use the `struct` keyword, the name we want, then a
semicolon. No need for curly brackets or parentheses! Then we can get an
instance of `AlwaysEqual` in the `subject` variable in a similar way: using the
name we defined, without any curly brackets or parentheses. Imagine we’ll be
implementing behavior for this type that every instance is always equal to
every instance of every other type, perhaps to have a known result for testing
purposes. We wouldn’t need any data to implement that behavior! You’ll see in
Chapter 10 how to define traits and implement them on any type, including
unit-like structs.
-->
<p>Pour définir <code>ToujoursEgal</code>, nous utilisons le mot-clé <code>struct</code>, puis le nom que
nous voulons lui donner, et enfin un point-virgule. Pas besoin d'accolades ou de
parenthèses ! Ensuite, nous pouvons obtenir une instance de <code>ToujourEgal</code> dans
la variable <code>sujet</code> de la même manière : utilisez le nom que vous avez défini,
sans aucune accolade ou parenthèse. Imaginez que nous allons implémenter un
comportement pour ce type pour que toutes les instances soient toujours égales à
chaque instance de n'importe quel autre type, peut-être pour avoir un résultat
connu pour des besoins de tests. Nous n'avons pas besoin d'aucune donnée pour
implémenter ce comportement ! Vous verrez au chapitre 10 comment définir des
traits et les implémenter sur l'importe quel type, y compris sur les structures
unité.</p>
<!--
> ### Ownership of Struct Data
>
> In the `User` struct definition in Listing 5-1, we used the owned `String`
> type rather than the `&str` string slice type. This is a deliberate choice
> because we want instances of this struct to own all of its data and for that
> data to be valid for as long as the entire struct is valid.
>
> It’s possible for structs to store references to data owned by something else,
> but to do so requires the use of *lifetimes*, a Rust feature that we’ll
> discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct
> is valid for as long as the struct is. Let’s say you try to store a reference
> in a struct without specifying lifetimes, like this, which won’t work:
>
> <span class="filename">Filename: src/main.rs</span>
>
> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -- >
>
> ```rust,ignore,does_not_compile
> struct User {
>     username: &str,
>     email: &str,
>     sign_in_count: u64,
>     active: bool,
> }
>
> fn main() {
>     let user1 = User {
>         email: "someone@example.com",
>         username: "someusername123",
>         active: true,
>         sign_in_count: 1,
>     };
> }
> ```
>
> The compiler will complain that it needs lifetime specifiers:
>
> ```console
> $ cargo run
>    Compiling structs v0.1.0 (file:///projects/structs)
> error[E0106]: missing lifetime specifier
>  -- > src/main.rs:2:15
>   |
> 2 |     username: &str,
>   |               ^ expected named lifetime parameter
>   |
> help: consider introducing a named lifetime parameter
>   |
> 1 | struct User<'a> {
> 2 |     username: &'a str,
>   |
>
> error[E0106]: missing lifetime specifier
>  -- > src/main.rs:3:12
>   |
> 3 |     email: &str,
>   |            ^ expected named lifetime parameter
>   |
> help: consider introducing a named lifetime parameter
>   |
> 1 | struct User<'a> {
> 2 |     username: &str,
> 3 |     email: &'a str,
>   |
>
> error: aborting due to 2 previous errors
>
> For more information about this error, try `rustc --explain E0106`.
> error: could not compile `structs`
>
> To learn more, run the command again with --verbose.
> ```
>
> In Chapter 10, we’ll discuss how to fix these errors so you can store
> references in structs, but for now, we’ll fix errors like these using owned
> types like `String` instead of references like `&str`.
-->
<blockquote>
<h3 id="la-possession-des-données-dune-structure"><a class="header" href="#la-possession-des-données-dune-structure">La possession des données d'une structure</a></h3>
<p>Dans la définition de la structure <code>Utilisateur</code> de l'encart 5-1, nous avions
utilisé le type possédé <code>String</code> plutôt que le type de <em>slice</em> de chaîne de
caractères <code>&amp;str</code>. Il s'agit d'un choix délibéré puisque nous voulons que les
instances de cette structure possèdent toutes leurs données et que ces données
restent valides tant que la structure tout entière est valide.</p>
<p>Il est possible pour les structures de stocker des références vers des données
possédées par autre chose, mais cela nécessiterait d'utiliser des
<em>durées de vie</em>, une fonctionnalité de Rust que nous aborderons au
chapitre 10. Les durées de vie assurent que les données référencées par une
structure restent valides tant que la structure l'est aussi. Disons que vous
essayiez de stocker une référence dans une structure sans indiquer de durées
de vie, comme ceci, ce qui ne fonctionnera pas :</p>
<p><span class="filename">Fichier : src/main.rs</span></p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore does_not_compile">struct Utilisateur {
    pseudo: &amp;str,
    email: &amp;str,
    nombre_de_connexions: u64,
    actif: bool,
}

fn main() {
    let utilisateur1 = Utilisateur {
        email: &quot;quelquun@example.com&quot;,
        pseudo: &quot;pseudoquelconque123&quot;,
        actif: true,
        nombre_de_connexions: 1,
    };
}
</code></pre>
<p>Le compilateur réclamera l'ajout des durées de vie :</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:2:15
  |
2 |     pseudo: &amp;str,
  |             ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct Utilisateur&lt;'a&gt; {
2 |     pseudo: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:12
  |
3 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct Utilisateur&lt;'a&gt; {
2 |     pseudo: &amp;str,
3 |     email: &amp;'a str,
  |

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs`

To learn more, run the command again with --verbose.
</code></pre>
<p>Au chapitre 10, nous aborderons la façon de corriger ces erreurs pour qu'on
puisse stocker des références dans des structures, mais pour le moment, nous
résoudrons les erreurs comme celles-ci en utilisant des types possédés comme
<code>String</code> plutôt que des références comme <code>&amp;str</code>.</p>
</blockquote>
<!--
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -- >
-->
<!--
[tuples]: ch03-02-data-types.html#the-tuple-type
[move]: ch04-01-what-is-ownership.html#ways-variables-and-data-interact-move
[copy]: ch04-01-what-is-ownership.html#stack-only-data-copy
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## An Example Program Using Structs
-->
<h2 id="un-exemple-de-programme-qui-utilise-des-structures"><a class="header" href="#un-exemple-de-programme-qui-utilise-des-structures">Un exemple de programme qui utilise des structures</a></h2>
<!--
To understand when we might want to use structs, let’s write a program that
calculates the area of a rectangle. We’ll start with single variables, and then
refactor the program until we’re using structs instead.
-->
<p>Pour comprendre dans quels cas nous voudrions utiliser des structures, écrivons
un programme qui calcule l'aire d'un rectangle. Nous commencerons avec de
simples variables, puis on remaniera le code jusqu'à utiliser des structures à
la place.</p>
<!--
Let’s make a new binary project with Cargo called *rectangles* that will take
the width and height of a rectangle specified in pixels and calculate the area
of the rectangle. Listing 5-8 shows a short program with one way of doing
exactly that in our project’s *src/main.rs*.
-->
<p>Créons un nouveau projet binaire avec Cargo nommé <em>rectangles</em> qui prendra la
largeur et la hauteur en pixels d'un rectangle et qui calculera l'aire de ce
rectangle. L'encart 5-8 montre un petit programme qui effectue cette tâche d'une
certaine manière dans le <em>src/main.rs</em> de notre projet.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier: src/main.rs</span></p>
<!--
```rust
fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -> u32 {
    width * height
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let largeur1 = 30;
    let hauteur1 = 50;

    println!(
        &quot;L'aire du rectangle est de {} pixels carrés.&quot;,
        aire(largeur1, hauteur1)
    );
}

fn aire(largeur: u32, hauteur: u32) -&gt; u32 {
    largeur * hauteur
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-8: Calculating the area of a rectangle
specified by separate width and height variables</span>
-->
<p><span class="caption">Encart 5-8 : Calcul de l'aire d'un rectangle défini par
les variables distinctes <code>largeur</code> et <code>hauteur</code></span></p>
<!--
Now, run this program using `cargo run`:
-->
<p>Maintenant, lancez ce programme avec <code>cargo run</code> :</p>
<!--
```console
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
The area of the rectangle is 1500 square pixels.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
L'aire du rectangle est de 1500 pixels carrés.
</code></pre>
<!--
Even though Listing 5-8 works and figures out the area of the rectangle by
calling the `area` function with each dimension, we can do better. The width
and the height are related to each other because together they describe one
rectangle.
-->
<p>Bien que l'encart 5-8 fonctionne et détermine l'aire du rectangle en appelant
la fonction <code>aire</code> avec chaque dimension, on peut faire mieux. La largeur et la
hauteur sont couplées entre elles car elles décrivent toutes les deux un rectangle.</p>
<!--
The issue with this code is evident in the signature of `area`:
-->
<p>Le problème de ce code se voit dans la signature de <code>aire</code> :</p>
<!--
```rust,ignore
# fn main() {
#     let width1 = 30;
#     let height1 = 50;
# 
#     println!(
#         "The area of the rectangle is {} square pixels.",
#         area(width1, height1)
#     );
# }
# 
fn area(width: u32, height: u32) -> u32 {
#     width * height
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let largeur1 = 30;
</span><span class="boring">    let hauteur1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;L'aire du rectangle est de {} pixels carrés.&quot;,
</span><span class="boring">        aire(largeur1, hauteur1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn aire(largeur: u32, hauteur: u32) -&gt; u32 {
<span class="boring">    largeur * hauteur
</span><span class="boring">}
</span></code></pre>
<!--
The `area` function is supposed to calculate the area of one rectangle, but the
function we wrote has two parameters. The parameters are related, but that’s
not expressed anywhere in our program. It would be more readable and more
manageable to group width and height together. We’ve already discussed one way
we might do that in [“The Tuple Type”][the-tuple-type]<!-- ignore -- > section
of Chapter 3: by using tuples.
-->
<p>La fonction <code>aire</code> est censée calculer l'aire d'un rectangle, mais la fonction
que nous avons écrite a deux paramètres. Les paramètres sont liés, mais ce n'est
exprimé nulle part dans notre programme. Il serait plus lisible et plus gérable
de regrouper ensemble la largeur et la hauteur. Nous avons déjà vu dans la
section <a href="ch03-02-data-types.html">“Le type <em>tuple</em>”</a><!-- ignore --> du chapitre 3 une
façon qui nous permettrait de le faire : en utilisant des tuples.</p>
<!--
### Refactoring with Tuples
-->
<h3 id="remanier-le-code-avec-des-tuples"><a class="header" href="#remanier-le-code-avec-des-tuples">Remanier le code avec des tuples</a></h3>
<!--
Listing 5-9 shows another version of our program that uses tuples.
-->
<p>L'encart 5-9 nous montre une autre version de notre programme qui utilise des
tuples.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;L'aire du rectangle est de {} pixels carrés.&quot;,
        aire(rect1)
    );
}

fn aire(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-9: Specifying the width and height of the
rectangle with a tuple</span>
-->
<p><span class="caption">Encart 5-9 : Renseigner la largeur et la hauteur du
rectangle dans un tuple</span></p>
<!--
In one way, this program is better. Tuples let us add a bit of structure, and
we’re now passing just one argument. But in another way, this version is less
clear: tuples don’t name their elements, so our calculation has become more
confusing because we have to index into the parts of the tuple.
-->
<p>D'une certaine façon, ce programme est meilleur. Les tuples nous permettent de
structurer un peu plus et nous ne passons plus qu'un argument. Mais d'une autre
façon, cette version est moins claire : les tuples ne donnent pas de noms à
leurs éléments, donc notre calcul est devenu plus déroutant puisqu'il faut
accéder aux éléments du tuple via leur indice.</p>
<!--
It doesn’t matter if we mix up width and height for the area calculation, but
if we want to draw the rectangle on the screen, it would matter! We would have
to keep in mind that `width` is the tuple index `0` and `height` is the tuple
index `1`. If someone else worked on this code, they would have to figure this
out and keep it in mind as well. It would be easy to forget or mix up these
values and cause errors, because we haven’t conveyed the meaning of our data in
our code.
-->
<p>Ce n'est pas grave de confondre la largeur et la hauteur pour calculer l'aire,
mais si on voulait afficher le rectangle à l'écran, cela serait problématique !
Il nous faut garder à l'esprit que la <code>largeur</code> est l'élément à l'indice 0 du
tuple et que la <code>hauteur</code> est l'élément à l'indice 1. Si quelqu'un d'autre
travaillait sur ce code, il devrait le déduire et s'en souvenir aussi. Il est
facile d'oublier ou de confondre ces valeurs et par conséquent provoquer des
erreurs, parce qu'on n'a pas exprimé la signification de nos données dans notre
code.</p>
<!--
### Refactoring with Structs: Adding More Meaning
-->
<h3 id="remanier-avec-des-structures--donner-plus-de-sens"><a class="header" href="#remanier-avec-des-structures--donner-plus-de-sens">Remanier avec des structures : donner plus de sens</a></h3>
<!--
We use structs to add meaning by labeling the data. We can transform the tuple
we’re using into a data type with a name for the whole as well as names for the
parts, as shown in Listing 5-10.
-->
<p>On utilise des structures pour rendre les données plus expressives en leur
donnant des noms. On peut transformer le tuple que nous avons utilisé en un type
de donnée nommé dont ses éléments sont aussi nommés, comme le montre l'encart
5-10.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

fn main() {
    let rect1 = Rectangle { largeur: 30, hauteur: 50 };

    println!(
        &quot;L'aire du rectangle est de {} pixels carrés.&quot;,
        aire(&amp;rect1)
    );
}

fn aire(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.largeur * rectangle.hauteur
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-10: Defining a `Rectangle` struct</span>
-->
<p><span class="caption">Encart 5-10 : Définition d'une structure
<code>Rectangle</code></span></p>
<!--
Here we’ve defined a struct and named it `Rectangle`. Inside the curly
brackets, we defined the fields as `width` and `height`, both of which have
type `u32`. Then in `main`, we created a particular instance of `Rectangle`
that has a width of 30 and a height of 50.
-->
<p>Ici, on a défini une structure et on l'a appelée <code>Rectangle</code>. Entre les
accolades, on a défini les champs <code>largeur</code> et <code>hauteur</code>, tous deux du type
<code>u32</code>. Puis dans <code>main</code>, on crée une instance de <code>Rectangle</code> de largeur 30 et de
hauteur 50.</p>
<!--
Our `area` function is now defined with one parameter, which we’ve named
`rectangle`, whose type is an immutable borrow of a struct `Rectangle`
instance. As mentioned in Chapter 4, we want to borrow the struct rather than
take ownership of it. This way, `main` retains its ownership and can continue
using `rect1`, which is the reason we use the `&` in the function signature and
where we call the function.
-->
<p>Notre fonction <code>aire</code> est désormais définie avec un unique paramètre, nommé
<code>rectangle</code>, et dont le type est une référence immuable vers une instance de la
structure <code>Rectangle</code>. Comme mentionné au chapitre 4, on préfère emprunter la
structure au lieu d'en prendre possession. Ainsi, elle reste en possession de
<code>main</code> qui peut continuer à utiliser <code>rect1</code> ; c'est pourquoi on utilise le <code>&amp;</code>
dans la signature de la fonction ainsi que dans l'appel de fonction.</p>
<!--
The `area` function accesses the `width` and `height` fields of the `Rectangle`
instance. Our function signature for `area` now says exactly what we mean:
calculate the area of `Rectangle`, using its `width` and `height` fields. This
conveys that the width and height are related to each other, and it gives
descriptive names to the values rather than using the tuple index values of `0`
and `1`. This is a win for clarity.
-->
<p>La fonction <code>aire</code> accède aux champs <code>largeur</code> et <code>hauteur</code> de l'instance de
<code>Rectangle</code>. Notre signature de fonction pour <code>aire</code> est enfin explicite :
calculer l'aire d'un <code>Rectangle</code> en utilisant ses champs <code>largeur</code> et <code>hauteur</code>.
Cela explique que la largeur et la hauteur sont liées entre elles, et cela donne
des noms descriptifs aux valeurs plutôt que d'utiliser les valeurs du tuple avec
les indices <code>0</code> et <code>1</code>. On gagne en clarté.</p>
<!--
### Adding Useful Functionality with Derived Traits
-->
<h3 id="ajouter-des-fonctionnalités-utiles-avec-les-traits-dérivés"><a class="header" href="#ajouter-des-fonctionnalités-utiles-avec-les-traits-dérivés">Ajouter des fonctionnalités utiles avec les traits dérivés</a></h3>
<!--
It’d be nice to be able to print an instance of `Rectangle` while we’re
debugging our program and see the values for all its fields. Listing 5-11 tries
using the [`println!` macro][println]<!-- ignore -- > as we have used in
previous chapters. This won’t work, however.
-->
<p>Cela serait bien de pouvoir afficher une instance de <code>Rectangle</code> pendant qu'on
débogue notre programme et de voir la valeur de chacun de ses champs. L'encart
5-11 essaye de le faire en utilisant <a href="https://doc.rust-lang.org/std/macro.println.html">la macro
<code>println!</code></a><!-- ignore --> comme on l'a fait dans les chapitres
précédents. Cependant, cela ne fonctionne pas.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {}", rect1);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

fn main() {
    let rect1 = Rectangle {
        largeur: 30,
        hauteur: 50
    };

    println!(&quot;rect1 est {}&quot;, rect1);
}
</code></pre>
<!--
<span class="caption">Listing 5-11: Attempting to print a `Rectangle`
instance</span>
-->
<p><span class="caption">Encart 5-11 : Tentative d'afficher une instance de
<code>Rectangle</code></span></p>
<!--
When we compile this code, we get an error with this core message:
-->
<p>Lorsqu'on compile ce code, on obtient ce message d'erreur qui nous informe que
<code>Rectangle</code> n'implémente pas le trait <code>std::fmt::Display</code> :</p>
<!--
```text
error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
```
-->
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<!--
The `println!` macro can do many kinds of formatting, and by default, the curly
brackets tell `println!` to use formatting known as `Display`: output intended
for direct end user consumption. The primitive types we’ve seen so far
implement `Display` by default, because there’s only one way you’d want to show
a `1` or any other primitive type to a user. But with structs, the way
`println!` should format the output is less clear because there are more
display possibilities: Do you want commas or not? Do you want to print the
curly brackets? Should all the fields be shown? Due to this ambiguity, Rust
doesn’t try to guess what we want, and structs don’t have a provided
implementation of `Display`.
-->
<p>La macro <code>println!</code> peut faire toutes sortes de formatages textuels, et par
défaut, les accolades demandent à <code>println!</code> d'utiliser le formatage appelé
<code>Display</code>, pour convertir en texte destiné à être vu par l'utilisateur final.
Les types primitifs qu'on a vus jusqu'ici implémentent <code>Display</code> par défaut
puisqu'il n'existe qu'une seule façon d'afficher un <code>1</code> ou tout autre type
primitif à l'utilisateur. Mais pour les structures, la façon dont <code>println!</code>
devrait formater son résultat est moins claire car il y a plus de possibilités
d'affichage : Voulez-vous des virgules ? Voulez-vous afficher les accolades ?
Est-ce que tous les champs devraient être affichés ? À cause de ces ambiguïtés,
Rust n'essaye pas de deviner ce qu'on veut, et les structures n'implémentent pas
<code>Display</code> par défaut.</p>
<!--
If we continue reading the errors, we’ll find this helpful note:
-->
<p>Si nous continuons de lire les erreurs, nous trouvons cette remarque utile :</p>
<!--
```text
   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
```
-->
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Le compilateur nous informe que dans notre chaîne de formatage, on est peut-être
en mesure d'utiliser <code>{:?}</code> (ou <code>{:#?}</code> pour un affichage plus élégant).</p>
<!--
Let’s try it! The `println!` macro call will now look like `println!("rect1 is
{:?}", rect1);`. Putting the specifier `:?` inside the curly brackets tells
`println!` we want to use an output format called `Debug`. The `Debug` trait
enables us to print our struct in a way that is useful for developers so we can
see its value while we’re debugging our code.
-->
<p>Essayons cela ! L'appel de la macro <code>println!</code> ressemble maintenant à
<code>println!(&quot;rect1 est {:?}&quot;, rect1);</code>. Insérer le sélecteur <code>:?</code> entre les
accolades permet d'indiquer à <code>println!</code> que nous voulons utiliser le formatage
appelé <code>Debug</code>. Le trait <code>Debug</code> nous permet d'afficher notre structure d'une
manière utile aux développeurs pour qu'on puisse voir sa valeur pendant qu'on
débogue le code.</p>
<!--
Compile the code with this change. Drat! We still get an error:
-->
<p>Compilez le code avec ce changement. Zut ! On a encore une erreur, nous
informant cette fois-ci que <code>Rectangle</code> n'implémente pas <code>std::fmt::Debug</code> :</p>
<!--
```text
error[E0277]: `Rectangle` doesn't implement `Debug`
```
-->
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<!--
But again, the compiler gives us a helpful note:
-->
<p>Mais une nouvelle fois, le compilateur nous fait une remarque utile :</p>
<!--
```text
   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
```
-->
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Il nous conseille d'ajouter <code>#[derive(Debug)]</code> ou d'implémenter manuellement
<code>std::fmt::Debug</code>.</p>
<!--
Rust *does* include functionality to print out debugging information, but we
have to explicitly opt in to make that functionality available for our struct.
To do that, we add the outer attribute `#[derive(Debug)]` just before the
struct definition, as shown in Listing 5-12.
-->
<p>Rust <em>inclut</em> bel et bien une fonctionnalité pour afficher des informations de
débogage, mais nous devons l'activer explicitement pour la rendre disponible sur
notre structure. Pour ce faire, on ajoute l'attribut externe <code>#[derive(Debug)]</code>
juste avant la définition de la structure, comme le montre l'encart 5-12.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {:?}", rect1);
}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

fn main() {
    let rect1 = Rectangle {
        largeur: 30,
        hauteur: 50
    };

    println!(&quot;rect1 est {:?}&quot;, rect1);
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-12: Adding the attribute to derive the `Debug`
trait and printing the `Rectangle` instance using debug formatting</span>
-->
<p><span class="caption">Encart 5-12 : ajout de l'attribut pour dériver le
trait <code>Debug</code> et afficher l'instance de <code>Rectangle</code> en utilisant le formatage
de débogage</span></p>
<!--
Now when we run the program, we won’t get any errors, and we’ll see the
following output:
-->
<p>Maintenant, quand on exécute le programme, nous n'avons plus d'erreurs et ce
texte s'affiche à l'écran :</p>
<!--
```console
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
```
-->
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 est Rectangle { largeur: 30, hauteur: 50 }
</code></pre>
<!--
Nice! It’s not the prettiest output, but it shows the values of all the fields
for this instance, which would definitely help during debugging. When we have
larger structs, it’s useful to have output that’s a bit easier to read; in
those cases, we can use `{:#?}` instead of `{:?}` in the `println!` string.
When we use the `{:#?}` style in the example, the output will look like this:
-->
<p>Super ! Ce n'est pas le plus beau des affichages, mais cela montre les
valeurs de tous les champs de cette instance, ce qui serait assurément utile
lors du débogage. Quand on a des structures plus grandes, il serait bien d'avoir
un affichage un peu plus lisible ; dans ces cas-là, on pourra utiliser <code>{:#?}</code>
au lieu de <code>{:?}</code> dans la chaîne de formatage. Quand on utilise <code>{:#?}</code> dans cet
exemple, l'affichage donnera plutôt ceci :</p>
<!--
```console
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
```
-->
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 est Rectangle {
    largeur: 30,
    hauteur: 50,
}
</code></pre>
<!--
Another way to print out a value using the `Debug` format is by using the
[`dbg!` macro][dbg] <!-- ignore -- >. The `dbg!` macro takes ownership of an
expression, prints the file and line number of where that `dbg!` macro call
occurs in your code along with the resulting value of that expression, and
returns ownership of the value. Calling the `dbg!` macro prints to the standard
error console stream (`stderr`), as opposed to `println!` which prints to the
standard output console stream (`stdout`). We’ll talk more about `stderr` and
`stdout` in the [“Writing Error Messages to Standard Error Instead of Standard
Output” section in Chapter 12][err]<!-- ignore -- >. Here’s an example where
we’re interested in the value that gets assigned to the `width` field, as well
as the value of the whole struct in `rect1`:
-->
<p>Une autre façon d'afficher une valeur en utilisant le format <code>Debug</code> est
d'utiliser la <a href="https://doc.rust-lang.org/std/macro.dbg.html">macro <code>dbg!</code></a><!-- ignore -->. La macro <code>dbg!</code> prend
possession de l'expression, affiche le nom du fichier et la ligne de votre code
où se trouve cet appel à la macro <code>dbg!</code> ainsi que le résultat de cette
expression, puis rend la possession de cette valeur. L'appel de la macro <code>dbg!</code>
écrit dans le flux d'erreur standard de la console (<code>stderr</code>), contrairement à
<code>println!</code> qui écrit dans le flux de sortie standard de la console (<code>stdout</code>).
Nous reparlerons de <code>stderr</code> et de <code>stdout</code> dans <a href="ch12-06-writing-to-stderr-instead-of-stdout.html">une section du
chapitre 12</a><!-- ignore -->. Voici un exemple dans lequel nous nous
intéressons à la valeur assignée au champ <code>largeur</code>, ainsi que la valeur de
toute la structure <code>rect1</code> :</p>
<!--
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&rect1);
}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

fn main() {
    let echelle = 2;
    let rect1 = Rectangle {
        largeur: dbg!(30 * echelle),
        hauteur: 50,
    };

    dbg!(&amp;rect1);
}
</code></pre></pre>
<!--
We can put `dbg!` around the expression `30 * scale` and, because `dbg!`
returns ownership of the expression’s value, the `width` field will get the
same value as if we didn’t have the `dbg!` call there. We don’t want `dbg!` to
take ownership of `rect1`, so we use a reference to `dbg!` in the next call.
Here’s what the output of this example looks like:
-->
<p>Nous pouvons placer le <code>dbg!</code> autour de l'expression <code>30 * echelle</code> et, comme
<code>dbg!</code> retourne la possession de la valeur issue de l'expression, le champ
<code>largeur</code> va avoir la même valeur que si nous n'avions pas appelé <code>dbg!</code> ici.
Nous ne voulons pas que <code>dbg!</code> prenne possession de <code>rect1</code>, donc nous donnons
une référence à <code>dbg!</code> lors de son prochain appel. Voici à quoi ressemble la
sortie de cet exemple :</p>
<!--
```console
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10] 30 * scale = 60
[src/main.rs:14] &rect1 = Rectangle {
    width: 60,
    height: 50,
}
```
-->
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10] 30 * echelle = 60
[src/main.rs:14] &amp;rect1 = Rectangle {
    largeur: 60,
    hauteur: 50,
}
</code></pre>
<!--
We can see the first bit of output came from *src/main.rs* line 10, where we’re
debugging the expression `30 * scale`, and its resulting value is 60 (the
`Debug` formatting implemented for integers is to print only their value). The
`dbg!` call on line 14 of *src/main.rs* outputs the value of `&rect1`, which is
the `Rectangle` struct. This output uses the pretty `Debug` formatting of the
`Rectangle` type. The `dbg!` macro can be really helpful when you’re trying to
figure out what your code is doing!
-->
<p>Nous pouvons constater que la première sortie provient de la ligne 10
de <em>src/main.rs</em>, où nous déboguons l'expression <code>30 * echelle</code>, et son résultat
est 60 (le formattage de <code>Debug</code> pour les entiers est d'afficher uniquement sa
valeur). L'appel à <code>dbg!</code> à la ligne 14 de <em>src/main.rs</em> affiche la valeur de
<code>&amp;rect1</code>, qui est une structure <code>Rectangle</code>. La macro <code>dbg!</code> peut être très
utile lorsque vous essayez de comprendre ce que fait votre code !</p>
<!--
In addition to the `Debug` trait, Rust has provided a number of traits for us
to use with the `derive` attribute that can add useful behavior to our custom
types. Those traits and their behaviors are listed in [Appendix C][app-c]<!--
ignore -- >. We’ll cover how to implement these traits with custom behavior as
well as how to create your own traits in Chapter 10. There are also many
attributes other than `derive`; for more information, see [the “Attributes”
section of the Rust Reference][attributes].
-->
<p>En plus du trait <code>Debug</code>, Rust nous offre d'autres traits pour que nous
puissions les utiliser avec l'attribut <code>derive</code> pour ajouter des comportements
utiles à nos propres types. Ces traits et leurs comportements sont listés à
<a href="appendix-03-derivable-traits.html">l'annexe C</a><!-- ignore -->. Nous expliquerons comment implémenter ces
traits avec des comportements personnalisés et comment créer vos propres traits
au chapitre 10. Il existe aussi de nombreux attributs autres que <code>derive</code> ; pour
en savoir plus, consultez <a href="https://doc.rust-lang.org/reference/attributes.html">la section “Attributs” de la référence de
Rust</a><!-- ignore -->.</p>
<!--
Our `area` function is very specific: it only computes the area of rectangles.
It would be helpful to tie this behavior more closely to our `Rectangle`
struct, because it won’t work with any other type. Let’s look at how we can
continue to refactor this code by turning the `area` function into an `area`
*method* defined on our `Rectangle` type.
-->
<p>Notre fonction <code>aire</code> est très spécifique : elle ne fait que calculer l'aire
d'un rectangle. Il serait utile de lier un peu plus ce comportement à notre
structure <code>Rectangle</code>, puisque cela ne fonctionnera pas avec un autre type.
Voyons comment on peut continuer de remanier ce code en transformant la fonction
<code>aire</code> en <em>méthode</em> <code>aire</code> définie sur notre type <code>Rectangle</code>.</p>
<!--
[the-tuple-type]: ch03-02-data-types.html#the-tuple-type
[app-c]: appendix-03-derivable-traits.md
[println]: ../std/macro.println.html
[dbg]: ../std/macro.dbg.html
[err]: ch12-06-writing-to-stderr-instead-of-stdout.html
[attributes]: ../reference/attributes.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Method Syntax
-->
<h2 id="la-syntaxe-des-méthodes"><a class="header" href="#la-syntaxe-des-méthodes">La syntaxe des méthodes</a></h2>
<!--
*Methods* are similar to functions: they’re declared with the `fn` keyword and
their name, they can have parameters and a return value, and they contain some
code that is run when they’re called from somewhere else. However, methods are
different from functions in that they’re defined within the context of a struct
(or an enum or a trait object, which we cover in Chapters 6 and 17,
respectively), and their first parameter is always `self`, which represents the
instance of the struct the method is being called on.
-->
<p>Les <em>méthodes</em> sont similaires aux fonctions : on les déclare avec le mot-clé
<code>fn</code> et leur nom, elles peuvent avoir des paramètres et une valeur de retour, et
elles contiennent du code qui est exécuté quand on les appelle depuis un autre
endroit. Cependant, les méthodes diffèrent des fonctions parce qu'elles sont
définies dans le contexte d'une structure (ou d'une énumération ou d'un objet de
trait, que nous aborderons respectivement aux chapitres 6 et 17) et que leur
premier paramètre est toujours <code>self</code>, un mot-clé qui représente l'instance de
la structure sur laquelle on appelle la méthode.</p>
<!--
### Defining Methods
-->
<h3 id="définir-des-méthodes"><a class="header" href="#définir-des-méthodes">Définir des méthodes</a></h3>
<!--
Let’s change the `area` function that has a `Rectangle` instance as a parameter
and instead make an `area` method defined on the `Rectangle` struct, as shown
in Listing 5-13.
-->
<p>Remplaçons la fonction <code>aire</code> qui prend une instance de <code>Rectangle</code> en paramètre
par une méthode <code>aire</code> définie sur la structure <code>Rectangle</code>, comme dans
l'encart 5-13.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }
}

fn main() {
    let rect1 = Rectangle { largeur: 30, hauteur: 50 };

    println!(
        &quot;L'aire du rectangle est de {} pixels carrés.&quot;,
        rect1.aire()
    );
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-13: Defining an `area` method on the
`Rectangle` struct</span>
-->
<p><span class="caption">Encart 5-13 : Définition d'une méthode <code>aire</code> sur la
structure <code>Rectangle</code></span></p>
<!--
To define the function within the context of `Rectangle`, we start an `impl`
(implementation) block for `Rectangle`. Everything within this `impl` block
will be associated with the `Rectangle` type. Then we move the `area` function
within the `impl` curly brackets and change the first (and in this case, only)
parameter to be `self` in the signature and everywhere within the body. In
`main`, where we called the `area` function and passed `rect1` as an argument,
we can instead use *method syntax* to call the `area` method on our `Rectangle`
instance. The method syntax goes after an instance: we add a dot followed by
the method name, parentheses, and any arguments.
-->
<p>Pour définir la fonction dans le contexte de <code>Rectangle</code>, nous démarrons un bloc
<code>impl</code> (<em>implémentation</em>) pour <code>Rectangle</code>. Tout ce qui sera dans ce bloc <code>impl</code>
sera lié au type <code>Rectangle</code>. Puis nous déplaçons la fonction <code>aire</code> entre les
accolades du <code>impl</code> et nous remplaçons le premier paramètre (et dans notre cas,
le seul) par <code>self</code> dans la signature et dans tout le corps. Dans <code>main</code>, où
nous avons appelé la fonction <code>aire</code> et passé <code>rect1</code> en argument, nous pouvons
utiliser à la place la <em>syntaxe des méthodes</em> pour appeler la méthode <code>aire</code> sur
notre instance de <code>Rectangle</code>. La syntaxe des méthodes se place après
l'instance : on ajoute un point suivi du nom de la méthode et des parenthèses
contenant les arguments s'il y en a.</p>
<!--
In the signature for `area`, we use `&self` instead of `rectangle: &Rectangle`.
The `&self` is actually short for `self: &Self`. Within an `impl` block, the
type `Self` is an alias for the type that the `impl` block is for. Methods must
have a parameter named `self` of type `Self` for their first parameter, so Rust
lets you abbreviate this with only the name `self` in the first parameter spot.
Note that we still need to use the `&` in front of the `self` shorthand to
indicate this method borrows the `Self` instance, just as we did in `rectangle:
&Rectangle`. Methods can take ownership of `self`, borrow `self` immutably as
we’ve done here, or borrow `self` mutably, just as they can any other parameter.
-->
<p>Dans la signature de <code>aire</code>, nous utilisons <code>&amp;self</code> à la place de
<code>rectangle: &amp;Rectangle</code>. Le <code>&amp;self</code> est un raccourci pour <code>self: &amp;Self</code>. Au
sein d'un bloc <code>impl</code>, le type de <code>Self</code> est un alias pour le type sur lequel
porte le <code>impl</code>. Les méthodes doivent avoir un paramètre <code>self</code> du type <code>Self</code>
comme premier paramètre afin que Rust puisse vous permettre d'abréger en
renseignant uniquement <code>self</code> en premier paramètre. Veuillez noter qu'il nous
faut quand même utiliser le <code>&amp;</code> devant le raccourci <code>self</code>, pour indiquer que
cette méthode emprunte l'instance de <code>Self</code>, comme nous l'avions fait pour
<code>rectangle: &amp;Rectangle</code>. Les méthodes peuvent prendre possession de <code>self</code>,
emprunter <code>self</code> de façon immuable comme nous l'avons fait ici, ou emprunter
<code>self</code> de façon mutable, comme pour n'importe quel autre paramètre.</p>
<!--
We’ve chosen `&self` here for the same reason we used `&Rectangle` in the
function version: we don’t want to take ownership, and we just want to read the
data in the struct, not write to it. If we wanted to change the instance that
we’ve called the method on as part of what the method does, we’d use `&mut
self` as the first parameter. Having a method that takes ownership of the
instance by using just `self` as the first parameter is rare; this technique is
usually used when the method transforms `self` into something else and you want
to prevent the caller from using the original instance after the transformation.
-->
<p>Nous avons choisi <code>&amp;self</code> ici pour la même raison que nous avions utilisé
<code>&amp;Rectangle</code> quand il s'agissait d'une fonction ; nous ne voulons pas en prendre
possession, et nous voulons seulement lire les données de la structure, pas les
modifier. Si nous voulions que la méthode modifie l'instance sur laquelle on
l'appelle, on utiliserait <code>&amp;mut self</code> comme premier paramètre. Il est rare
d'avoir une méthode qui prend possession de l'instance en utilisant uniquement
<code>self</code> comme premier argument ; cette technique est généralement utilisée
lorsque la méthode transforme <code>self</code> en quelque chose d'autre et que vous voulez
empêcher le code appelant d'utiliser l'instance d'origine après la
transformation.</p>
<!--
The main benefit of using methods instead of functions, in addition to using
method syntax and not having to repeat the type of `self` in every method’s
signature, is for organization. We’ve put all the things we can do with an
instance of a type in one `impl` block rather than making future users of our
code search for capabilities of `Rectangle` in various places in the library we
provide.
-->
<p>Outre l'utilisation de la syntaxe des méthodes et le fait de ne pas être obligé
de répéter le type de <code>self</code> dans la signature de chaque méthode, le principal
avantage de l'utilisation de méthodes plutôt que de fonctions est pour
l'organisation. Nous avons mis tout ce qu'on pouvait faire avec une instance de
notre type dans un bloc <code>impl</code> plutôt que d'imposer aux futurs utilisateurs de
notre code à rechercher les fonctionnalités de <code>Rectangle</code> à divers endroits de
la bibliothèque que nous fournissons.</p>
<!--
Note that we can choose to give a method the same name as one of the struct’s
fields. For example, we can define a method on `Rectangle` also named `width`:
-->
<p>Notez que nous pourions faire en sorte qu'une méthode porte le même nom qu'un
des champs de la structure. Par exemple, nous pourions définir une méthode sur
<code>Rectangle</code> qui s'appelle elle aussi <code>largeur</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn largeur(&amp;self) -&gt; bool {
        self.largeur &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        largeur: 30,
        hauteur: 50,
    };

    if rect1.largeur() {
        println!(&quot;Le rectangle a une largeur non nulle ; elle vaut {}&quot;, rect1.largeur);
    }
}
</code></pre></pre>
<!--
Here, we’re choosing to make the behavior of the `width` method be that it
returns `true` if the value in the instance’s `width` field is greater than 0,
and `false` if the value is 0: we can use a field within a method of the same
name for any purpose. In `main`, when we follow `rect1.width` with parentheses,
Rust knows we mean the method `width`. When we don’t use parentheses, Rust
knows we mean the field `width`.
-->
<p>Ici, nous avons choisi de définir le comportement de la méthode <code>largeur</code> pour
qu'elle retourne <code>true</code> si la valeur dans le champ <code>largeur</code> est supérieur ou
égal à 0, et <code>false</code> si la valeur est 0 : nous pouvons utiliser un champ à
l'intérieur d'une méthode du même nom, pour n'importe quel usage. Dans le
<code>main</code>, lorsque nous ajoutons des parenthèses après <code>rect1.largeur</code>, Rust
comprend que nous parlons de la méthode <code>largeur</code>. Lorsque nous n'utilisons pas
les parenthèses, Rust sait nous parlons du champ <code>largeur</code>.</p>
<!--
Often, but not always, methods with the same name as a field will be defined to
only return the value in the field and do nothing else. Methods like this are
called *getters*, and Rust does not implement them automatically for struct
fields as some other languages do. Getters are useful because you can make the
field private but the method public and thus enable read-only access to that
field as part of the type’s public API. We will be discussing what public and
private are and how to designate a field or method as public or private in
Chapter 7.
-->
<p>Souvent, mais pas toujours, les méthodes avec le même nom qu'un champ sont
définies pour retourner uniquement la valeur de ce champ et ne rien faire
d'autre. Ces méthodes sont appelées des <em>accesseurs</em>, et Rust ne les implémente
pas automatiquement pour les champs des structures comme le font certains
langages. Les accesseurs sont utiles pour rendre le champ privé mais rendre
la méthode publique et ainsi donner un accès en lecture seule à ce champ dans
l'API publique de ce type. Nous développerons les notions de publique et privé
et comment définir un champ ou une méthode publique ou privée au chapitre 7.</p>
<!--
> ### Where’s the `->` Operator?
>
> In C and C++, two different operators are used for calling methods: you use
> `.` if you’re calling a method on the object directly and `->` if you’re
> calling the method on a pointer to the object and need to dereference the
> pointer first. In other words, if `object` is a pointer,
> `object->something()` is similar to `(*object).something()`.
>
> Rust doesn’t have an equivalent to the `->` operator; instead, Rust has a
> feature called *automatic referencing and dereferencing*. Calling methods is
> one of the few places in Rust that has this behavior.
>
> Here’s how it works: when you call a method with `object.something()`, Rust
> automatically adds in `&`, `&mut`, or `*` so `object` matches the signature of
> the method. In other words, the following are the same:
>
> <!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -- >
> ```rust
> # #[derive(Debug,Copy,Clone)]
> # struct Point {
> #     x: f64,
> #     y: f64,
> # }
> #
> # impl Point {
> #    fn distance(&self, other: &Point) -> f64 {
> #        let x_squared = f64::powi(other.x - self.x, 2);
> #        let y_squared = f64::powi(other.y - self.y, 2);
> #
> #        f64::sqrt(x_squared + y_squared)
> #    }
> # }
> # let p1 = Point { x: 0.0, y: 0.0 };
> # let p2 = Point { x: 5.0, y: 6.5 };
> p1.distance(&p2);
> (&p1).distance(&p2);
> ```
>
> The first one looks much cleaner. This automatic referencing behavior works
> because methods have a clear receiver—the type of `self`. Given the receiver
> and name of a method, Rust can figure out definitively whether the method is
> reading (`&self`), mutating (`&mut self`), or consuming (`self`). The fact
> that Rust makes borrowing implicit for method receivers is a big part of
> making ownership ergonomic in practice.
-->
<blockquote>
<h3 id="où-est-lopérateur---"><a class="header" href="#où-est-lopérateur---">Où est l'opérateur <code>-&gt;</code> ?</a></h3>
<p>En C et en C++, deux opérateurs différents sont utilisés pour appeler les
méthodes : on utilise <code>.</code> si on appelle une méthode directement sur l'objet
et <code>-&gt;</code> si on appelle la méthode sur un pointeur vers l'objet et qu'il faut
d'abord déréférencer le pointeur. En d'autres termes, si <code>objet</code> est un
pointeur, <code>objet-&gt;methode()</code> est similaire à <code>(*objet).methode()</code>.</p>
<p>Rust n'a pas d'équivalent à l'opérateur <code>-&gt;</code> ; à la place, Rust a une
fonctionnalité appelée <em>référencement et déréférencement automatiques</em>.
L'appel de méthodes est l'un des rares endroits de Rust où on retrouve ce
comportement.</p>
<p>Voilà comment cela fonctionne : quand on appelle une méthode avec
<code>objet.methode()</code>, Rust ajoute automatiquement le <code>&amp;</code>, <code>&amp;mut</code> ou <code>*</code> pour que
<code>objet</code> corresponde à la signature de la méthode. Autrement dit, ces deux
lignes sont identiques :</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, autre: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_carre = f64::powi(autre.x - self.x, 2);
</span><span class="boring">       let y_carre = f64::powi(autre.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_carre + y_carre)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>La première ligne semble bien plus propre. Ce comportement du
(dé)référencement automatique fonctionne parce que les méthodes ont une
cible claire : le type de <code>self</code>. Compte tenu du nom de la méthode et
de l'instance sur laquelle elle s'applique, Rust peut déterminer de manière
irréfutable si la méthode lit (<code>&amp;self</code>), modifie (<code>&amp;mut self</code>) ou consomme
(<code>self</code>) l'instance. Le fait que Rust rend implicite l'emprunt pour les
instances sur lesquelles on appelle les méthodes améliore significativement
l'ergonomie de la possession.</p>
</blockquote>
<!--
### Methods with More Parameters
-->
<h3 id="les-méthodes-avec-davantage-de-paramètres"><a class="header" href="#les-méthodes-avec-davantage-de-paramètres">Les méthodes avec davantage de paramètres</a></h3>
<!--
Let’s practice using methods by implementing a second method on the `Rectangle`
struct. This time, we want an instance of `Rectangle` to take another instance
of `Rectangle` and return `true` if the second `Rectangle` can fit completely
within `self`; otherwise it should return `false`. That is, we want to be able
to write the program shown in Listing 5-14, once we’ve defined the `can_hold`
method.
-->
<p>Entraînons-nous à utiliser des méthodes en implémentant une seconde méthode sur
la structure <code>Rectangle</code>. Cette fois-ci, nous voulons qu'une instance de
<code>Rectangle</code> prenne une autre instance de <code>Rectangle</code> et qu'on retourne <code>true</code> si
le second <code>Rectangle</code> peut se dessiner intégralement à l'intérieur de <code>self</code> ;
sinon, on renverra <code>false</code>. En d'autres termes, on veut pouvoir écrire le
programme de l'encart 5-14 une fois qu'on aura défini la méthode
<code>peut_contenir</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```
-->
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        largeur: 30,
        hauteur: 50
    };
    let rect2 = Rectangle {
        largeur: 10,
        hauteur: 40
    };
    let rect3 = Rectangle {
        largeur: 60,
        hauteur: 45
    };

    println!(&quot;rect1 peut-il contenir rect2 ? {}&quot;, rect1.peut_contenir(&amp;rect2));
    println!(&quot;rect1 peut-il contenir rect3 ? {}&quot;, rect1.peut_contenir(&amp;rect3));
}
</code></pre>
<!--
<span class="caption">Listing 5-14: Using the as-yet-unwritten `can_hold`
method</span>
-->
<p><span class="caption">Encart 5-14 : Utilisation de la méthode <code>peut_contenir</code>
qui reste à écrire</span></p>
<!--
And the expected output would look like the following, because both dimensions
of `rect2` are smaller than the dimensions of `rect1` but `rect3` is wider than
`rect1`:
-->
<p>Et on s'attend à ce que le texte suivant s'affiche, puisque les deux dimensions
de <code>rect2</code> sont plus petites que les dimensions de <code>rect1</code>, mais <code>rect3</code> est
plus large que <code>rect1</code> :</p>
<!--
```text
Can rect1 hold rect2? true
Can rect1 hold rect3? false
```
-->
<pre><code class="language-text">rect1 peut-il contenir rect2 ? true
rect1 peut-il contenir rect3 ? false
</code></pre>
<!--
We know we want to define a method, so it will be within the `impl Rectangle`
block. The method name will be `can_hold`, and it will take an immutable borrow
of another `Rectangle` as a parameter. We can tell what the type of the
parameter will be by looking at the code that calls the method:
`rect1.can_hold(&rect2)` passes in `&rect2`, which is an immutable borrow to
`rect2`, an instance of `Rectangle`. This makes sense because we only need to
read `rect2` (rather than write, which would mean we’d need a mutable borrow),
and we want `main` to retain ownership of `rect2` so we can use it again after
calling the `can_hold` method. The return value of `can_hold` will be a
Boolean, and the implementation will check whether the width and height of
`self` are both greater than the width and height of the other `Rectangle`,
respectively. Let’s add the new `can_hold` method to the `impl` block from
Listing 5-13, shown in Listing 5-15.
-->
<p>Nous voulons définir une méthode, donc elle doit se trouver dans le bloc
<code>impl Rectangle</code>. Le nom de la méthode sera <code>peut_contenir</code> et elle prendra une
référence immuable vers un autre <code>Rectangle</code> en paramètre. On peut déterminer le
type du paramètre en regardant le code qui appelle la méthode :
<code>rect1.peut_contenir(&amp;rect2)</code> prend en argument <code>&amp;rect2</code>, une référence immuable
vers <code>rect2</code>, une instance de <code>Rectangle</code>. Cela est logique puisque nous voulons
uniquement lire <code>rect2</code> (plutôt que de la modifier, ce qui aurait nécessité une
référence mutable) et nous souhaitons que <code>main</code> garde possession de <code>rect2</code>
pour qu'on puisse le réutiliser après avoir appelé la méthode <code>peut_contenir</code>.
La valeur de retour de <code>peut_contenir</code> sera un booléen et l'implémentation de la
méthode vérifiera si la largeur et la hauteur de <code>self</code> sont respectivement plus
grandes que la largeur et la hauteur de l'autre <code>Rectangle</code>. Ajoutons la
nouvelle méthode <code>peut_contenir</code> dans le bloc <code>impl</code> de l'encart 5-13, comme le
montre l'encart 5-15.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
# 
# fn main() {
#     let rect1 = Rectangle {
#         width: 30,
#         height: 50,
#     };
#     let rect2 = Rectangle {
#         width: 10,
#         height: 40,
#     };
#     let rect3 = Rectangle {
#         width: 60,
#         height: 45,
#     };
# 
#     println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
#     println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }

    fn peut_contenir(&amp;self, autre: &amp;Rectangle) -&gt; bool {
        self.largeur &gt; autre.largeur &amp;&amp; self.hauteur &gt; autre.hauteur
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        largeur: 30,
</span><span class="boring">        hauteur: 50
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        largeur: 10,
</span><span class="boring">        hauteur: 40
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        largeur: 60,
</span><span class="boring">        hauteur: 45
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect2 ? {}&quot;, rect1.peut_contenir(&amp;rect2));
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect3 ? {}&quot;, rect1.peut_contenir(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-15: Implementing the `can_hold` method on
`Rectangle` that takes another `Rectangle` instance as a parameter</span>
-->
<p><span class="caption">Encart 5-15 : Implémentation de la méthode <code>peut_contenir</code>
sur <code>Rectangle</code> qui prend une autre instance de <code>Rectangle</code> en paramètre</span></p>
<!--
When we run this code with the `main` function in Listing 5-14, we’ll get our
desired output. Methods can take multiple parameters that we add to the
signature after the `self` parameter, and those parameters work just like
parameters in functions.
-->
<p>Lorsque nous exécutons ce code avec la fonction <code>main</code> de l'encart 5-14, nous
obtenons l'affichage attendu. Les méthodes peuvent prendre plusieurs paramètres
qu'on peut ajouter à la signature après le paramètre <code>self</code>, et ces paramètres
fonctionnent de la même manière que les paramètres des fonctions.</p>
<!--
### Associated Functions
-->
<h3 id="les-fonctions-associées"><a class="header" href="#les-fonctions-associées">Les fonctions associées</a></h3>
<!--
All functions defined within an `impl` block are called *associated functions*
because they’re associated with the type named after the `impl`. We can define
associated functions that don’t have `self` as their first parameter (and thus
are not methods) because they don’t need an instance of the type to work with.
We’ve already used one function like this, the `String::from` function, that’s
defined on the `String` type.
-->
<p>Toutes les fonctions définies dans un bloc <code>impl</code> s'appellent des <em>fonctions
associées</em> car elles sont associées au type renseigné après le <code>impl</code>. Nous
pouvons aussi y définir des fonctions associées qui n'ont pas de <code>self</code> en
premier paramètre (et donc ce ne sont pas des méthodes) car elles n'ont pas
besoin d'une instance du type sur lequel elles travaillent. Nous avons déjà
utilisé une fonction comme celle-ci, la fonction <code>String::from</code>, qui est définie
sur le type <code>String</code>.</p>
<!--
Associated functions that aren’t methods are often used for constructors that
will return a new instance of the struct. For example, we could provide an
associated function that would have one dimension parameter and use that as
both width and height, thus making it easier to create a square `Rectangle`
rather than having to specify the same value twice:
-->
<p>Les fonctions associées qui ne ne sont pas des méthodes sont souvent utilisées
comme constructeurs qui vont retourner une nouvelle instance de la structure.
Par exemple, on pourrait écrire une fonction associée qui prend une unique
dimension en paramètre et l'utilise à la fois pour la largeur et pour la
hauteur, ce qui rend plus aisé la création d'un <code>Rectangle</code> carré plutôt que
d'avoir à indiquer la même valeur deux fois :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
# 
# fn main() {
#     let sq = Rectangle::square(3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn carre(cote: u32) -&gt; Rectangle {
        Rectangle {
            largeur: cote,
            hauteur: cote
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mon_carre = Rectangle::carre(3);
</span><span class="boring">}
</span></code></pre></pre>
<!--
To call this associated function, we use the `::` syntax with the struct name;
`let sq = Rectangle::square(3);` is an example. This function is namespaced by
the struct: the `::` syntax is used for both associated functions and
namespaces created by modules. We’ll discuss modules in Chapter 7.
-->
<p>Pour appeler cette fonction associée, on utilise la syntaxe <code>::</code> avec le nom de
la structure ; <code>let mon_carre = Rectangle::carre(3);</code> en est un exemple. Cette
fonction est cloisonnée dans l'espace de noms de la structure : la syntaxe <code>::</code>
s'utilise aussi bien pour les fonctions associées que pour les espaces de noms
créés par des modules. Nous aborderons les modules au chapitre 7.</p>
<!--
### Multiple `impl` Blocks
-->
<h3 id="plusieurs-blocs-impl"><a class="header" href="#plusieurs-blocs-impl">Plusieurs blocs <code>impl</code></a></h3>
<!--
Each struct is allowed to have multiple `impl` blocks. For example, Listing
5-15 is equivalent to the code shown in Listing 5-16, which has each method
in its own `impl` block.
-->
<p>Chaque structure peut avoir plusieurs blocs <code>impl</code>. Par exemple, l'encart 5-15
est équivalent au code de l'encart 5-16, où chaque méthode est dans son propre
bloc <code>impl</code>.</p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
# 
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
# 
# fn main() {
#     let rect1 = Rectangle {
#         width: 30,
#         height: 50,
#     };
#     let rect2 = Rectangle {
#         width: 10,
#         height: 40,
#     };
#     let rect3 = Rectangle {
#         width: 60,
#         height: 45,
#     };
# 
#     println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
#     println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }
}

impl Rectangle {
    fn peut_contenir(&amp;self, autre: &amp;Rectangle) -&gt; bool {
        self.largeur &gt; autre.largeur &amp;&amp; self.hauteur &gt; autre.hauteur
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        largeur: 30,
</span><span class="boring">        hauteur: 50
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        largeur: 10,
</span><span class="boring">        hauteur: 40
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        largeur: 60,
</span><span class="boring">        hauteur: 45
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect2 ? {}&quot;, rect1.peut_contenir(&amp;rect2));
</span><span class="boring">    println!(&quot;rect1 peut-il contenir rect3 ? {}&quot;, rect1.peut_contenir(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-16: Rewriting Listing 5-15 using multiple `impl`
blocks</span>
-->
<p><span class="caption">Encart 5-16 : Réécriture de l'encart 5-15 en utilisant
plusieurs blocs <code>impl</code></span></p>
<!--
There’s no reason to separate these methods into multiple `impl` blocks here,
but this is valid syntax. We’ll see a case in which multiple `impl` blocks are
useful in Chapter 10, where we discuss generic types and traits.
-->
<p>Il n'y a aucune raison de séparer ces méthodes dans plusieurs blocs <code>impl</code> dans
notre exemple, mais c'est une syntaxe valide. Nous verrons un exemple de
l'utilité d'avoir plusieurs blocs <code>impl</code> au chapitre 10, où nous aborderons les
types génériques et les traits.</p>
<!--
## Summary
-->
<h2 id="résumé-4"><a class="header" href="#résumé-4">Résumé</a></h2>
<!--
Structs let you create custom types that are meaningful for your domain. By
using structs, you can keep associated pieces of data connected to each other
and name each piece to make your code clear. In `impl` blocks, you can define
functions that are associated with your type, and methods are a kind of
associated function that let you specify the behavior that instances of your
structs have.
-->
<p>Les structures vous permettent de créer des types personnalisés significatifs
pour votre domaine. En utilisant des structures, on peut relier entre elles
des données associées et nommer chaque donnée pour rendre le code plus clair.
Dans des blocs <code>impl</code>, vous pouvez définir des fonctions qui sont associées à
votre type, et les méthodes sont un genre de fonction associée qui vous permet
de renseigner le comportement que doivent suivre les instances de votre
structure.</p>
<!--
But structs aren’t the only way you can create custom types: let’s turn to
Rust’s enum feature to add another tool to your toolbox.
-->
<p>Mais les structures ne sont pas le seul moyen de créer des types personnalisés :
nous allons maintenant voir les énumérations de Rust, une fonctionnalité que
vous pourrez bientôt ajouter à votre boîte à outils.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Enums and Pattern Matching
-->
<h1 id="les-énumérations-et-le-filtrage-par-motif"><a class="header" href="#les-énumérations-et-le-filtrage-par-motif">Les énumérations et le filtrage par motif</a></h1>
<!--
In this chapter we’ll look at *enumerations*, also referred to as *enums*.
Enums allow you to define a type by enumerating its possible *variants*. First,
we’ll define and use an enum to show how an enum can encode meaning along with
data. Next, we’ll explore a particularly useful enum, called `Option`, which
expresses that a value can be either something or nothing. Then we’ll look at
how pattern matching in the `match` expression makes it easy to run different
code for different values of an enum. Finally, we’ll cover how the `if let`
construct is another convenient and concise idiom available to you to handle
enums in your code.
-->
<p>Dans ce chapitre, nous allons aborder les <em>énumérations</em>, aussi appelées
<em>enums</em>. Les énumérations vous permettent de définir un type en énumérant ses
<em>variantes</em> possibles. Pour commencer, nous allons définir et utiliser une
énumération pour voir comment une énumération peut donner du sens aux données.
Ensuite, nous examinerons une énumération particulièrement utile qui s'appelle
<code>Option</code> et qui permet de décrire des situations où la valeur peut être soit
quelque chose, soit rien. Ensuite, nous regarderons comment le filtrage par
motif avec l'expression <code>match</code> peut faciliter l'exécution de codes différents
pour chaque valeur d'une énumération. Enfin, nous analyserons pourquoi la
construction <code>if let</code> est un autre outil commode et concis à votre disposition
pour traiter les énumérations dans votre code.</p>
<!--
Enums are a feature in many languages, but their capabilities differ in each
language. Rust’s enums are most similar to *algebraic data types* in functional
languages, such as F#, OCaml, and Haskell.
-->
<p>Les énumérations sont des fonctionnalités présentes dans de nombreux langages,
mais leurs aptitudes varient d'un langage à l'autre. Les énumérations de Rust
sont plus proches des <em>types de données algébriques</em> des langages fonctionnels,
comme F#, OCaml et Haskell.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Defining an Enum
-->
<h2 id="définir-une-énumération"><a class="header" href="#définir-une-énumération">Définir une énumération</a></h2>
<!--
Let’s look at a situation we might want to express in code and see why enums
are useful and more appropriate than structs in this case. Say we need to work
with IP addresses. Currently, two major standards are used for IP addresses:
version four and version six. These are the only possibilities for an IP
address that our program will come across: we can *enumerate* all possible
variants, which is where enumeration gets its name.
-->
<p>Imaginons une situation que nous voudrions exprimer avec du code et regardons
pourquoi les énumérations sont utiles et plus appropriées que les structures
dans ce cas. Disons que nous avons besoin de travailler avec des adresses IP.
Pour le moment, il existe deux normes principales pour les adresses IP : la
version quatre et la version six. Ce seront les seules possibilités d'adresse
IP que notre programme va rencontrer : nous pouvons <em>énumérer</em> toutes les
variantes possibles, d'où vient le nom de l'énumération.</p>
<!--
Any IP address can be either a version four or a version six address, but not
both at the same time. That property of IP addresses makes the enum data
structure appropriate, because enum values can only be one of its variants.
Both version four and version six addresses are still fundamentally IP
addresses, so they should be treated as the same type when the code is handling
situations that apply to any kind of IP address.
-->
<p>N'importe quelle adresse IP peut être soit une adresse en version quatre, soit
en version six, mais pas les deux en même temps. Cette propriété des adresses IP
est appropriée à la structure de données d'énumérations, car les valeurs de
l'énumération ne peuvent être qu'une de ses variantes. Les adresses en version
quatre et six sont toujours fondamentalement des adresses IP, donc elles doivent
être traitées comme étant du même type lorsque le code travaille avec des
situations qui s'appliquent à n'importe quelle sorte d'adresse IP.</p>
<!--
We can express this concept in code by defining an `IpAddrKind` enumeration and
listing the possible kinds an IP address can be, `V4` and `V6`. These are the
variants of the enum:
-->
<p>Nous pouvons exprimer ce concept dans le code en définissant une énumération
<code>SorteAdresseIp</code> et en listant les différentes sortes possibles d'adresses IP
qu'elle peut avoir, <code>V4</code> et <code>V6</code>. Ce sont les variantes de l'énumération :</p>
<!--
```rust
enum IpAddrKind {
    V4,
    V6,
}
# 
# fn main() {
#     let four = IpAddrKind::V4;
#     let six = IpAddrKind::V6;
# 
#     route(IpAddrKind::V4);
#     route(IpAddrKind::V6);
# }
# 
# fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust">enum SorteAdresseIp {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let quatre = SorteAdresseIp::V4;
</span><span class="boring">    let six = SorteAdresseIp::V6;
</span><span class="boring">
</span><span class="boring">    router(SorteAdresseIp::V4);
</span><span class="boring">    router(SorteAdresseIp::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn router(sorte_ip: SorteAdresseIp) { }
</span></code></pre></pre>
<!--
`IpAddrKind` is now a custom data type that we can use elsewhere in our code.
-->
<p><code>SorteAdresseIp</code> est maintenant un type de données personnalisé que nous pouvons
utiliser n'importe où dans notre code.</p>
<!--
### Enum Values
-->
<h3 id="les-valeurs-dénumérations"><a class="header" href="#les-valeurs-dénumérations">Les valeurs d'énumérations</a></h3>
<!--
We can create instances of each of the two variants of `IpAddrKind` like this:
-->
<p>Nous pouvons créer des instances de chacune des deux variantes de
<code>SorteAdresseIp</code> de cette manière :</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
# 
# fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
# 
#     route(IpAddrKind::V4);
#     route(IpAddrKind::V6);
# }
# 
# fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let quatre = SorteAdresseIp::V4;
    let six = SorteAdresseIp::V6;
<span class="boring">
</span><span class="boring">    router(SorteAdresseIp::V4);
</span><span class="boring">    router(SorteAdresseIp::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn router(sorte_ip: SorteAdresseIp) { }
</span></code></pre></pre>
<!--
Note that the variants of the enum are namespaced under its identifier, and we
use a double colon to separate the two. The reason this is useful is that now
both values `IpAddrKind::V4` and `IpAddrKind::V6` are of the same type:
`IpAddrKind`. We can then, for instance, define a function that takes any
`IpAddrKind`:
-->
<p>Remarquez que les variantes de l'énumération sont dans un espace de nom qui se
situe avant leur nom, et nous utilisons un double deux-points pour les séparer
tous les deux. C'est utile car maintenant les deux valeurs <code>SorteAdresseIp::V4</code>
et <code>SorteAdresseIp::V6</code> sont du même type : <code>SorteAdresseIp</code>. Ensuite, nous
pouvons, par exemple, définir une fonction qui accepte n'importe quelle
<code>SorteAdresseIp</code> :</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
# 
# fn main() {
#     let four = IpAddrKind::V4;
#     let six = IpAddrKind::V6;
# 
#     route(IpAddrKind::V4);
#     route(IpAddrKind::V6);
# }
# 
fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let quatre = SorteAdresseIp::V4;
</span><span class="boring">    let six = SorteAdresseIp::V6;
</span><span class="boring">
</span><span class="boring">    router(SorteAdresseIp::V4);
</span><span class="boring">    router(SorteAdresseIp::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn router(sorte_ip: SorteAdresseIp) { }
</code></pre></pre>
<!--
And we can call this function with either variant:
-->
<p>Et nous pouvons appeler cette fonction avec chacune des variantes :</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
# 
# fn main() {
#     let four = IpAddrKind::V4;
#     let six = IpAddrKind::V6;
# 
    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
# }
# 
# fn route(ip_kind: IpAddrKind) {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let quatre = SorteAdresseIp::V4;
</span><span class="boring">    let six = SorteAdresseIp::V6;
</span><span class="boring">
</span>    router(SorteAdresseIp::V4);
    router(SorteAdresseIp::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn router(sorte_ip: SorteAdresseIp) { }
</span></code></pre></pre>
<!--
Using enums has even more advantages. Thinking more about our IP address type,
at the moment we don’t have a way to store the actual IP address *data*; we
only know what *kind* it is. Given that you just learned about structs in
Chapter 5, you might tackle this problem as shown in Listing 6-1.
-->
<p>L'utilisation des énumérations a encore plus d'avantages. En étudiant un peu
plus notre type d'adresse IP, nous constatons que pour le moment, nous ne
pouvons pas stocker <em>la donnée</em> de l'adresse IP ; nous savons seulement de
quelle sorte elle est. Avec ce que vous avez appris au chapitre 5, vous pouvez
résoudre ce problème comme dans l'encart 6-1.</p>
<!--
```rust
# fn main() {
    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum SorteAdresseIp {
        V4,
        V6,
    }

    struct AdresseIp {
        sorte: SorteAdresseIp,
        adresse: String,
    }

    let local = AdresseIp {
        sorte: SorteAdresseIp::V4,
        adresse: String::from(&quot;127.0.0.1&quot;),
    };
    
    let rebouclage = AdresseIp {
        sorte: SorteAdresseIp::V6,
        adresse: String::from(&quot;::1&quot;),
    };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-1: Storing the data and `IpAddrKind` variant of
an IP address using a `struct`</span>
-->
<p><span class="caption">Encart 6-1 : Stockage de la donnée et de la variante de
<code>SorteAdresseIp</code> d'une adresse IP en utilisant une <code>struct</code></span></p>
<!--
Here, we’ve defined a struct `IpAddr` that has two fields: a `kind` field that
is of type `IpAddrKind` (the enum we defined previously) and an `address` field
of type `String`. We have two instances of this struct. The first, `home`, has
the value `IpAddrKind::V4` as its `kind` with associated address data of
`127.0.0.1`. The second instance, `loopback`, has the other variant of
`IpAddrKind` as its `kind` value, `V6`, and has address `::1` associated with
it. We’ve used a struct to bundle the `kind` and `address` values together, so
now the variant is associated with the value.
-->
<p>Ainsi, nous avons défini une structure <code>AdresseIp</code> qui a deux champs : un champ
<code>sorte</code> qui est du type <code>SorteAdresseIp</code> (l'énumération que nous avons définie
précédemment) et un champ <code>adresse</code> qui est du type <code>String</code>. Nous avons deux
instances de cette structure. La première, <code>local</code>, a la valeur
<code>SorteAdresseIp::V4</code> pour son champ <code>sorte</code>, associé à la donnée d'adresse qui
est <code>127.0.0.1</code>. La seconde instance, <code>rebouclage</code>, a comme valeur de champ
<code>sorte</code> l'autre variante de <code>SorteAdresseIp</code>, <code>V6</code>, et a l'adresse<code>::1</code> qui lui
est associée. Nous avons utilisé une structure pour relier ensemble la <code>sorte</code>
et l'<code>adresse</code>, donc maintenant la variante est liée à la valeur.</p>
<!--
We can represent the same concept in a more concise way using just an enum,
rather than an enum inside a struct, by putting data directly into each enum
variant. This new definition of the `IpAddr` enum says that both `V4` and `V6`
variants will have associated `String` values:
-->
<p>Nous pouvons appliquer le même principe de manière plus concise en utilisant
uniquement une énumération, plutôt que d'utiliser une énumération dans une
structure, en insérant directement la donnée dans chaque variante de
l'énumération. Cette nouvelle définition de l'énumération <code>AdresseIp</code> indique
que chacune des variantes <code>V4</code> et <code>V6</code> auront des valeurs associées de type
<code>String</code> :</p>
<!--
```rust
# fn main() {
    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum AdresseIp {
        V4(String),
        V6(String),
    }
    
    let local = AdresseIp::V4(String::from(&quot;127.0.0.1&quot;));
    
    let rebouclage = AdresseIp::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<!--
We attach data to each variant of the enum directly, so there is no need for an
extra struct. Here it’s also easier to see another detail of how enums work:
the name of each enum variant that we define also becomes a function that
constructs an instance of the enum. That is, `IpAddr::V4()` is a function call
that takes a `String` argument and returns an instance of the `IpAddr` type. We
automatically get this constructor function defined as a result of defining the
enum.
-->
<p>Nous relions les données de chaque variante directement à l'énumération, donc il
n'est pas nécessaire d'avoir une structure en plus. Ceci nous permet de voir
plus facilement un détail de fonctionnement des énumérations : le nom de chaque
variante d'énumération que nous définissons devient aussi une fonction qui
construit une instance de l'énumération. Ainsi, <code>AdresseIp::V4()</code> est un appel
de fonction qui prend une <code>String</code> en argument et qui retourne une instance du
type <code>AdresseIp</code>. Nous obtenons automatiquement cette fonction de constructeur
qui est définie lorsque nous définissons l'énumération.</p>
<!--
There’s another advantage to using an enum rather than a struct: each variant
can have different types and amounts of associated data. Version four type IP
addresses will always have four numeric components that will have values
between 0 and 255. If we wanted to store `V4` addresses as four `u8` values but
still express `V6` addresses as one `String` value, we wouldn’t be able to with
a struct. Enums handle this case with ease:
-->
<p>Il y a un autre avantage à utiliser une énumération plutôt qu'une structure :
chaque variante peut stocker des types différents, et aussi avoir une quantité
différente de données associées. Les adresses IP version quatre vont toujours
avoir quatre composantes numériques qui auront une valeur entre 0 et 255. Si
nous voulions stocker les adresses <code>V4</code> avec quatre valeurs de type <code>u8</code> mais
continuer à stocker les adresses <code>V6</code> dans une <code>String</code>, nous ne pourrions pas
le faire avec une structure. Les énumérations permettent de faire cela
facilement :</p>
<!--
```rust
# fn main() {
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum AdresseIp {
        V4(u8, u8, u8, u8),
        V6(String),
    }
    
    let local = AdresseIp::V4(127, 0, 0, 1);
    
    let rebouclage = AdresseIp::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<!--
We’ve shown several different ways to define data structures to store version
four and version six IP addresses. However, as it turns out, wanting to store
IP addresses and encode which kind they are is so common that [the standard
library has a definition we can use!][IpAddr]<!-- ignore -- > Let’s look at how
the standard library defines `IpAddr`: it has the exact enum and variants that
we’ve defined and used, but it embeds the address data inside the variants in
the form of two different structs, which are defined differently for each
variant:
-->
<p>Nous avons vu différentes manières de définir des structures de données pour
enregistrer des adresses IP en version quatre et version six. Cependant, il
s'avère que vouloir stocker des adresses IP et identifier de quelle sorte elles
sont est si fréquent que <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">la bibliothèque standard a une définition que nous
pouvons utiliser !</a><!-- ignore --> Analysons comment la bibliothèque
standard a défini <code>IpAddr</code> (l'équivalent de notre <code>AdresseIp</code>) : nous retrouvons
la même énumération et les variantes que nous avons définies et utilisées, mais
stocke les données d'adresse dans des variantes dans deux structures
différentes, qui sont définies chacune pour chaque variante :</p>
<!--
[IpAddr]: ../std/net/enum.IpAddr.html
-->
<!--
```rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // -- code masqué ici --
}

struct Ipv6Addr {
    // -- code masqué ici --
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code illustrates that you can put any kind of data inside an enum variant:
strings, numeric types, or structs, for example. You can even include another
enum! Also, standard library types are often not much more complicated than
what you might come up with.
-->
<p>Ce code montre comment vous pouvez insérer n'importe quel type de données dans
une variante d'énumération : des chaînes de caractères, des nombres ou des
structures, par exemple. Vous pouvez même y intégrer d'autres énumérations ! Par
ailleurs, les types de la bibliothèque standard ne sont parfois pas plus
compliqués que ce que vous pourriez inventer.</p>
<!--
Note that even though the standard library contains a definition for `IpAddr`,
we can still create and use our own definition without conflict because we
haven’t brought the standard library’s definition into our scope. We’ll talk
more about bringing types into scope in Chapter 7.
-->
<p>Notez aussi que même si la bibliothèque standard embarque une définition de
<code>IpAddr</code>, nous pouvons quand même créer et utiliser notre propre définition de
ce type sans avoir de conflit de nom car nous n'avons pas importé cette
définition de la bibliothèque standard dans la portée. Nous verrons plus en
détail comment importer les types dans la portée au chapitre 7.</p>
<!--
Let’s look at another example of an enum in Listing 6-2: this one has a wide
variety of types embedded in its variants.
-->
<p>Analysons un autre exemple d'une énumération dans l'encart 6-2 : celle-ci a une
grande diversité de types dans ses variantes.</p>
<!--
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-2: A `Message` enum whose variants each store
different amounts and types of values</span>
-->
<p><span class="caption">Encart 6-2 : Une énumération <code>Message</code> dont chaque
variante stocke des valeurs de différents types et en différentes
quantités</span></p>
<!--
This enum has four variants with different types:
-->
<p>Cette énumération a quatre variantes avec des types différents :</p>
<!--
* `Quit` has no data associated with it at all.
* `Move` has named fields like a struct does.
* `Write` includes a single `String`.
* `ChangeColor` includes three `i32` values.
-->
<ul>
<li><code>Quitter</code> n'a pas du tout de donnée associée.</li>
<li><code>Deplacer</code> intègre une structure anonyme en son sein.</li>
<li><code>Ecrire</code> intègre une seule <code>String</code>.</li>
<li><code>ChangerCouleur</code> intègre trois valeurs de type <code>i32</code>.</li>
</ul>
<!--
Defining an enum with variants such as the ones in Listing 6-2 is similar to
defining different kinds of struct definitions, except the enum doesn’t use the
`struct` keyword and all the variants are grouped together under the `Message`
type. The following structs could hold the same data that the preceding enum
variants hold:
-->
<p>Définir une énumération avec des variantes comme celles dans l'encart 6-2
ressemble à la définition de différentes sortes de structures, sauf que
l'énumération n'utilise pas le mot-clé <code>struct</code> et que toutes les variantes sont
regroupées ensemble sous le type <code>Message</code>. Les structures suivantes peuvent
stocker les mêmes données que celles stockées par les variantes précédentes :</p>
<!--
```rust
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct MessageQuitter; // une structure unité
struct MessageDeplacer {
    x: i32,
    y: i32,
}
struct MessageEcrire(String); // une structure tuple
struct MessageChangerCouleur(i32, i32, i32); // une structure tuple
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
But if we used the different structs, which each have their own type, we
couldn’t as easily define a function to take any of these kinds of messages as
we could with the `Message` enum defined in Listing 6-2, which is a single type.
-->
<p>Mais si nous utilisions les différentes structures, qui ont chacune leur propre
type, nous ne pourrions pas définir facilement une fonction qui prend en
paramètre toutes les sortes de messages, tel que nous pourrions le faire avec
l'énumération <code>Message</code> que nous avons définie dans l'encart 6-2, qui est un
seul type.</p>
<!--
There is one more similarity between enums and structs: just as we’re able to
define methods on structs using `impl`, we’re also able to define methods on
enums. Here’s a method named `call` that we could define on our `Message` enum:
-->
<p>Il y a un autre point commun entre les énumérations et les structures : tout
comme on peut définir des méthodes sur les structures en utilisant <code>impl</code>, on
peut aussi définir des méthodes sur des énumérations. Voici une méthode appelée
<code>appeler</code> que nous pouvons définir sur notre énumération <code>Message</code> :</p>
<!--
```rust
# fn main() {
#     enum Message {
#         Quit,
#         Move { x: i32, y: i32 },
#         Write(String),
#         ChangeColor(i32, i32, i32),
#     }
# 
    impl Message {
        fn call(&self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quitter,
</span><span class="boring">        Deplacer { x: i32, y: i32 },
</span><span class="boring">        Ecrire(String),
</span><span class="boring">        ChangerCouleur(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn appeler(&amp;self) {
            // le corps de la méthode sera défini ici
        }
    }
    
    let m = Message::Ecrire(String::from(&quot;hello&quot;));
    m.appeler();
<span class="boring">}
</span></code></pre></pre>
<!--
The body of the method would use `self` to get the value that we called the
method on. In this example, we’ve created a variable `m` that has the value
`Message::Write(String::from("hello"))`, and that is what `self` will be in the
body of the `call` method when `m.call()` runs.
-->
<p>Le corps de la méthode va utiliser <code>self</code> pour obtenir la valeur sur laquelle
nous avons utilisé la méthode. Dans cet exemple, nous avons créé une variable
<code>m</code> qui a la valeur <code>Message::Ecrire(String::from(&quot;hello&quot;))</code>, et cela sera ce
que <code>self</code> aura comme valeur dans le corps de la méthode <code>appeler</code> quand nous
lancerons <code>m.appeler()</code>.</p>
<!--
Let’s look at another enum in the standard library that is very common and
useful: `Option`.
-->
<p>Regardons maintenant une autre énumération de la bibliothèque standard qui est
très utilisée et utile : <code>Option</code>.</p>
<!--
### The `Option` Enum and Its Advantages Over Null Values
-->
<h3 id="lénumération-option-et-ses-avantages-par-rapport-à-la-valeur-null"><a class="header" href="#lénumération-option-et-ses-avantages-par-rapport-à-la-valeur-null">L'énumération <code>Option</code> et ses avantages par rapport à la valeur null</a></h3>
<!--
In the previous section, we looked at how the `IpAddr` enum let us use Rust’s
type system to encode more information than just the data into our program.
This section explores a case study of `Option`, which is another enum defined
by the standard library. The `Option` type is used in many places because it
encodes the very common scenario in which a value could be something or it
could be nothing. Expressing this concept in terms of the type system means the
compiler can check whether you’ve handled all the cases you should be handling;
this functionality can prevent bugs that are extremely common in other
programming languages.
-->
<p>Dans la section précédente, nous avons découvert comment l'énumération
<code>AdresseIp</code> nous permet d'utiliser le système de types de Rust pour enregistrer
dans nos programmes encore plus d'informations qu'uniquement la donnée. Cette
section étudie le cas de <code>Option</code>, qui est une autre énumération définie dans la
bibliothèque standard. Le type <code>Option</code> est utilisé dans de nombreux endroits
car il décrit un scénario très courant où une valeur peut être soit quelque
chose, soit rien du tout. Exprimer ce concept avec le système de types implique
que le compilateur peut vérifier si vous avez géré tous les cas que vous
pourriez rencontrer ; cette fonctionnalité peut éviter des bogues qui sont très
courants dans d'autres langages de programmation.</p>
<!--
Programming language design is often thought of in terms of which features you
include, but the features you exclude are important too. Rust doesn’t have the
null feature that many other languages have. *Null* is a value that means there
is no value there. In languages with null, variables can always be in one of
two states: null or not-null.
-->
<p>La conception d'un langage de programmation est souvent pensée en fonction des
fonctionnalités qu'on inclut, mais les fonctionnalités qu'on refuse sont elles
aussi importantes. Rust n'a pas de fonctionnalité <em>null</em> qu'ont de nombreux
langages. <em>Null</em> est une valeur qui signifie qu'il n'y a pas de valeur à cet
endroit. Avec les langages qui utilisent null, les variables peuvent toujours
être dans deux états : null ou non null.</p>
<!--
In his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony
Hoare, the inventor of null, has this to say:
-->
<p>Dans sa thèse de 2009 “Null References: The Billion Dollar Mistake” (les
références nulles : l'erreur à un milliard de dollars), Tony Hoare, l'inventeur
de null, a écrit ceci :</p>
<!--
> I call it my billion-dollar mistake. At that time, I was designing the first
> comprehensive type system for references in an object-oriented language. My
> goal was to ensure that all use of references should be absolutely safe, with
> checking performed automatically by the compiler. But I couldn’t resist the
> temptation to put in a null reference, simply because it was so easy to
> implement. This has led to innumerable errors, vulnerabilities, and system
> crashes, which have probably caused a billion dollars of pain and damage in
> the last forty years.
-->
<blockquote>
<p>Je l'appelle mon erreur à un milliard de dollars. À cette époque, je concevais
le premier système de type complet pour des références dans un langage orienté
objet. Mon objectif était de garantir que toutes les utilisations des
références soient totalement sûres, et soient vérifiées automatiquement par le
compilateur. Mais je n'ai pas pu résister à la tentation d'inclure la
référence nulle, simplement parce que c'était si simple à implémenter. Cela a
conduit à d'innombrables erreurs, vulnérabilités, et pannes systèmes, qui ont
probablement causé un milliard de dollars de dommages au cours des quarante
dernières années.</p>
</blockquote>
<!--
The problem with null values is that if you try to use a null value as a
not-null value, you’ll get an error of some kind. Because this null or not-null
property is pervasive, it’s extremely easy to make this kind of error.
-->
<p>Le problème avec les valeurs nulles, c'est que si vous essayez d'utiliser une
valeur nulle comme si elle n'était pas nulle, vous obtiendrez une erreur d'une
façon ou d'une autre. Comme cette propriété nulle ou non nulle est omniprésente,
il est très facile de faire cette erreur.</p>
<!--
However, the concept that null is trying to express is still a useful one: a
null is a value that is currently invalid or absent for some reason.
-->
<p>Cependant, le concept que null essaye d'exprimer reste utile : une valeur nulle
est une valeur qui est actuellement invalide ou absente pour une raison ou une
autre.</p>
<!--
The problem isn’t really with the concept but with the particular
implementation. As such, Rust does not have nulls, but it does have an enum
that can encode the concept of a value being present or absent. This enum is
`Option<T>`, and it is [defined by the standard library][option]<!-- ignore -- >
as follows:
-->
<p>Le problème ne vient pas vraiment du concept, mais de son implémentation. C'est
pourquoi Rust n'a pas de valeurs nulles, mais il a une énumération qui décrit le
concept d'une valeur qui peut être soit présente, soit absente. Cette
énumération est <code>Option&lt;T&gt;</code>, et elle est <a href="https://doc.rust-lang.org/std/option/enum.Option.html">définie dans la bibliothèque
standard</a><!-- ignore --> comme ci-dessous :</p>
<!--
[option]: ../std/option/enum.Option.html
-->
<!--
```rust
enum Option<T> {
    None,
    Some(T),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `Option<T>` enum is so useful that it’s even included in the prelude; you
don’t need to bring it into scope explicitly. In addition, so are its variants:
you can use `Some` and `None` directly without the `Option::` prefix. The
`Option<T>` enum is still just a regular enum, and `Some(T)` and `None` are
still variants of type `Option<T>`.
-->
<p>L'énumération <code>Option&lt;T&gt;</code> est tellement utile qu'elle est intégrée dans l'étape
préliminaire ; vous n'avez pas besoin de l'importer explicitement dans la
portée. De plus, voici ses variantes : vous pouvez utiliser directement <code>Some</code>
(<em>quelque chose</em>) et <code>None</code> (<em>rien</em>) sans les préfixer par <code>Option::</code>.
L'énumération <code>Option&lt;T&gt;</code> reste une énumération normale, et <code>Some(T)</code> ainsi que
<code>None</code> sont toujours des variantes de type <code>Option&lt;T&gt;</code>.</p>
<!--
The `<T>` syntax is a feature of Rust we haven’t talked about yet. It’s a
generic type parameter, and we’ll cover generics in more detail in Chapter 10.
For now, all you need to know is that `<T>` means the `Some` variant of the
`Option` enum can hold one piece of data of any type, and that each concrete
type that gets used in place of `T` makes the overall `Option<T>` type a
different type. Here are some examples of using `Option` values to hold number
types and string types:
-->
<p>La syntaxe <code>&lt;T&gt;</code> est une fonctionnalité de Rust que nous n'avons pas encore
abordée. Il s'agit d'un paramètre de type générique, et nous verrons la
généricité plus en détail au chapitre 10. Pour le moment, dites-vous que ce
<code>&lt;T&gt;</code> signifie que la variante <code>Some</code> de l'énumération <code>Option</code> peut stocker un
élément de donnée de n'importe quel type, et que chaque type concret qui est
utilisé à la place du <code>T</code> transforme tout le type <code>Option&lt;T&gt;</code> en un type
différent. Voici quelques exemples d'utilisation de valeurs de <code>Option</code> pour
stocker des types de nombres et des types de chaînes de caractères :</p>
<!--
```rust
# fn main() {
    let some_number = Some(5);
    let some_string = Some("a string");

    let absent_number: Option<i32> = None;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let un_nombre = Some(5);
    let une_chaine = Some(&quot;une chaîne&quot;);

    let nombre_absent: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<!--
The type of `some_number` is `Option<i32>`. The type of `some_string` is
`Option<&str>`, which is a different type. Rust can infer these types because
we’ve specified a value inside the `Some` variant. For `absent_number`, Rust
requires us to annotate the overall `Option` type: the compiler can’t infer the
type that the corresponding `Some` variant will hold by looking only at a
`None` value. Here, we tell Rust that we mean for `absent_number` to be of type
`Option<i32>`.
-->
<p>La variable <code>un_nombre</code> est du type <code>Option&lt;i32&gt;</code>. Mais la variable <code>une_chaine</code>
est du type <code>Option&lt;&amp;str&gt;</code>, qui est un tout autre type. Rust peut déduire ces
types car nous avons renseigné une valeur dans la variante <code>Some</code>. Pour
<code>nombre_absent</code>, Rust nécessite que nous annotions le type de tout le <code>Option</code> :
le compilateur ne peut pas déduire le type qui devrait être stocké dans la
variante <code>Some</code> à partir de la valeur <code>None</code>. Ici, nous avons renseigné à Rust
que nous voulions que <code>nombre_absent</code> soit du type <code>Option&lt;i32&gt;</code>.</p>
<!--
When we have a `Some` value, we know that a value is present and the value is
held within the `Some`. When we have a `None` value, in some sense, it means
the same thing as null: we don’t have a valid value. So why is having
`Option<T>` any better than having null?
-->
<p>Lorsque nous avons une valeur <code>Some</code>, nous savons que la valeur est présente et
que la valeur est stockée dans le <code>Some</code>. Lorsque nous avons une valeur <code>None</code>,
en quelque sorte, cela veut dire la même chose que null : nous n'avons pas une
valeur valide. Donc pourquoi obtenir <code>Option&lt;T&gt;</code> est meilleur que d'avoir null ?</p>
<!--
In short, because `Option<T>` and `T` (where `T` can be any type) are different
types, the compiler won’t let us use an `Option<T>` value as if it were
definitely a valid value. For example, this code won’t compile because it’s
trying to add an `i8` to an `Option<i8>`:
-->
<p>En bref, comme <code>Option&lt;T&gt;</code> et <code>T</code> (où <code>T</code> représente n'importe quel type) sont
de types différents, le compilateur ne va pas nous autoriser à utiliser une
valeur <code>Option&lt;T&gt;</code> comme si cela était bien une valeur valide. Par exemple, le
code suivant ne se compile pas car il essaye d'additionner un <code>i8</code> et une
<code>Option&lt;i8&gt;</code> :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let x: i8 = 5;
    let y: Option<i8> = Some(5);

    let sum = x + y;
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let somme = x + y;
<span class="boring">}
</span></code></pre>
<!--
If we run this code, we get an error message like this:
-->
<p>Si nous lançons ce code, nous aurons un message d'erreur comme celui-ci :</p>
<!--
```console
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option<i8>` to `i8`
 -- > src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option<i8>`
  |
  = help: the trait `Add<Option<i8>>` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let somme = x + y;
  |                   ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
</code></pre>
<!--
Intense! In effect, this error message means that Rust doesn’t understand how
to add an `i8` and an `Option<i8>`, because they’re different types. When we
have a value of a type like `i8` in Rust, the compiler will ensure that we
always have a valid value. We can proceed confidently without having to check
for null before using that value. Only when we have an `Option<i8>` (or
whatever type of value we’re working with) do we have to worry about possibly
not having a value, and the compiler will make sure we handle that case before
using the value.
-->
<p>Intense ! Effectivement, ce message d'erreur signifie que Rust ne comprend pas
comment additionner un <code>i8</code> et une <code>Option&lt;i8&gt;</code>, car ils sont de types
différents. Quand nous avons une valeur d'un type comme <code>i8</code> avec Rust, le
compilateur va s'assurer que nous avons toujours une valeur valide. Nous pouvons
continuer en toute confiance sans avoir à vérifier que cette valeur n'est pas
nulle avant de l'utiliser. Ce n'est que lorsque nous avons une <code>Option&lt;i8&gt;</code> (ou
tout autre type de valeur avec lequel nous travaillons) que nous devons nous
inquiéter de ne pas avoir de valeur, et le compilateur va s'assurer que nous
gérons ce cas avant d'utiliser la valeur.</p>
<!--
In other words, you have to convert an `Option<T>` to a `T` before you can
perform `T` operations with it. Generally, this helps catch one of the most
common issues with null: assuming that something isn’t null when it actually
is.
-->
<p>Autrement dit, vous devez convertir une <code>Option&lt;T&gt;</code> en <code>T</code> pour pouvoir faire
avec elle des opérations du type <code>T</code>. Généralement, cela permet de résoudre l'un
des problèmes les plus courants avec null : supposer qu'une valeur n'est pas
nulle alors qu'en réalité, elle l'est.</p>
<!--
Not having to worry about incorrectly assuming a not-null value helps you to be
more confident in your code. In order to have a value that can possibly be
null, you must explicitly opt in by making the type of that value `Option<T>`.
Then, when you use that value, you are required to explicitly handle the case
when the value is null. Everywhere that a value has a type that isn’t an
`Option<T>`, you *can* safely assume that the value isn’t null. This was a
deliberate design decision for Rust to limit null’s pervasiveness and increase
the safety of Rust code.
-->
<p>Ne pas avoir à s'inquiéter que des valeurs nulles puissent être mal gérées vous
aide à être plus confiant en votre code. Pour avoir une valeur qui peut
potentiellement être nulle, vous devez l'indiquer explicitement en déclarant que
le type de cette valeur est <code>Option&lt;T&gt;</code>. Ensuite, quand vous utiliserez cette
valeur, il vous faudra gérer explicitement le cas où cette valeur est nulle. Si
vous utilisez une valeur qui n'est pas une <code>Option&lt;T&gt;</code>, alors vous <em>pouvez</em>
considérer que cette valeur ne sera jamais nulle sans prendre de risques. Il
s'agit d'un choix de conception délibéré de Rust pour limiter l'omniprésence de
null et augmenter la sécurité du code en Rust.</p>
<!--
So, how do you get the `T` value out of a `Some` variant when you have a value
of type `Option<T>` so you can use that value? The `Option<T>` enum has a large
number of methods that are useful in a variety of situations; you can check
them out in [its documentation][docs]<!-- ignore -- >. Becoming familiar with
the methods on `Option<T>` will be extremely useful in your journey with Rust.
-->
<p>Donc, comment récupérer la valeur de type <code>T</code> d'une variante <code>Some</code> quand vous
avez une valeur de type <code>Option&lt;T&gt;</code> afin de l'utiliser ? L'énumération
<code>Option&lt;T&gt;</code> a un large choix de méthodes qui sont plus ou moins utiles selon les
cas ; vous pouvez les découvrir dans <a href="https://doc.rust-lang.org/std/option/enum.Option.html">sa documentation</a><!-- ignore -->. Se
familiariser avec les méthodes de <code>Option&lt;T&gt;</code> peut être très utile dans votre
aventure avec Rust.</p>
<!--
[docs]: ../std/option/enum.Option.html
-->
<!--
In general, in order to use an `Option<T>` value, you want to have code that
will handle each variant. You want some code that will run only when you have a
`Some(T)` value, and this code is allowed to use the inner `T`. You want some
other code to run if you have a `None` value, and that code doesn’t have a `T`
value available. The `match` expression is a control flow construct that does
just this when used with enums: it will run different code depending on which
variant of the enum it has, and that code can use the data inside the matching
value.
-->
<p>De manière générale, pour pouvoir utiliser une valeur de <code>Option&lt;T&gt;</code>, votre code
doit gérer chaque variante. On veut que du code soit exécuté uniquement quand on
a une valeur <code>Some(T)</code>, et que ce code soit autorisé à utiliser la valeur de
type <code>T</code> à l'intérieur. On veut aussi qu'un autre code soit exécuté si on a une
valeur <code>None</code>, et ce code n'aura pas de valeur de type <code>T</code> de disponible.
L'expression <code>match</code> est une structure de contrôle qui fait bien ceci
lorsqu'elle est utilisée avec les énumérations : elle va exécuter du code
différent en fonction de quelle variante de l'énumération elle obtient, et ce
code pourra utiliser la donnée présente dans la valeur correspondante.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## The `match` Control Flow Operator
-->
<h2 id="la-structure-de-contrôle-match"><a class="header" href="#la-structure-de-contrôle-match">La structure de contrôle <code>match</code></a></h2>
<!--
Rust has an extremely powerful control flow operator called `match` that allows
you to compare a value against a series of patterns and then execute code based
on which pattern matches. Patterns can be made up of literal values, variable
names, wildcards, and many other things; Chapter 18 covers all the different
kinds of patterns and what they do. The power of `match` comes from the
expressiveness of the patterns and the fact that the compiler confirms that all
possible cases are handled.
-->
<p>Rust a un opérateur de contrôle très puissant appelé <code>match</code> qui vous permet de
comparer une valeur avec une série de motifs et d'exécuter du code en fonction
du motif qui correspond. Les motifs peuvent être constitués de valeurs
littérales, de noms de variables, de jokers, parmi tant d'autres ; le
chapitre 18 va couvrir tous les différents types de motifs et ce qu'ils font. Ce
qui fait la puissance de <code>match</code> est l'expressivité des motifs et le fait que le
compilateur vérifie que tous les cas possibles sont bien gérés.</p>
<!--
Think of a `match` expression as being like a coin-sorting machine: coins slide
down a track with variously sized holes along it, and each coin falls through
the first hole it encounters that it fits into. In the same way, values go
through each pattern in a `match`, and at the first pattern the value “fits,”
the value falls into the associated code block to be used during execution.
-->
<p>Considérez l'expression <code>match</code> comme une machine à trier les pièces de
monnaie : les pièces descendent le long d'une piste avec des trous de tailles
différentes, et chaque pièce tombe dans le premier trou à sa taille qu'elle
rencontre. De manière similaire, les valeurs parcourent tous les motifs dans un
<code>match</code>, et au premier motif auquel la valeur “correspond”, la valeur va
descendre dans le bloc de code correspondant afin d'être utilisée pendant son
exécution.</p>
<!--
Because we just mentioned coins, let’s use them as an example using `match`! We
can write a function that can take an unknown United States coin and, in a
similar way as the counting machine, determine which coin it is and return its
value in cents, as shown here in Listing 6-3.
-->
<p>Comme nous venons de mentionner des pièces, utilisons-les avec un exemple qui
utilise <code>match</code> ! Nous pouvons écrire une fonction qui prend en paramètre une
pièce inconnue des États-Unis d'Amérique et qui peut, de la même manière qu'une
machine à trier, déterminer quelle pièce c'est et retourner sa valeur en
centimes, comme ci-dessous dans l'encart 6-3.</p>
<!--
```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">enum PieceUs {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn valeur_en_centimes(piece: PieceUs) -&gt; u8 {
    match piece {
        PieceUs::Penny =&gt; 1,
        PieceUs::Nickel =&gt; 5,
        PieceUs::Dime =&gt; 10,
        PieceUs::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-3: An enum and a `match` expression that has
the variants of the enum as its patterns</span>
-->
<p><span class="caption">Encart 6-3 : Une énumération et une expression <code>match</code> qui
trie les variantes de l'énumération dans ses motifs</span></p>
<!--
Let’s break down the `match` in the `value_in_cents` function. First, we list
the `match` keyword followed by an expression, which in this case is the value
`coin`. This seems very similar to an expression used with `if`, but there’s a
big difference: with `if`, the expression needs to return a Boolean value, but
here, it can be any type. The type of `coin` in this example is the `Coin` enum
that we defined on line 1.
-->
<p>Décomposons le <code>match</code> dans la fonction <code>valeur_en_centimes</code>. En premier lieu,
nous utilisons le mot-clé <code>match</code> suivi par une expression, qui dans notre cas
est la valeur de <code>piece</code>. Cela ressemble beaucoup à une expression utilisée avec
<code>if</code>, mais il y a une grosse différence : avec <code>if</code>, l'expression doit retourner
une valeur booléenne, mais ici, elle peut être de n'importe quel type. Dans cet
exemple, <code>piece</code> est de type <code>PieceUs</code>, qui est l'énumération que nous avons
définie à la ligne 1.</p>
<!--
Next are the `match` arms. An arm has two parts: a pattern and some code. The
first arm here has a pattern that is the value `Coin::Penny` and then the `=>`
operator that separates the pattern and the code to run. The code in this case
is just the value `1`. Each arm is separated from the next with a comma.
-->
<p>Ensuite, nous avons les branches du <code>match</code>. Une branche a deux parties : un
motif et du code. La première branche a ici pour motif la valeur
<code>PieceUs::Penny</code> et ensuite l'opérateur <code>=&gt;</code> qui sépare le motif et le code à
exécuter. Le code dans ce cas est uniquement la valeur <code>1</code>. Chaque branche est
séparée de la suivante par une virgule.</p>
<!--
When the `match` expression executes, it compares the resulting value against
the pattern of each arm, in order. If a pattern matches the value, the code
associated with that pattern is executed. If that pattern doesn’t match the
value, execution continues to the next arm, much as in a coin-sorting machine.
We can have as many arms as we need: in Listing 6-3, our `match` has four arms.
-->
<p>Lorsqu'une expression <code>match</code> est exécutée, elle compare la valeur de <code>piece</code>
avec le motif de chaque branche, dans l'ordre. Si un motif correspond à la
valeur, le code correspondant à ce motif est alors exécuté. Si ce motif ne
correspond pas à la valeur, l'exécution passe à la prochaine branche, un peu
comme dans une machine de tri de pièces. Nous pouvons avoir autant de branches
que nécessaire : dans l'encart 6-3, notre <code>match</code> a quatre branches.</p>
<!--
The code associated with each arm is an expression, and the resulting value of
the expression in the matching arm is the value that gets returned for the
entire `match` expression.
-->
<p>Le code correspondant à chaque branche est une expression, et la valeur qui
résulte de l'expression dans la branche correspondante est la valeur qui sera
retournée par l'expression <code>match</code>.</p>
<!--
Curly brackets typically aren’t used if the match arm code is short, as it is
in Listing 6-3 where each arm just returns a value. If you want to run multiple
lines of code in a match arm, you can use curly brackets. For example, the
following code would print “Lucky penny!” every time the method was called with
a `Coin::Penny` but would still return the last value of the block, `1`:
-->
<p>Les accolades ne sont généralement pas utilisées si le code de la branche
correspondante est court, comme c'est le cas dans l'encart 6-3 où chaque branche
retourne simplement une valeur. Si vous voulez exécuter plusieurs lignes de
code dans une branche d'un <code>match</code>, vous devez utiliser les accolades. Par
exemple, le code suivant va afficher “Un centime porte-bonheur !” à chaque fois
que la méthode est appelée avec une valeur <code>PieceUs::Penny</code> mais va continuer à
retourner la dernière valeur du bloc, <code>1</code> :</p>
<!--
```rust
# enum Coin {
#     Penny,
#     Nickel,
#     Dime,
#     Quarter,
# }
# 
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum PieceUs {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn valeur_en_centimes(piece: PieceUs) -&gt; u8 {
    match piece {
        PieceUs::Penny =&gt; {
            println!(&quot;Un centime porte-bonheur !&quot;);
            1
        }
        PieceUs::Nickel =&gt; 5,
        PieceUs::Dime =&gt; 10,
        PieceUs::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
### Patterns that Bind to Values
-->
<h3 id="des-motifs-reliés-à-des-valeurs"><a class="header" href="#des-motifs-reliés-à-des-valeurs">Des motifs reliés à des valeurs</a></h3>
<!--
Another useful feature of match arms is that they can bind to the parts of the
values that match the pattern. This is how we can extract values out of enum
variants.
-->
<p>Une autre fonctionnalité intéressante des branches de <code>match</code> est qu'elles
peuvent se lier aux valeurs qui correspondent au motif. C'est ainsi que nous
pouvons extraire des valeurs d'une variante d'énumération.</p>
<!--
As an example, let’s change one of our enum variants to hold data inside it.
From 1999 through 2008, the United States minted quarters with different
designs for each of the 50 states on one side. No other coins got state
designs, so only quarters have this extra value. We can add this information to
our `enum` by changing the `Quarter` variant to include a `UsState` value stored
inside it, which we’ve done here in Listing 6-4.
-->
<p>En guise d'exemple, changeons une de nos variantes d'énumération pour stocker
une donnée à l'intérieur. Entre 1999 et 2008, les États-Unis d'Amérique ont
frappé un côté des <em>quarters</em> (pièces de 25 centimes) avec des dessins
différents pour chacun des 50 États. Les autres pièces n'ont pas eu de dessins
d'États, donc seul le <em>quarter</em> a cette valeur en plus. Nous pouvons ajouter
cette information à notre <code>enum</code> en changeant la variante <code>Quarter</code> pour y
ajouter une valeur <code>EtatUs</code> qui y sera stockée à l'intérieur, comme nous
l'avons fait dans l'encart 6-4.</p>
<!--
```rust
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // pour pouvoir afficher l'État
enum EtatUs {
    Alabama,
    Alaska,
    // -- partie masquée ici --
}

enum PieceUs {
    Penny,
    Nickel,
    Dime,
    Quarter(EtatUs),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-4: A `Coin` enum in which the `Quarter` variant
also holds a `UsState` value</span>
-->
<p><span class="caption">Encart 6-4 : Une énumération <code>PieceUs</code> dans laquelle la
variante <code>Quarter</code> stocke en plus une valeur de type <code>EtatUs</code></span></p>
<!--
Let’s imagine that a friend of ours is trying to collect all 50 state quarters.
While we sort our loose change by coin type, we’ll also call out the name of
the state associated with each quarter so if it’s one our friend doesn’t have,
they can add it to their collection.
-->
<p>Imaginons qu'un de vos amis essaye de collectionner tous les <em>quarters</em> des 50
États. Pendant que nous trions notre monnaie en vrac par type de pièce, nous
mentionnerons aussi le nom de l'État correspondant à chaque <em>quarter</em> de sorte
que si notre ami ne l'a pas, il puisse l'ajouter à sa collection.</p>
<!--
In the match expression for this code, we add a variable called `state` to the
pattern that matches values of the variant `Coin::Quarter`. When a
`Coin::Quarter` matches, the `state` variable will bind to the value of that
quarter’s state. Then we can use `state` in the code for that arm, like so:
-->
<p>Dans l'expression <code>match</code> de ce code, nous avons ajouté une variable <code>etat</code> au
motif qui correspond à la variante <code>PieceUs::Quarter</code>. Quand on aura une
correspondance <code>PieceUs::Quarter</code>, la variable <code>etat</code> sera liée à la valeur de
l'État de cette pièce. Ensuite, nous pourrons utiliser <code>etat</code> dans le code de
cette branche, comme ceci :</p>
<!--
```rust
# #[derive(Debug)]
# enum UsState {
#     Alabama,
#     Alaska,
#     // --snip--
# }
# 
# enum Coin {
#     Penny,
#     Nickel,
#     Dime,
#     Quarter(UsState),
# }
# 
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
# 
# fn main() {
#     value_in_cents(Coin::Quarter(UsState::Alaska));
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum EtatUs {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // -- partie masquée ici --
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum PieceUs {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(EtatUs),
</span><span class="boring">}
</span><span class="boring">
</span>fn valeur_en_centimes(piece: PieceUs) -&gt; u8 {
    match piece {
        PieceUs::Penny =&gt; 1,
        PieceUs::Nickel =&gt; 5,
        PieceUs::Dime =&gt; 10,
        PieceUs::Quarter(etat) =&gt; {
            println!(&quot;Il s'agit d'un quarter de l'État de {:?} !&quot;, etat);
            25
        },
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    valeur_en_centimes(PieceUs::Quarter(EtatUs::Alaska));
</span><span class="boring">}
</span></code></pre></pre>
<!--
If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin`
would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with each
of the match arms, none of them match until we reach `Coin::Quarter(state)`. At
that point, the binding for `state` will be the value `UsState::Alaska`. We can
then use that binding in the `println!` expression, thus getting the inner
state value out of the `Coin` enum variant for `Quarter`.
-->
<p>Si nous appelons <code>valeur_en_centimes(PieceUs::Quarter(EtatUs::Alaska))</code>, <code>piece</code>
vaudra <code>PieceUs::Quarter(EtatUs::Alaska)</code>. Quand nous comparons cette valeur
avec toutes les branches du <code>match</code>, aucune d'entre elles ne correspondra
jusqu'à ce qu'on arrive à <code>PieceUs::Quarter(etat)</code>. À partir de ce moment, la
variable <code>etat</code> aura la valeur <code>EtatUs::Alaska</code>. Nous pouvons alors utiliser
cette variable dans l'expression <code>println!</code>, ce qui nous permet d'afficher la
valeur de l'État à l'intérieur de la variante <code>Quarter</code> de l'énumération
<code>PieceUs</code>.</p>
<!--
### Matching with `Option<T>`
-->
<h3 id="utiliser-match-avec-optiont"><a class="header" href="#utiliser-match-avec-optiont">Utiliser <code>match</code> avec <code>Option&lt;T&gt;</code></a></h3>
<!--
In the previous section, we wanted to get the inner `T` value out of the `Some`
case when using `Option<T>`; we can also handle `Option<T>` using `match` as we
did with the `Coin` enum! Instead of comparing coins, we’ll compare the
variants of `Option<T>`, but the way that the `match` expression works remains
the same.
-->
<p>Dans la section précédente, nous voulions obtenir la valeur interne <code>T</code> dans le
cas de <code>Some</code> lorsqu'on utilisait <code>Option&lt;T&gt;</code> ; nous pouvons aussi gérer les
<code>Option&lt;T&gt;</code> en utilisant <code>match</code> comme nous l'avons fait avec l'énumération
<code>PieceUs</code> ! Au lieu de comparer des pièces, nous allons comparer les variantes
de <code>Option&lt;T&gt;</code>, mais la façon d'utiliser l'expression <code>match</code> reste la même.</p>
<!--
Let’s say we want to write a function that takes an `Option<i32>` and, if
there’s a value inside, adds 1 to that value. If there isn’t a value inside,
the function should return the `None` value and not attempt to perform any
operations.
-->
<p>Disons que nous voulons écrire une fonction qui prend une <code>Option&lt;i32&gt;</code> et qui,
s'il y a une valeur à l'intérieur, ajoute 1 à cette valeur. S'il n'y a pas de
valeur à l'intérieur, la fonction retournera la valeur <code>None</code> et ne va rien
faire de plus.</p>
<!--
This function is very easy to write, thanks to `match`, and will look like
Listing 6-5.
-->
<p>Cette fonction est très facile à écrire, grâce à <code>match</code>, et ressemblera à
l'encart 6-5.</p>
<!--
```rust
# fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let cinq = Some(5);
    let six = plus_un(cinq);
    let none = plus_un(None);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-5: A function that uses a `match` expression on
an `Option<i32>`</span>
-->
<p><span class="caption">Encart 6-5 : Une fonction qui utilise une expression
<code>match</code> sur une <code>Option&lt;i32&gt;</code></span></p>
<!--
Let’s examine the first execution of `plus_one` in more detail. When we call
`plus_one(five)`, the variable `x` in the body of `plus_one` will have the
value `Some(5)`. We then compare that against each match arm.
-->
<p>Examinons la première exécution de <code>plus_un</code> en détail. Lorsque nous appelons
<code>plus_un(cinq)</code>, la variable <code>x</code> dans le corps de <code>plus_un</code> aura la valeur
<code>Some(5)</code>. Ensuite, nous comparons cela à chaque branche du <code>match</code>.</p>
<!--
```rust,ignore
# fn main() {
#     fn plus_one(x: Option<i32>) -> Option<i32> {
#         match x {
            None => None,
#             Some(i) => Some(i + 1),
#         }
#     }
# 
#     let five = Some(5);
#     let six = plus_one(five);
#     let none = plus_one(None);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
The `Some(5)` value doesn’t match the pattern `None`, so we continue to the
next arm.
-->
<p>La valeur <code>Some(5)</code> ne correspond pas au motif <code>None</code>, donc nous continuons à la
branche suivante.</p>
<!--
```rust,ignore
# fn main() {
#     fn plus_one(x: Option<i32>) -> Option<i32> {
#         match x {
#             None => None,
            Some(i) => Some(i + 1),
#         }
#     }
# 
#     let five = Some(5);
#     let six = plus_one(five);
#     let none = plus_one(None);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
Does `Some(5)` match `Some(i)`? Why yes it does! We have the same variant. The
`i` binds to the value contained in `Some`, so `i` takes the value `5`. The
code in the match arm is then executed, so we add 1 to the value of `i` and
create a new `Some` value with our total `6` inside.
-->
<p>Est-ce que <code>Some(5)</code> correspond au motif <code>Some(i)</code> ? Bien sûr ! Nous avons la
même variante. Le <code>i</code> va prendre la valeur contenue dans le <code>Some</code>, donc <code>i</code>
prend la valeur <code>5</code>. Le code dans la branche du <code>match</code> est exécuté, donc nous
ajoutons 1 à la valeur de <code>i</code> et nous créons une nouvelle valeur <code>Some</code> avec
notre résultat <code>6</code> à l'intérieur.</p>
<!--
Now let’s consider the second call of `plus_one` in Listing 6-5, where `x` is
`None`. We enter the `match` and compare to the first arm.
-->
<p>Maintenant, regardons le second appel à <code>plus_un</code> dans l'encart 6-5, où <code>x</code> vaut
<code>None</code>. Nous entrons dans le <code>match</code> et nous le comparons à la première branche.</p>
<!--
```rust,ignore
# fn main() {
#     fn plus_one(x: Option<i32>) -> Option<i32> {
#         match x {
            None => None,
#             Some(i) => Some(i + 1),
#         }
#     }
# 
#     let five = Some(5);
#     let six = plus_one(five);
#     let none = plus_one(None);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
It matches! There’s no value to add to, so the program stops and returns the
`None` value on the right side of `=>`. Because the first arm matched, no other
arms are compared.
-->
<p>Cela correspond ! Il n'y a pas de valeur à additionner, donc le programme
s'arrête et retourne la valeur <code>None</code> qui est dans le côté droit du <code>=&gt;</code>. Comme
la première branche correspond, les autres branches ne sont pas comparées.</p>
<!--
Combining `match` and enums is useful in many situations. You’ll see this
pattern a lot in Rust code: `match` against an enum, bind a variable to the
data inside, and then execute code based on it. It’s a bit tricky at first, but
once you get used to it, you’ll wish you had it in all languages. It’s
consistently a user favorite.
-->
<p>La combinaison de <code>match</code> et des énumérations est utile dans de nombreuses
situations. Vous allez revoir de nombreuses fois ce schéma dans du code Rust :
utiliser <code>match</code> sur une énumération, récupérer la valeur qu'elle renferme, et
exécuter du code en fonction de sa valeur. C'est un peu délicat au début, mais
une fois que vous vous y êtes habitué, vous regretterez de ne pas l'avoir dans
les autres langages. Cela devient toujours l'outil préféré de ses utilisateurs.</p>
<!--
### Matches Are Exhaustive
-->
<h3 id="les-match-sont-toujours-exhaustifs"><a class="header" href="#les-match-sont-toujours-exhaustifs">Les <code>match</code> sont toujours exhaustifs</a></h3>
<!--
There’s one other aspect of `match` we need to discuss. Consider this version
of our `plus_one` function that has a bug and won’t compile:
-->
<p>Il y a un autre point de <code>match</code> que nous devons aborder. Examinez cette version
de notre fonction <code>plus_un</code> qui a un bogue et ne va pas se compiler :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            Some(i) => Some(i + 1),
        }
    }
# 
#     let five = Some(5);
#     let six = plus_one(five);
#     let none = plus_one(None);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
We didn’t handle the `None` case, so this code will cause a bug. Luckily, it’s
a bug Rust knows how to catch. If we try to compile this code, we’ll get this
error:
-->
<p>Nous n'avons pas géré le cas du <code>None</code>, donc ce code va générer un bogue.
Heureusement, c'est un bogue que Rust sait gérer. Si nous essayons de compiler
ce code, nous allons obtenir cette erreur :</p>
<!--
```console
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   -- > src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
    = note: the matched value is of type `Option<i32>`

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --&gt; src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
    = note: the matched value is of type `Option&lt;i32&gt;`

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
</code></pre>
<!--
Rust knows that we didn’t cover every possible case and even knows which
pattern we forgot! Matches in Rust are *exhaustive*: we must exhaust every last
possibility in order for the code to be valid. Especially in the case of
`Option<T>`, when Rust prevents us from forgetting to explicitly handle the
`None` case, it protects us from assuming that we have a value when we might
have null, thus making the billion-dollar mistake discussed earlier impossible.
-->
<p>Rust sait que nous n'avons pas couvert toutes les possibilités et sait même quel
motif nous avons oublié ! Les <code>match</code> de Rust sont <em>exhaustifs</em> : nous devons
traiter toutes les possibilités afin que le code soit valide. C'est notamment le
cas avec <code>Option&lt;T&gt;</code> : quand Rust nous empêche d'oublier de gérer explicitement
le cas de <code>None</code>, il nous protège d'une situation où nous supposons que nous
avons une valeur alors que nous pourrions avoir null, ce qui rend impossible
l'erreur à un milliard de dollars que nous avons vue précédemment.</p>
<!--
### Catch-all Patterns and the `_` Placeholder
-->
<h3 id="les-motifs-génériques-et-le-motif-_"><a class="header" href="#les-motifs-génériques-et-le-motif-_">Les motifs génériques et le motif <code>_</code></a></h3>
<!--
Let’s look at an example where we want to take special actions for a few
particular values, but for all other values take one default action. Imagine
we’re implementing a game where if you get a value of 3 on a dice roll, your
player doesn’t move, but instead gets a new fancy hat. If you roll a 7, your
player loses a fancy hat. For all other values, your player moves that number
of spaces on the game board. Here’s a `match` that implements that logic, with
the result of the dice roll hardcoded rather than a random value, and all other
logic represented by functions without bodies because actually implementing
them is out of scope for this example:
-->
<p>Voyons voir un exemple dans lequel nous voulons appliquer des actions spéciales
pour certaines valeurs précises, mais une action par défaut pour toutes les
autres valeurs. Imaginons que nous implémentons un jeu dans lequel si vous
obtenez une valeur de 3 sur un lancé de dé, votre joueur ne se déplace pas, mais
à la place il obtient un nouveau chapeau fataisie. Si vous obtenez un 7, votre
joueur perd son chapeau fantaisie. Pour toutes les autres valeurs, votre joueur
se déplace de ce nombre de cases sur le plateau du jeu. Voici un <code>match</code> qui
implémente cette logique, avec le résultat du lancé de dé codé en dur plutôt
qu'issu d'une génération aléatoire, et toute la logique des autres fonctions
sont des corps vides car leur implémentation n'est pas le sujet de cet exemple :</p>
<!--
```rust
# fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        other => move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let jete_de_de = 9;
    match jete_de_de {
        3 =&gt; ajouter_chapeau_fantaisie(),
        7 =&gt; enleve_chapeau_fantaisie(),
        autre =&gt; deplace_joueur(autre),
    }

    fn ajouter_chapeau_fantaisie() {}
    fn enleve_chapeau_fantaisie() {}
    fn deplace_joueur(nombre_cases: u8) {}
<span class="boring">}
</span></code></pre></pre>
<!--
For the first two arms, the patterns are the literal values 3 and 7. For the
last arm that covers every other possible value, the pattern is the variable
we’ve chosen to name `other`. The code that runs for the `other` arm uses the
variable by passing it to the `move_player` function.
-->
<p>Dans les deux premières branches, les motifs sont les valeurs litérales 3 et 7.
La dernière branche couvre toutes les autres valeurs possibles, le motif est la
variable <code>autre</code>. Le code qui s'exécute pour la branche <code>autre</code> utilise la
variable en la passant dans la fonction <code>deplacer_joueur</code>.</p>
<!--
This code compiles, even though we haven’t listed all the possible values a
`u8` can have, because the last pattern will match all values not specifically
listed. This catch-all pattern meets the requirement that `match` must be
exhaustive. Note that we have to put the catch-all arm last because the
patterns are evaluated in order. Rust will warn us if we add arms after a
catch-all because those later arms would never match!
-->
<p>Ce code se compile, même si nous n'avons pas lité toutes les valeurs possibles
qu'un <code>u8</code> puisse avoir, car le dernier motif va correspondre à toutes les
valeurs qui ne sont pas spécifiquement listés. Ce motif générique répond à la
condition qu'un <code>match</code> doive être exhaustif. Notez que nous devons placer la
branche avec le motif générique en tout dernier, car les motifs sont évalués
dans l'ordre. Rust va nous prévenir si nous ajoutons des branches après un motif
générique car toutes ces autres branches ne seront jamais vérifiées !</p>
<!--
Rust also has a pattern we can use when we don’t want to use the value in the
catch-all pattern: `_`, which is a special pattern that matches any value and
does not bind to that value. This tells Rust we aren’t going to use the value,
so Rust won’t warn us about an unused variable.
-->
<p>Rust a aussi un motif que nous pouvons utiliser lorsque nous n'avons pas besoin
d'utiliser la valeur dans le motif générique : <code>_</code>, qui est un motif spécial
qui vérifie n'importe quelle valeur et ne récupère pas cette valeur. Ceci
indique à Rust que nous n'allons pas utiliser la valeur, donc Rust ne va pas
nous prévenir qu'il y a une variable non utilisée.</p>
<!--
Let’s change the rules of the game to be that if you roll anything other than
a 3 or a 7, you must roll again. We don’t need to use the value in that case,
so we can change our code to use `_` instead of the variable named `other`:
-->
<p>Changeons les règles du jeu pour que si nous obtenions autre chose qu'un 3 ou
un 7, nous jetions à nouveau le dé. Nous n'avons pas besoin d'utiliser la valeur
dans ce cas, donc nous pouvons changer notre code pour utiliser <code>_</code> au lieu de
la variable <code>autre</code> :</p>
<!--
```rust
# fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let jete_de_de = 9;
    match jete_de_de {
        3 =&gt; ajouter_chapeau_fantaisie(),
        7 =&gt; enleve_chapeau_fantaisie(),
        _ =&gt; relancer(),
    }

    fn ajouter_chapeau_fantaisie() {}
    fn enleve_chapeau_fantaisie() {}
    fn relancer() {}
<span class="boring">}
</span></code></pre></pre>
<!--
This example also meets the exhaustiveness requirement because we’re explicitly
ignoring all other values in the last arm; we haven’t forgotten anything.
-->
<p>Cet exemple répond bien aux critères d'exhaustivité car nous ignorons
explicitement toutes les autres valeurs dans la dernière branche ; nous n'avons
rien oublié.</p>
<!--
If we change the rules of the game one more time, so that nothing else happens
on your turn if you roll anything other than a 3 or a 7, we can express that
by using the unit value (the empty tuple type we mentioned in [“The Tuple
Type”][tuples]<!-- ignore -- > section) as the code that goes with the `_` arm:
-->
<p>Si nous changeons à nouveau les règles du jeu, afin que rien se passe si vous
obtenez autre chose qu'un 3 ou un 7, nous pouvons exprimer cela en utilisant la
valeur unité (le type tuple vide que nous avons cité dans <a href="ch03-02-data-types.html">une section
précédente</a><!-- ignore -->) dans le code de la branche <code>_</code> :</p>
<!--
```rust
# fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let jete_de_de = 9;
    match jete_de_de {
        3 =&gt; ajouter_chapeau_fantaisie(),
        7 =&gt; enleve_chapeau_fantaisie(),
        _ =&gt; (),
    }

    fn ajouter_chapeau_fantaisie() {}
    fn enleve_chapeau_fantaisie() {}
<span class="boring">}
</span></code></pre></pre>
<!--
Here, we’re telling Rust explicitly that we aren’t going to use any other value
that doesn’t match a pattern in an earlier arm, and we don’t want to run any
code in this case.
-->
<p>Ici, nous indiquons explicitement à Rust que nous n'allons pas utiliser d'autres
valeurs qui ne correspondent pas à un motif des branches antérieures, et nous ne
voulons lancer aucun code dans ce cas.</p>
<!--
There’s more about patterns and matching that we’ll cover in [Chapter
18][ch18-00-patterns]<!-- ignore -- >. For now, we’re going to move on to the
`if let` syntax, which can be useful in situations where the `match` expression
is a bit wordy.
-->
<p>Il existe aussi d'autres motifs que nous allons voir dans le
<a href="ch18-00-patterns.html">chapitre 18</a><!-- ignore -->. Pour l'instant, nous allons voir
l'autre syntaxe <code>if let</code>, qui peut se rendre utile dans des cas où l'expression
<code>match</code> est trop verbeuse.</p>
<!--
[tuples]: ch03-02-data-types.html#the-tuple-type
[ch18-00-patterns]: ch18-00-patterns.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Concise Control Flow with `if let`
-->
<h2 id="une-structure-de-contrôle-concise--if-let"><a class="header" href="#une-structure-de-contrôle-concise--if-let">Une structure de contrôle concise : <code>if let</code></a></h2>
<!--
The `if let` syntax lets you combine `if` and `let` into a less verbose way to
handle values that match one pattern while ignoring the rest. Consider the
program in Listing 6-6 that matches on an `Option<u8>` value in the `config_max`
variable but only wants to execute code if the value is the `Some` variant.
-->
<p>La syntaxe <code>if let</code> vous permet de combiner <code>if</code> et <code>let</code> afin de gérer les
valeurs qui correspondent à un motif donné, tout en ignorant les autres.
Imaginons le programme dans l'encart 6-6 qui fait un <code>match</code> sur la valeur
<code>Option&lt;u8&gt;</code> de la variable <code>config_max</code> mais n'a besoin d'exécuter du code que
si la valeur est la variante <code>Some</code>.</p>
<!--
```rust
# fn main() {
    let config_max = Some(3u8);
    match config_max {
        Some(max) => println!("The maximum is configured to be {}", max),
        _ => (),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let une_valeur_u8 = Some(3u8);
    match une_valeur_u8 {
        Some(max) =&gt; println!(&quot;Le maximum est réglé sur {}&quot;, max),
        _ =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-6: A `match` that only cares about executing
code when the value is `Some`</span>
-->
<p><span class="caption">Encart 6-6 : Un <code>match</code> qui n'exécute du code que si la
valeur est <code>Some</code></span></p>
<!--
If the value is `Some`, we want to print out the value in the `Some` variant,
which we do by binding the value to the variable `max` in the pattern.
We don’t want to do anything with the `None` value. To satisfy the `match`
expression, we have to add `_ => ()` after processing just one variant, which
is annoying boilerplate code to add.
-->
<p>Si la valeur est un <code>Some</code>, nous voulons afficher la valeur dans la variante
<code>Some</code>, en associant la valeur à la variable <code>max</code> dans le motif.
Nous ne voulons rien faire avec la valeur <code>None</code>. Pour satisfaire l'expression
<code>match</code>, nous devons ajouter <code>_ =&gt; ()</code> après avoir géré une seule variante, ce
qui est du code inutile.</p>
<!--
Instead, we could write this in a shorter way using `if let`. The following
code behaves the same as the `match` in Listing 6-6:
-->
<p>À la place, nous pourrions écrire le même programme de manière plus concise en
utilisant <code>if let</code>. Le code suivant se comporte comme le <code>match</code> de l'encart
6-6 :</p>
<!--
```rust
# fn main() {
    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("The maximum is configured to be {}", max);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let une_valeur_u8 = Some(3u8);
    if let Some(max) = une_valeur_u8 {
        println!(&quot;Le maximum est réglé sur {}&quot;, max);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
The syntax `if let` takes a pattern and an expression separated by an equal
sign. It works the same way as a `match`, where the expression is given to the
`match` and the pattern is its first arm. In this case, the pattern is
`Some(max)`, and the `max` binds to the value inside the `Some`. We can then
use `max` in the body of the `if let` block in the same way as we used `max` in
the corresponding `match` arm. The code in the `if let` block isn’t run if the
value doesn’t match the pattern.
-->
<p>La syntaxe <code>if let</code> prend un motif et une expression séparés par un signe égal.
Elle fonctionne de la même manière qu'un <code>match</code> où l'expression est donnée au
<code>match</code> et où le motif est sa première branche. Dans ce cas, le motif est
<code>Some(max)</code>, et le <code>max</code> est associé à la valeur dans le <code>Some</code>. Nous pouvons
ensuite utiliser <code>max</code> dans le corps du bloc <code>if let</code> de la même manière que
nous avons utilisé <code>max</code> dans la branche correspondante au <code>match</code>. Le code dans
le bloc <code>if let</code> n'est pas exécuté si la valeur ne correspond pas au motif.</p>
<!--
Using `if let` means less typing, less indentation, and less boilerplate code.
However, you lose the exhaustive checking that `match` enforces. Choosing
between `match` and `if let` depends on what you’re doing in your particular
situation and whether gaining conciseness is an appropriate trade-off for
losing exhaustive checking.
-->
<p>Utiliser <code>if let</code> permet d'écrire moins de code, et de moins l'indenter.
Cependant, vous perdez la vérification de l'exhaustivité qu'assure le <code>match</code>.
Choisir entre <code>match</code> et <code>if let</code> dépend de la situation : à vous de choisir
s'il vaut mieux être concis ou appliquer une vérification exhaustive.</p>
<!--
In other words, you can think of `if let` as syntax sugar for a `match` that
runs code when the value matches one pattern and then ignores all other values.
-->
<p>Autrement dit, vous pouvez considérer le <code>if let</code> comme du sucre syntaxique pour
un <code>match</code> qui exécute du code uniquement quand la valeur correspond à un motif
donné et ignore toutes les autres valeurs.</p>
<!--
We can include an `else` with an `if let`. The block of code that goes with the
`else` is the same as the block of code that would go with the `_` case in the
`match` expression that is equivalent to the `if let` and `else`. Recall the
`Coin` enum definition in Listing 6-4, where the `Quarter` variant also held a
`UsState` value. If we wanted to count all non-quarter coins we see while also
announcing the state of the quarters, we could do that with a `match`
expression like this:
-->
<p>Nous pouvons joindre un <code>else</code> à un <code>if let</code>. Le bloc de code qui va dans le
<code>else</code> est le même que le bloc de code qui va dans le cas <code>_</code> avec l'expression
<code>match</code>. Souvenez-vous de la définition de l'énumération <code>PieceUs</code> de l'encart
6-4, où la variante <code>Quarter</code> stockait aussi une valeur <code>EtatUs</code>. Si nous
voulions compter toutes les pièces qui ne sont pas des <em>quarters</em> que nous
voyons passer, tout en affichant l'État des <em>quarters</em>, nous pourrions le faire
avec une expression <code>match</code> comme ceci :</p>
<!--
```rust
# #[derive(Debug)]
# enum UsState {
#     Alabama,
#     Alaska,
#     // --snip--
# }
# 
# enum Coin {
#     Penny,
#     Nickel,
#     Dime,
#     Quarter(UsState),
# }
# 
# fn main() {
#     let coin = Coin::Penny;
    let mut count = 0;
    match coin {
        Coin::Quarter(state) => println!("State quarter from {:?}!", state),
        _ => count += 1,
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum EtatUs {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // -- partie masquée ici --
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum PieceUs {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(EtatUs),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let piece = PieceUs::Penny;
</span>    let mut compteur = 0;
    match piece {
        PieceUs::Quarter(etat) =&gt; println!(&quot;Il s'agit d'un quarter de l'État de {:?} !&quot;, etat),
        _ =&gt; compteur += 1,
    }
<span class="boring">}
</span></code></pre></pre>
<!--
Or we could use an `if let` and `else` expression like this:
-->
<p>Ou nous pourrions utiliser une expression <code>if let</code>/<code>else</code> comme ceci :</p>
<!--
```rust
# #[derive(Debug)]
# enum UsState {
#     Alabama,
#     Alaska,
#     // --snip--
# }
# 
# enum Coin {
#     Penny,
#     Nickel,
#     Dime,
#     Quarter(UsState),
# }
# 
# fn main() {
#     let coin = Coin::Penny;
    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!("State quarter from {:?}!", state);
    } else {
        count += 1;
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum EtatUs {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // -- partie masquée ici --
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum PieceUs {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(EtatUs),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let piece = PieceUs::Penny;
</span>    let mut compteur = 0;
    if let PieceUs::Quarter(etat) = piece {
        println!(&quot;Il s'agit d'un quarter de l'État de {:?} !&quot;, etat);
    } else {
        compteur += 1;
    }
<span class="boring">}
</span></code></pre></pre>
<!--
If you have a situation in which your program has logic that is too verbose to
express using a `match`, remember that `if let` is in your Rust toolbox as well.
-->
<p>Si vous trouvez que votre programme est alourdi par l'utilisation d'un <code>match</code>,
souvenez-vous que <code>if let</code> est aussi présent dans votre boite à outils Rust.</p>
<!--
## Summary
-->
<h2 id="résumé-5"><a class="header" href="#résumé-5">Résumé</a></h2>
<!--
We’ve now covered how to use enums to create custom types that can be one of a
set of enumerated values. We’ve shown how the standard library’s `Option<T>`
type helps you use the type system to prevent errors. When enum values have
data inside them, you can use `match` or `if let` to extract and use those
values, depending on how many cases you need to handle.
-->
<p>Nous avons désormais appris comment utiliser les énumérations pour créer des
types personnalisés qui peuvent faire partie d'un jeu de valeurs recensées. Nous
avons montré comment le type <code>Option&lt;T&gt;</code> de la bibliothèque standard vous aide
à utiliser le système de types pour éviter les erreurs. Lorsque les valeurs
d'énumération contiennent des données, vous pouvez utiliser <code>match</code> ou <code>if let</code>
pour extraire et utiliser ces valeurs, à choisir en fonction du nombre de cas
que vous voulez gérer.</p>
<!--
Your Rust programs can now express concepts in your domain using structs and
enums. Creating custom types to use in your API ensures type safety: the
compiler will make certain your functions get only values of the type each
function expects.
-->
<p>Vos programmes Rust peuvent maintenant décrire des concepts métier à l'aide de
structures et d'énumérations. Créer des types personnalisés à utiliser dans
votre API assure la sécurité des types : le compilateur s'assurera que vos
fonctions ne reçoivent que des valeurs du type attendu.</p>
<!--
In order to provide a well-organized API to your users that is straightforward
to use and only exposes exactly what your users will need, let’s now turn to
Rust’s modules.
-->
<p>Afin de fournir une API bien organisée, simple à utiliser et qui n'expose que ce
dont vos utilisateurs auront besoin, découvrons maintenant les modules de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Managing Growing Projects with Packages, Crates, and Modules
-->
<h1 id="gérer-des-projets-grandissants-avec-les-paquets-crates-et-modules"><a class="header" href="#gérer-des-projets-grandissants-avec-les-paquets-crates-et-modules">Gérer des projets grandissants avec les paquets, crates et modules</a></h1>
<!--
As you write large programs, organizing your code will be important because
keeping track of your entire program in your head will become impossible. By
grouping related functionality and separating code with distinct features,
you’ll clarify where to find code that implements a particular feature and
where to go to change how a feature works.
-->
<p>Lorsque vous commencerez à écrire des gros programmes, organiser votre code va
devenir important car vous ne pourrez plus garder en tête l'intégralité de votre
programme. En regroupant des fonctionnalités qui ont des points communs et en
les séparant des autres fonctionnalités, vous clarifiez l'endroit où trouver le
code qui implémente une fonctionnalité spécifique afin de pouvoir le relire ou
le modifier.</p>
<!--
The programs we’ve written so far have been in one module in one file. As a
project grows, you can organize code by splitting it into multiple modules and
then multiple files. A package can contain multiple binary crates and
optionally one library crate. As a package grows, you can extract parts into
separate crates that become external dependencies. This chapter covers all
these techniques. For very large projects of a set of interrelated packages
that evolve together, Cargo provides workspaces, which we’ll cover in the
[“Cargo Workspaces”][workspaces]<!-- ignore -- > section in Chapter 14.
-->
<p>Les programmes que nous avons écrits jusqu'à présent étaient dans un module au
sein d'un seul fichier. À mesure que le projet grandit, vous pouvez organiser
votre code en le découpant en plusieurs modules et ensuite en plusieurs
fichiers. Un paquet peut contenir plusieurs crates binaires et accessoirement
une crate de bibliothèque. À mesure qu'un paquet grandit, vous pouvez en
extraire des parties dans des crates séparées qui deviennent des dépendances
externes. Ce chapitre va aborder toutes ces techniques. Pour un projet de très
grande envergure qui a des paquets interconnectés qui évoluent ensemble, Cargo
propose les espaces de travail, que nous découvrirons dans une section du
<a href="ch14-03-cargo-workspaces.html">chapitre 14</a><!-- ignore -->.</p>
<!--
In addition to grouping functionality, encapsulating implementation details
lets you reuse code at a higher level: once you’ve implemented an operation,
other code can call that code via the code’s public interface without knowing
how the implementation works. The way you write code defines which parts are
public for other code to use and which parts are private implementation details
that you reserve the right to change. This is another way to limit the amount
of detail you have to keep in your head.
-->
<p>En plus de regrouper des fonctionnalités, les modules vous permettent
d'encapsuler les détails de l'implémentation d'une opération : vous pouvez
écrire du code puis l'utiliser comme une abstraction à travers l'interface de
programmation publique (API) du code sans se soucier de connaître les détails de
son implémentation. La façon dont vous écrivez votre code définit quelles
parties sont publiques et donc utilisables par un autre code, et quelles parties
sont des détails d'implémentation privés dont vous vous réservez le droit de
modifier. C'est un autre moyen de limiter le nombre d'éléments de l'API pour
celui qui l'utilise.</p>
<!--
A related concept is scope: the nested context in which code is written has a
set of names that are defined as “in scope.” When reading, writing, and
compiling code, programmers and compilers need to know whether a particular
name at a particular spot refers to a variable, function, struct, enum, module,
constant, or other item and what that item means. You can create scopes and
change which names are in or out of scope. You can’t have two items with the
same name in the same scope; tools are available to resolve name conflicts.
-->
<p>Un concept qui lui est associé est la portée : le contexte dans lequel le code
est écrit a un jeu de noms qui sont définis comme “dans la portée”. Quand ils
lisent, écrivent et compilent du code, les développeurs et les compilateurs ont
besoin de savoir ce que tel nom désigne à tel endroit, et s'il s'agit d'une
variable, d'une fonction, d'une structure, d'une énumération, d'un module, d'une
constante, etc. Vous pouvez créer des portées et décider quels noms sont dans la
portée ou non. Vous ne pouvez pas avoir deux entités avec le même nom dans la
même portée ; cependant, des outils existent pour résoudre les conflits de nom.</p>
<!--
Rust has a number of features that allow you to manage your code’s
organization, including which details are exposed, which details are private,
and what names are in each scope in your programs. These features, sometimes
collectively referred to as the *module system*, include:
-->
<p>Rust a de nombreuses fonctionnalités qui vous permettent de gérer l'organisation
de votre code, grâce à ce que la communauté Rust appelle le <em>système de
modules</em>. Ce système définit quels sont les éléments qui sont accessibles depuis
l'extérieur de la bibliothèque (notion de privé ou public), ainsi que leur
portée. Ces fonctionnalités comprennent :</p>
<!--
* **Packages:** A Cargo feature that lets you build, test, and share crates
* **Crates:** A tree of modules that produces a library or executable
* **Modules** and **use:** Let you control the organization, scope, and
  privacy of paths
* **Paths:** A way of naming an item, such as a struct, function, or module
-->
<ul>
<li><strong>les paquets :</strong> une fonctionnalité de Cargo qui vous permet de compiler,
tester, et partager des crates ;</li>
<li><strong>les <em>crates</em> :</strong> une arborescence de modules qui fournit une bibliothèque ou
un exécutable ;</li>
<li><strong>les modules</strong> : utilisés avec le mot-clé <code>use</code>, ils vous permettent de
contrôler l'organisation, la portée et la visibilité des chemins ;</li>
<li><strong>les chemins :</strong> une façon de nommer un élément, comme une structure, une
fonction ou un module.</li>
</ul>
<!--
In this chapter, we’ll cover all these features, discuss how they interact, and
explain how to use them to manage scope. By the end, you should have a solid
understanding of the module system and be able to work with scopes like a pro!
-->
<p>Dans ce chapitre, nous allons découvrir ces fonctionnalités, voir comment elles
interagissent, et expliquer comment les utiliser pour gérer les portées. À
l'issue de ce chapitre, vous aurez de solides connaissances sur le système de
modules et vous pourrez travailler avec les portées comme un pro !</p>
<!--
[workspaces]: ch14-03-cargo-workspaces.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Packages and Crates
-->
<h2 id="les-paquets-et-les-crates"><a class="header" href="#les-paquets-et-les-crates">Les paquets et les crates</a></h2>
<!--
The first parts of the module system we’ll cover are packages and crates. A
crate is a binary or library. The *crate root* is a source file that the Rust
compiler starts from and makes up the root module of your crate (we’ll explain
modules in depth in the [“Defining Modules to Control Scope and
Privacy”][modules]<!-- ignore -- > section). A *package* is one or more crates
that provide a set of functionality. A package contains a *Cargo.toml* file
that describes how to build those crates.
-->
<p>La première partie du système de modules que nous allons aborder concerne les
paquets et les <em>crates</em>. Une crate est un binaire ou une bibliothèque. Pour la
compiler, le compilateur Rust part d'un fichier source, la racine de la <em>crate</em>,
à partir duquel est alors créé le <em>module racine</em> de votre <em>crate</em> (nous verrons
les modules plus en détail dans la <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">section suivante</a><!-- ignore -->).
Un <em>paquet</em> se compose d'une ou plusieurs crates qui fournissent un ensemble de
fonctionnalités. Un paquet contient un fichier <em>Cargo.toml</em> qui décrit comment
construire ces crates.</p>
<!--
Several rules determine what a package can contain. A package can contain
at most one library crate. It can contain as many binary crates
as you’d like, but it must contain at least one crate (either library or
binary).
-->
<p>Il y a plusieurs règles qui déterminent ce qu'un paquet peut contenir. Il <em>doit</em>
contenir au maximum une seule crate de bibliothèque. Il peut contenir autant de
crates binaires que vous le souhaitez, mais il doit contenir au moins une crate
(que ce soit une bibliothèque ou un binaire).</p>
<!--
Let’s walk through what happens when we create a package. First, we enter the
command `cargo new`:
-->
<p>Découvrons ce qui se passe quand nous créons un paquet. D'abord, nous utilisons
la commande <code>cargo new</code> :</p>
<!--
```console
$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
```
-->
<pre><code class="language-console">$ cargo new mon-projet
     Created binary (application) `mon-projet` package
$ ls mon-projet
Cargo.toml
src
$ ls mon-projet/src
main.rs
</code></pre>
<!--
When we entered the command, Cargo created a *Cargo.toml* file, giving us a
package. Looking at the contents of *Cargo.toml*, there’s no mention of
*src/main.rs* because Cargo follows a convention that *src/main.rs* is the
crate root of a binary crate with the same name as the package. Likewise, Cargo
knows that if the package directory contains *src/lib.rs*, the package contains
a library crate with the same name as the package, and *src/lib.rs* is its
crate root. Cargo passes the crate root files to `rustc` to build the library
or binary.
-->
<p>Lorsque nous avons saisi la commande, Cargo a créé un fichier <em>Cargo.toml</em>, qui
définit un paquet. Si on regarde le contenu de <em>Cargo.toml</em>, le fichier
<em>src/main.rs</em> n'est pas mentionné car Cargo obéit à une convention selon
laquelle <em>src/main.rs</em> est la racine de la crate binaire portant le même
nom que le paquet. De la même façon, Cargo sait que si le dossier du paquet
contient <em>src/lib.rs</em>, alors le paquet contient une crate de bibliothèque qui a
le même nom que le paquet, et que <em>src/lib.rs</em> est sa racine. Cargo transmet les
fichiers de la crate racine à <code>rustc</code> pour compiler la bibliothèque ou le
binaire.</p>
<!--
Here, we have a package that only contains *src/main.rs*, meaning it only
contains a binary crate named `my-project`. If a package contains *src/main.rs*
and *src/lib.rs*, it has two crates: a library and a binary, both with the same
name as the package. A package can have multiple binary crates by placing files
in the *src/bin* directory: each file will be a separate binary crate.
-->
<p>Dans notre cas, nous avons un paquet qui contient uniquement <em>src/main.rs</em>, ce
qui veut dire qu'il contient uniquement une crate binaire qui s'appelle
<code>mon-projet</code>. Si un paquet contient <em>src/main.rs</em> et <em>src/lib.rs</em>, il a deux
crates : une bibliothèque et une binaire, chacune avec le même nom que le
paquet. Un paquet peut avoir plusieurs crates binaires en ajoutant des fichiers
dans le répertoire <em>src/bin</em> : chaque fichier sera une crate séparée.</p>
<!--
A crate will group related functionality together in a scope so the
functionality is easy to share between multiple projects. For example, the
`rand` crate we used in [Chapter 2][rand]<!-- ignore -- > provides functionality
that generates random numbers. We can use that functionality in our own
projects by bringing the `rand` crate into our project’s scope. All the
functionality provided by the `rand` crate is accessible through the crate’s
name, `rand`.
-->
<p>Une crate regroupe plusieurs fonctionnalités associées ensemble dans une portée
afin que les fonctionnalités soient faciles à partager entre plusieurs projets.
Par exemple, la crate <code>rand</code> que nous avons utilisée dans
<a href="ch02-00-guessing-game-tutorial.html#g%C3%A9n%C3%A9rer-le-nombre-secret">le chapitre 2</a><!-- ignore --> nous permet de générer des nombres
aléatoires. Nous pouvons utiliser cette fonctionnalité dans notre propre projet
en important la crate <code>rand</code> dans la portée de notre projet. Toutes les
fonctionnalités fournies par la crate <code>rand</code> sont accessibles via le nom de la
crate, <code>rand</code>.</p>
<!--
Keeping a crate’s functionality in its own scope clarifies whether particular
functionality is defined in our crate or the `rand` crate and prevents
potential conflicts. For example, the `rand` crate provides a trait named
`Rng`. We can also define a `struct` named `Rng` in our own crate. Because a
crate’s functionality is namespaced in its own scope, when we add `rand` as a
dependency, the compiler isn’t confused about what the name `Rng` refers to. In
our crate, it refers to the `struct Rng` that we defined. We would access the
`Rng` trait from the `rand` crate as `rand::Rng`.
-->
<p>Ranger une fonctionnalité d'une crate dans sa propre portée clarifie si une
fonctionnalité précise est définie dans notre crate ou dans la crate <code>rand</code> et
évite ainsi de potentiels conflits. Par exemple, la crate <code>rand</code> fournit un
<em>trait</em> qui s'appelle <code>Rng</code>. Nous pouvons nous aussi définir une structure qui
s'appelle <code>Rng</code> dans notre propre crate. Comme les fonctionnalités des crates
sont dans la portée de leur propre espace de nom, quand nous ajoutons <code>rand</code> en
dépendance, il n'y a pas d'ambiguïté pour le compilateur sur le nom <code>Rng</code>. Dans
notre crate, il se réfère au <code>struct Rng</code> que nous avons défini. Nous accédons
au <em>trait</em> <code>Rng</code> de la crate <code>rand</code> via <code>rand::Rng</code>.</p>
<!--
Let’s move on and talk about the module system!
-->
<p>Poursuivons et parlons maintenant du système de modules !</p>
<!--
[modules]: ch07-02-defining-modules-to-control-scope-and-privacy.html
[rand]: ch02-00-guessing-game-tutorial.html#generating-a-random-number
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Defining Modules to Control Scope and Privacy
-->
<h2 id="définir-des-modules-pour-gérer-la-portée-et-la-visibilité"><a class="header" href="#définir-des-modules-pour-gérer-la-portée-et-la-visibilité">Définir des modules pour gérer la portée et la visibilité</a></h2>
<!--
In this section, we’ll talk about modules and other parts of the module system,
namely *paths* that allow you to name items; the `use` keyword that brings a
path into scope; and the `pub` keyword to make items public. We’ll also discuss
the `as` keyword, external packages, and the glob operator. For now, let’s
focus on modules!
-->
<p>Dans cette section, nous allons aborder les modules et les autres outils du
système de modules, à savoir les <em>chemins</em> qui nous permettent de nommer les
éléments ; l'utilisation du mot-clé <code>use</code> qui importe un chemin dans la portée ;
et le mot-clé <code>pub</code> qui rend publics les éléments. Nous verrons aussi le mot-clé
<code>as</code>, les paquets externes, et l'opérateur glob. Pour commencer, penchons-nous
sur les modules !</p>
<!--
*Modules* let us organize code within a crate into groups for readability and
easy reuse. Modules also control the *privacy* of items, which is whether an
item can be used by outside code (*public*) or is an internal implementation
detail and not available for outside use (*private*).
-->
<p>Les <em>modules</em> nous permettent de regrouper le code d'une crate pour une
meilleure lisibilité et pour la facilité de réutilisation. Les modules
permettent aussi de gérer la <em>visibilité</em> des éléments, qui précise si un
élément peut être utilisé à l'extérieur du module (<em>c'est public</em>) ou s'il est
un constituant interne et n'est pas disponible pour une utilisation externe
(<em>c'est privé</em>).</p>
<!--
As an example, let’s write a library crate that provides the functionality of a
restaurant. We’ll define the signatures of functions but leave their bodies
empty to concentrate on the organization of the code, rather than actually
implement a restaurant in code.
-->
<p>Voici un exemple : écrivons une crate de bibliothèque qui permet de simuler un
restaurant. Nous allons définir les signatures des fonctions mais nous allons
laisser leurs corps vides pour nous concentrer sur l'organisation du code,
plutôt que de coder pour de vrai un restaurant.</p>
<!--
In the restaurant industry, some parts of a restaurant are referred to as
*front of house* and others as *back of house*. Front of house is where
customers are; this is where hosts seat customers, servers take orders and
payment, and bartenders make drinks. Back of house is where the chefs and cooks
work in the kitchen, dishwashers clean up, and managers do administrative work.
-->
<p>Dans le secteur de la restauration, certaines parties d'un restaurant sont
assimilées à la <em>salle à manger</em> et d'autres <em>aux cuisines</em>. La partie salle à
manger est l'endroit où se trouvent les clients ; c'est l'endroit où les hôtes
installent les clients, où les serveurs prennent les commandes et encaissent les
clients, et où les barmans préparent des boissons. Dans la partie cuisines, nous
retrouvons les chefs et les cuisiniers qui travaillent dans la cuisine, mais
aussi les plongeurs qui nettoient la vaisselle et les gestionnaires qui
s'occupent des tâches administratives.</p>
<!--
To structure our crate in the same way that a real restaurant works, we can
organize the functions into nested modules. Create a new library named
`restaurant` by running `cargo new --lib restaurant`; then put the code in
Listing 7-1 into *src/lib.rs* to define some modules and function signatures.
-->
<p>Pour organiser notre crate de la même manière qu'un vrai restaurant, nous
pouvons organiser les fonctions avec des modules imbriqués. Créez une nouvelle
bibliothèque qui s'appelle <code>restaurant</code> en utilisant
<code>cargo new --lib restaurant</code> ; puis écrivez le code de l'encart 7-1 dans
<em>src/lib.rs</em> afin de définir quelques modules et quelques signatures de
fonctions.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```
-->
<pre><code class="language-rust noplayground">mod salle_a_manger {
    mod accueil {
        fn ajouter_a_la_liste_attente() {}

        fn installer_a_une_table() {}
    }

    mod service {
        fn prendre_commande() {}

        fn servir_commande() {}

        fn encaisser() {}
    }
}
</code></pre>
<!--
<span class="caption">Listing 7-1: A `front_of_house` module containing other
modules that then contain functions</span>
-->
<p><span class="caption">Encart 7-1 : Un module <code>salle_a_manger</code> qui contient
d'autres modules qui contiennent eux-mêmes des fonctions</span></p>
<!--
We define a module by starting with the `mod` keyword and then specify the
name of the module (in this case, `front_of_house`) and place curly brackets
around the body of the module. Inside modules, we can have other modules, as in
this case with the modules `hosting` and `serving`. Modules can also hold
definitions for other items, such as structs, enums, constants, traits, or—as
in Listing 7-1—functions.
-->
<p>Nous définissons un module en commençant avec le mot-clé <code>mod</code> et nous précisons
ensuite le nom du module (dans notre cas, <code>salle_a_manger</code>) et nous ajoutons des
accolades autour du corps du module. Dans les modules, nous pouvons avoir
d'autres modules, comme dans notre cas avec les modules <code>accueil</code> et <code>service</code>.
Les modules peuvent aussi contenir des définitions pour d'autres éléments, comme
des structures, des énumérations, des constantes, des traits, ou des fonctions
(comme c'est le cas dans l'encart 7-1).</p>
<!--
By using modules, we can group related definitions together and name why
they’re related. Programmers using this code would have an easier time finding
the definitions they wanted to use because they could navigate the code based
on the groups rather than having to read through all the definitions.
Programmers adding new functionality to this code would know where to place the
code to keep the program organized.
-->
<p>Grâce aux modules, nous pouvons regrouper ensemble des définitions qui sont
liées et donner un nom à ce lien. Les développeurs qui utiliseront ce code
pourront plus facilement trouver les définitions dont ils ont besoin car ils
peuvent parcourir le code en fonction des groupes plutôt que d'avoir à lire
toutes les définitions. Les développeurs qui veulent rajouter des nouvelles
fonctionnalités à ce code sauront maintenant où placer le code tout en gardant
le programme organisé.</p>
<!--
Earlier, we mentioned that *src/main.rs* and *src/lib.rs* are called crate
roots. The reason for their name is that the contents of either of these two
files form a module named `crate` at the root of the crate’s module structure,
known as the *module tree*.
-->
<p>Précédemment, nous avons dit que <em>src/main.rs</em> et <em>src/lib.rs</em> étaient des
racines de crates. Nous les appelons ainsi car le contenu de chacun de ces
deux fichiers constituent un module qui s'appelle <code>crate</code> à la racine de
<em>l'arborescence du module</em>.</p>
<!--
Listing 7-2 shows the module tree for the structure in Listing 7-1.
-->
<p>L'encart 7-2 présente l'arborescence du module pour la structure de
l'encart 7-1.</p>
<!--
```text
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
```
-->
<pre><code class="language-text">crate
 └── salle_a_manger
     ├── accueil
     │   ├── ajouter_a_la_liste_attente
     │   └── installer_a_une_table
     └── service
         ├── prendre_commande
         ├── servir_commande
         └── encaisser
</code></pre>
<!--
<span class="caption">Listing 7-2: The module tree for the code in Listing
7-1</span>
-->
<p><span class="caption">Encart 7-2 : L'arborescence des modules pour le code de
l'encart 7-1</span></p>
<!--
This tree shows how some of the modules nest inside one another (for example,
`hosting` nests inside `front_of_house`). The tree also shows that some modules
are *siblings* to each other, meaning they’re defined in the same module
(`hosting` and `serving` are defined within `front_of_house`). To continue the
family metaphor, if module A is contained inside module B, we say that module A
is the *child* of module B and that module B is the *parent* of module A.
Notice that the entire module tree is rooted under the implicit module named
`crate`.
-->
<p>Cette arborescence montre comment les modules sont imbriqués entre eux (par
exemple, <code>accueil</code> est imbriqué dans <code>salle_a_manger</code>). L'arborescence montre
aussi que certains modules sont les <em>frères</em> d'autres modules, ce qui veut dire
qu'ils sont définis dans le même module (<code>accueil</code> et <code>service</code> sont définis
dans <code>salle_a_manger</code>). Pour prolonger la métaphore familiale, si le module A
est contenu dans le module B, on dit que le module A est <em>l'enfant</em> du module B
et que ce module B est le <em>parent</em> du module A. Notez aussi que le module
implicite nommé <code>crate</code> est le parent de toute cette arborescence.</p>
<!--
The module tree might remind you of the filesystem’s directory tree on your
computer; this is a very apt comparison! Just like directories in a filesystem,
you use modules to organize your code. And just like files in a directory, we
need a way to find our modules.
-->
<p>L'arborescence des modules peut rappeler les dossiers du système de fichiers de
votre ordinateur ; et c'est une excellente comparaison ! Comme les dossiers dans
un système de fichiers, vous utilisez les modules pour organiser votre code. Et
comme pour les fichiers dans un dossier, nous avons besoin d'un moyen de trouver
nos modules.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Paths for Referring to an Item in the Module Tree
-->
<h2 id="désigner-un-élément-dans-larborescence-de-modules"><a class="header" href="#désigner-un-élément-dans-larborescence-de-modules">Désigner un élément dans l'arborescence de modules</a></h2>
<!--
To show Rust where to find an item in a module tree, we use a path in the same
way we use a path when navigating a filesystem. If we want to call a function,
we need to know its path.
-->
<p>Pour indiquer à Rust où trouver un élément dans l'arborescence de modules, nous
utilisons un chemin à l'instar des chemins que nous utilisons lorsque nous
naviguons dans un système de fichiers. Si nous voulons appeler une fonction,
nous avons besoin de connaître son chemin.</p>
<!--
A path can take two forms:
-->
<p>Il existe deux types de chemins :</p>
<!--
* An *absolute path* starts from a crate root by using a crate name or a
  literal `crate`.
* A *relative path* starts from the current module and uses `self`, `super`, or
  an identifier in the current module.
-->
<ul>
<li>Un <em>chemin absolu</em> qui commence à partir de la racine de la crate en utilisant
le nom d'une crate, ou le mot <code>crate</code>.</li>
<li>Un <em>chemin relatif</em> qui commence à partir du module courant et qui utilise
<code>self</code>, <code>super</code>, ou un identificateur à l'intérieur du module.</li>
</ul>
<!--
Both absolute and relative paths are followed by one or more identifiers
separated by double colons (`::`).
-->
<p>Les chemins absolus et relatifs sont suivis par un ou plusieurs identificateurs
séparés par <code>::</code>.</p>
<!--
Let’s return to the example in Listing 7-1. How do we call the
`add_to_waitlist` function? This is the same as asking, what’s the path of the
`add_to_waitlist` function? In Listing 7-3, we simplified our code a bit by
removing some of the modules and functions. We’ll show two ways to call the
`add_to_waitlist` function from a new function `eat_at_restaurant` defined in
the crate root. The `eat_at_restaurant` function is part of our library crate’s
public API, so we mark it with the `pub` keyword. In the [”Exposing Paths with
the `pub` Keyword”][pub]<!-- ignore -- > section, we’ll go into more detail
about `pub`. Note that this example won’t compile just yet; we’ll explain why
in a bit.
-->
<p>Reprenons notre exemple de l'encart 7-1. Comment pouvons-nous appeler la
fonction <code>ajouter_a_la_liste_attente</code> ? Cela revient à se demander : quel est le
chemin de la fonction <code>ajouter_a_la_liste_attente</code> ? Dans l'encart 7-3, nous
avons un peu simplifié notre code en enlevant quelques modules et quelques
fonctions. Nous allons voir deux façons d'appeler la fonction
<code>ajouter_a_la_liste_attente</code> à partir d'une nouvelle fonction
<code>manger_au_restaurant</code> définie à la racine de la crate. La fonction
<code>manger_au_restaurant</code> fait partie de l'API publique de notre crate de
bibliothèque, donc nous la marquons avec le mot-clé <code>pub</code>. Dans la section
<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposer-des-chemins-avec-le-mot-cl%C3%A9-pub">”Exposer les chemins avec le mot-clé <code>pub</code>”</a><!-- ignore -->, nous en
apprendrons plus sur <code>pub</code>. Notez que cet exemple ne se compile pas pour le
moment ; nous allons l'expliquer un peu plus tard.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">mod salle_a_manger {
    mod accueil {
        fn ajouter_a_la_liste_attente() {}
    }
}

pub fn manger_au_restaurant() {
    // Chemin absolu
    crate::salle_a_manger::accueil::ajouter_a_la_liste_attente();

    // Chemin relatif
    salle_a_manger::accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-3: Calling the `add_to_waitlist` function using
absolute and relative paths</span>
-->
<p><span class="caption">Encart 7-3 : appel à la fonction
<code>ajouter_a_la_liste_attente</code> en utilisant un chemin absolu et relatif</span></p>
<!--
The first time we call the `add_to_waitlist` function in `eat_at_restaurant`,
we use an absolute path. The `add_to_waitlist` function is defined in the same
crate as `eat_at_restaurant`, which means we can use the `crate` keyword to
start an absolute path.
-->
<p>Au premier appel de la fonction <code>ajouter_a_la_liste_attente</code> dans
<code>manger_au_restaurant</code>, nous utilisons un chemin absolu. La fonction
<code>ajouter_a_la_liste_attente</code> est définie dans la même crate que
<code>manger_au_restaurant</code>, ce qui veut dire que nous pouvons utiliser le mot-clé
<code>crate</code> pour démarrer un chemin absolu.</p>
<!--
After `crate`, we include each of the successive modules until we make our way
to `add_to_waitlist`. You can imagine a filesystem with the same structure, and
we’d specify the path `/front_of_house/hosting/add_to_waitlist` to run the
`add_to_waitlist` program; using the `crate` name to start from the crate root
is like using `/` to start from the filesystem root in your shell.
-->
<p>Après <code>crate</code>, nous ajoutons chacun des modules successifs jusqu'à
<code>ajouter_a_la_liste_attente</code>. Nous pouvons faire l'analogie avec un système de
fichiers qui aurait la même structure, où nous pourrions utiliser le chemin
<code>/salle_a_manger/accueil/ajouter_a_la_liste_attente</code> pour lancer le programme
<code>ajouter_a_la_liste_attente</code> ; utiliser le nom <code>crate</code> pour partir de la racine
de la crate revient à utiliser <code>/</code> pour partir de la racine de votre système de
fichiers dans votre invite de commande.</p>
<!--
The second time we call `add_to_waitlist` in `eat_at_restaurant`, we use a
relative path. The path starts with `front_of_house`, the name of the module
defined at the same level of the module tree as `eat_at_restaurant`. Here the
filesystem equivalent would be using the path
`front_of_house/hosting/add_to_waitlist`. Starting with a name means that the
path is relative.
-->
<p>Lors du second appel à <code>ajouter_a_la_liste_attente</code> dans <code>manger_au_restaurant</code>,
nous utilisons un chemin relatif. Le chemin commence par <code>salle_a_manger</code>, le
nom du module qui est défini au même niveau que <code>manger_au_restaurant</code> dans
l'arborescence de modules. Ici, l'équivalent en terme de système de fichier
serait le chemin <code>salle_a_manger/accueil/ajouter_a_la_liste_attente</code>. Commencer
par un nom signifie que le chemin est relatif.</p>
<!--
Choosing whether to use a relative or absolute path is a decision you’ll make
based on your project. The decision should depend on whether you’re more likely
to move item definition code separately from or together with the code that
uses the item. For example, if we move the `front_of_house` module and the
`eat_at_restaurant` function into a module named `customer_experience`, we’d
need to update the absolute path to `add_to_waitlist`, but the relative path
would still be valid. However, if we moved the `eat_at_restaurant` function
separately into a module named `dining`, the absolute path to the
`add_to_waitlist` call would stay the same, but the relative path would need to
be updated. Our preference is to specify absolute paths because it’s more
likely to move code definitions and item calls independently of each other.
-->
<p>Choisir entre utiliser un chemin relatif ou absolu sera une décision que vous
ferez en fonction de votre projet. Le choix se fera en fonction de si vous êtes
susceptible de déplacer la définition de l'élément souhaité séparément ou en
même temps que le code qui l'utilise. Par exemple, si nous déplaçons le module
<code>salle_a_manger</code> ainsi que la fonction <code>manger_au_restaurant</code> dans un module qui
s'appelle <code>experience_client</code>, nous aurons besoin de mettre à jour le chemin
absolu vers <code>ajouter_a_la_liste_attente</code>, mais le chemin relatif restera valide.
Cependant, si nous avions déplacé uniquement la fonction <code>manger_au_restaurant</code>
dans un module <code>repas</code> séparé, le chemin absolu de l'appel à
<code>ajouter_a_la_liste_attente</code> restera le même, mais le chemin relatif aura besoin
d'être mis à jour. Notre préférence est d'utiliser un chemin absolu car il est
plus facile de déplacer les définitions de code et les appels aux éléments
indépendamment les uns des autres.</p>
<!--
Let’s try to compile Listing 7-3 and find out why it won’t compile yet! The
error we get is shown in Listing 7-4.
-->
<p>Essayons de compiler l'encart 7-3 et essayons de comprendre pourquoi il ne se
compile pas pour le moment ! L'erreur que nous obtenons est affichée dans
l'encart 7-4.</p>
<!--
```console
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 -- > src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ private module
  |
note: the module `hosting` is defined here
 -- > src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  -- > src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^ private module
   |
note: the module `hosting` is defined here
  -- > src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
```
-->
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `accueil` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::salle_a_manger::accueil::ajouter_a_la_liste_attente();
  |                            ^^^^^^^ private module
  |
note: the module `accueil` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod accueil {
  |     ^^^^^^^^^^^

error[E0603]: module `accueil` is private
  --&gt; src/lib.rs:12:21
   |
12 |     salle_a_manger::accueil::ajouter_a_la_liste_attente();
   |                     ^^^^^^^ private module
   |
note: the module `accueil` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod accueil {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<!--
<span class="caption">Listing 7-4: Compiler errors from building the code in
Listing 7-3</span>
-->
<p><span class="caption">Encart 7-4 : les erreurs de compilation du code de
l'encart 7-3</span></p>
<!--
The error messages say that module `hosting` is private. In other words, we
have the correct paths for the `hosting` module and the `add_to_waitlist`
function, but Rust won’t let us use them because it doesn’t have access to the
private sections.
-->
<p>Le message d'erreur nous rappelle que ce module <code>accueil</code> est privé. Autrement
dit, nous avons des chemins corrects pour le module <code>accueil</code> et pour la
fonction <code>ajouter_a_la_liste_attente</code>, mais Rust ne nous laisse pas les utiliser
car il n'a pas accès aux sections privées.</p>
<!--
Modules aren’t useful only for organizing your code. They also define Rust’s
*privacy boundary*: the line that encapsulates the implementation details
external code isn’t allowed to know about, call, or rely on. So, if you want to
make an item like a function or struct private, you put it in a module.
-->
<p>Les modules ne servent pas uniquement à organiser votre code. Ils définissent
aussi les <em>limites de visibilité</em> de Rust : le code externe n'est pas autorisé
à connaître, à appeler ou à se fier à des éléments internes au module. Donc, si
vous voulez rendre un élément privé comme une fonction ou une structure, vous
devez le placer dans un module.</p>
<!--
The way privacy works in Rust is that all items (functions, methods, structs,
enums, modules, and constants) are private by default. Items in a parent module
can’t use the private items inside child modules, but items in child modules
can use the items in their ancestor modules. The reason is that child modules
wrap and hide their implementation details, but the child modules can see the
context in which they’re defined. To continue with the restaurant metaphor,
think of the privacy rules as being like the back office of a restaurant: what
goes on in there is private to restaurant customers, but office managers can
see and do everything in the restaurant in which they operate.
-->
<p>La visibilité en Rust fait en sorte que tous les éléments (fonctions,
méthodes, structures, énumérations, modules et constantes) sont privés par
défaut. Les éléments dans un module parent ne peuvent pas utiliser les éléments
privés dans les modules enfants, mais les éléments dans les modules enfants
peuvent utiliser les éléments dans les modules parents. C'est parce que les
modules enfants englobent et cachent les détails de leur implémentation, mais
les modules enfants peuvent voir dans quel contexte ils sont définis. Pour
continuer la métaphore du restaurant, considérez que les règles de visibilité de
Rust fonctionnent comme les cuisines d'un restaurant : ce qui s'y passe n'est
pas connu des clients, mais les gestionnaires peuvent tout voir et tout faire
dans le restaurant dans lequel ils travaillent.</p>
<!--
Rust chose to have the module system function this way so that hiding inner
implementation details is the default. That way, you know which parts of the
inner code you can change without breaking outer code. But you can expose inner
parts of child modules’ code to outer ancestor modules by using the `pub`
keyword to make an item public.
-->
<p>Rust a décidé de faire fonctionner le système de modules de façon à ce que les
détails d'implémentation interne sont cachés par défaut. Ainsi, vous savez
quelles parties du code interne vous pouvez changer sans casser le code externe.
Mais vous pouvez exposer aux parents des parties internes des modules enfants en
utilisant le mot-clé <code>pub</code> afin de les rendre publiques.</p>
<!--
### Exposing Paths with the `pub` Keyword
-->
<h3 id="exposer-des-chemins-avec-le-mot-clé-pub"><a class="header" href="#exposer-des-chemins-avec-le-mot-clé-pub">Exposer des chemins avec le mot-clé <code>pub</code></a></h3>
<!--
Let’s return to the error in Listing 7-4 that told us the `hosting` module is
private. We want the `eat_at_restaurant` function in the parent module to have
access to the `add_to_waitlist` function in the child module, so we mark the
`hosting` module with the `pub` keyword, as shown in Listing 7-5.
-->
<p>Retournons à l'erreur de l'encart 7-4 qui nous informe que le module <code>accueil</code>
est privé. Nous voulons que la fonction <code>manger_au_restaurant</code> du module parent
ait accès à la fonction <code>ajouter_a_la_liste_attente</code> du module enfant, donc nous
utilisons le mot-clé <code>pub</code> sur le module <code>accueil</code>, comme dans l'encart 7-5.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">mod salle_a_manger {
    pub mod accueil {
        fn ajouter_a_la_liste_attente() {}
    }
}

pub fn manger_au_restaurant() {
    // Chemin absolu
    crate::salle_a_manger::accueil::ajouter_a_la_liste_attente();

    // Chemin relatif
    salle_a_manger::accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-5: Declaring the `hosting` module as `pub` to
use it from `eat_at_restaurant`</span>
-->
<p><span class="caption">Encart 7-5 : utiliser <code>pub</code> sur le module <code>accueil</code> permet
de l'utiliser dans <code>manger_au_restaurant</code></span></p>
<!--
Unfortunately, the code in Listing 7-5 still results in an error, as shown in
Listing 7-6.
-->
<p>Malheureusement, il reste une erreur dans le code de l'encart 7-5, la voici dans
l'encart 7-6.</p>
<!--
```console
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 -- > src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 -- > src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  -- > src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  -- > src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
```
-->
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `ajouter_a_la_liste_attente` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::salle_a_manger::accueil::ajouter_a_la_liste_attente();
  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ private function
  |
note: the function `ajouter_a_la_liste_attente` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn ajouter_a_la_liste_attente() {}
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `ajouter_a_la_liste_attente` is private
  --&gt; src/lib.rs:12:30
   |
12 |     salle_a_manger::accueil::ajouter_a_la_liste_attente();
   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^ private function
   |
note: the function `ajouter_a_la_liste_attente` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn ajouter_a_la_liste_attente() {}
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<!--
<span class="caption">Listing 7-6: Compiler errors from building the code in
Listing 7-5</span>
-->
<p><span class="caption">Encart 7-6 : erreurs de compilation du code de l'encart
7-5</span></p>
<!--
What happened? Adding the `pub` keyword in front of `mod hosting` makes the
module public. With this change, if we can access `front_of_house`, we can
access `hosting`. But the *contents* of `hosting` are still private; making the
module public doesn’t make its contents public. The `pub` keyword on a module
only lets code in its ancestor modules refer to it.
-->
<p>Que s'est-il passé ? Ajouter le mot-clé <code>pub</code> devant <code>mod accueil</code> rend public
le module. Avec cette modification, si nous pouvons accéder à <code>salle_a_manger</code>,
alors nous pouvons accéder à <code>accueil</code>. Mais le <em>contenu</em> de <code>accueil</code> reste
privé ; rendre le module public ne rend pas son contenu public. Le mot-clé <code>pub</code>
sur un module permet uniquement au code de ses parents d'y faire référence.</p>
<!--
The errors in Listing 7-6 say that the `add_to_waitlist` function is private.
The privacy rules apply to structs, enums, functions, and methods as well as
modules.
-->
<p>Les erreurs dans l'encart 7-6 nous informent que la fonction
<code>ajouter_a_la_liste_attente</code> est privée. Les règles de visibilité s'appliquent
aussi bien aux modules qu'aux structures, énumérations, fonctions et méthodes.</p>
<!--
Let’s also make the `add_to_waitlist` function public by adding the `pub`
keyword before its definition, as in Listing 7-7.
-->
<p>Rendons publique la fonction <code>ajouter_a_la_liste_attente</code>, en ajoutant le
mot-clé <code>pub</code> devant sa définition, comme dans l'encart 7-7.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground,test_harness
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust noplayground test_harness">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

pub fn manger_au_restaurant() {
    // Chemin absolu
    crate::salle_a_manger::accueil::ajouter_a_la_liste_attente();

    // Chemin relatif
    salle_a_manger::accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-7: Adding the `pub` keyword to `mod hosting`
and `fn add_to_waitlist` lets us call the function from
`eat_at_restaurant`</span>
-->
<p><span class="caption">Encart 7-7 : ajout du mot-clé <code>pub</code> devant <code>mod accueil</code>
et <code>fn ajouter_a_la_liste_attente</code> pour nous permettre d'appeler la fonction à
partir de <code>manger_au_restaurant</code></span></p>
<!--
Now the code will compile! Let’s look at the absolute and the relative path and
double-check why adding the `pub` keyword lets us use these paths in
`add_to_waitlist` with respect to the privacy rules.
-->
<p>Maintenant, le code va compiler ! Analysons les chemins relatif et absolu et
vérifions pourquoi l'ajout du mot-clé <code>pub</code> nous permet d'utiliser ces chemins
dans <code>ajouter_a_la_liste_attente</code> tout en respectant les règles de visibilité.</p>
<!--
In the absolute path, we start with `crate`, the root of our crate’s module
tree. Then the `front_of_house` module is defined in the crate root. The
`front_of_house` module isn’t public, but because the `eat_at_restaurant`
function is defined in the same module as `front_of_house` (that is,
`eat_at_restaurant` and `front_of_house` are siblings), we can refer to
`front_of_house` from `eat_at_restaurant`. Next is the `hosting` module marked
with `pub`. We can access the parent module of `hosting`, so we can access
`hosting`. Finally, the `add_to_waitlist` function is marked with `pub` and we
can access its parent module, so this function call works!
-->
<p>Dans le chemin absolu, nous commençons avec <code>crate</code>, la racine de l'arborescence
de modules de notre crate. Ensuite, le module <code>salle_a_manger</code> est défini à la
racine de la crate. Le module <code>salle_a_manger</code> n'est pas public, mais comme la
fonction <code>manger_au_restaurant</code> est définie dans le même module que
<code>salle_a_manger</code> (car <code>manger_au_restaurant</code> et <code>salle_a_manger</code> sont frères),
nous pouvons utiliser <code>salle_a_manger</code> à partir de <code>manger_au_restaurant</code>.
Ensuite, nous avons le module <code>accueil</code>, défini avec <code>pub</code>. Nous pouvons accéder
au module parent de <code>accueil</code>, donc nous pouvons accéder à <code>accueil</code>. Enfin, la
fonction <code>ajouter_a_la_liste_attente</code> est elle aussi définie avec <code>pub</code> et nous
pouvons accéder à son module parent, donc au final cet appel à la fonction
fonctionne bien !</p>
<!--
In the relative path, the logic is the same as the absolute path except for the
first step: rather than starting from the crate root, the path starts from
`front_of_house`. The `front_of_house` module is defined within the same module
as `eat_at_restaurant`, so the relative path starting from the module in which
`eat_at_restaurant` is defined works. Then, because `hosting` and
`add_to_waitlist` are marked with `pub`, the rest of the path works, and this
function call is valid!
-->
<p>Dans le chemin relatif, le fonctionnement est le même que le chemin absolu sauf
pour la première étape : plutôt que de démarrer de la racine de la crate, le
chemin commence à partir de <code>salle_a_manger</code>. Le module <code>salle_a_manger</code> est
défini dans le même module que <code>manger_au_restaurant</code>, donc le chemin relatif
qui commence à partir du module où est défini <code>manger_au_restaurant</code> fonctionne
bien. Ensuite, comme <code>accueil</code> et <code>ajouter_a_la_liste_attente</code> sont définis avec
<code>pub</code>, le reste du chemin fonctionne, et cet appel à la fonction est donc
valide !</p>
<!--
### Starting Relative Paths with `super`
-->
<h3 id="commencer-les-chemins-relatifs-avec-super"><a class="header" href="#commencer-les-chemins-relatifs-avec-super">Commencer les chemins relatifs avec <code>super</code></a></h3>
<!--
We can also construct relative paths that begin in the parent module by using
`super` at the start of the path. This is like starting a filesystem path with
the `..` syntax. Why would we want to do this?
-->
<p>Nous pouvons aussi créer des chemins relatifs qui commencent à partir du module
parent en utilisant <code>super</code> au début du chemin. C'est comme débuter un chemin
dans un système de fichiers avec la syntaxe <code>..</code>. Mais pourquoi voudrions-nous
faire cela ?</p>
<!--
Consider the code in Listing 7-8 that models the situation in which a chef
fixes an incorrect order and personally brings it out to the customer. The
function `fix_incorrect_order` calls the function `serve_order` by specifying
the path to `serve_order` starting with `super`:
-->
<p>Imaginons le code dans l'encart 7-8 qui représente le cas où le chef corrige une
commande erronée et l'apporte personnellement au client pour s'excuser. La
fonction <code>corriger_commande_erronee</code> appelle la fonction <code>servir_commande</code> en
commençant le chemin de <code>servir_commande</code> avec <code>super</code> :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground,test_harness
fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
```
-->
<pre><code class="language-rust noplayground test_harness">fn servir_commande() {}

mod cuisines {
    fn corriger_commande_erronee() {
        cuisiner_commande();
        super::servir_commande();
    }

    fn cuisiner_commande() {}
}
</code></pre>
<!--
<span class="caption">Listing 7-8: Calling a function using a relative path
starting with `super`</span>
-->
<p><span class="caption">Encart 7-8 : appel d'une fonction en utilisant un chemin
relatif qui commence par <code>super</code></span></p>
<!--
The `fix_incorrect_order` function is in the `back_of_house` module, so we can
use `super` to go to the parent module of `back_of_house`, which in this case
is `crate`, the root. From there, we look for `serve_order` and find it.
Success! We think the `back_of_house` module and the `serve_order` function are
likely to stay in the same relationship to each other and get moved together
should we decide to reorganize the crate’s module tree. Therefore, we used
`super` so we’ll have fewer places to update code in the future if this code
gets moved to a different module.
-->
<p>La fonction <code>corriger_commande_erronee</code> est dans le module <code>cuisines</code>, donc nous
pouvons utiliser <code>super</code> pour nous rendre au module parent de <code>cuisines</code>, qui
dans notre cas est <code>crate</code>, la racine. De là, nous cherchons <code>servir_commande</code>
et nous la trouvons. Avec succès ! Nous pensons que le module <code>cuisines</code> et la
fonction <code>servir_commande</code> vont toujours garder la même relation et devrons être
déplacés ensemble si nous réorganisons l'arborescence de modules de la crate.
Ainsi, nous avons utilisé <code>super</code> pour avoir moins de code à mettre à jour à
l'avenir si ce code est déplacé dans un module différent.</p>
<!--
### Making Structs and Enums Public
-->
<h3 id="rendre-publiques-des-structures-et-des-énumérations"><a class="header" href="#rendre-publiques-des-structures-et-des-énumérations">Rendre publiques des structures et des énumérations</a></h3>
<!--
We can also use `pub` to designate structs and enums as public, but there are a
few extra details. If we use `pub` before a struct definition, we make the
struct public, but the struct’s fields will still be private. We can make each
field public or not on a case-by-case basis. In Listing 7-9, we’ve defined a
public `back_of_house::Breakfast` struct with a public `toast` field but a
private `seasonal_fruit` field. This models the case in a restaurant where the
customer can pick the type of bread that comes with a meal, but the chef
decides which fruit accompanies the meal based on what’s in season and in
stock. The available fruit changes quickly, so customers can’t choose the fruit
or even see which fruit they’ll get.
-->
<p>Nous pouvons aussi utiliser <code>pub</code> pour déclarer des structures et des
énumérations publiquement, mais il y a d'autres points à prendre en compte. Si
nous utilisons <code>pub</code> avant la définition d'une structure, nous rendons la
structure publique, mais les champs de la structure restent privés. Nous pouvons
rendre chaque champ public ou non au cas par cas. Dans l'encart 7-9, nous avons
défini une structure publique <code>cuisines::PetitDejeuner</code> avec un champ public
<code>tartine_grillee</code> mais avec un champ privé <code>fruit_de_saison</code>. Cela simule un
restaurant où le client peut choisir le type de pain qui accompagne le repas,
mais le chef décide des fruits qui accompagnent le repas en fonction de la
saison et ce qu'il y a en stock. Les fruits disponibles changent rapidement,
donc les clients ne peuvent pas choisir le fruit ou même voir quel fruit ils
obtiendront.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from("blueberries");
}
```
-->
<pre><code class="language-rust noplayground">mod cuisines {
    pub struct PetitDejeuner {
        pub tartine_grillee: String,
        fruit_de_saison: String,
    }

    impl PetitDejeuner {
        pub fn en_ete(tartine_grillee: &amp;str) -&gt; PetitDejeuner {
            PetitDejeuner {
                tartine_grillee: String::from(tartine_grillee),
                fruit_de_saison: String::from(&quot;pêches&quot;),
            }
        }
    }
}

pub fn manger_au_restaurant() {
    // On commande un petit-déjeuner en été avec tartine grillée au seigle
    let mut repas = cuisines::PetitDejeuner::en_ete(&quot;seigle&quot;);
    // On change d'avis sur le pain que nous souhaitons
    repas.tartine_grillee = String::from(&quot;blé&quot;);
    println!( &quot;Je voudrais une tartine grillée au {}, s'il vous plaît.&quot;,
              repas.tartine_grillee);

    // La prochaine ligne ne va pas se compiler si nous ne la commentons pas,
    // car nous ne sommes pas autorisés à voir ou modifier le fruit de saison
    // qui accompagne le repas.

    // repas.fruit_de_saison = String::from(&quot;myrtilles&quot;);
}
</code></pre>
<!--
<span class="caption">Listing 7-9: A struct with some public fields and some
private fields</span>
-->
<p><span class="caption">Encart 7-9 : une structure avec certains champs publics et
d'autres privés</span></p>
<!--
Because the `toast` field in the `back_of_house::Breakfast` struct is public,
in `eat_at_restaurant` we can write and read to the `toast` field using dot
notation. Notice that we can’t use the `seasonal_fruit` field in
`eat_at_restaurant` because `seasonal_fruit` is private. Try uncommenting the
line modifying the `seasonal_fruit` field value to see what error you get!
-->
<p>Comme le champ <code>tartine_grillee</code> est public dans la structure
<code>cuisines::PetitDejeuner</code>, nous pouvons lire et écrire dans le champ
<code>tartine_grillee</code> à partir de <code>manger_au_restaurant</code> en utilisant <code>.</code>. Notez
aussi que nous ne pouvons pas utiliser le champ <code>fruit_de_saison</code> dans
<code>manger_au_restaurant</code> car <code>fruit_de_saison</code> est privé. Essayez de dé-commenter
la ligne qui tente de modifier la valeur du champ <code>fruit_de_saison</code> et voyez
l'erreur que vous obtenez !</p>
<!--
Also, note that because `back_of_house::Breakfast` has a private field, the
struct needs to provide a public associated function that constructs an
instance of `Breakfast` (we’ve named it `summer` here). If `Breakfast` didn’t
have such a function, we couldn’t create an instance of `Breakfast` in
`eat_at_restaurant` because we couldn’t set the value of the private
`seasonal_fruit` field in `eat_at_restaurant`.
-->
<p>Aussi, remarquez que comme <code>cuisines::PetitDejeuner</code> a un champ privé, la
structure a besoin de fournir une fonction associée publique qui construit une
instance de <code>PetitDejeuner</code> (que nous avons nommée <code>en_ete</code> ici). Si
<code>PetitDejeuner</code> n'avait pas une fonction comme celle-ci, nous ne pourrions pas
créer une instance de <code>PetitDejeuner</code> dans <code>manger_au_restaurant</code> car nous ne
pourrions pas donner une valeur au champ privé <code>fruit_de_saison</code> dans
<code>manger_au_restaurant</code>.</p>
<!--
In contrast, if we make an enum public, all of its variants are then public. We
only need the `pub` before the `enum` keyword, as shown in Listing 7-10.
-->
<p>Par contre, si nous rendons publique une énumération, toutes ses variantes
seront publiques. Nous avons simplement besoin d'un <code>pub</code> devant le mot-clé
<code>enum</code>, comme dans l'encart 7-10.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
```
-->
<pre><code class="language-rust noplayground">mod cuisines {
    pub enum AmuseBouche {
        Soupe,
        Salade,
    }
}

pub fn manger_au_restaurant() {
    let commande1 = cuisines::AmuseBouche::Soupe;
    let commande2 = cuisines::AmuseBouche::Salade;
}
</code></pre>
<!--
<span class="caption">Listing 7-10: Designating an enum as public makes all its
variants public</span>
-->
<p><span class="caption">Encart 7-10 : on rend publique une énumération et cela
rend aussi toutes ses variantes publiques</span></p>
<!--
Because we made the `Appetizer` enum public, we can use the `Soup` and `Salad`
variants in `eat_at_restaurant`. Enums aren’t very useful unless their variants
are public; it would be annoying to have to annotate all enum variants with
`pub` in every case, so the default for enum variants is to be public. Structs
are often useful without their fields being public, so struct fields follow the
general rule of everything being private by default unless annotated with `pub`.
-->
<p>Comme nous rendons l'énumération <code>AmuseBouche</code> publique, nous pouvons utiliser
les variantes <code>Soupe</code> et <code>Salade</code> dans <code>manger_au_restaurant</code>. Les énumérations
ne sont pas très utiles si elles n'ont pas leurs variantes publiques ; et cela
serait pénible d'avoir à marquer toutes les variantes de l'énumération avec
<code>pub</code>, donc par défaut les variantes d'énumérations sont publiques. Les
structures sont souvent utiles sans avoir de champs publics, donc les champs des
structures sont tous privés par défaut, sauf si ces éléments sont marqués d'un
<code>pub</code>.</p>
<!--
There’s one more situation involving `pub` that we haven’t covered, and that is
our last module system feature: the `use` keyword. We’ll cover `use` by itself
first, and then we’ll show how to combine `pub` and `use`.
-->
<p>Il y a encore une chose que nous n'avons pas abordée concernant <code>pub</code>, et c'est
la dernière fonctionnalité du système de modules : le mot-clé <code>use</code>. Nous
commencerons par parler de l'utilisation de <code>use</code> de manière générale, puis nous
verrons comment combiner <code>pub</code> et <code>use</code>.</p>
<!--
[pub]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Bringing Paths into Scope with the `use` Keyword
-->
<h2 id="importer-des-chemins-dans-la-portée-via-le-mot-clé-use"><a class="header" href="#importer-des-chemins-dans-la-portée-via-le-mot-clé-use">Importer des chemins dans la portée via le mot-clé <code>use</code></a></h2>
<!--
It might seem like the paths we’ve written to call functions so far are
inconveniently long and repetitive. For example, in Listing 7-7, whether we
chose the absolute or relative path to the `add_to_waitlist` function, every
time we wanted to call `add_to_waitlist` we had to specify `front_of_house` and
`hosting` too. Fortunately, there’s a way to simplify this process. We can
bring a path into a scope once and then call the items in that path as if
they’re local items with the `use` keyword.
-->
<p>Les chemins que nous avons écrits jusqu'ici peuvent paraître pénibles car trop
longs et répétitifs. Par exemple, dans l'encart 7-7, que nous ayons choisi
d'utiliser le chemin absolu ou relatif pour la fonction
<code>ajouter_a_la_liste_attente</code>, nous aurions dû aussi écrire <code>salle_a_manger</code> et
<code>accueil</code> à chaque fois que nous voulions appeler <code>ajouter_a_la_liste_attente</code>.
Heureusement, il existe une solution pour simplifier ce cheminement.
Nous pouvons importer un chemin dans la portée et appeler ensuite les éléments
de ce chemin comme s'ils étaient locaux grâce au mot-clé <code>use</code>.</p>
<!--
In Listing 7-11, we bring the `crate::front_of_house::hosting` module into the
scope of the `eat_at_restaurant` function so we only have to specify
`hosting::add_to_waitlist` to call the `add_to_waitlist` function in
`eat_at_restaurant`.
-->
<p>Dans l'encart 7-11, nous importons le module <code>crate::salle_a_manger::accueil</code>
dans la portée de la fonction <code>manger_au_restaurant</code> afin que nous n'ayons plus
qu'à utiliser <code>accueil::ajouter_a_la_liste_attente</code> pour appeler la fonction
<code>ajouter_a_la_liste_attente</code> dans <code>manger_au_restaurant</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground,test_harness
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust noplayground test_harness">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

use crate::salle_a_manger::accueil;

pub fn manger_au_restaurant() {
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-11: Bringing a module into scope with
`use`</span>
-->
<p><span class="caption">Encart 7-11 : importer un module dans la portée via <code>use</code>
</span></p>
<!--
Adding `use` and a path in a scope is similar to creating a symbolic link in
the filesystem. By adding `use crate::front_of_house::hosting` in the crate
root, `hosting` is now a valid name in that scope, just as though the `hosting`
module had been defined in the crate root. Paths brought into scope with `use`
also check privacy, like any other paths.
-->
<p>Dans une portée, utiliser un <code>use</code> et un chemin s'apparente à créer un lien
symbolique dans le système de fichier. Grâce à l'ajout de
<code>use crate::salle_a_manger::accueil</code> à la racine de la crate, <code>accueil</code> est
maintenant un nom valide dans cette portée, comme si le module <code>accueil</code> avait
été défini à la racine de la crate. Les chemins importés dans la portée via
<code>use</code> doivent respecter les règles de visibilité, tout comme les autres chemins.</p>
<!--
You can also bring an item into scope with `use` and a relative path. Listing
7-12 shows how to specify a relative path to get the same behavior as in
Listing 7-11.
-->
<p>Vous pouvez aussi importer un élément dans la portée avec <code>use</code> et un chemin
relatif. L'encart 7-12 nous montre comment utiliser un chemin relatif pour
obtenir le même résultat que l'encart 7-11.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground,test_harness
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use self::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust noplayground test_harness">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

use salle_a_manger::accueil;

pub fn manger_au_restaurant() {
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-12: Bringing a module into scope with `use` and
a relative path</span>
-->
<p><span class="caption">Encart 7-12 : importer un module dans la portée avec <code>use</code>
et un chemin relatif</span></p>
<!--
### Creating Idiomatic `use` Paths
-->
<h3 id="créer-des-chemins-idéaux-pour-use"><a class="header" href="#créer-des-chemins-idéaux-pour-use">Créer des chemins idéaux pour <code>use</code></a></h3>
<!--
In Listing 7-11, you might have wondered why we specified `use
crate::front_of_house::hosting` and then called `hosting::add_to_waitlist` in
`eat_at_restaurant` rather than specifying the `use` path all the way out to
the `add_to_waitlist` function to achieve the same result, as in Listing 7-13.
-->
<p>Dans l'encart 7-11, vous vous êtes peut-être demandé pourquoi nous avions
utilisé <code>use crate::salle_a_manger::accueil</code> et appelé ensuite
<code>accueil::ajouter_a_la_liste_attente</code> dans <code>manger_au_restaurant</code> plutôt que
d'écrire le chemin du <code>use</code> jusqu'à la fonction <code>ajouter_a_la_liste_attente</code>
pour avoir le même résultat, comme dans l'encart 7-13.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground,test_harness
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
```
-->
<pre><code class="language-rust noplayground test_harness">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

use crate::salle_a_manger::accueil::ajouter_a_la_liste_attente;

pub fn manger_au_restaurant() {
    ajouter_a_la_liste_attente();
    ajouter_a_la_liste_attente();
    ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-13: Bringing the `add_to_waitlist` function
into scope with `use`, which is unidiomatic</span>
-->
<p><span class="caption">Encart 7-13 : importer la fonction
<code>ajouter_a_la_liste_attente</code> dans la portée avec <code>use</code>, ce qui n'est pas idéal
</span></p>
<!--
Although both Listing 7-11 and 7-13 accomplish the same task, Listing 7-11 is
the idiomatic way to bring a function into scope with `use`. Bringing the
function’s parent module into scope with `use` means we have to specify the
parent module when calling the function. Specifying the parent module when
calling the function makes it clear that the function isn’t locally defined
while still minimizing repetition of the full path. The code in Listing 7-13 is
unclear as to where `add_to_waitlist` is defined.
-->
<p>Bien que l'encart 7-11 et 7-13 accomplissent la même tâche, l'encart 7-11 est la
façon idéale d'importer une fonction dans la portée via <code>use</code>. L'import du
module parent de la fonction dans notre portée avec <code>use</code> nécessite que nous
ayons à préciser le module parent quand nous appelons la fonction. Renseigner le
module parent lorsque nous appelons la fonction précise clairement que la
fonction n'est pas définie localement, tout en minimisant la répétition du
chemin complet. Nous ne pouvons pas repérer facilement là où est défini
<code>ajouter_a_la_liste_attente</code> dans l'encart 7-13.</p>
<!--
On the other hand, when bringing in structs, enums, and other items with `use`,
it’s idiomatic to specify the full path. Listing 7-14 shows the idiomatic way
to bring the standard library’s `HashMap` struct into the scope of a binary
crate.
-->
<p>Cela dit, lorsque nous importons des structures, des énumérations, et d'autres
éléments avec <code>use</code>, il est idéal de préciser le chemin complet. L'encart 7-14
montre la manière idéale d'importer la structure <code>HashMap</code> de la bibliothèque
standard dans la portée d'une crate binaire.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<!--
<span class="caption">Listing 7-14: Bringing `HashMap` into scope in an
idiomatic way</span>
-->
<p><span class="caption">Encart 7-14 : import de <code>HashMap</code> dans la portée de
manière idéale</span></p>
<!--
There’s no strong reason behind this idiom: it’s just the convention that has
emerged, and folks have gotten used to reading and writing Rust code this way.
-->
<p>Il n'y a pas de forte justification à cette pratique : c'est simplement une
convention qui a germé, et les gens se sont habitués à lire et écrire du code
Rust de cette façon.</p>
<!--
The exception to this idiom is if we’re bringing two items with the same name
into scope with `use` statements, because Rust doesn’t allow that. Listing 7-15
shows how to bring two `Result` types into scope that have the same name but
different parent modules and how to refer to them.
-->
<p>Il y a une exception à cette pratique : nous ne pouvons pas utiliser
l'instruction <code>use</code> pour importer deux éléments avec le même nom dans la portée,
car Rust ne l'autorise pas. L'encart 7-15 nous montre comment importer puis
utiliser deux types <code>Result</code> ayant le même nom mais dont les modules parents
sont distincts.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    // --snip--
#     Ok(())
}

fn function2() -> io::Result<()> {
    // --snip--
#     Ok(())
}
```
-->
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn fonction1() -&gt; fmt::Result {
    // -- partie masquée ici --
<span class="boring">    Ok(())
</span>}

fn fonction2() -&gt; io::Result&lt;()&gt; {
    // -- partie masquée ici --
<span class="boring">    Ok(())
</span>}
</code></pre>
<!--
<span class="caption">Listing 7-15: Bringing two types with the same name into
the same scope requires using their parent modules.</span>
-->
<p><span class="caption">Encart 7-15 : l'import de deux types ayant le même nom
dans la même portée nécessite d'utiliser leurs modules parents.</span></p>
<!--
As you can see, using the parent modules distinguishes the two `Result` types.
If instead we specified `use std::fmt::Result` and `use std::io::Result`, we’d
have two `Result` types in the same scope and Rust wouldn’t know which one we
meant when we used `Result`.
-->
<p>Comme vous pouvez le constater, l'utilisation des modules parents permet de
distinguer les deux types <code>Result</code>. Si nous avions utilisé
<code>use std::fmt::Result</code> et <code>use std::io::Result</code>, nous aurions deux types nommés
<code>Result</code> dans la même portée et donc Rust ne pourrait pas comprendre lequel nous
voudrions utiliser en demandant <code>Result</code>.</p>
<!--
### Providing New Names with the `as` Keyword
-->
<h3 id="renommer-des-éléments-avec-le-mot-clé-as"><a class="header" href="#renommer-des-éléments-avec-le-mot-clé-as">Renommer des éléments avec le mot-clé <code>as</code></a></h3>
<!--
There’s another solution to the problem of bringing two types of the same name
into the same scope with `use`: after the path, we can specify `as` and a new
local name, or alias, for the type. Listing 7-16 shows another way to write the
code in Listing 7-15 by renaming one of the two `Result` types using `as`.
-->
<p>Il y a une autre solution au fait d'avoir deux types du même nom dans la même
portée à cause de <code>use</code> : après le chemin, nous pouvons rajouter <code>as</code> suivi d'un
nouveau nom local, ou alias, sur le type. L'encart 7-16 nous montre une autre
façon d'écrire le code de l'encart 7-15 en utilisant <code>as</code> pour renommer un des
deux types <code>Result</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
#     Ok(())
}

fn function2() -> IoResult<()> {
    // --snip--
#     Ok(())
}
```
-->
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn fonction1() -&gt; Result {
    // -- partie masquée ici --
<span class="boring">    Ok(())
</span>}

fn fonction2() -&gt; IoResult&lt;()&gt; {
    // -- partie masquée ici --
<span class="boring">    Ok(())
</span>}
</code></pre>
<!--
<span class="caption">Listing 7-16: Renaming a type when it’s brought into
scope with the `as` keyword</span>
-->
<p><span class="caption">Encart 7-16 : renommer un type lorsqu'il est importé dans
la portée, avec le mot-clé <code>as</code></span></p>
<!--
In the second `use` statement, we chose the new name `IoResult` for the
`std::io::Result` type, which won’t conflict with the `Result` from `std::fmt`
that we’ve also brought into scope. Listing 7-15 and Listing 7-16 are
considered idiomatic, so the choice is up to you!
-->
<p>Dans la seconde instruction <code>use</code>, nous avons choisi <code>IoResult</code> comme nouveau
nom du type <code>std::io::Result</code>, qui n'est plus en conflit avec le <code>Result</code> de
<code>std::fmt</code> que nous avons aussi importé dans la portée. Les encarts 7-15 et 7-16
sont idéaux, donc le choix vous revient !</p>
<!--
### Re-exporting Names with `pub use`
-->
<h3 id="réexporter-des-éléments-avec-pub-use"><a class="header" href="#réexporter-des-éléments-avec-pub-use">Réexporter des éléments avec <code>pub use</code></a></h3>
<!--
When we bring a name into scope with the `use` keyword, the name available in
the new scope is private. To enable the code that calls our code to refer to
that name as if it had been defined in that code’s scope, we can combine `pub`
and `use`. This technique is called *re-exporting* because we’re bringing
an item into scope but also making that item available for others to bring into
their scope.
-->
<p>Lorsque nous importons un élément dans la portée avec le mot-clé <code>use</code>, son nom
dans la nouvelle portée est privé. Pour permettre au code appelant d'utiliser ce
nom comme s'il était défini dans cette portée, nous pouvons associer <code>pub</code> et
<code>use</code>. Cette technique est appelée <em>réexporter</em> car nous importons un élément
dans la portée, mais nous rendons aussi cet élément disponible aux portées des
autres.</p>
<!--
Listing 7-17 shows the code in Listing 7-11 with `use` in the root module
changed to `pub use`.
-->
<p>L'encart 7-17 nous montre le code de l'encart 7-11 où le <code>use</code> du module racine
a été remplacé par <code>pub use</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground,test_harness
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust noplayground test_harness">mod salle_a_manger {
    pub mod accueil {
        pub fn ajouter_a_la_liste_attente() {}
    }
}

pub use crate::salle_a_manger::accueil;

pub fn manger_au_restaurant() {
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-17: Making a name available for any code to use
from a new scope with `pub use`</span>
-->
<p><span class="caption">Encart 7-17 : rendre un élément disponible pour n'importe
quel code qui l'importera dans sa portée, avec <code>pub use</code></span></p>
<!--
By using `pub use`, external code can now call the `add_to_waitlist` function
using `hosting::add_to_waitlist`. If we hadn’t specified `pub use`, the
`eat_at_restaurant` function could call `hosting::add_to_waitlist` in its
scope, but external code couldn’t take advantage of this new path.
-->
<p>Grâce à <code>pub use</code>, le code externe peut maintenant appeler la fonction
<code>ajouter_a_la_liste_attente</code> en utilisant <code>accueil::ajouter_a_la_liste_attente</code>.
Si nous n'avions pas utilisé <code>pub use</code>, la fonction <code>manger_au_restaurant</code>
aurait pu appeler <code>accueil::ajouter_a_la_liste_attente</code> dans sa portée, mais le
code externe n'aurait pas pu profiter de ce nouveau chemin.</p>
<!--
Re-exporting is useful when the internal structure of your code is different
from how programmers calling your code would think about the domain. For
example, in this restaurant metaphor, the people running the restaurant think
about “front of house” and “back of house.” But customers visiting a restaurant
probably won’t think about the parts of the restaurant in those terms. With
`pub use`, we can write our code with one structure but expose a different
structure. Doing so makes our library well organized for programmers working on
the library and programmers calling the library.
-->
<p>Réexporter est utile quand la structure interne de votre code est différente de
la façon dont les développeurs qui utilisent votre code se la représentent. Par
exemple, dans cette métaphore du restaurant, les personnes qui font fonctionner
le restaurant se structurent en fonction de la “salle à manger” et des
“cuisines”. Mais les clients qui utilisent le restaurant ne vont probablement
pas voir les choses ainsi. Avec <code>pub use</code>, nous pouvons écrire notre code selon
une certaine organisation, mais l'exposer avec une organisation différente. En
faisant ainsi, la bibliothèque est bien organisée autant pour les développeurs
qui travaillent sur la bibliothèque que pour les développeurs qui utilisent la
bibliothèque.</p>
<!--
### Using External Packages
-->
<h3 id="utiliser-des-paquets-externes"><a class="header" href="#utiliser-des-paquets-externes">Utiliser des paquets externes</a></h3>
<!--
In Chapter 2, we programmed a guessing game project that used an external
package called `rand` to get random numbers. To use `rand` in our project, we
added this line to *Cargo.toml*:
-->
<p>Dans le chapitre 2, nous avions développé un projet de jeu du plus ou du moins
qui utilisait le paquet externe <code>rand</code> afin d'obtenir des nombres aléatoires.
Pour pouvoir utiliser <code>rand</code> dans notre projet, nous avions ajouté cette ligne
dans <em>Cargo.toml</em> :</p>
<!--
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-- >
-->
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<!--
```toml
rand = "0.8.3"
```
-->
<pre><code class="language-toml">rand = &quot;0.8.3&quot;
</code></pre>
<!--
Adding `rand` as a dependency in *Cargo.toml* tells Cargo to download the
`rand` package and any dependencies from [crates.io](https://crates.io/) and
make `rand` available to our project.
-->
<p>L'ajout de <code>rand</code> comme dépendance dans <em>Cargo.toml</em> demande à Cargo de
télécharger le paquet <code>rand</code> et toutes ses dépendances à partir de
<a href="https://crates.io/">crates.io</a> et rend disponible <code>rand</code> pour notre projet.</p>
<!--
Then, to bring `rand` definitions into the scope of our package, we added a
`use` line starting with the name of the crate, `rand`, and listed the items
we wanted to bring into scope. Recall that in the [“Generating a Random
Number”][rand]<!-- ignore -- > section in Chapter 2, we brought the `Rng` trait
into scope and called the `rand::thread_rng` function:
-->
<p>Ensuite, pour importer les définitions de <code>rand</code> dans la portée de notre paquet,
nous avions ajouté une ligne <code>use</code> qui commence avec le nom de la crate, <code>rand</code>,
et nous avions listé les éléments que nous voulions importer dans notre portée.
Dans la section <a href="ch02-00-guessing-game-tutorial.html#g%C3%A9n%C3%A9rer-le-nombre-secret">“Générer le nombre secret”</a><!-- ignore --> du chapitre 2,
nous avions importé le trait <code>Rng</code> dans la portée, puis nous avions appelé la
fonction <code>rand::thread_rng</code> :</p>
<!--
```rust,ignore
# use std::io;
use rand::Rng;

fn main() {
#     println!("Guess the number!");
# 
    let secret_number = rand::thread_rng().gen_range(1..101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!(&quot;Devinez le nombre !&quot;);
</span><span class="boring">
</span>    let nombre_secret = rand::thread_rng().gen_range(1..101);
<span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret est : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Votre nombre : {}&quot;, supposition);
</span>}
</code></pre>
<!--
Members of the Rust community have made many packages available at
[crates.io](https://crates.io/), and pulling any of them into your package
involves these same steps: listing them in your package’s *Cargo.toml* file and
using `use` to bring items from their crates into scope.
-->
<p>Les membres de la communauté Rust ont mis à disposition de nombreux paquets sur
<a href="https://crates.io/">crates.io</a>, et utiliser l'un d'entre eux dans votre paquet
implique toujours ces mêmes étapes : les lister dans le fichier <em>Cargo.toml</em> de
votre paquet et utiliser <code>use</code> pour importer certains éléments de ces crates
dans la portée.</p>
<!--
Note that the standard library (`std`) is also a crate that’s external to our
package. Because the standard library is shipped with the Rust language, we
don’t need to change *Cargo.toml* to include `std`. But we do need to refer to
it with `use` to bring items from there into our package’s scope. For example,
with `HashMap` we would use this line:
-->
<p>Notez que la bibliothèque standard (<code>std</code>) est aussi une crate qui est externe à
notre paquet. Comme la bibliothèque standard est livrée avec le langage Rust,
nous n'avons pas à modifier le <em>Cargo.toml</em> pour y inclure <code>std</code>. Mais nous
devons utiliser <code>use</code> pour importer les éléments qui se trouvent dans la portée
de notre paquet. Par exemple, pour <code>HashMap</code>, nous pourrions utiliser cette
ligne :</p>
<!--
```rust
use std::collections::HashMap;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}
</span></code></pre></pre>
<!--
This is an absolute path starting with `std`, the name of the standard library
crate.
-->
<p>C'est un chemin absolu qui commence par <code>std</code>, le nom de la crate de la
bibliothèque standard.</p>
<!--
### Using Nested Paths to Clean Up Large `use` Lists
-->
<h3 id="utiliser-des-chemins-imbriqués-pour-simplifier-les-grandes-listes-de-use"><a class="header" href="#utiliser-des-chemins-imbriqués-pour-simplifier-les-grandes-listes-de-use">Utiliser des chemins imbriqués pour simplifier les grandes listes de <code>use</code></a></h3>
<!--
If we’re using multiple items defined in the same crate or same module,
listing each item on its own line can take up a lot of vertical space in our
files. For example, these two `use` statements we had in the Guessing Game in
Listing 2-4 bring items from `std` into scope:
-->
<p>Si vous utilisez de nombreux éléments définis dans une même crate ou dans un
même module, lister chaque élément sur sa propre ligne prendra beaucoup d'espace
vertical dans vos fichiers. Par exemple, ces deux instructions <code>use</code>, que nous
avions dans le jeu du plus ou du moins dans l'encart 2-4, importaient des
éléments de <code>std</code> dans la portée :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1..101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     println!("You guessed: {}", guess);
# 
#     match guess.cmp(&secret_number) {
#         Ordering::Less => println!("Too small!"),
#         Ordering::Greater => println!("Too big!"),
#         Ordering::Equal => println!("You win!"),
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// -- partie masquée ici --
use std::cmp::Ordering;
use std::io;
// -- partie masquée ici --
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret est : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombre : {}&quot;, supposition);
</span><span class="boring">
</span><span class="boring">    match supposition.cmp(&amp;nombre_secret) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;Vous avez gagné !&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Instead, we can use nested paths to bring the same items into scope in one
line. We do this by specifying the common part of the path, followed by two
colons, and then curly brackets around a list of the parts of the paths that
differ, as shown in Listing 7-18.
-->
<p>À la place, nous pouvons utiliser des chemins imbriqués afin d'importer ces
mêmes éléments dans la portée en une seule ligne. Nous pouvons faire cela en
indiquant la partie commune du chemin, suivi d'un double deux-points, puis
d'accolades autour d'une liste des éléments qui diffèrent entre les chemins,
comme dans l'encart 7-18 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use rand::Rng;
// --snip--
use std::{cmp::Ordering, io};
// --snip--
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1..101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     println!("Please input your guess.");
# 
#     let mut guess = String::new();
# 
#     io::stdin()
#         .read_line(&mut guess)
#         .expect("Failed to read line");
# 
#     let guess: u32 = guess.trim().parse().expect("Please type a number!");
# 
#     println!("You guessed: {}", guess);
# 
#     match guess.cmp(&secret_number) {
#         Ordering::Less => println!("Too small!"),
#         Ordering::Greater => println!("Too big!"),
#         Ordering::Equal => println!("You win!"),
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// -- partie masquée ici --
use std::{cmp::Ordering, io};
// -- partie masquée ici --
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret est : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut supposition)
</span><span class="boring">        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</span><span class="boring">
</span><span class="boring">    let supposition: u32 = supposition.trim().parse().expect(&quot;Veuillez saisir un nombre !&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Votre nombre : {}&quot;, supposition);
</span><span class="boring">
</span><span class="boring">    match supposition.cmp(&amp;nombre_secret) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;Vous avez gagné !&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 7-18: Specifying a nested path to bring multiple
items with the same prefix into scope</span>
-->
<p><span class="caption">Encart 7-18 : utiliser un chemin imbriqué pour importer
plusieurs éléments avec le même préfixe dans la portée</span></p>
<!--
In bigger programs, bringing many items into scope from the same crate or
module using nested paths can reduce the number of separate `use` statements
needed by a lot!
-->
<p>Pour des programmes plus gros, importer plusieurs éléments dans la portée depuis
la même crate ou module en utilisant des chemins imbriqués peut réduire
considérablement le nombre de <code>use</code> utilisés !</p>
<!--
We can use a nested path at any level in a path, which is useful when combining
two `use` statements that share a subpath. For example, Listing 7-19 shows two
`use` statements: one that brings `std::io` into scope and one that brings
`std::io::Write` into scope.
-->
<p>Nous pouvons utiliser un chemin imbriqué à tous les niveaux d'un chemin, ce qui
peut être utile lorsqu'on utilise deux instructions <code>use</code> qui partagent un
sous-chemin. Par exemple, l'encart 7-19 nous montre deux instructions <code>use</code> :
une qui importe <code>std::io</code> dans la portée et une autre qui importe
<code>std::io::Write</code> dans la portée.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
use std::io;
use std::io::Write;
```
-->
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;
</code></pre>
<!--
<span class="caption">Listing 7-19: Two `use` statements where one is a subpath
of the other</span>
-->
<p><span class="caption">Encart 7-19 : deux instructions <code>use</code> où l'une est un
sous-chemin de l'autre</span></p>
<!--
The common part of these two paths is `std::io`, and that’s the complete first
path. To merge these two paths into one `use` statement, we can use `self` in
the nested path, as shown in Listing 7-20.
-->
<p>La partie commune entre ces deux chemins est <code>std::io</code>, et c'est le premier
chemin complet. Pour imbriquer ces deux chemins en une seule instruction <code>use</code>,
nous pouvons utiliser <code>self</code> dans le chemin imbriqué, comme dans l'encart 7-20.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
use std::io::{self, Write};
```
-->
<pre><code class="language-rust noplayground">use std::io::{self, Write};
</code></pre>
<!--
<span class="caption">Listing 7-20: Combining the paths in Listing 7-19 into
one `use` statement</span>
-->
<p><span class="caption">Encart 7-20 : imbrication des chemins de l'encart 7-19
dans une seule instruction <code>use</code></span></p>
<!--
This line brings `std::io` and `std::io::Write` into scope.
-->
<p>Cette ligne importe <code>std::io</code> et <code>std::io::Write</code> dans la portée.</p>
<!--
### The Glob Operator
-->
<h3 id="lopérateur-global"><a class="header" href="#lopérateur-global">L'opérateur global</a></h3>
<!--
If we want to bring *all* public items defined in a path into scope, we can
specify that path followed by `*`, the glob operator:
-->
<p>Si nous voulons importer, dans la portée, <em>tous</em> les éléments publics définis
dans un chemin, nous pouvons indiquer ce chemin suivi par <code>*</code>, l'opérateur
global :</p>
<!--
```rust
use std::collections::*;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}
</span></code></pre></pre>
<!--
This `use` statement brings all public items defined in `std::collections` into
the current scope. Be careful when using the glob operator! Glob can make it
harder to tell what names are in scope and where a name used in your program
was defined.
-->
<p>Cette instruction <code>use</code> va importer tous les éléments publics définis dans
<code>std::collections</code> dans la portée courante. Mais soyez prudent quand vous
utilisez l'opérateur global ! L'opérateur global rend difficile à dire quels
éléments sont dans la portée et là où un élément utilisé dans notre programme a
été défini.</p>
<!--
The glob operator is often used when testing to bring everything under test
into the `tests` module; we’ll talk about that in the [“How to Write
Tests”][writing-tests]<!-- ignore -- > section in Chapter 11. The glob operator
is also sometimes used as part of the prelude pattern: see [the standard
library documentation](../std/prelude/index.html#other-preludes)<!-- ignore -- >
for more information on that pattern.
-->
<p>L'opérateur global est souvent utilisé lorsque nous écrivons des tests, pour
importer tout ce qu'il y a à tester dans le module <code>tests</code> ; nous verrons cela
dans une section du <a href="ch11-01-writing-tests.html">chapitre 11</a>. L'opérateur global est parfois
aussi utilisé pour l'étape préliminaire : rendez-vous dans <a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes">la documentation de
la bibliothèque
standard</a><!--
ignore --> pour plus d'informations sur cela.</p>
<!--
[rand]: ch02-00-guessing-game-tutorial.html#generating-a-random-number
[writing-tests]: ch11-01-writing-tests.html#how-to-write-tests
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Separating Modules into Different Files
-->
<h2 id="séparer-les-modules-dans-différents-fichiers"><a class="header" href="#séparer-les-modules-dans-différents-fichiers">Séparer les modules dans différents fichiers</a></h2>
<!--
So far, all the examples in this chapter defined multiple modules in one file.
When modules get large, you might want to move their definitions to a separate
file to make the code easier to navigate.
-->
<p>Jusqu'à présent, tous les exemples de ce chapitre ont défini plusieurs modules
dans un seul fichier. Quand les modules vont grossir, vous allez probablement
vouloir déplacer leurs définitions dans un fichier séparé pour faciliter le
parcours de votre code.</p>
<!--
For example, let’s start from the code in Listing 7-17 and move the
`front_of_house` module to its own file *src/front_of_house.rs* by changing the
crate root file so it contains the code shown in Listing 7-21. In this case,
the crate root file is *src/lib.rs*, but this procedure also works with binary
crates whose crate root file is *src/main.rs*.
-->
<p>Prenons par exemple le code de l'encart 7-17 et déplaçons le module
<code>salle_a_manger</code> dans son propre fichier <em>src/salle_a_manger.rs</em> en changeant le
fichier à la racine de la crate afin qu'il corresponde au code de l'encart 7-21.
Dans notre cas, le fichier à la racine de la crate est <em>src/lib.rs</em>, mais cette
procédure fonctionne aussi avec les crates binaires dans lesquelles le fichier à
la racine de la crate est <em>src/main.rs</em>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```
-->
<pre><code class="language-rust ignore">mod salle_a_manger;

pub use crate::salle_a_manger::accueil;

pub fn manger_au_restaurant() {
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
    accueil::ajouter_a_la_liste_attente();
}
</code></pre>
<!--
<span class="caption">Listing 7-21: Declaring the `front_of_house` module whose
body will be in *src/front_of_house.rs*</span>
-->
<p><span class="caption">Encart 7-21 : Déclaration du module <code>salle_a_manger</code> dont
le corps sera dans <em>src/salle_a_manger.rs</em></span></p>
<!--
And *src/front_of_house.rs* gets the definitions from the body of the
`front_of_house` module, as shown in Listing 7-22.
-->
<p>Et <em>src/salle_a_manger.rs</em> contiendra la définition du corps du module
<code>salle_a_manger</code>, comme dans l'encart 7-22.</p>
<!--
<span class="filename">Filename: src/front_of_house.rs</span>
-->
<p><span class="filename">Fichier : src/salle_a_manger.rs</span></p>
<!--
```rust,ignore
pub mod hosting {
    pub fn add_to_waitlist() {}
}
```
-->
<pre><code class="language-rust ignore">pub mod accueil {
    pub fn ajouter_a_la_liste_attente() {}
}
</code></pre>
<!--
<span class="caption">Listing 7-22: Definitions inside the `front_of_house`
module in *src/front_of_house.rs*</span>
-->
<p><span class="caption">Encart 7-22 : Les définitions à l'intérieur du module
<code>salle_a_manger</code> dans <em>src/salle_a_manger.rs</em></span></p>
<!--
Using a semicolon after `mod front_of_house` rather than using a block tells
Rust to load the contents of the module from another file with the same name as
the module. To continue with our example and extract the `hosting` module to
its own file as well, we change *src/front_of_house.rs* to contain only the
declaration of the `hosting` module:
-->
<p>Utiliser un point-virgule après <code>mod salle_a_manger</code> plutôt que de créer un bloc
indique à Rust de charger le contenu du module à partir d'un autre fichier qui
porte le même nom que le module. Pour continuer avec notre exemple et déplacer
également le module <code>accueil</code> dans son propre fichier, nous modifions
<em>src/salle_a_manger.rs</em> pour avoir uniquement la déclaration du module
<code>accueil</code> :</p>
<!--
<span class="filename">Filename: src/front_of_house.rs</span>
-->
<p><span class="filename">Fichier : src/salle_a_manger.rs</span></p>
<!--
```rust,ignore
pub mod hosting;
```
-->
<pre><code class="language-rust ignore">pub mod accueil;
</code></pre>
<!--
Then we create a *src/front_of_house* directory and a file
*src/front_of_house/hosting.rs* to contain the definitions made in the
`hosting` module:
-->
<p>Ensuite, nous créons un dossier <em>src/salle_a_manger</em> et un fichier
<em>src/salle_a_manger/accueil.rs</em> qui contiendra les définitions du module
<code>accueil</code> :</p>
<!--
<span class="filename">Filename: src/front_of_house/hosting.rs</span>
-->
<p><span class="filename">Fichier : src/salle_a_manger/accueil.rs</span></p>
<!--
```rust
pub fn add_to_waitlist() {}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn ajouter_a_la_liste_attente() {}
<span class="boring">}
</span></code></pre></pre>
<!--
The module tree remains the same, and the function calls in `eat_at_restaurant`
will work without any modification, even though the definitions live in
different files. This technique lets you move modules to new files as they grow
in size.
-->
<p>L'arborescence des modules reste identique, et les appels aux fonctions de
<code>manger_au_restaurant</code> vont continuer à fonctionner sans aucune modification,
même si les définitions se retrouvent dans des fichiers différents. Cette
technique vous permet de déplacer des modules dans de nouveaux fichiers au fur
et à mesure qu'ils s'agrandissent.</p>
<!--
Note that the `pub use crate::front_of_house::hosting` statement in
*src/lib.rs* also hasn’t changed, nor does `use` have any impact on what files
are compiled as part of the crate. The `mod` keyword declares modules, and Rust
looks in a file with the same name as the module for the code that goes into
that module.
-->
<p>Remarquez que l'instruction <code>pub use crate::salle_a_manger::accueil</code> dans
<em>src/lib.rs</em> n'a pas changé, et que <code>use</code> n'a aucun impact sur quels fichiers
sont compilés pour constituer la crate. Le mot-clé <code>mod</code> déclare un module, et
Rust recherche un fichier de code qui porte le nom dudit module.</p>
<!--
## Summary
-->
<h2 id="résumé-6"><a class="header" href="#résumé-6">Résumé</a></h2>
<!--
Rust lets you split a package into multiple crates and a crate into modules
so you can refer to items defined in one module from another module. You can do
this by specifying absolute or relative paths. These paths can be brought into
scope with a `use` statement so you can use a shorter path for multiple uses of
the item in that scope. Module code is private by default, but you can make
definitions public by adding the `pub` keyword.
-->
<p>Rust vous permet de découper un paquet en plusieurs crates et une crate en
modules afin que vous puissiez réutiliser vos éléments d'un module à un autre.
Vous pouvez faire cela en utilisant des chemins absolus ou relatifs. Ces chemins
peuvent être importés dans la portée avec l'instruction <code>use</code> pour pouvoir
utiliser l'élément plusieurs fois dans la portée avec un chemin plus court. Le
code du module est privé par défaut, mais vous pouvez rendre publiques des
définitions en ajoutant le mot-clé <code>pub</code>.</p>
<!--
In the next chapter, we’ll look at some collection data structures in the
standard library that you can use in your neatly organized code.
-->
<p>Au prochain chapitre, nous allons nous intéresser à quelques collections de
structures de données de la bibliothèque standard que vous pourrez utiliser dans
votre code soigneusement organisé.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Common Collections
-->
<h1 id="les-collections-standard"><a class="header" href="#les-collections-standard">Les collections standard</a></h1>
<!--
Rust’s standard library includes a number of very useful data structures called
*collections*. Most other data types represent one specific value, but
collections can contain multiple values. Unlike the built-in array and tuple
types, the data these collections point to is stored on the heap, which means
the amount of data does not need to be known at compile time and can grow or
shrink as the program runs. Each kind of collection has different capabilities
and costs, and choosing an appropriate one for your current situation is a
skill you’ll develop over time. In this chapter, we’ll discuss three
collections that are used very often in Rust programs:
-->
<p>La bibliothèque standard de Rust apporte quelques structures de données très
utiles appelées <em>collections</em>. La plupart des autres types de données
représentent une seule valeur précise, mais les collections peuvent contenir
plusieurs valeurs. Contrairement aux tableaux et aux tuples, les données que ces
collections contiennent sont stockées sur le tas, ce qui veut dire que la
quantité de données n'a pas à être connue au moment de la compilation et peut
augmenter ou diminuer pendant l'exécution du programme. Chaque type de
collection a ses avantages et ses inconvénients, et en choisir un qui répond à
votre besoin sur le moment est une aptitude que vous allez développer avec le
temps. Dans ce chapitre, nous allons découvrir trois collections qui sont très
utilisées dans les programmes Rust :</p>
<!--
* A *vector* allows you to store a variable number of values next to each other.
* A *string* is a collection of characters. We’ve mentioned the `String` type
  previously, but in this chapter we’ll talk about it in depth.
* A *hash map* allows you to associate a value with a particular key. It’s a
  particular implementation of the more general data structure called a *map*.
-->
<ul>
<li>Le <em>vecteur</em> qui vous permet de stocker un nombre variable de valeurs les unes
à côté des autres.</li>
<li>La <em>String</em>, qui est une collection de caractères. Nous avons déjà aperçu le
type <code>String</code> précédemment, mais dans ce chapitre, nous allons l'étudier en
détail.</li>
<li>La <em>table de hachage</em> qui vous permet d'associer une valeur à une clé précise.
C'est une implémentation spécifique d'une structure de données plus
générique : le <em>tableau associatif</em>.</li>
</ul>
<!--
To learn about the other kinds of collections provided by the standard library,
see [the documentation][collections].
-->
<p>Pour en savoir plus sur les autres types de collections fournies par la
bibliothèque standard, allez voir <a href="https://doc.rust-lang.org/std/collections/index.html">la documentation</a>.</p>
<!--
[collections]: ../std/collections/index.html
-->
<!--
We’ll discuss how to create and update vectors, strings, and hash maps, as well
as what makes each special.
-->
<p>Nous allons voir comment créer et modifier les vecteurs, les Strings et les
tables de hachage, et étudier leurs différences.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Storing Lists of Values with Vectors
-->
<h2 id="stocker-des-listes-de-valeurs-avec-des-vecteurs"><a class="header" href="#stocker-des-listes-de-valeurs-avec-des-vecteurs">Stocker des listes de valeurs avec des vecteurs</a></h2>
<!--
The first collection type we’ll look at is `Vec<T>`, also known as a *vector*.
Vectors allow you to store more than one value in a single data structure that
puts all the values next to each other in memory. Vectors can only store values
of the same type. They are useful when you have a list of items, such as the
lines of text in a file or the prices of items in a shopping cart.
-->
<p>Le premier type de collection que nous allons voir est <code>Vec&lt;T&gt;</code>, aussi appelé
<em>vecteur</em>. Les vecteurs vous permettent de stocker plus d'une valeur dans une
seule structure de données qui stocke les valeurs les unes à côté des autres
dans la mémoire. Les vecteurs peuvent stocker uniquement des valeurs du même
type. Ils sont utiles lorsque vous avez une liste d'éléments, tels que les
lignes de texte provenant d'un fichier ou les prix des articles d'un panier
d'achat.</p>
<!--
### Creating a New Vector
-->
<h3 id="créer-un-nouveau-vecteur"><a class="header" href="#créer-un-nouveau-vecteur">Créer un nouveau vecteur</a></h3>
<!--
To create a new, empty vector, we can call the `Vec::new` function, as shown in
Listing 8-1.
-->
<p>Pour créer un nouveau vecteur vide, nous pouvons appeler la fonction <code>Vec::new</code>,
comme dans l'encart 8-1.</p>
<!--
```rust
# fn main() {
    let v: Vec<i32> = Vec::new();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-1: Creating a new, empty vector to hold values
of type `i32`</span>
-->
<p><span class="caption">Encart 8-1 : création d'un nouveau vecteur vide pour y
stocker des valeurs de type <code>i32</code></span></p>
<!--
Note that we added a type annotation here. Because we aren’t inserting any
values into this vector, Rust doesn’t know what kind of elements we intend to
store. This is an important point. Vectors are implemented using generics;
we’ll cover how to use generics with your own types in Chapter 10. For now,
know that the `Vec<T>` type provided by the standard library can hold any type,
and when a specific vector holds a specific type, the type is specified within
angle brackets. In Listing 8-1, we’ve told Rust that the `Vec<T>` in `v` will
hold elements of the `i32` type.
-->
<p>Remarquez que nous avons ajouté ici une annotation de type. Comme nous
n'ajoutons pas de valeurs dans ce vecteur, Rust ne sait pas quel type d'éléments
nous souhaitons stocker. C'est une information importante. Les vecteurs sont
implémentés avec la généricité ; nous verrons comment utiliser la généricité sur
vos propres types au chapitre 10. Pour l'instant, sachez que le type <code>Vec&lt;T&gt;</code>
qui est fourni par la bibliothèque standard peut stocker n'importe quel type, et
lorsqu'un vecteur précis stocke un type précis, ce type est renseigné entre des
chevrons. Dans l'encart 8-1, nous précisons à Rust que le <code>Vec&lt;T&gt;</code> dans <code>v</code> va
stocker des éléments de type <code>i32</code>.</p>
<!--
In more realistic code, Rust can often infer the type of value you want to
store once you insert values, so you rarely need to do this type annotation.
It’s more common to create a `Vec<T>` that has initial values, and Rust
provides the `vec!` macro for convenience. The macro will create a new vector
that holds the values you give it. Listing 8-2 creates a new `Vec<i32>` that
holds the values `1`, `2`, and `3`. The integer type is `i32` because that’s
the default integer type, as we discussed in the [“Data Types”][data-types]<!--
ignore -- > section of Chapter 3.
-->
<p>Dans du code plus réaliste, Rust peut souvent deviner le type de la valeur que
vous souhaitez stocker dès que vous ajoutez des valeurs, donc vous n'aurez pas
souvent besoin de faire cette annotation de type. Il est plus fréquent de créer
un <code>Vec&lt;T&gt;</code> qui a des valeurs initiales, et Rust fournit la macro <code>vec!</code> par
commodité. La macro va créer un nouveau vecteur qui stockera les valeurs que
vous lui donnerez. L'encart 8-2 crée un nouveau <code>Vec&lt;i32&gt;</code> qui stocke les
valeurs <code>1</code>, <code>2</code> et <code>3</code>. Le type d'entier est <code>i32</code> car c'est le type d'entier
par défaut, comme nous l'avons évoqué dans la section <a href="ch03-02-data-types.html">“Les types de
données”</a><!-- ignore --> du chapitre 3.</p>
<!--
```rust
# fn main() {
    let v = vec![1, 2, 3];
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-2: Creating a new vector containing
values</span>
-->
<p><span class="caption">Encart 8-2 : création d'un nouveau vecteur qui contient
des valeurs</span></p>
<!--
Because we’ve given initial `i32` values, Rust can infer that the type of `v`
is `Vec<i32>`, and the type annotation isn’t necessary. Next, we’ll look at how
to modify a vector.
-->
<p>Comme nous avons donné des valeurs initiales <code>i32</code>, Rust peut en déduire que le
type de <code>v</code> est <code>Vec&lt;i32&gt;</code>, et l'annotation de type n'est plus nécessaire.
Maintenant, nous allons voir comment modifier un vecteur.</p>
<!--
### Updating a Vector
-->
<h3 id="modifier-un-vecteur"><a class="header" href="#modifier-un-vecteur">Modifier un vecteur</a></h3>
<!--
To create a vector and then add elements to it, we can use the `push` method,
as shown in Listing 8-3.
-->
<p>Pour créer un vecteur et ensuite lui ajouter des éléments, nous pouvons utiliser
la méthode <code>push</code>, comme dans l'encart 8-3.</p>
<!--
```rust
# fn main() {
    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-3: Using the `push` method to add values to a
vector</span>
-->
<p><span class="caption">Encart 8-3 : utilisation de la méthode <code>push</code> pour ajouter
des valeurs à un vecteur</span></p>
<!--
As with any variable, if we want to be able to change its value, we need to
make it mutable using the `mut` keyword, as discussed in Chapter 3. The numbers
we place inside are all of type `i32`, and Rust infers this from the data, so
we don’t need the `Vec<i32>` annotation.
-->
<p>Comme pour toute variable, si nous voulons pouvoir modifier sa valeur, nous
devons la rendre mutable en utilisant le mot-clé <code>mut</code>, comme nous l'avons vu
au chapitre 3. Les nombres que nous ajoutons dedans sont tous du type <code>i32</code>, et
Rust le devine à partir des données, donc nous n'avons pas besoin de
l'annotation <code>Vec&lt;i32&gt;</code>.</p>
<!--
### Dropping a Vector Drops Its Elements
-->
<h3 id="libérer-un-vecteur-libère-aussi-ses-éléments"><a class="header" href="#libérer-un-vecteur-libère-aussi-ses-éléments">Libérer un vecteur libère aussi ses éléments</a></h3>
<!--
Like any other `struct`, a vector is freed when it goes out of scope, as
annotated in Listing 8-4.
-->
<p>Comme toutes les autres structures, un vecteur est libéré quand il sort de la
portée, comme précisé dans l'encart 8-4.</p>
<!--
```rust
# fn main() {
    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v
    } // <- v goes out of scope and is freed here
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];
    
        // on fait des choses avec v
    
    } // &lt;- v sort de la portée et est libéré ici
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-4: Showing where the vector and its elements
are dropped</span>
-->
<p><span class="caption">Encart 8-4 : mise en évidence de là où le vecteur et ses
éléments sont libérés</span></p>
<!--
When the vector gets dropped, all of its contents are also dropped, meaning
those integers it holds will be cleaned up. This may seem like a
straightforward point but can get a bit more complicated when you start to
introduce references to the elements of the vector. Let’s tackle that next!
-->
<p>Lorsque le vecteur est libéré, tout son contenu est aussi libéré, ce qui veut
dire que les nombres entiers qu'il stocke vont être effacés de la mémoire. Cela
semble très simple mais cela peut devenir plus compliqué quand vous commencez à
utiliser des références vers les éléments du vecteur. Voyons ceci dès à
présent !</p>
<!--
### Reading Elements of Vectors
-->
<h3 id="lire-les-éléments-des-vecteurs"><a class="header" href="#lire-les-éléments-des-vecteurs">Lire les éléments des vecteurs</a></h3>
<!--
Now that you know how to create, update, and destroy vectors, knowing how to
read their contents is a good next step. There are two ways to reference a
value stored in a vector. In the examples, we’ve annotated the types of the
values that are returned from these functions for extra clarity.
-->
<p>Maintenant que vous savez comment créer, modifier, et détruire des vecteurs,
la prochaine étape est de savoir lire leur contenu. Il existe deux façons de
désigner une valeur enregistrée dans un vecteur. Dans ces exemples, nous avons
précisé les types des valeurs qui sont retournées par ces fonctions pour plus de
clarté.</p>
<!--
Listing 8-5 shows both methods of accessing a value in a vector, either with
indexing syntax or the `get` method.
-->
<p>L'encart 8-5 nous montre les deux façons d'accéder à une valeur d'un vecteur :
soit via la syntaxe d'indexation, soit avec la méthode <code>get</code>.</p>
<!--
```rust
# fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let third: &i32 = &v[2];
    println!("The third element is {}", third);

    match v.get(2) {
        Some(third) => println!("The third element is {}", third),
        None => println!("There is no third element."),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let troisieme: &amp;i32 = &amp;v[2];
    println!(&quot;Le troisième élément est {}&quot;, troisieme);

    match v.get(2) {
        Some(troisieme) =&gt; println!(&quot;Le troisième élément est {}&quot;, troisieme),
        None =&gt; println!(&quot;Il n'y a pas de troisième élément.&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-5: Using indexing syntax or the `get` method to
access an item in a vector</span>
-->
<p><span class="caption">Encart 8-5 : utilisation de la syntaxe d'indexation ainsi
que la méthode <code>get</code> pour accéder à un élément d'un vecteur</span></p>
<!--
Note two details here. First, we use the index value of `2` to get the third
element: vectors are indexed by number, starting at zero. Second, the two ways
to get the third element are by using `&` and `[]`, which gives us a reference,
or by using the `get` method with the index passed as an argument, which gives
us an `Option<&T>`.
-->
<p>Il y a deux détails à remarquer ici. Premièrement, nous avons utilisé l'indice
<code>2</code> pour obtenir le troisième élément : les vecteurs sont indexés par des
nombres, qui commencent à partir de zéro. Deuxièmement, les deux façons
d'obtenir le troisième élément consistent soit à utiliser <code>&amp;</code> et <code>[]</code>, ce qui
nous donne une référence, soit en utilisant la méthode <code>get</code> avec l'indice en
argument, ce qui nous fournit une <code>Option&lt;&amp;T&gt;</code>.</p>
<!--
Rust has two ways to reference an element so you can choose how the program
behaves when you try to use an index value that the vector doesn’t have an
element for. As an example, let’s see what a program will do if it has a vector
that holds five elements and then tries to access an element at index 100, as
shown in Listing 8-6.
-->
<p>Rust a deux manières de récupérer un élément afin que vous puissiez choisir
comment le programme doit se comporter lorsque vous essayez d'utiliser un
indice pour lequel le vecteur n'a pas d'élément correspondant. Par exemple,
regardons ce qu'un programme fait s'il a un vecteur qui contient cinq éléments
et qu'il essaye d'accéder à l'élément à l'indice 100, comme dans l'encart 8-6.</p>
<!--
```rust,should_panic,panics
# fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &v[100];
    let does_not_exist = v.get(100);
# }
```
-->
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let existe_pas = &amp;v[100];
    let existe_pas = v.get(100);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-6: Attempting to access the element at index
100 in a vector containing five elements</span>
-->
<p><span class="caption">Encart 8-6 : tentative d'accès à l'élément à l'indice 100
dans un vecteur qui contient cinq éléments</span></p>
<!--
When we run this code, the first `[]` method will cause the program to panic
because it references a nonexistent element. This method is best used when you
want your program to crash if there’s an attempt to access an element past the
end of the vector.
-->
<p>Lorsque nous exécutons ce code, la première méthode <code>[]</code> va faire paniquer le
programme car il demande un élément non existant. Cette méthode doit être
favorisée lorsque vous souhaitez que votre programme plante s'il y a une
tentative d'accéder à un élément après la fin du vecteur.</p>
<!--
When the `get` method is passed an index that is outside the vector, it returns
`None` without panicking. You would use this method if accessing an element
beyond the range of the vector happens occasionally under normal circumstances.
Your code will then have logic to handle having either `Some(&element)` or
`None`, as discussed in Chapter 6. For example, the index could be coming from
a person entering a number. If they accidentally enter a number that’s too
large and the program gets a `None` value, you could tell the user how many
items are in the current vector and give them another chance to enter a valid
value. That would be more user-friendly than crashing the program due to a typo!
-->
<p>Lorsque nous passons un indice en dehors de l'intervalle du vecteur à la méthode
<code>get</code>, elle retourne <code>None</code> sans paniquer. Vous devriez utiliser cette méthode
s'il vous arrive occasionnellement de vouloir accéder à un élément en dehors de
l'intervalle du vecteur en temps normal. Votre code va ensuite devoir gérer les
deux valeurs <code>Some(&amp;element)</code> ou <code>None</code>, comme nous l'avons vu au chapitre 6.
Par exemple, l'indice peut provenir d'une saisie utilisateur. Si par accident il
saisit un nombre qui est trop grand et que le programme obtient une valeur
<code>None</code>, vous pouvez alors dire à l'utilisateur combien il y a d'éléments dans le
vecteur courant et lui donner une nouvelle chance de saisir une valeur valide.
Cela sera plus convivial que de faire planter le programme à cause d'une faute
de frappe !</p>
<!--
When the program has a valid reference, the borrow checker enforces the
ownership and borrowing rules (covered in Chapter 4) to ensure this reference
and any other references to the contents of the vector remain valid. Recall the
rule that states you can’t have mutable and immutable references in the same
scope. That rule applies in Listing 8-7, where we hold an immutable reference to
the first element in a vector and try to add an element to the end, which won’t
work if we also try to refer to that element later in the function:
-->
<p>Lorsque le programme obtient une référence valide, le vérificateur d'emprunt va
faire appliquer les règles de possession et d'emprunt (que nous avons vues au
chapitre 4) pour s'assurer que cette référence ainsi que toutes les autres
références au contenu de ce vecteur restent valides. Souvenez-vous de la règle
qui dit que vous ne pouvez pas avoir des références mutables et immuables dans
la même portée. Cette règle s'applique à l'encart 8-7, où nous obtenons une
référence immuable vers le premier élément d'un vecteur et nous essayons
d'ajouter un élément à la fin, ce qui ne fonctionnera pas si nous essayons aussi
d'utiliser cet élément plus tard dans la fonction :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let mut v = vec![1, 2, 3, 4, 5];

    let first = &v[0];

    v.push(6);

    println!("The first element is: {}", first);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let premier = &amp;v[0];

    v.push(6);

    println!(&quot;Le premier élément est : {}&quot;, premier);
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 8-7: Attempting to add an element to a vector
while holding a reference to an item</span>
-->
<p><span class="caption">Encart 8-7 : tentative d'ajout d'un élément à un vecteur
alors que nous utilisons une référence à un élément</span></p>
<!--
Compiling this code will result in this error:
-->
<p>Compiler ce code va nous mener à cette erreur :</p>
<!--
```console
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 -- > src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 | 
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 | 
8 |     println!("The first element is: {}", first);
  |                                          ----- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let premier = &amp;v[0];
  |                    - immutable borrow occurs here
5 | 
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;Le premier élément est : {}&quot;, premier);
  |                                             ------- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` due to previous error
</code></pre>
<!--
The code in Listing 8-7 might look like it should work: why should a reference
to the first element care about what changes at the end of the vector? This
error is due to the way vectors work: adding a new element onto the end of the
vector might require allocating new memory and copying the old elements to the
new space, if there isn’t enough room to put all the elements next to each
other where the vector currently is. In that case, the reference to the first
element would be pointing to deallocated memory. The borrowing rules prevent
programs from ending up in that situation.
-->
<p>Le code dans l'encart 8-7 semble pourtant marcher : pourquoi une référence au
premier élément devrait se soucier de ce qui se passe à la fin du vecteur ?
Cette erreur s'explique par la façon dont les vecteurs fonctionnent : ajouter un
nouvel élément à la fin du vecteur peut nécessiter d'allouer un nouvel espace
mémoire et copier tous les anciens éléments dans ce nouvel espace, s'il n'y a
pas assez de place pour placer tous les éléments les uns à côté des autres dans
la mémoire là où se trouve actuellement le vecteur. Dans ce cas, la référence
au premier élément pointerait vers de la mémoire désallouée. Les règles
d'emprunt évitent aux programmes de se retrouver dans cette situation.</p>
<!--
> Note: For more on the implementation details of the `Vec<T>` type, see [“The
> Rustonomicon”][nomicon].
-->
<blockquote>
<p>Remarque : pour plus de détails sur l'implémentation du type <code>Vec&lt;T&gt;</code>,
consultez <a href="https://doc.rust-lang.org/nomicon/vec/vec.html">le “Rustonomicon”</a>.</p>
</blockquote>
<!--
### Iterating over the Values in a Vector
-->
<h3 id="itérer-sur-les-valeurs-dun-vecteur"><a class="header" href="#itérer-sur-les-valeurs-dun-vecteur">Itérer sur les valeurs d'un vecteur</a></h3>
<!--
If we want to access each element in a vector in turn, we can iterate through
all of the elements rather than use indices to access one at a time. Listing
8-8 shows how to use a `for` loop to get immutable references to each element
in a vector of `i32` values and print them.
-->
<p>Si nous voulons accéder à chaque élément d'un vecteur chacun son tour, nous
pouvons itérer sur tous les éléments plutôt que d'utiliser individuellement les
indices. L'encart 8-8 nous montre comment utiliser une boucle <code>for</code> pour obtenir
des références immuables pour chacun des éléments dans un vecteur de <code>i32</code>, et
les afficher.</p>
<!--
```rust
# fn main() {
    let v = vec![100, 32, 57];
    for i in &v {
        println!("{}", i);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!(&quot;{}&quot;, i);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-8: Printing each element in a vector by
iterating over the elements using a `for` loop</span>
-->
<p><span class="caption">Encart 8-8 : affichage de chaque élément d'un vecteur en
itérant sur les éléments en utilisant une boucle <code>for</code></span></p>
<!--
We can also iterate over mutable references to each element in a mutable vector
in order to make changes to all the elements. The `for` loop in Listing 8-9
will add `50` to each element.
-->
<p>Nous pouvons aussi itérer avec des références mutables pour chacun des éléments
d'un vecteur mutable afin de modifier tous les éléments. La boucle <code>for</code> de
l'encart 8-9 va ajouter <code>50</code> à chacun des éléments.</p>
<!--
```rust
# fn main() {
    let mut v = vec![100, 32, 57];
    for i in &mut v {
        *i += 50;
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-9: Iterating over mutable references to
elements in a vector</span>
-->
<p><span class="caption">Encart 8-9 : itérations sur des références mutables vers
des éléments d'un vecteur</span></p>
<!--
To change the value that the mutable reference refers to, we have to use the
dereference operator (`*`) to get to the value in `i` before we can use the
`+=` operator. We’ll talk more about the dereference operator in the
[“Following the Pointer to the Value with the Dereference Operator”][deref]<!-- ignore -- >
section of Chapter 15.
-->
<p>Afin de changer la valeur vers laquelle pointe la référence mutable, nous devons
utiliser l'opérateur de déréférencement (<code>*</code>) pour obtenir la valeur dans <code>i</code>
avant que nous puissions utiliser l'opérateur <code>+=</code>. Nous verrons plus en détail
l'opérateur de déréférencement dans une section du
<a href="ch15-02-deref.html">chapitre 15</a><!-- ignore -->.</p>
<!--
### Using an Enum to Store Multiple Types
-->
<h3 id="utiliser-une-énumération-pour-stocker-différents-types"><a class="header" href="#utiliser-une-énumération-pour-stocker-différents-types">Utiliser une énumération pour stocker différents types</a></h3>
<!--
At the beginning of this chapter, we said that vectors can only store values
that are the same type. This can be inconvenient; there are definitely use
cases for needing to store a list of items of different types. Fortunately, the
variants of an enum are defined under the same enum type, so when we need to
store elements of a different type in a vector, we can define and use an enum!
-->
<p>Au début de ce chapitre, nous avons dit que les vecteurs ne peuvent stocker que
des valeurs du même type. Cela peut être un problème ; il y a forcément des cas
où on a besoin de stocker une liste d'éléments de types différents.
Heureusement, les variantes d'une énumération sont définies sous le même type
qui est l'énumération, donc lorsque nous avons besoin de stocker des éléments
d'un type différent dans un vecteur, nous pouvons définir et utiliser une
énumération !</p>
<!--
For example, say we want to get values from a row in a spreadsheet in which
some of the columns in the row contain integers, some floating-point numbers,
and some strings. We can define an enum whose variants will hold the different
value types, and then all the enum variants will be considered the same type:
that of the enum. Then we can create a vector that holds that enum and so,
ultimately, holds different types. We’ve demonstrated this in Listing 8-10.
-->
<p>Par exemple, imaginons que nous voulions obtenir les valeurs d'une ligne d'une
feuille de calcul dans laquelle quelques colonnes sont des entiers, d'autres des
nombres à virgule flottante, et quelques chaînes de caractères. Nous pouvons
définir une énumération dont les variantes vont avoir les différents types, et
ainsi toutes les variantes de l'énumération seront du même type : celui de
l'énumération. Ensuite, nous pouvons créer un vecteur qui stocke cette
énumération et ainsi, au final, qui stocke différents types. La démonstration de
cette technique est dans l'encart 8-10.</p>
<!--
```rust
# fn main() {
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Cellule {
        Int(i32),
        Float(f64),
        Text(String),
    }
    
    let ligne = vec![
        Cellule::Int(3),
        Cellule::Text(String::from(&quot;bleu&quot;)),
        Cellule::Float(10.12),
    ];
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-10: Defining an `enum` to store values of
different types in one vector</span>
-->
<p><span class="caption">Encart 8-10 : définition d'une <code>enum</code> pour stocker des
valeurs de différents types dans un seul vecteur</span></p>
<!--
Rust needs to know what types will be in the vector at compile time so it knows
exactly how much memory on the heap will be needed to store each element. A
secondary advantage is that we can be explicit about what types are allowed in
this vector. If Rust allowed a vector to hold any type, there would be a chance
that one or more of the types would cause errors with the operations performed
on the elements of the vector. Using an enum plus a `match` expression means
that Rust will ensure at compile time that every possible case is handled, as
discussed in Chapter 6.
-->
<p>Rust a besoin de savoir quel type de donnée sera stocké dans le vecteur au
moment de la compilation afin de connaître la quantité de mémoire nécessaire
pour stocker chaque élément sur le tas. Le second avantage est que nous sommes
précis sur les types autorisés dans ce vecteur. Si Rust avait permis qu'un
vecteur stocke n'importe quel type, il y aurait pu avoir un risque qu'un ou
plusieurs des types provoquent une erreur avec les manipulations effectuées sur
les éléments du vecteur. L'utilisation d'une énumération ainsi qu'une expression
<code>match</code> permet à Rust de garantir au moment de la compilation que tous les cas
possibles sont traités, comme nous l'avons appris au chapitre 6.</p>
<!--
When you’re writing a program, if you don’t know the exhaustive set of types
the program will get at runtime to store in a vector, the enum technique won’t
work. Instead, you can use a trait object, which we’ll cover in Chapter 17.
-->
<p>Lorsque vous écrivez un programme, si vous n'avez pas une liste exhaustive des
types que votre vecteur va stocker, la technique de l'énumération ne va pas
fonctionner. À la place, vous pouvez utiliser un objet trait, que nous verrons
au chapitre 17.</p>
<!--
Now that we’ve discussed some of the most common ways to use vectors, be sure
to review [the API documentation][vec-api]<!-- ignore -- > for all the many
useful methods defined on `Vec<T>` by the standard library. For example, in
addition to `push`, a `pop` method removes and returns the last element. Let’s
move on to the next collection type: `String`!
-->
<p>Maintenant que nous avons vu les manières les plus courantes d'utiliser les
vecteurs, prenez le temps de consulter <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">la documentation de
l'API</a><!-- ignore --> pour découvrir toutes les méthodes très utiles
définies dans la bibliothèque standard pour <code>Vec&lt;T&gt;</code>. Par exemple, en plus de
<code>push</code>, nous avons une méthode <code>pop</code> qui retire et retourne le dernier élément.
Intéressons-nous maintenant au prochain type de collection : la <code>String</code> !</p>
<!--
[data-types]: ch03-02-data-types.html#data-types
[nomicon]: ../nomicon/vec/vec.html
[vec-api]: ../std/vec/struct.Vec.html
[deref]: ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Storing UTF-8 Encoded Text with Strings
-->
<h2 id="stocker-du-texte-encodé-en-utf-8-avec-les-strings"><a class="header" href="#stocker-du-texte-encodé-en-utf-8-avec-les-strings">Stocker du texte encodé en UTF-8 avec les Strings</a></h2>
<!--
We talked about strings in Chapter 4, but we’ll look at them in more depth now.
New Rustaceans commonly get stuck on strings for a combination of three
reasons: Rust’s propensity for exposing possible errors, strings being a more
complicated data structure than many programmers give them credit for, and
UTF-8. These factors combine in a way that can seem difficult when you’re
coming from other programming languages.
-->
<p>Nous avons déjà parlé des chaînes de caractères dans le chapitre 4, mais nous
allons à présent les analyser plus en détail. Les nouveaux Rustacés bloquent
souvent avec les chaînes de caractères pour trois raisons : la tendance de Rust
à prévenir les erreurs, le fait que les chaînes de caractères sont des
structures de données plus compliquées que ne le pensent la plupart des
développeurs, et l'UTF-8. Ces raisons cumulées rendent les choses compliquées
lorsque vous venez d'un autre langage de programmation.</p>
<!--
It’s useful to discuss strings in the context of collections because strings
are implemented as a collection of bytes, plus some methods to provide useful
functionality when those bytes are interpreted as text. In this section, we’ll
talk about the operations on `String` that every collection type has, such as
creating, updating, and reading. We’ll also discuss the ways in which `String`
is different from the other collections, namely how indexing into a `String` is
complicated by the differences between how people and computers interpret
`String` data.
-->
<p>Il est pertinent de présenter les chaînes de caractères comme des collections
car les chaînes de caractères sont en réalité des suites d'octets, avec quelques
méthodes supplémentaires qui sont utiles lorsque ces octets sont considérés
comme du texte. Dans cette section, nous allons voir les points communs entre le
fonctionnement des <code>String</code> et celui des autres collections, comme la création,
la modification et la lecture. Nous verrons les raisons pour lesquelles les
<code>String</code> sont différentes des autres collections, en particulier pourquoi
l'indexation d'une <code>String</code> est compliquée à cause des différences entre la
façon dont les gens et les ordinateurs interprètent les données d'une <code>String</code>.</p>
<!--
### What Is a String?
-->
<h3 id="quest-ce-quune-chaîne-de-caractères-"><a class="header" href="#quest-ce-quune-chaîne-de-caractères-">Qu'est-ce qu'une chaîne de caractères ?</a></h3>
<!--
We’ll first define what we mean by the term *string*. Rust has only one string
type in the core language, which is the string slice `str` that is usually seen
in its borrowed form `&str`. In Chapter 4, we talked about *string slices*,
which are references to some UTF-8 encoded string data stored elsewhere. String
literals, for example, are stored in the program’s binary and are therefore
string slices.
-->
<p>Nous allons d'abord définir ce que nous entendons par le terme <em>chaîne de
caractères</em>. Rust a un seul type de chaînes de caractères dans le noyau du
langage, qui est la slice de chaîne de caractères <code>str</code> qui est habituellement
utilisée sous sa forme empruntée, <code>&amp;str</code>. Dans le chapitre 4, nous avons abordé
les <em>slices de chaînes de caractères</em>, qui sont des références à des données
d'une chaîne de caractères encodée en UTF-8 qui sont stockées autre part. Les
littéraux de chaînes de caractères, par exemple, sont stockés dans le binaire du
programme et sont des slices de chaînes de caractères.</p>
<!--
The `String` type, which is provided by Rust’s standard library rather than
coded into the core language, is a growable, mutable, owned, UTF-8 encoded
string type. When Rustaceans refer to “strings” in Rust, they usually mean the
`String` and the string slice `&str` types, not just one of those types.
Although this section is largely about `String`, both types are used heavily in
Rust’s standard library, and both `String` and string slices are UTF-8 encoded.
-->
<p>Le type <code>String</code>, qui est fourni par la bibliothèque standard de Rust plutôt que
d'être intégré au noyau du langage, est un type de chaîne de caractères encodé
en UTF-8 qui peut s'agrandir, être mutable, et être possédé. Lorsque les
Rustacés parlent de “chaînes de caractères” en Rust, cela désigne le type
<code>String</code> mais aussi le type de slice de chaînes de caractères <code>&amp;str</code>, et non pas
un seul de ces types. Bien que cette section traite essentiellement de <code>String</code>,
ces deux types sont utilisés massivement dans la bibliothèque standard de Rust,
et tous les deux sont encodés en UTF-8.</p>
<!--
Rust’s standard library also includes a number of other string types, such as
`OsString`, `OsStr`, `CString`, and `CStr`. Library crates can provide even
more options for storing string data. See how those names all end in `String`
or `Str`? They refer to owned and borrowed variants, just like the `String` and
`str` types you’ve seen previously. These string types can store text in
different encodings or be represented in memory in a different way, for
example. We won’t discuss these other string types in this chapter; see their
API documentation for more about how to use them and when each is appropriate.
-->
<p>La bibliothèque standard de Rust apporte aussi un certain nombre d'autres types
de chaînes de caractères, comme <code>OsString</code>, <code>OsStr</code>, <code>CString</code>, et <code>CStr</code>. Les
crates de bibliothèque peuvent fournir encore plus de solutions pour stocker des
chaînes de caractères. Avez-vous remarqué que ces noms finissent tous par
<code>String</code> ou <code>Str</code> ? Cela fait référence aux variantes possédées et empruntées,
comme les types <code>String</code> et <code>str</code> que nous avons vus précédemment. Ces types de
chaînes de caractères peuvent stocker leur texte dans de différents encodages,
ou le stocker en mémoire de manière différente, par exemple. Nous n'allons pas
traiter de ces autres types de chaînes de caractères dans ce chapitre ;
référez-vous à la documentation de leur API pour en savoir plus sur leur
utilisation et leur utilité.</p>
<!--
### Creating a New String
-->
<h3 id="créer-une-nouvelle-string"><a class="header" href="#créer-une-nouvelle-string">Créer une nouvelle String</a></h3>
<!--
Many of the same operations available with `Vec<T>` are available with `String`
as well, starting with the `new` function to create a string, shown in Listing
8-11.
-->
<p>De nombreuses opérations disponibles avec <code>Vec&lt;T&gt;</code> sont aussi disponibles avec
<code>String</code>, en commençant par la fonction <code>new</code> pour créer une <code>String</code>, utilisée
dans l'encart 8-11.</p>
<!--
```rust
# fn main() {
    let mut s = String::new();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-11: Creating a new, empty `String`</span>
-->
<p><span class="caption">Encart 8-11 : Création d'une nouvelle <code>String</code> vide</span></p>
<!--
This line creates a new empty string called `s`, which we can then load data
into. Often, we’ll have some initial data that we want to start the string
with. For that, we use the `to_string` method, which is available on any type
that implements the `Display` trait, as string literals do. Listing 8-12 shows
two examples.
-->
<p>Cette ligne crée une nouvelle <code>String</code> vide qui s'appelle <code>s</code>, dans laquelle
nous pouvons ensuite charger des données. Souvent, nous aurons quelques données
initiales que nous voudrions ajouter dans la <code>String</code>. Pour cela, nous utilisons
la méthode <code>to_string</code>, qui est disponible sur tous les types qui implémentent
le trait <code>Display</code>, comme le font les littéraux de chaînes de caractères.
L'encart 8-12 nous montre deux exemples.</p>
<!--
```rust
# fn main() {
    let data = "initial contents";

    let s = data.to_string();

    // the method also works on a literal directly:
    let s = "initial contents".to_string();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let donnee = &quot;contenu initial&quot;;

    let s = donnee.to_string();

    // cette méthode fonctionne aussi directement sur un
    // littéral de chaîne de caractères :
    let s = &quot;contenu initial&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-12: Using the `to_string` method to create a
`String` from a string literal</span>
-->
<p><span class="caption">Encart 8-12 : Utilisation de la méthode <code>to_string</code> pour
créer une <code>String</code> à partir d'un littéral de chaîne</span></p>
<!--
This code creates a string containing `initial contents`.
-->
<p>Ce code crée une <code>String</code> qui contient <code>contenu initial</code>.</p>
<!--
We can also use the function `String::from` to create a `String` from a string
literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12
that uses `to_string`.
-->
<p>Nous pouvons aussi utiliser la fonction <code>String::from</code> pour créer une <code>String</code>
à partir d'un littéral de chaîne. Le code dans l'encart 8-13 est équivalent au
code dans l'encart 8-12 qui utilisait <code>to_string</code>.</p>
<!--
```rust
# fn main() {
    let s = String::from("initial contents");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;contenu initial&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-13: Using the `String::from` function to create
a `String` from a string literal</span>
-->
<p><span class="caption">Encart 8-13 : Utilisation de la fonction <code>String::from</code>
afin de créer une <code>String</code> à partir d'un littéral de chaîne</span></p>
<!--
Because strings are used for so many things, we can use many different generic
APIs for strings, providing us with a lot of options. Some of them can seem
redundant, but they all have their place! In this case, `String::from` and
`to_string` do the same thing, so which you choose is a matter of style.
-->
<p>Comme les chaînes de caractères sont utilisées pour de nombreuses choses, nous
pouvons utiliser beaucoup d'API génériques pour les chaînes de caractères.
Certaines d'entre elles peuvent paraître redondantes, mais elles ont toutes
leur place ! Dans notre cas, <code>String::from</code> et <code>to_string</code> font la même chose,
donc votre choix est une question de goût.</p>
<!--
Remember that strings are UTF-8 encoded, so we can include any properly encoded
data in them, as shown in Listing 8-14.
-->
<p>Souvenez-vous que les chaînes de caractères sont encodées en UTF-8, donc nous
pouvons y intégrer n'importe quelle donnée valide, comme nous le voyons dans
l'encart 8-14.</p>
<!--
```rust
# fn main() {
    let hello = String::from("السلام عليكم");
    let hello = String::from("Dobrý den");
    let hello = String::from("Hello");
    let hello = String::from("שָׁלוֹם");
    let hello = String::from("नमस्ते");
    let hello = String::from("こんにちは");
    let hello = String::from("안녕하세요");
    let hello = String::from("你好");
    let hello = String::from("Olá");
    let hello = String::from("Здравствуйте");
    let hello = String::from("Hola");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let bonjour = String::from(&quot;السلام عليكم&quot;);
    let bonjour = String::from(&quot;Dobrý den&quot;);
    let bonjour = String::from(&quot;Hello&quot;);
    let bonjour = String::from(&quot;שָׁלוֹם&quot;);
    let bonjour = String::from(&quot;नमस्ते&quot;);
    let bonjour = String::from(&quot;こんにちは&quot;);
    let bonjour = String::from(&quot;안녕하세요&quot;);
    let bonjour = String::from(&quot;你好&quot;);
    let bonjour = String::from(&quot;Olá&quot;);
    let bonjour = String::from(&quot;Здравствуйте&quot;);
    let bonjour = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-14: Storing greetings in different languages in
strings</span>
-->
<p><span class="caption">Encart 8-14 : Stockage de salutations dans différentes
langues dans des chaînes de caractères</span></p>
<!--
All of these are valid `String` values.
-->
<p>Toutes ces chaînes sont des valeurs <code>String</code> valides.</p>
<!--
### Updating a String
-->
<h3 id="modifier-une-string"><a class="header" href="#modifier-une-string">Modifier une <code>String</code></a></h3>
<!--
A `String` can grow in size and its contents can change, just like the contents
of a `Vec<T>`, if you push more data into it. In addition, you can conveniently
use the `+` operator or the `format!` macro to concatenate `String` values.
-->
<p>Une <code>String</code> peut s'agrandir et son contenu peut changer, exactement comme le
contenu d'un <code>Vec&lt;T&gt;</code>, si on y ajoute des données. De plus, vous pouvez aisément
utiliser l'opérateur <code>+</code> ou la macro <code>format!</code> pour concaténer des valeurs
<code>String</code>.</p>
<!--
#### Appending to a String with `push_str` and `push`
-->
<h4 id="ajouter-du-texte-à-une-chaîne-avec-push_str-et-push"><a class="header" href="#ajouter-du-texte-à-une-chaîne-avec-push_str-et-push">Ajouter du texte à une chaîne avec <code>push_str</code> et <code>push</code></a></h4>
<!--
We can grow a `String` by using the `push_str` method to append a string slice,
as shown in Listing 8-15.
-->
<p>Nous pouvons agrandir une <code>String</code> en utilisant la méthode <code>push_str</code> pour
ajouter une slice de chaîne de caractères, comme dans l'encart 8-15.</p>
<!--
```rust
# fn main() {
    let mut s = String::from("foo");
    s.push_str("bar");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-15: Appending a string slice to a `String`
using the `push_str` method</span>
-->
<p><span class="caption">Encart 8-15 : Ajout d'une slice de chaîne de caractères
dans une <code>String</code> en utilisant la méthode <code>push_str</code></span></p>
<!--
After these two lines, `s` will contain `foobar`. The `push_str` method takes a
string slice because we don’t necessarily want to take ownership of the
parameter. For example, the code in Listing 8-16 shows that it would be
unfortunate if we weren’t able to use `s2` after appending its contents to `s1`.
-->
<p>À l'issue de ces deux lignes, <code>s</code> va contenir <code>foobar</code>. La méthode <code>push_str</code>
prend une slice de chaîne de caractères car nous ne souhaitons pas forcément
prendre possession du paramètre. Par exemple, le code de l'encart 8-16 nous
montre une situation où il serait regrettable de ne plus pouvoir utiliser <code>s2</code>
après avoir ajouté son contenu dans <code>s1</code>.</p>
<!--
```rust
# fn main() {
    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {}", s2);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s1 = String::from(&quot;foo&quot;);
    let s2 = &quot;bar&quot;;
    s1.push_str(s2);
    println!(&quot;s2 est {}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-16: Using a string slice after appending its
contents to a `String`</span>
-->
<p><span class="caption">Encart 8-16 : Utilisation d'une slice de chaîne de
caractères après avoir ajouté son contenu dans une <code>String</code></span></p>
<!--
If the `push_str` method took ownership of `s2`, we wouldn’t be able to print
its value on the last line. However, this code works as we’d expect!
-->
<p>Si la méthode <code>push_str</code> prenait possession de <code>s2</code>, à la dernière ligne, nous
ne pourrions pas afficher sa valeur. Cependant, ce code fonctionne comme nous
l'espérions !</p>
<!--
The `push` method takes a single character as a parameter and adds it to the
`String`. Listing 8-17 shows code that adds the letter “l” to a `String` using
the `push` method.
-->
<p>La méthode <code>push</code> prend un seul caractère en paramètre et l'ajoute à la
<code>String</code>. L'encart 8-17 nous montre du code qui ajoute la lettre “l” à une
<code>String</code> en utilisant la méthode <code>push</code>.</p>
<!--
```rust
# fn main() {
    let mut s = String::from("lo");
    s.push('l');
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;lo&quot;);
    s.push('l');
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-17: Adding one character to a `String` value
using `push`</span>
-->
<p><span class="caption">Encart 8-17 : Ajout d'un unique caractère à la valeur
d'une <code>String</code> en utilisant <code>push</code></span></p>
<!--
As a result of this code, `s` will contain `lol`.
-->
<p>Après exécution de ce code, <code>s</code> contiendra <code>lol</code>.</p>
<!--
#### Concatenation with the `+` Operator or the `format!` Macro
-->
<h4 id="concaténation-avec-lopérateur--ou-la-macro-format"><a class="header" href="#concaténation-avec-lopérateur--ou-la-macro-format">Concaténation avec l'opérateur <code>+</code> ou la macro <code>format!</code></a></h4>
<!--
Often, you’ll want to combine two existing strings. One way is to use the `+`
operator, as shown in Listing 8-18.
-->
<p>Souvent, vous aurez besoin de combiner deux chaînes de caractères existantes.
Une façon de faire cela est d'utiliser l'opérateur <code>+</code>, comme dans l'encart
8-18.</p>
<!--
```rust
# fn main() {
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;Hello, &quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1 + &amp;s2; // notez que s1 a été déplacé ici
                       // et ne pourra plus être utilisé
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-18: Using the `+` operator to combine two
`String` values into a new `String` value</span>
-->
<p><span class="caption">Encart 8-18 : Utilisation de l'opérateur <code>+</code> pour combiner
deux valeurs de <code>String</code></span></p>
<!--
The string `s3` will contain `Hello, world!` as a result of this code. The
reason `s1` is no longer valid after the addition and the reason we used a
reference to `s2` has to do with the signature of the method that gets called
when we use the `+` operator. The `+` operator uses the `add` method, whose
signature looks something like this:
-->
<p>La chaîne de caractères <code>s3</code> va contenir <code>Hello, world!</code> à l'issue de
l'exécution de ce code. La raison pour laquelle <code>s1</code> n'est plus utilisable après
avoir été ajouté et la raison pour laquelle nous utilisons une référence vers
<code>s2</code> s'expliquent par la signature de la méthode qui est appelée lorsque nous
utilisons l'opérateur <code>+</code>. L'opérateur <code>+</code> utilise la méthode <code>add</code>, dont la
signature ressemble à ceci :</p>
<!--
```rust,ignore
fn add(self, s: &str) -> String {
```
-->
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<!--
This isn’t the exact signature that’s in the standard library: in the standard
library, `add` is defined using generics. Here, we’re looking at the signature
of `add` with concrete types substituted for the generic ones, which is what
happens when we call this method with `String` values. We’ll discuss generics
in Chapter 10. This signature gives us the clues we need to understand the
tricky bits of the `+` operator.
-->
<p>Ce n'est pas exactement la même signature que celle de la bibliothèque
standard : dans la bibliothèque standard, <code>add</code> est défini avec des types
génériques. Ici, nous voyons la signature de <code>add</code> avec des types concrets à la
place des génériques, ce qui se passe lorsque nous utilisons cette méthode avec
des valeurs de type <code>String</code>. Nous verrons la généricité au chapitre 10. Cette
signature nous donne les éléments dont nous avons besoin pour comprendre les
subtilités de l'opérateur <code>+</code>.</p>
<!--
First, `s2` has an `&`, meaning that we’re adding a *reference* of the second
string to the first string because of the `s` parameter in the `add` function:
we can only add a `&str` to a `String`; we can’t add two `String` values
together. But wait—the type of `&s2` is `&String`, not `&str`, as specified in
the second parameter to `add`. So why does Listing 8-18 compile?
-->
<p>Premièrement, <code>s2</code> a un <code>&amp;</code>, ce qui veut dire que nous ajoutons une <em>référence</em>
vers la seconde chaîne de caractères à la première chaîne en raison du paramètre
<code>s</code> de la fonction <code>add</code> : nous pouvons seulement ajouter un <code>&amp;str</code> à une
<code>String</code> ; nous ne pouvons pas ajouter deux valeurs de type <code>String</code> ensemble.
Mais attendez — le type de <code>&amp;s2</code> est <code>&amp;String</code>, et non pas <code>&amp;str</code>, comme c'est
écrit dans le second paramètre de <code>add</code>. Alors pourquoi est-ce que le code de
l'encart 8-18 se compile ?</p>
<!--
The reason we’re able to use `&s2` in the call to `add` is that the compiler
can *coerce* the `&String` argument into a `&str`. When we call the `add`
method, Rust uses a *deref coercion*, which here turns `&s2` into `&s2[..]`.
We’ll discuss deref coercion in more depth in Chapter 15. Because `add` does
not take ownership of the `s` parameter, `s2` will still be a valid `String`
after this operation.
-->
<p>La raison pour laquelle nous pouvons utiliser <code>&amp;s2</code> dans l'appel à <code>add</code> est que
le compilateur peut <em>extrapoler</em> l'argument <code>&amp;String</code> en un <code>&amp;str</code>. Lorsque nous
appelons la méthode <code>add</code>, Rust va utiliser une <em>extrapolation de
déréférencement</em>, qui transforme ici <code>&amp;s2</code> en <code>&amp;s2[..]</code>. Nous verrons plus en
détail l'extrapolation de déréférencement au chapitre 15. Comme <code>add</code> ne prend
pas possession du paramètre <code>s</code>, <code>s2</code> sera toujours une <code>String</code> valide après
cette opération.</p>
<!--
Second, we can see in the signature that `add` takes ownership of `self`,
because `self` does *not* have an `&`. This means `s1` in Listing 8-18 will be
moved into the `add` call and no longer be valid after that. So although `let
s3 = s1 + &s2;` looks like it will copy both strings and create a new one, this
statement actually takes ownership of `s1`, appends a copy of the contents of
`s2`, and then returns ownership of the result. In other words, it looks like
it’s making a lot of copies but isn’t; the implementation is more efficient
than copying.
-->
<p>Ensuite, nous pouvons constater que la signature de <code>add</code> prend possession de
<code>self</code>, car <code>self</code> n'a <em>pas</em> de <code>&amp;</code>. Cela signifie que <code>s1</code> dans l'encart 8-18
va être déplacé dans l'appel à <code>add</code> et ne sera plus en vigueur après cela. Donc
bien que <code>let s3 = s1 + &amp;s2</code> semble copier les deux chaînes de caractères pour
en créer une nouvelle, cette instruction va en réalité prendre possession de
<code>s1</code>, y ajouter une copie du contenu de <code>s2</code> et nous redonner la possession du
résultat. Autrement dit, cela semble faire beaucoup de copies mais en réalité
non ; son implémentation est plus efficace que la copie.</p>
<!--
If we need to concatenate multiple strings, the behavior of the `+` operator
gets unwieldy:
-->
<p>Si nous avons besoin de concaténer plusieurs chaînes de caractères, le
comportement de l'opérateur <code>+</code> devient difficile à utiliser :</p>
<!--
```rust
# fn main() {
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &s2 + "-" + &s3;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}
</span></code></pre></pre>
<!--
At this point, `s` will be `tic-tac-toe`. With all of the `+` and `"`
characters, it’s difficult to see what’s going on. For more complicated string
combining, we can use the `format!` macro:
-->
<p>Au final, <code>s</code> vaudra <code>tic-tac-toe</code>. Avec tous les caractères <code>+</code> et <code>&quot;</code>, il est
difficile de visualiser ce qui se passe. Pour une combinaison de chaînes de
caractères plus complexe, nous pouvons utiliser la macro <code>format!</code> :</p>
<!--
```rust
# fn main() {
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{}-{}-{}", s1, s2, s3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}
</span></code></pre></pre>
<!--
This code also sets `s` to `tic-tac-toe`. The `format!` macro works in the same
way as `println!`, but instead of printing the output to the screen, it returns
a `String` with the contents. The version of the code using `format!` is much
easier to read, and the code generated by the `format!` macro uses references
so that this call doesn’t take ownership of any of its parameters.
-->
<p>Ce code assigne lui aussi à <code>s</code> la valeur <code>tic-tac-toe</code>. La macro <code>format!</code>
fonctionne de la même manière que <code>println!</code>, mais au lieu d'afficher son
résultat à l'écran, elle retourne une <code>String</code> avec son contenu. La version du
code qui utilise <code>format!</code> est plus facile à lire, et le code généré par la
macro <code>format!</code> utilise des références afin qu'il ne prenne pas possession de
ses paramètres.</p>
<!--
### Indexing into Strings
-->
<h3 id="lindexation-des-strings"><a class="header" href="#lindexation-des-strings">L'indexation des Strings</a></h3>
<!--
In many other programming languages, accessing individual characters in a
string by referencing them by index is a valid and common operation. However,
if you try to access parts of a `String` using indexing syntax in Rust, you’ll
get an error. Consider the invalid code in Listing 8-19.
-->
<p>Dans de nombreux autres langages de programmation, l'accès individuel aux
caractères d'une chaîne de caractères en utilisant leur indice est une opération
valide et courante. Cependant, si vous essayez d'accéder à des éléments d'une
<code>String</code> en utilisant la syntaxe d'indexation avec Rust, vous allez avoir une
erreur. Nous tentons cela dans le code invalide de l'encart 8-19.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s1 = String::from("hello");
    let h = s1[0];
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let h = s1[0];
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 8-19: Attempting to use indexing syntax with a
String</span>
-->
<p><span class="caption">Encart 8-19 : Tentative d'utilisation de la syntaxe
d'indexation avec une <code>String</code></span></p>
<!--
This code will result in the following error:
-->
<p>Ce code va produire l'erreur suivante :</p>
<!--
```console
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 -- > src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index<{integer}>` is not implemented for `String`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index&lt;{integer}&gt;` is not implemented for `String`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` due to previous error
</code></pre>
<!--
The error and the note tell the story: Rust strings don’t support indexing. But
why not? To answer that question, we need to discuss how Rust stores strings in
memory.
-->
<p>L'erreur et la remarque nous expliquent le problème : les <code>String</code> de Rust
n'acceptent pas l'utilisation des indices. Mais pourquoi ? Pour répondre à cette
question, nous avons besoin de savoir comment Rust enregistre les chaînes de
caractères dans la mémoire.</p>
<!--
#### Internal Representation
-->
<h4 id="représentation-interne"><a class="header" href="#représentation-interne">Représentation interne</a></h4>
<!--
A `String` is a wrapper over a `Vec<u8>`. Let’s look at some of our properly
encoded UTF-8 example strings from Listing 8-14. First, this one:
-->
<p>Une <code>String</code> est une surcouche de <code>Vec&lt;u8&gt;</code>. Revenons sur certains exemples de
chaînes de caractères correctement encodées en UTF-8 que nous avions dans
l'encart 8-14. Premièrement, celle-ci :</p>
<!--
```rust
# fn main() {
#     let hello = String::from("السلام عليكم");
#     let hello = String::from("Dobrý den");
#     let hello = String::from("Hello");
#     let hello = String::from("שָׁלוֹם");
#     let hello = String::from("नमस्ते");
#     let hello = String::from("こんにちは");
#     let hello = String::from("안녕하세요");
#     let hello = String::from("你好");
#     let hello = String::from("Olá");
#     let hello = String::from("Здравствуйте");
    let hello = String::from("Hola");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let bonjour = String::from(&quot;السلام عليكم&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Dobrý den&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Hello&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;שָׁלוֹם&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;नमस्ते&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;こんにちは&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;안녕하세요&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;你好&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Olá&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Здравствуйте&quot;);
</span>    let bonjour = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
In this case, `len` will be 4, which means the vector storing the string “Hola”
is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. But
what about the following line? (Note that this string begins with the capital
Cyrillic letter Ze, not the Arabic number 3.)
-->
<p>Dans ce cas-ci, <code>len</code> vaudra 4, ce qui veut dire que le vecteur qui stocke la
chaîne “Hola” a une taille de 4 octets. Chacune des lettres prend 1 octet
lorsqu'elles sont encodées en UTF-8. Mais qu'en est-il de la ligne suivante ?
(Notez que cette chaîne de caractères commence avec la lettre majuscule
cyrillique Zé, et non pas le chiffre arabe 3.)</p>
<!--
```rust
# fn main() {
#     let hello = String::from("السلام عليكم");
#     let hello = String::from("Dobrý den");
#     let hello = String::from("Hello");
#     let hello = String::from("שָׁלוֹם");
#     let hello = String::from("नमस्ते");
#     let hello = String::from("こんにちは");
#     let hello = String::from("안녕하세요");
#     let hello = String::from("你好");
#     let hello = String::from("Olá");
    let hello = String::from("Здравствуйте");
#     let hello = String::from("Hola");
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let bonjour = String::from(&quot;السلام عليكم&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Dobrý den&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Hello&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;שָׁלוֹם&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;नमस्ते&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;こんにちは&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;안녕하세요&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;你好&quot;);
</span><span class="boring">    let bonjour = String::from(&quot;Olá&quot;);
</span>    let bonjour = String::from(&quot;Здравствуйте&quot;);
<span class="boring">    let bonjour = String::from(&quot;Hola&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<!--
Asked how long the string is, you might say 12. However, Rust’s answer is 24:
that’s the number of bytes it takes to encode “Здравствуйте” in UTF-8, because
each Unicode scalar value in that string takes 2 bytes of storage. Therefore,
an index into the string’s bytes will not always correlate to a valid Unicode
scalar value. To demonstrate, consider this invalid Rust code:
-->
<p>Si on vous demandait la longueur de la chaîne de caractères, vous répondriez
probablement 12. Cependant, la réponse de Rust sera 24 : c'est le nombre
d'octets nécessaires pour encoder “Здравствуйте” en UTF-8, car chaque valeur
scalaire Unicode dans cette chaîne de caractères prend 2 octets en mémoire.
Par conséquent, un indice dans les octets de la chaîne de caractères ne
correspondra pas forcément à une valeur scalaire Unicode valide. Pour démontrer
cela, utilisons ce code Rust invalide :</p>
<!--
```rust,ignore,does_not_compile
let hello = "Здравствуйте";
let answer = &hello[0];
```
-->
<pre><code class="language-rust ignore does_not_compile">let bonjour = &quot;Здравствуйте&quot;;
let reponse = &amp;bonjour[0];
</code></pre>
<!--
What should the value of `answer` be? Should it be `З`, the first letter? When
encoded in UTF-8, the first byte of `З` is `208` and the second is `151`, so
`answer` should in fact be `208`, but `208` is not a valid character on its
own. Returning `208` is likely not what a user would want if they asked for the
first letter of this string; however, that’s the only data that Rust has at
byte index 0. Users generally don’t want the byte value returned, even if the
string contains only Latin letters: if `&"hello"[0]` were valid code that
returned the byte value, it would return `104`, not `h`. To avoid returning an
unexpected value and causing bugs that might not be discovered immediately,
Rust doesn’t compile this code at all and prevents misunderstandings early in
the development process.
-->
<p>Quelle serait la valeur de <code>reponse</code> ? Est-ce que ce serait <code>З</code>, la première
lettre ? Lorsqu'il est encodé en UTF-8, le premier octet de <code>З</code> est <code>208</code> et le
second est <code>151</code>, donc en vérité <code>reponse</code> vaudrait <code>208</code>, mais <code>208</code> n'est pas
un caractère valide à lui seul. Retourner <code>208</code> n'est pas ce qu'un utilisateur
attend s'il demande la première lettre de cette chaîne de caractères ;
cependant, c'est la seule valeur que Rust a à l'indice 0 des octets. Les
utilisateurs ne souhaitent généralement pas obtenir la valeur d'un octet, même
si la chaîne de caractères contient uniquement des lettres latines : si
<code>&amp;&quot;hello&quot;[0]</code> était un code valide qui retournait la valeur de l'octet, il
retournerait <code>104</code> et non pas <code>h</code>. Pour éviter de retourner une valeur
inattendue et générer des bogues qui ne seraient pas découverts immédiatement,
Rust ne va pas compiler ce code et va ainsi éviter des erreurs dès le début du
processus de développement.</p>
<!--
#### Bytes and Scalar Values and Grapheme Clusters! Oh My!
-->
<h4 id="des-octets-des-valeurs-scalaires-et-des-groupes-de-graphèmes--oh-mon-dieu-"><a class="header" href="#des-octets-des-valeurs-scalaires-et-des-groupes-de-graphèmes--oh-mon-dieu-">Des octets, des valeurs scalaires et des groupes de graphèmes !? Oh mon Dieu !</a></h4>
<!--
Another point about UTF-8 is that there are actually three relevant ways to
look at strings from Rust’s perspective: as bytes, scalar values, and grapheme
clusters (the closest thing to what we would call *letters*).
-->
<p>Un autre problème avec l'UTF-8 est qu'il a en fait trois manières pertinentes
de considérer les chaînes de caractères avec Rust : comme des octets, comme
des valeurs scalaires ou comme des groupes de graphèmes (ce qui se rapproche le
plus de ce que nous pourrions appeler des <em>lettres</em>).</p>
<!--
If we look at the Hindi word “नमस्ते” written in the Devanagari script, it is
stored as a vector of `u8` values that looks like this:
-->
<p>Si l'on considère le mot hindi “नमस्ते” écrit en écriture devanagari, il est
stocké comme un vecteur de valeurs <code>u8</code> qui sont les suivantes :</p>
<!--
```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```
-->
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<!--
That’s 18 bytes and is how computers ultimately store this data. If we look at
them as Unicode scalar values, which are what Rust’s `char` type is, those
bytes look like this:
-->
<p>Cela fait 18 octets et c'est ainsi que les ordinateurs stockeront cette donnée.
Si nous les voyons comme des valeurs scalaires Unicode, ce qu'est le type <code>char</code>
de Rust, ces octets seront les suivants :</p>
<!--
```text
['न', 'म', 'स', '्', 'त', 'े']
```
-->
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<!--
There are six `char` values here, but the fourth and sixth are not letters:
they’re diacritics that don’t make sense on their own. Finally, if we look at
them as grapheme clusters, we’d get what a person would call the four letters
that make up the Hindi word:
-->
<p>Nous avons six valeurs <code>char</code> ici, mais les quatrième et sixième valeurs ne sont
pas des lettres : ce sont des signes diacritiques qui n'ont pas de sens employés
seuls. Enfin, si nous les voyons comme des groupes de graphèmes, on obtient ce
qu'on pourrait appeler les quatre lettres qui constituent le mot hindi :</p>
<!--
```text
["न", "म", "स्", "ते"]
```
-->
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<!--
Rust provides different ways of interpreting the raw string data that computers
store so that each program can choose the interpretation it needs, no matter
what human language the data is in.
-->
<p>Rust fournit différentes manières d'interpréter les données brutes des chaînes
de caractères que les ordinateurs stockent afin que chaque programme puisse
choisir l'interprétation dont il a besoin, peu importe la langue dans laquelle
sont les données.</p>
<!--
A final reason Rust doesn’t allow us to index into a `String` to get a
character is that indexing operations are expected to always take constant time
(O(1)). But it isn’t possible to guarantee that performance with a `String`,
because Rust would have to walk through the contents from the beginning to the
index to determine how many valid characters there were.
-->
<p>Une dernière raison pour laquelle Rust ne nous autorise pas à indexer une
<code>String</code> pour récupérer un caractère est que les opérations d'indexation sont
censées prendre un temps constant (O(1)). Mais il n'est pas possible de garantir
cette performance avec une <code>String</code>, car Rust devrait parcourir le contenu
depuis le début jusqu'à l'indice pour déterminer combien il y a de caractères
valides.</p>
<!--
### Slicing Strings
-->
<h3 id="les-slices-de-chaînes-de-caractères-1"><a class="header" href="#les-slices-de-chaînes-de-caractères-1">Les slices de chaînes de caractères</a></h3>
<!--
Indexing into a string is often a bad idea because it’s not clear what the
return type of the string-indexing operation should be: a byte value, a
character, a grapheme cluster, or a string slice. Therefore, Rust asks you to
be more specific if you really need to use indices to create string slices. To
be more specific in your indexing and indicate that you want a string slice,
rather than indexing using `[]` with a single number, you can use `[]` with a
range to create a string slice containing particular bytes:
-->
<p>L'indexation sur une chaîne de caractères est souvent une mauvaise idée car le
type de retour de l'opération n'est pas toujours évident : un octet, un
caractère, un groupe de graphèmes ou une slice de chaîne de caractères ? C'est
pourquoi Rust vous demande d'être plus explicite si vous avez vraiment besoin
d'utiliser des indices pour créer des slices de chaînes. Afin d'expliciter votre
utilisation d'indices et d'indiquer que vous souhaitez obtenir une slice de
chaîne de caractères, vous pouvez utiliser <code>[]</code> avec un intervalle d'indices
pour créer une slice de chaîne contenant des octets bien précis, plutôt que
d'utiliser <code>[]</code> avec un seul nombre :</p>
<!--
```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bonjour = &quot;Здравствуйте&quot;;

let s = &amp;bonjour[0..4];
<span class="boring">}
</span></code></pre></pre>
<!--
Here, `s` will be a `&str` that contains the first 4 bytes of the string.
Earlier, we mentioned that each of these characters was 2 bytes, which means
`s` will be `Зд`.
-->
<p>Ici, <code>s</code> sera un <code>&amp;str</code> qui contiendra les 4 premiers octets de la chaîne de
caractères. Précédemment, nous avions mentionné que chacun de ces caractères
était encodé sur 2 octets, ce qui veut dire que <code>s</code> vaudra <code>Зд</code>.</p>
<!--
What would happen if we used `&hello[0..1]`? The answer: Rust would panic at
runtime in the same way as if an invalid index were accessed in a vector:
-->
<p>Que se passerait-il si nous utilisions <code>&amp;bonjour[0..1]</code> ? Réponse : Rust aurait
paniqué au moment de l'exécution de la même façon que si nous utilisions un
indice invalide pour accéder à un élément d'un vecteur :</p>
<!--
```console
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/main.rs:4:14
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/main.rs:4:14
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
You should use ranges to create string slices with caution, because doing so
can crash your program.
-->
<p>Vous devriez utiliser les intervalles pour créer des slices avec prudence, car
cela peut provoquer un plantage de votre programme.</p>
<!--
### Methods for Iterating Over Strings
-->
<h3 id="les-méthodes-pour-parcourir-les-chaînes-de-caractères"><a class="header" href="#les-méthodes-pour-parcourir-les-chaînes-de-caractères">Les méthodes pour parcourir les chaînes de caractères</a></h3>
<!--
Fortunately, you can access elements in a string in other ways.
-->
<p>Heureusement, il existe d'autres manières d'accéder aux éléments d'une chaîne
de caractères.</p>
<!--
If you need to perform operations on individual Unicode scalar values, the best
way to do so is to use the `chars` method. Calling `chars` on “नमस्ते” separates
out and returns six values of type `char`, and you can iterate over the result
to access each element:
-->
<p>Si vous avez besoin de faire des opérations sur les valeurs scalaires Unicode
une par une, la meilleure façon de procéder est d'utiliser la méthode <code>chars</code>.
Appeler <code>chars</code> sur “नमस्ते” sépare et retourne six valeurs de type <code>char</code>, et
vous pouvez itérer sur le résultat pour accéder à chaque élément :</p>
<!--
```rust
for c in "नमस्ते".chars() {
    println!("{}", c);
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code will print the following:
-->
<p>Ce code va afficher ceci :</p>
<!--
```text
न
म
स
्
त
े
```
-->
<pre><code class="language-text">न
म
स
्
त
े
</code></pre>
<!--
The `bytes` method returns each raw byte, which might be appropriate for your
domain:
-->
<p>La méthode <code>bytes</code> va retourner chaque octet brut, ce qui sera peut-être plus
utile selon ce que vous voulez faire :</p>
<!--
```rust
for b in "नमस्ते".bytes() {
    println!("{}", b);
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code will print the 18 bytes that make up this `String`:
-->
<p>Ce code va afficher les 18 octets qui constituent cette <code>String</code> :</p>
<!--
```text
224
164
// --snip--
165
135
```
-->
<pre><code class="language-text">224
164
// -- éléments masqués ici --
165
135
</code></pre>
<!--
But be sure to remember that valid Unicode scalar values may be made up of more
than 1 byte.
-->
<p>Rappelez-vous bien que des valeurs scalaires Unicode peuvent être constituées de
plus d'un octet.</p>
<!--
Getting grapheme clusters from strings is complex, so this functionality is not
provided by the standard library. Crates are available on
[crates.io](https://crates.io/)<!-- ignore -- > if this is the functionality you
need.
-->
<p>L'obtention des groupes de graphèmes à partir de chaînes de caractères est
complexe, donc cette fonctionnalité n'est pas fournie par la bibliothèque
standard. Des crates sont disponibles sur
<a href="https://crates.io/">crates.io</a><!-- ignore --> si c'est la fonctionnalité dont
vous avez besoin.</p>
<!--
### Strings Are Not So Simple
-->
<h3 id="les-chaînes-de-caractères-ne-sont-pas-si-simples"><a class="header" href="#les-chaînes-de-caractères-ne-sont-pas-si-simples">Les chaînes de caractères ne sont pas si simples</a></h3>
<!--
To summarize, strings are complicated. Different programming languages make
different choices about how to present this complexity to the programmer. Rust
has chosen to make the correct handling of `String` data the default behavior
for all Rust programs, which means programmers have to put more thought into
handling UTF-8 data upfront. This trade-off exposes more of the complexity of
strings than is apparent in other programming languages, but it prevents you
from having to handle errors involving non-ASCII characters later in your
development life cycle.
-->
<p>Pour résumer, les chaînes de caractères sont complexes. Les différents langages
de programmation ont fait différents choix sur la façon de présenter cette
complexité aux développeurs. Rust a choisi d'appliquer par défaut la gestion
rigoureuse des données de <code>String</code> pour tous les programmes Rust, ce qui veut
dire que les développeurs doivent réfléchir davantage à la gestion des données
UTF-8. Ce compromis révèle davantage la complexité des chaînes de caractères par
rapport à ce que les autres langages de programmation laissent paraître, mais
vous évite d'avoir à gérer plus tard dans votre cycle de développement des
erreurs à cause de caractères non ASCII.</p>
<!--
Let’s switch to something a bit less complex: hash maps!
-->
<p>Passons maintenant à quelque chose de moins complexe : les tables de hachage !</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Storing Keys with Associated Values in Hash Maps
-->
<h2 id="stocker-des-clés-associées-à-des-valeurs-dans-des-tables-de-hachage"><a class="header" href="#stocker-des-clés-associées-à-des-valeurs-dans-des-tables-de-hachage">Stocker des clés associées à des valeurs dans des tables de hachage</a></h2>
<!--
The last of our common collections is the *hash map*. The type `HashMap<K, V>`
stores a mapping of keys of type `K` to values of type `V`. It does this via a
*hashing function*, which determines how it places these keys and values into
memory. Many programming languages support this kind of data structure, but
they often use a different name, such as hash, map, object, hash table,
dictionary, or associative array, just to name a few.
-->
<p>La dernière des collections les plus courantes est la <em>table de hachage (hash
map)</em>. Le type <code>HashMap&lt;K, V&gt;</code> stocke une association de clés de type <code>K</code> à des
valeurs de type <code>V</code>. Elle fait cela via une <em>fonction de hachage</em>, qui détermine
comment elle va ranger ces clés et valeurs dans la mémoire. De nombreux langages
de programmation prennent en charge ce genre de structure de données, mais elles
ont souvent un nom différent, tel que hash, map, objet, table d'association,
dictionnaire ou tableau associatif, pour n'en nommer que quelques-uns.</p>
<!--
Hash maps are useful when you want to look up data not by using an index, as
you can with vectors, but by using a key that can be of any type. For example,
in a game, you could keep track of each team’s score in a hash map in which
each key is a team’s name and the values are each team’s score. Given a team
name, you can retrieve its score.
-->
<p>Les tables de hachage sont utiles lorsque vous voulez rechercher des données non
pas en utilisant des indices, comme vous pouvez le faire avec les vecteurs, mais
en utilisant une clé qui peut être de n'importe quel type. Par exemple, dans un
jeu, vous pouvez consigner le score de chaque équipe dans une table de hachage
dans laquelle chaque clé est le nom d'une équipe et la valeur est le score de
l'équipe. Si vous avez le nom d'une équipe, vous pouvez récupérer son score.</p>
<!--
We’ll go over the basic API of hash maps in this section, but many more goodies
are hiding in the functions defined on `HashMap<K, V>` by the standard library.
As always, check the standard library documentation for more information.
-->
<p>Nous allons passer en revue l'API de base des tables de hachage dans cette
section, mais bien d'autres fonctionnalités se cachent dans les fonctions
définies sur <code>HashMap&lt;K, V&gt;</code> par la bibliothèque standard. Comme d'habitude,
consultez la documentation de la bibliothèque standard pour plus d'informations.</p>
<!--
### Creating a New Hash Map
-->
<h3 id="créer-une-nouvelle-table-de-hachage"><a class="header" href="#créer-une-nouvelle-table-de-hachage">Créer une nouvelle table de hachage</a></h3>
<!--
You can create an empty hash map with `new` and add elements with `insert`. In
Listing 8-20, we’re keeping track of the scores of two teams whose names are
Blue and Yellow. The Blue team starts with 10 points, and the Yellow team
starts with 50.
-->
<p>Vous pouvez créer une table de hachage vide avec <code>new</code> et y ajouter des éléments
avec <code>insert</code>. Dans l'encart 8-20, nous consignons les scores de deux équipes
qui s'appellent Bleu et Jaune. L'équipe Bleu commence avec 10 points, et
l'équipe Jaune commence avec 50.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Bleu"), 10);
    scores.insert(String::from("Jaune"), 50);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Bleu&quot;), 10);
    scores.insert(String::from(&quot;Jaune&quot;), 50);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-20: Creating a new hash map and inserting some
keys and values</span>
-->
<p><span class="caption">Encart 8-20 : création d'une nouvelle table de hachage et
insertion de quelques clés et valeurs</span></p>
<!--
Note that we need to first `use` the `HashMap` from the collections portion of
the standard library. Of our three common collections, this one is the least
often used, so it’s not included in the features brought into scope
automatically in the prelude. Hash maps also have less support from the
standard library; there’s no built-in macro to construct them, for example.
-->
<p>Notez que nous devons d'abord importer <code>HashMap</code> via <code>use</code> depuis la partie des
collections de la bibliothèque standard. De nos trois collections courantes,
cette dernière est la moins utilisée, donc elle n'est pas présente dans les
fonctionnalités importées automatiquement dans la portée par l'étape
préliminaire. Les tables de hachage sont aussi moins gérées par la bibliothèque
standard ; il n'y a pas de macro intégrée pour les construire, par exemple.</p>
<!--
Just like vectors, hash maps store their data on the heap. This `HashMap` has
keys of type `String` and values of type `i32`. Like vectors, hash maps are
homogeneous: all of the keys must have the same type, and all of the values
must have the same type.
-->
<p>Exactement comme les vecteurs, les tables de hachage stockent leurs données sur
le tas. Cette <code>HashMap</code> a des clés de type <code>String</code> et des valeurs de type
<code>i32</code>. Et comme les vecteurs, les tables de hachage sont homogènes : toutes les
clés doivent être du même type, et toutes les valeurs doivent aussi être du
même type.</p>
<!--
Another way of constructing a hash map is by using iterators and the `collect`
method on a vector of tuples, where each tuple consists of a key and its value.
We’ll be going into more detail about iterators and their associated methods in
the [”Processing a Series of Items with Iterators” section of Chapter
13][iterators]<!-- ignore -- >. The `collect` method gathers data into a number
of collection types, including `HashMap`. For example, if we had the team names
and initial scores in two separate vectors, we could use the `zip` method to
create an iterator of tuples where “Blue” is paired with 10, and so forth. Then
we could use the `collect` method to turn that iterator of tuples into a hash
map, as shown in Listing 8-21.
-->
<p>Une autre façon de construire une table de hachage est d'utiliser les itérateurs
et la méthode <code>collect</code> sur un vecteur de tuples, où chaque tuple représente une
clé et sa valeur. Nous aborderons en détail les itérateurs et leurs méthodes
associées dans <a href="ch13-02-iterators.html">une section du chapitre 13</a><!-- ignore -->. La
méthode <code>collect</code> regroupe les données dans quelques types de collections, dont
<code>HashMap</code>. Par exemple, si nous avions les noms des équipes et les scores
initiaux dans deux vecteurs séparés, nous pourrions utiliser la méthode <code>zip</code>
pour créer un itérateur de tuples où “Bleu” est associé à 10, et ainsi de suite.
Ensuite, nous pourrions utiliser la méthode <code>collect</code> pour transformer cet
itérateur de tuples en table de hachage, comme dans l'encart 8-21.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let equipes = vec![String::from("Bleu"), String::from("Jaune")];
    let scores_initiaux = vec![10, 50];

    let mut scores: HashMap<_, _> =
        equipes.into_iter().zip(scores_initiaux.into_iter()).collect();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let equipes = vec![String::from(&quot;Bleu&quot;), String::from(&quot;Jaune&quot;)];
    let scores_initiaux = vec![10, 50];

    let mut scores: HashMap&lt;_, _&gt; =
        equipes.into_iter().zip(scores_initiaux.into_iter()).collect();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-21: Creating a hash map from a list of teams
and a list of scores</span>
-->
<p><span class="caption">Encart 8-21 : création d'une table de hachage à partir
d'une liste d'équipes et d'une liste de scores</span></p>
<!--
The type annotation `HashMap<_, _>` is needed here because it’s possible to
`collect` into many different data structures and Rust doesn’t know which you
want unless you specify. For the parameters for the key and value types,
however, we use underscores, and Rust can infer the types that the hash map
contains based on the types of the data in the vectors. In Listing 8-21, the
key type will be `String` and the value type will be `i32`, just as the types
were in Listing 8-20.
-->
<p>L'annotation de type <code>HashMap&lt;_, _&gt;</code> est nécessaire ici car <code>collect</code> peut
générer plusieurs types de structures de données et Rust ne sait pas laquelle
vous souhaitez si vous ne le précisez pas. Mais pour les paramètres qui
correspondent aux types de clé et de valeur, nous utilisons des tirets bas, et
Rust peut déduire les types que la table de hachage contient en fonction des
types des données présentes dans les vecteurs. Dans l'encart 8-21, le type des
clés sera <code>String</code> et le type des valeurs sera <code>i32</code>, tout comme l'étaient les
types dans l'encart 8-20.</p>
<!--
### Hash Maps and Ownership
-->
<h3 id="les-tables-de-hachage-et-la-possession"><a class="header" href="#les-tables-de-hachage-et-la-possession">Les tables de hachage et la possession</a></h3>
<!--
For types that implement the `Copy` trait, like `i32`, the values are copied
into the hash map. For owned values like `String`, the values will be moved and
the hash map will be the owner of those values, as demonstrated in Listing 8-22.
-->
<p>Pour les types qui implémentent le trait <code>Copy</code>, comme <code>i32</code>, les valeurs sont
copiées dans la table de hachage. Pour les valeurs qui sont possédées comme
<code>String</code>, les valeurs seront déplacées et la table de hachage sera la
propriétaire de ces valeurs, comme démontré dans l'encart 8-22.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let nom_champ = String::from("Couleur favorite");
    let valeur_champ = String::from("Bleu");

    let mut table = HashMap::new();
    table.insert(nom_champ, valeur_champ);
    // nom_champ et valeur_champ ne sont plus en vigueur à partir d'ici,
    // essayez de les utiliser et vous verrez l'erreur du compilateur que
    // vous obtiendrez !
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let nom_champ = String::from(&quot;Couleur favorite&quot;);
    let valeur_champ = String::from(&quot;Bleu&quot;);

    let mut table = HashMap::new();
    table.insert(nom_champ, valeur_champ);
    // nom_champ et valeur_champ ne sont plus en vigueur à partir d'ici,
    // essayez de les utiliser et vous verrez l'erreur du compilateur que
    // vous obtiendrez !
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-22: Showing that keys and values are owned by
the hash map once they’re inserted</span>
-->
<p><span class="caption">Encart 8-22 : démonstration que les clés et les valeurs
sont possédées par la table de hachage une fois qu'elles sont insérées</span></p>
<!--
We aren’t able to use the variables `field_name` and `field_value` after
they’ve been moved into the hash map with the call to `insert`.
-->
<p>Nous ne pouvons plus utiliser les variables <code>nom_champ</code> et <code>valeur_champ</code> après
qu'elles ont été déplacées dans la table de hachage lors de l'appel à <code>insert</code>.</p>
<!--
If we insert references to values into the hash map, the values won’t be moved
into the hash map. The values that the references point to must be valid for at
least as long as the hash map is valid. We’ll talk more about these issues in
the [“Validating References with
Lifetimes”][validating-references-with-lifetimes]<!-- ignore -- > section in
Chapter 10.
-->
<p>Si nous insérons dans la table de hachage des références vers des valeurs, ces
valeurs ne seront pas déplacées dans la table de hachage. Les valeurs vers
lesquelles les références pointent doivent rester en vigueur au moins aussi
longtemps que la table de hachage. Nous verrons ces problématiques dans <a href="ch10-03-lifetime-syntax.html">une
section du chapitre 10</a><!-- ignore -->.</p>
<!--
### Accessing Values in a Hash Map
-->
<h3 id="accéder-aux-valeurs-dans-une-table-de-hachage"><a class="header" href="#accéder-aux-valeurs-dans-une-table-de-hachage">Accéder aux valeurs dans une table de hachage</a></h3>
<!--
We can get a value out of the hash map by providing its key to the `get`
method, as shown in Listing 8-23.
-->
<p>Nous pouvons obtenir une valeur d'une table de hachage en passant sa clé à la
méthode <code>get</code>, comme dans l'encart 8-23.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Bleu"), 10);
    scores.insert(String::from("Jaune"), 50);

    let nom_equipe = String::from("Bleu");
    let score = scores.get(&nom_equipe);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Bleu&quot;), 10);
    scores.insert(String::from(&quot;Jaune&quot;), 50);

    let nom_equipe = String::from(&quot;Bleu&quot;);
    let score = scores.get(&amp;nom_equipe);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-23: Accessing the score for the Blue team
stored in the hash map</span>
-->
<p><span class="caption">Encart 8-23 : récupération du score de l'équipe <code>Bleu</code>,
stocké dans la table de hachage</span></p>
<!--
Here, `score` will have the value that’s associated with the Blue team, and the
result will be `Some(&10)`. The result is wrapped in `Some` because `get`
returns an `Option<&V>`; if there’s no value for that key in the hash map,
`get` will return `None`. The program will need to handle the `Option` in one
of the ways that we covered in Chapter 6.
-->
<p>Dans notre cas, <code>score</code> aura la valeur qui est associée à l'équipe <code>Bleu</code>, et le
résultat sera <code>Some(&amp;10)</code>. Le résultat est encapsulé dans un <code>Some</code> car <code>get</code>
retourne une <code>Option&lt;&amp;V&gt;</code> : s'il n'y a pas de valeur pour cette clé dans la
table de hachage, <code>get</code> va retourner <code>None</code>. Le programme doit gérer cette
<code>Option</code> d'une des manières dont nous avons parlé au chapitre 6.</p>
<!--
We can iterate over each key/value pair in a hash map in a similar manner as we
do with vectors, using a `for` loop:
-->
<p>Nous pouvons itérer sur chaque paire de clé/valeur dans une table de hachage de
la même manière que nous le faisons avec les vecteurs, en utilisant une boucle
<code>for</code> :</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Bleu"), 10);
    scores.insert(String::from("Jaune"), 50);

    for (cle, valeur) in &scores {
        println!("{} : {}", cle, valeur);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Bleu&quot;), 10);
    scores.insert(String::from(&quot;Jaune&quot;), 50);

    for (cle, valeur) in &amp;scores {
        println!(&quot;{} : {}&quot;, cle, valeur);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
This code will print each pair in an arbitrary order:
-->
<p>Ce code va afficher chaque paire dans un ordre arbitraire :</p>
<!--
```text
Yellow: 50
Blue: 10
```
-->
<pre><code class="language-text">Jaune : 50
Bleu : 10
</code></pre>
<!--
### Updating a Hash Map
-->
<h3 id="modifier-une-table-de-hachage"><a class="header" href="#modifier-une-table-de-hachage">Modifier une table de hachage</a></h3>
<!--
Although the number of keys and values is growable, each key can only have one
value associated with it at a time. When you want to change the data in a hash
map, you have to decide how to handle the case when a key already has a value
assigned. You could replace the old value with the new value, completely
disregarding the old value. You could keep the old value and ignore the new
value, only adding the new value if the key *doesn’t* already have a value. Or
you could combine the old value and the new value. Let’s look at how to do each
of these!
-->
<p>Bien que le nombre de clés et de valeurs puisse augmenter, chaque clé ne peut
être associée qu'à une seule valeur à la fois. Lorsque vous souhaitez modifier
les données d'une table de hachage, vous devez choisir comment gérer le cas où
une clé a déjà une valeur qui lui est associée. Vous pouvez remplacer l'ancienne
valeur avec la nouvelle valeur, en ignorant complètement l'ancienne valeur. Vous
pouvez garder l'ancienne valeur et ignorer la nouvelle valeur, en insérant la
nouvelle valeur uniquement si la clé <em>n'a pas</em> déjà une valeur. Ou vous pouvez
fusionner l'ancienne valeur et la nouvelle. Découvrons dès maintenant comment
faire chacune de ces actions !</p>
<!--
#### Overwriting a Value
-->
<h4 id="réécrire-une-valeur"><a class="header" href="#réécrire-une-valeur">Réécrire une valeur</a></h4>
<!--
If we insert a key and a value into a hash map and then insert that same key
with a different value, the value associated with that key will be replaced.
Even though the code in Listing 8-24 calls `insert` twice, the hash map will
only contain one key/value pair because we’re inserting the value for the Blue
team’s key both times.
-->
<p>Si nous ajoutons une clé et une valeur dans une table de hachage et que nous
ajoutons à nouveau la même clé avec une valeur différente, la valeur associée
à cette clé sera remplacée. Même si le code dans l'encart 8-24 appelle deux
fois <code>insert</code>, la table de hachage contiendra une seule paire de clé/valeur car
nous ajoutons la valeur pour l'équipe <code>Bleu</code> à deux reprises.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Bleu"), 10);
    scores.insert(String::from("Bleu"), 25);

    println!("{:?}", scores);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Bleu&quot;), 10);
    scores.insert(String::from(&quot;Bleu&quot;), 25);

    println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-24: Replacing a value stored with a particular
key</span>
-->
<p><span class="caption">Encart 8-24 : remplacement d'une valeur stockée sous une
clé spécifique</span></p>
<!--
This code will print `{"Blue": 25}`. The original value of `10` has been
overwritten.
-->
<p>Ce code va afficher <code>{&quot;Bleu&quot;: 25}</code>. La valeur initiale <code>10</code> a été remplacée.</p>
<!--
#### Only Inserting a Value If the Key Has No Value
-->
<h4 id="ajouter-une-valeur-seulement-si-la-clé-na-pas-déjà-de-valeur"><a class="header" href="#ajouter-une-valeur-seulement-si-la-clé-na-pas-déjà-de-valeur">Ajouter une valeur seulement si la clé n'a pas déjà de valeur</a></h4>
<!--
It’s common to check whether a particular key has a value and, if it doesn’t,
insert a value for it. Hash maps have a special API for this called `entry`
that takes the key you want to check as a parameter. The return value of the
`entry` method is an enum called `Entry` that represents a value that might or
might not exist. Let’s say we want to check whether the key for the Yellow team
has a value associated with it. If it doesn’t, we want to insert the value 50,
and the same for the Blue team. Using the `entry` API, the code looks like
Listing 8-25.
-->
<p>Il est courant de vérifier si une clé spécifique a déjà une valeur, et si ce
n'est pas le cas, de lui associer une valeur. Les tables de hachage ont une API
spécifique pour ce cas-là qui s'appelle <code>entry</code> et qui prend en paramètre la
clé que vous voulez vérifier. La valeur de retour de la méthode <code>entry</code> est une
énumération qui s'appelle <code>Entry</code> qui représente une valeur qui existe ou non.
Imaginons que nous souhaitons vérifier si la clé pour l'équipe <code>Jaune</code> a une
valeur qui lui est associée. Si ce n'est pas le cas, nous voulons lui associer
la valeur 50, et faire de même pour l'équipe <code>Bleu</code>. En utilisant l'API <code>entry</code>,
ce code va ressembler à l'encart 8-25.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from("Bleu"), 10);

    scores.entry(String::from("Jaune")).or_insert(50);
    scores.entry(String::from("Bleu")).or_insert(50);

    println!("{:?}", scores);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from(&quot;Bleu&quot;), 10);

    scores.entry(String::from(&quot;Jaune&quot;)).or_insert(50);
    scores.entry(String::from(&quot;Bleu&quot;)).or_insert(50);

    println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-25: Using the `entry` method to only insert if
the key does not already have a value</span>
-->
<p><span class="caption">Encart 8-25 : utilisation de la méthode <code>entry</code> pour
ajouter la clé uniquement si elle n'a pas déjà de valeur associée</span></p>
<!--
The `or_insert` method on `Entry` is defined to return a mutable reference to
the value for the corresponding `Entry` key if that key exists, and if not,
inserts the parameter as the new value for this key and returns a mutable
reference to the new value. This technique is much cleaner than writing the
logic ourselves and, in addition, plays more nicely with the borrow checker.
-->
<p>La méthode <code>or_insert</code> sur <code>Entry</code> est conçue pour retourner une référence
mutable vers la valeur correspondant à la clé du <code>Entry</code> si cette clé existe,
et sinon, d'ajouter son paramètre comme nouvelle valeur pour cette clé et
retourner une référence mutable vers la nouvelle valeur. Cette technique est
plus propre que d'écrire la logique nous-mêmes et, de plus, elle fonctionne
mieux avec le vérificateur d'emprunt.</p>
<!--
Running the code in Listing 8-25 will print `{"Yellow": 50, "Blue": 10}`. The
first call to `entry` will insert the key for the Yellow team with the value
50 because the Yellow team doesn’t have a value already. The second call to
`entry` will not change the hash map because the Blue team already has the
value 10.
-->
<p>L'exécution du code de l'encart 8-25 va afficher <code>{&quot;Jaune&quot;: 50, &quot;Bleu&quot;: 10}</code>.
Le premier appel à <code>entry</code> va ajouter la clé pour l'équipe <code>Jaune</code> avec la
valeur <code>50</code> car l'équipe <code>Jaune</code> n'a pas encore de valeur. Le second appel à
<code>entry</code> ne va pas changer la table de hachage car l'équipe <code>Bleu</code> a déjà la
valeur <code>10</code>.</p>
<!--
#### Updating a Value Based on the Old Value
-->
<h4 id="modifier-une-valeur-en-fonction-de-lancienne-valeur"><a class="header" href="#modifier-une-valeur-en-fonction-de-lancienne-valeur">Modifier une valeur en fonction de l'ancienne valeur</a></h4>
<!--
Another common use case for hash maps is to look up a key’s value and then
update it based on the old value. For instance, Listing 8-26 shows code that
counts how many times each word appears in some text. We use a hash map with
the words as keys and increment the value to keep track of how many times we’ve
seen that word. If it’s the first time we’ve seen a word, we’ll first insert
the value 0.
-->
<p>Une autre utilisation courante avec les tables de hachage est de regarder la
valeur d'une clé et ensuite la modifier en fonction de l'ancienne valeur. Par
exemple, l'encart 8-26 contient du code qui compte combien de fois chaque mot
apparaît dans du texte. Nous utilisons une table de hachage avec les mots comme
clés et nous incrémentons la valeur pour compter combien de fois nous avons vu
ce mot. Si c'est la première fois que nous voyons un mot, nous allons d'abord
insérer la valeur <code>0</code>.</p>
<!--
```rust
# fn main() {
    use std::collections::HashMap;

    let texte = "bonjour le monde magnifique monde";

    let mut table = HashMap::new();

    for mot in texte.split_whitespace() {
        let compteur = table.entry(mot).or_insert(0);
        *compteur += 1;
    }

    println!("{:?}", table);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let texte = &quot;bonjour le monde magnifique monde&quot;;

    let mut table = HashMap::new();

    for mot in texte.split_whitespace() {
        let compteur = table.entry(mot).or_insert(0);
        *compteur += 1;
    }

    println!(&quot;{:?}&quot;, table);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-26: Counting occurrences of words using a hash
map that stores words and counts</span>
-->
<p><span class="caption">Encart 8-26 : comptage des occurrences des mots en
utilisant une table de hachage qui stocke les mots et leur quantité</span></p>
<!--
This code will print `{"world": 2, "hello": 1, "wonderful": 1}`. The
`split_whitespace` method iterates over sub-slices, separated by whitespace, of
the value in `text`. The `or_insert` method returns a mutable reference (`&mut
V`) to the value for the specified key. Here we store that mutable reference in
the `count` variable, so in order to assign to that value, we must first
dereference `count` using the asterisk (`*`). The mutable reference goes out of
scope at the end of the `for` loop, so all of these changes are safe and
allowed by the borrowing rules.
-->
<p>Ce code va afficher <code>{&quot;monde&quot;: 2, &quot;bonjour&quot;: 1, &quot;magnifique&quot;: 1, &quot;le&quot;: 1}</code>. La
méthode <code>split_whitespace</code> va itérer sur les sous-slices, séparées par des
espaces vides, sur la valeur dans <code>texte</code>. La méthode <code>or_insert</code> retourne une
référence mutable (<code>&amp;mut V</code>) vers la valeur de la clé spécifiée. Nous stockons
ici la référence mutable dans la variable <code>compteur</code>, donc pour affecter une
valeur, nous devons d'abord déréférencer <code>compteur</code> en utilisant l'astérisque
(<code>*</code>). La référence mutable sort de la portée à la fin de la boucle <code>for</code>, donc
tous ces changements sont sûrs et autorisés par les règles d'emprunt.</p>
<!--
### Hashing Functions
-->
<h3 id="fonctions-de-hachage"><a class="header" href="#fonctions-de-hachage">Fonctions de hachage</a></h3>
<!--
By default, `HashMap` uses a hashing function called SipHash that can provide
resistance to Denial of Service (DoS) attacks involving hash
tables[^siphash]<!-- ignore -- >. This is not the fastest hashing algorithm
available, but the trade-off for better security that comes with the drop in
performance is worth it. If you profile your code and find that the default
hash function is too slow for your purposes, you can switch to another function
by specifying a different *hasher*. A hasher is a type that implements the
`BuildHasher` trait. We’ll talk about traits and how to implement them in
Chapter 10. You don’t necessarily have to implement your own hasher from
scratch; [crates.io](https://crates.io/)<!-- ignore -- > has libraries shared by
other Rust users that provide hashers implementing many common hashing
algorithms.
-->
<p>Par défaut, <code>HashMap</code> utilise une fonction de hachage nommée SipHash qui résiste
aux attaques par déni de service (DoS) envers les tables de hachage<sup class="footnote-reference"><a href="#siphash">1</a></sup>.
Ce n'est pas l'algorithme de hachage le plus rapide qui existe, mais le
compromis entre une meilleure sécurité et la baisse de performances en vaut la
peine. Si vous analysez la performance de votre code et que vous vous rendez
compte que la fonction de hachage par défaut est trop lente pour vos besoins,
vous pouvez la remplacer par une autre fonction en spécifiant un <em>hacheur</em>
différent. Un hacheur est un type qui implémente le trait <code>BuildHasher</code>. Nous
verrons les traits et comment les implémenter au chapitre 10. Vous n'avez pas
forcément besoin d'implémenter votre propre hacheur à partir de zéro ;
<a href="https://crates.io/">crates.io</a> héberge des bibliothèques partagées par d'autres
utilisateurs de Rust qui fournissent de nombreux algorithmes de hachage
répandus.</p>
<!--
[^siphash]: [https://en.wikipedia.org/wiki/SipHash](https://en.wikipedia.org/wiki/SipHash)
-->
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a></p>
</div>
<!--
## Summary
-->
<h2 id="résumé-7"><a class="header" href="#résumé-7">Résumé</a></h2>
<!--
Vectors, strings, and hash maps will provide a large amount of functionality
necessary in programs when you need to store, access, and modify data. Here are
some exercises you should now be equipped to solve:
-->
<p>Les vecteurs, Strings, et tables de hachage vont vous apporter de nombreuses
fonctionnalités nécessaires à vos programmes lorsque vous aurez besoin de
stocker, accéder, et modifier des données. Voici quelques exercices que vous
devriez maintenant être en mesure de résoudre :</p>
<!--
* Given a list of integers, use a vector and return the median (when sorted,
  the value in the middle position) and mode (the value that occurs most often;
  a hash map will be helpful here) of the list.
* Convert strings to pig latin. The first consonant of each word is moved to
  the end of the word and “ay” is added, so “first” becomes “irst-fay.” Words
  that start with a vowel have “hay” added to the end instead (“apple” becomes
  “apple-hay”). Keep in mind the details about UTF-8 encoding!
* Using a hash map and vectors, create a text interface to allow a user to add
  employee names to a department in a company. For example, “Add Sally to
  Engineering” or “Add Amir to Sales.” Then let the user retrieve a list of all
  people in a department or all people in the company by department, sorted
  alphabetically.
-->
<ul>
<li>À partir d'une liste d'entiers, utiliser un vecteur et retourner la médiane
(la valeur au milieu lorsque la liste est triée) et le mode (la valeur qui
apparaît le plus souvent ; une table de hachage sera utile dans ce cas) de la
liste.</li>
<li>Convertir des chaînes de caractères dans une variante du louchébem.
La consonne initiale de chaque mot est remplacée par la lettre <code>l</code> et est
rétablie à la fin du mot suivie du suffixe argotique “em” ; ainsi, “bonjour”
devient “<em>l</em>onjour<em>bem</em>”. Si le mot commence par une voyelle, ajouter un <code>l</code>
au début du mot et ajouter à la fin le suffixe “muche”. Et gardez en tête les
détails à propos de l'encodage UTF-8 !</li>
<li>En utilisant une table de hachage et des vecteurs, créez une interface
textuelle pour permettre à un utilisateur d'ajouter des noms d'employés dans
un département d'une entreprise. Par exemple, “Ajouter Sally au bureau
d'études” ou “Ajouter Amir au service commercial”. Ensuite, donnez la
possibilité à l'utilisateur de récupérer une liste de toutes les personnes
dans un département, ou tout le monde dans l'entreprise trié par département,
et classés dans l'ordre alphabétique dans tous les cas.</li>
</ul>
<!--
The standard library API documentation describes methods that vectors, strings,
and hash maps have that will be helpful for these exercises!
-->
<p>La documentation de l'API de la bibliothèque standard décrit les méthodes qu'ont
les vecteurs, chaînes de caractères et tables de hachage, ce qui vous sera bien
utile pour mener à bien ces exercices !</p>
<!--
We’re getting into more complex programs in which operations can fail, so, it’s
a perfect time to discuss error handling. We’ll do that next!
-->
<p>Nous nous lançons dans des programmes de plus en plus complexes dans lesquels
les opérations peuvent échouer, c'est donc le moment idéal pour voir comment
bien gérer les erreurs. C'est ce que nous allons faire au prochain chapitre !</p>
<!--
[iterators]: ch13-02-iterators.html
[validating-references-with-lifetimes]:
ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Error Handling
-->
<h1 id="la-gestion-des-erreurs"><a class="header" href="#la-gestion-des-erreurs">La gestion des erreurs</a></h1>
<!--
Rust’s commitment to reliability extends to error handling. Errors are a fact
of life in software, so Rust has a number of features for handling situations
in which something goes wrong. In many cases, Rust requires you to acknowledge
the possibility of an error and take some action before your code will compile.
This requirement makes your program more robust by ensuring that you’ll
discover errors and handle them appropriately before you’ve deployed your code
to production!
-->
<p>L'engagement de Rust pour la fiabilité concerne aussi la gestion des erreurs.
Les erreurs font partie de la vie des programmes informatiques, c'est pourquoi
Rust a des fonctionnalités pour gérer les situations dans lesquelles quelque
chose dérape. Dans de nombreux cas, Rust exige que vous anticipiez les erreurs
possibles et que vous preniez des dispositions avant de pouvoir compiler votre
code. Cette exigence rend votre programme plus résiliant en s'assurant que vous
détectez et gérez les erreurs correctement avant même que vous ne déployiez
votre code en production !</p>
<!--
Rust groups errors into two major categories: *recoverable* and *unrecoverable*
errors. For a recoverable error, such as a file not found error, it’s
reasonable to report the problem to the user and retry the operation.
Unrecoverable errors are always symptoms of bugs, like trying to access a
location beyond the end of an array.
-->
<p>Rust classe les erreurs dans deux catégories principales : les erreurs
<em>récupérables</em> et <em>irrécupérables</em>. Pour les erreurs récupérables, comme
lorsqu'un fichier n'est pas trouvable, il est préférable de signaler le problème
à l'utilisateur et de relancer l'opération. Les erreurs irrécupérables sont
toujours des symptômes de bogues, comme essayer d'accéder à un élément en dehors
de l'intervalle de données d'un tableau.</p>
<!--
Most languages don’t distinguish between these two kinds of errors and handle
both in the same way, using mechanisms such as exceptions. Rust doesn’t have
exceptions. Instead, it has the type `Result<T, E>` for recoverable errors and
the `panic!` macro that stops execution when the program encounters an
unrecoverable error. This chapter covers calling `panic!` first and then talks
about returning `Result<T, E>` values. Additionally, we’ll explore
considerations when deciding whether to try to recover from an error or to stop
execution.
-->
<p>La plupart des langages de programmation ne font pas de distinction entre ces
deux types d'erreurs et les gèrent de la même manière, en utilisant des
fonctionnalités comme les exceptions. Rust n'a pas d'exception. À la place, il
a les types <code>Result&lt;T, E&gt;</code> pour les erreurs récupérables, et la macro <code>panic!</code>
qui arrête l'exécution quand le programme se heurte à des erreurs
irrécupérables. Nous allons commencer ce chapitre par expliquer l'utilisation de
<code>panic!</code>, puis nous allons voir les valeurs de retour <code>Result&lt;T, E&gt;</code>. Enfin,
nous allons voir les éléments à prendre en compte pour décider si nous devons
essayer de rattraper une erreur ou alors arrêter l'exécution.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Unrecoverable Errors with `panic!`
-->
<h2 id="les-erreurs-irrécupérables-avec-panic"><a class="header" href="#les-erreurs-irrécupérables-avec-panic">Les erreurs irrécupérables avec <code>panic!</code></a></h2>
<!--
Sometimes, bad things happen in your code, and there’s nothing you can do about
it. In these cases, Rust has the `panic!` macro. When the `panic!` macro
executes, your program will print a failure message, unwind and clean up the
stack, and then quit. This most commonly occurs when a bug of some kind has
been detected and it’s not clear to the programmer how to handle the error.
-->
<p>Parfois, des choses se passent mal dans votre code, et vous ne pouvez rien y
faire. Pour ces cas-là, Rust a la macro <code>panic!</code>. Quand la macro <code>panic!</code>
s'exécute, votre programme va afficher un message d'erreur, dérouler et nettoyer
la pile, et ensuite fermer le programme. Cela se produit fréquemment lorsqu'un
bogue a été détecté, et que le développeur n'a pas su comment gérer cette
erreur.</p>
<!--
> ### Unwinding the Stack or Aborting in Response to a Panic
>
> By default, when a panic occurs, the program starts *unwinding*, which
> means Rust walks back up the stack and cleans up the data from each function
> it encounters. But this walking back and cleanup is a lot of work. The
> alternative is to immediately *abort*, which ends the program without
> cleaning up. Memory that the program was using will then need to be cleaned
> up by the operating system. If in your project you need to make the resulting
> binary as small as possible, you can switch from unwinding to aborting upon a
> panic by adding `panic = 'abort'` to the appropriate `[profile]` sections in
> your *Cargo.toml* file. For example, if you want to abort on panic in release
> mode, add this:
>
> ```toml
> [profile.release]
> panic = 'abort'
> ```
-->
<blockquote>
<h3 id="dérouler-la-pile-ou-abandonner-suite-à-un-panic"><a class="header" href="#dérouler-la-pile-ou-abandonner-suite-à-un-panic">Dérouler la pile ou abandonner suite à un <code>panic!</code></a></h3>
<p>Par défaut, quand un <em>panic</em> se produit, le programme se met à <em>dérouler</em>, ce
qui veut dire que Rust retourne en arrière dans la pile et nettoie les données
de chaque fonction qu'il rencontre sur son passage. Mais cette marche arrière
et le nettoyage demandent beaucoup de travail. Une alternative est
<em>d'abandonner</em> immédiatement, ce qui arrête le programme sans nettoyage. La
mémoire qu'utilisait le programme devra ensuite être nettoyée par le système
d'exploitation. Si dans votre projet vous avez besoin de construire un
exécutable le plus petit possible, vous pouvez passer du déroulage à l'abandon
lors d'un panic en ajoutant <code>panic = 'abort'</code> aux sections <code>[profile]</code>
appropriées dans votre fichier <em>Cargo.toml</em>. Par exemple, si vous souhaitez
abandonner lors d'un panic en mode publication <em>(release)</em>, ajoutez ceci :</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<!--
Let’s try calling `panic!` in a simple program:
-->
<p>Essayons d'appeler <code>panic!</code> dans un programme simple :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,should_panic,panics
fn main() {
    panic!("crash and burn");
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre></pre>
<!--
When you run the program, you’ll see something like this:
-->
<p>Lorsque vous lancez le programme, vous allez voir quelque chose comme ceci :</p>
<!--
```console
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
The call to `panic!` causes the error message contained in the last two lines.
The first line shows our panic message and the place in our source code where
the panic occurred: *src/main.rs:2:5* indicates that it’s the second line,
fifth character of our *src/main.rs* file.
-->
<p>L'appel à <code>panic!</code> déclenche le message d'erreur présent dans les deux dernières
lignes. La première ligne affiche notre message associé au panic et
l'emplacement dans notre code source où se produit le panic : <em>src/main.rs:2:5</em>
indique que c'est à la seconde ligne et au cinquième caractère de notre fichier
<em>src/main.rs</em>.</p>
<!--
In this case, the line indicated is part of our code, and if we go to that
line, we see the `panic!` macro call. In other cases, the `panic!` call might
be in code that our code calls, and the filename and line number reported by
the error message will be someone else’s code where the `panic!` macro is
called, not the line of our code that eventually led to the `panic!` call. We
can use the backtrace of the functions the `panic!` call came from to figure
out the part of our code that is causing the problem. We’ll discuss what a
backtrace is in more detail next.
-->
<p>Dans cet exemple, la ligne indiquée fait partie de notre code, et si nous
allons voir cette ligne, nous verrons l'appel à la macro <code>panic!</code>. Dans d'autres
cas, l'appel de <code>panic!</code> pourrait se produire dans du code que notre code
utilise. Le nom du fichier et la ligne indiquée par le message d'erreur seront
alors ceux du code de quelqu'un d'autre où la macro <code>panic!</code> est appelée, et non
pas la ligne de notre code qui nous a mené à cet appel de <code>panic!</code>. Nous pouvons
utiliser le retraçage des fonctions qui ont appelé <code>panic!</code> pour repérer la
partie de notre code qui pose problème. Nous allons maintenant parler plus en
détail de ce qu'est le retraçage.</p>
<!--
### Using a `panic!` Backtrace
-->
<h3 id="utiliser-le-retraçage-de-panic"><a class="header" href="#utiliser-le-retraçage-de-panic">Utiliser le retraçage de <code>panic!</code></a></h3>
<!--
Let’s look at another example to see what it’s like when a `panic!` call comes
from a library because of a bug in our code instead of from our code calling
the macro directly. Listing 9-1 has some code that attempts to access an
element by index in a vector.
-->
<p>Analysons un autre exemple pour voir ce qui se passe lors d'un appel de <code>panic!</code>
qui se produit dans une bibliothèque à cause d'un bogue dans notre code plutôt
qu'un appel à la macro directement. L'encart 9-1 montre du code qui essaye
d'accéder à un élément d'un vecteur via son indice :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,should_panic,panics
fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<!--
<span class="caption">Listing 9-1: Attempting to access an element beyond the
end of a vector, which will cause a call to `panic!`</span>
-->
<p><span class="caption">Encart 9-1 : tentative d'accès à un élément qui dépasse de
l'intervalle d'un vecteur, ce qui provoque un <code>panic!</code></span></p>
<!--
Here, we’re attempting to access the 100th element of our vector (which is at
index 99 because indexing starts at zero), but it has only 3 elements. In this
situation, Rust will panic. Using `[]` is supposed to return an element, but if
you pass an invalid index, there’s no element that Rust could return here that
would be correct.
-->
<p>Ici, nous essayons d'accéder au centième élément de notre vecteur (qui est à
l'indice 99 car l'indexation commence à zéro), mais le vecteur a seulement trois
éléments. Dans ce cas, Rust va paniquer. Utiliser <code>[]</code> est censé retourner un
élément, mais si vous lui donnez un indice invalide, Rust ne pourra pas
retourner un élément acceptable dans ce cas.</p>
<!--
In C, attempting to read beyond the end of a data structure is undefined
behavior. You might get whatever is at the location in memory that would
correspond to that element in the data structure, even though the memory
doesn’t belong to that structure. This is called a *buffer overread* and can
lead to security vulnerabilities if an attacker is able to manipulate the index
in such a way as to read data they shouldn’t be allowed to that is stored after
the data structure.
-->
<p>En C, tenter de lire au-delà de la fin d'une structure de données suit un
comportement indéfini. Vous pourriez récupérer la valeur à l'emplacement mémoire
qui correspondrait à l'élément demandé de la structure de données, même si cette
partie de la mémoire n'appartient pas à cette structure de données. C'est ce
qu'on appelle une <em>lecture hors limites</em> et cela peut mener à des failles de
sécurité si un attaquant a la possibilité de contrôler l'indice de telle manière
qu'il puisse lire les données qui ne devraient pas être lisibles en dehors de la
structure de données.</p>
<!--
To protect your program from this sort of vulnerability, if you try to read an
element at an index that doesn’t exist, Rust will stop execution and refuse to
continue. Let’s try it and see:
-->
<p>Afin de protéger votre programme de ce genre de vulnérabilité, si vous essayez
de lire un élément à un indice qui n'existe pas, Rust va arrêter l'exécution et
refuser de continuer. Essayez et vous verrez :</p>
<!--
```console
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
This error points at line 4 of our `main.rs` where we attempt to access index
99. The next note line tells us that we can set the `RUST_BACKTRACE`
environment variable to get a backtrace of exactly what happened to cause the
error. A *backtrace* is a list of all the functions that have been called to
get to this point. Backtraces in Rust work as they do in other languages: the
key to reading the backtrace is to start from the top and read until you see
files you wrote. That’s the spot where the problem originated. The lines above
the lines mentioning your files are code that your code called; the lines below
are code that called your code. These lines might include core Rust code,
standard library code, or crates that you’re using. Let’s try getting a
backtrace by setting the `RUST_BACKTRACE` environment variable to any value
except 0. Listing 9-2 shows output similar to what you’ll see.
-->
<p>Cette erreur mentionne la ligne 4 de notre fichier <em>main.rs</em> où on essaie
d'accéder à l'indice 99. La ligne suivante nous informe que nous pouvons régler
la variable d'environnement <code>RUST_BACKTRACE</code> pour obtenir le retraçage de ce qui
s'est exactement passé pour mener à cette erreur. Un <em>retraçage</em> consiste à
lister toutes les fonctions qui ont été appelées pour arriver jusqu'à ce point.
En Rust, le retraçage fonctionne comme dans d'autres langages : le secret pour
lire le retraçage est de commencer d'en haut et lire jusqu'à ce que vous voyiez
les fichiers que vous avez écrits. C'est l'endroit où s'est produit le problème.
Les lignes avant celles qui mentionnent vos fichiers représentent le code qu'a
appelé votre code ; les lignes qui suivent représentent le code qui a appelé
votre code. Ces lignes peuvent être du code du cœur de Rust, du code de la
bibliothèque standard, ou des crates que vous utilisez. Essayons d'obtenir un
retraçage en réglant la variable d'environnement <code>RUST_BACKTRACE</code> à n'importe
quelle valeur autre que 0. L'encart 9-2 nous montre un retour similaire à ce que
vous devriez voir :</p>
<!--
<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-- >
-->
<!--
```console
$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/std/src/panicking.rs:483
   1: core::panicking::panic_fmt
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:85
   2: core::panicking::panic_bounds_check
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:62
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:255
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:15
   5: <alloc::vec::Vec<T> as core::ops::index::Index<I>>::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/alloc/src/vec.rs:1982
   6: panic::main
             at ./src/main.rs:4
   7: core::ops::function::FnOnce::call_once
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/ops/function.rs:227
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
```
-->
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/std/src/panicking.rs:483
   1: core::panicking::panic_fmt
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:85
   2: core::panicking::panic_bounds_check
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:62
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:255
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:15
   5: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/alloc/src/vec.rs:1982
   6: panic::main
             at ./src/main.rs:4
   7: core::ops::function::FnOnce::call_once
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/ops/function.rs:227
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<!--
<span class="caption">Listing 9-2: The backtrace generated by a call to
`panic!` displayed when the environment variable `RUST_BACKTRACE` is set</span>
-->
<p><span class="caption">Encart 9-2 : le retraçage généré par l'appel de <code>panic!</code>
qui s'affiche quand la variable d'environnement <code>RUST_BACKTRACE</code> est définie
</span></p>
<!--
That’s a lot of output! The exact output you see might be different depending
on your operating system and Rust version. In order to get backtraces with this
information, debug symbols must be enabled. Debug symbols are enabled by
default when using `cargo build` or `cargo run` without the `--release` flag,
as we have here.
-->
<p>Cela fait beaucoup de contenu ! Ce que vous voyez sur votre machine peut être
différent en fonction de votre système d'exploitation et de votre version de
Rust. Pour avoir le retraçage avec ces informations, les symboles de débogage
doivent être activés. Les symboles de débogage sont activés par défaut quand on
utilise <code>cargo build</code> ou <code>cargo run</code> sans le drapeau <code>--release</code>, comme c'est le
cas ici.</p>
<!--
In the output in Listing 9-2, line 6 of the backtrace points to the line in
our project that’s causing the problem: line 4 of *src/main.rs*. If we don’t
want our program to panic, the location pointed to by the first line mentioning
a file we wrote is where we should start investigating. In Listing 9-1, where
we deliberately wrote code that would panic in order to demonstrate how to use
backtraces, the way to fix the panic is to not request an element at index 99
from a vector that only contains 3 items. When your code panics in the future,
you’ll need to figure out what action the code is taking with what values to
cause the panic and what the code should do instead.
-->
<p>Dans l'encart 9-2, la ligne 6 du retraçage nous montre la ligne de notre projet
qui provoque le problème : la ligne 4 de <em>src/main.rs</em>. Si nous ne voulons pas
que notre programme panique, le premier endroit que nous devrions inspecter est
l'emplacement cité par la première ligne qui mentionne du code que nous avons
écrit. Dans l'encart 9-1, où nous avons délibérément écrit du code qui panique
dans le but de montrer comment utiliser le retraçage, la solution pour ne pas
paniquer est de ne pas demander l'élément à l'indice 99 à un vecteur qui n'en
contient que 3. À l'avenir, quand votre code paniquera, vous aurez besoin de
prendre des dispositions dans votre code pour les valeurs qui font paniquer et
de coder quoi faire lorsque cela se produit.</p>
<!--
We’ll come back to `panic!` and when we should and should not use `panic!` to
handle error conditions in the [“To `panic!` or Not to
`panic!`”][to-panic-or-not-to-panic]<!-- ignore -- > section later in this
chapter. Next, we’ll look at how to recover from an error using `Result`.
-->
<p>Nous reviendrons sur le cas du <code>panic!</code> et sur les cas où nous devrions et ne
devrions pas utiliser <code>panic!</code> pour gérer les conditions d'erreur plus tard
à <a href="ch09-03-to-panic-or-not-to-panic.html">la fin de ce chapitre</a><!-- ignore -->. Pour le
moment, nous allons voir comment gérer une erreur en utilisant <code>Result</code>.</p>
<!--
[to-panic-or-not-to-panic]:
ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Recoverable Errors with `Result`
-->
<h2 id="des-erreurs-récupérables-avec-result"><a class="header" href="#des-erreurs-récupérables-avec-result">Des erreurs récupérables avec <code>Result</code></a></h2>
<!--
Most errors aren’t serious enough to require the program to stop entirely.
Sometimes, when a function fails, it’s for a reason that you can easily
interpret and respond to. For example, if you try to open a file and that
operation fails because the file doesn’t exist, you might want to create the
file instead of terminating the process.
-->
<p>La plupart des erreurs ne sont pas assez graves au point d'arrêter complètement
le programme. Parfois, lorsqu'une fonction échoue, c'est pour une raison que
vous pouvez facilement comprendre et pour laquelle vous pouvez agir en
conséquence. Par exemple, si vous essayez d'ouvrir un fichier et que l'opération
échoue parce que le fichier n'existe pas, vous pourriez vouloir créer le fichier
plutôt que d'arrêter le processus.</p>
<!--
Recall from [“Handling Potential Failure with the `Result`
Type”][handle_failure]<!-- ignore -- > in Chapter 2 that the `Result` enum is
defined as having two variants, `Ok` and `Err`, as follows:
-->
<p>Souvenez-vous de la section <a href="ch02-00-guessing-game-tutorial.html#g%C3%A9rer-les-erreurs-potentielles-avec-le-type-result">“Gérer les erreurs potentielles avec le type
<code>Result</code>”</a><!-- ignore --> du chapitre 2 que l'énumération
<code>Result</code> possède deux variantes, <code>Ok</code> et <code>Err</code>, comme ci-dessous :</p>
<!--
[handle_failure]: ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type
-->
<!--
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `T` and `E` are generic type parameters: we’ll discuss generics in more
detail in Chapter 10. What you need to know right now is that `T` represents
the type of the value that will be returned in a success case within the `Ok`
variant, and `E` represents the type of the error that will be returned in a
failure case within the `Err` variant. Because `Result` has these generic type
parameters, we can use the `Result` type and the functions that the standard
library has defined on it in many different situations where the successful
value and error value we want to return may differ.
-->
<p>Le <code>T</code> et le <code>E</code> sont des paramètres de type génériques : nous parlerons plus en
détail de la généricité au chapitre 10. Tout ce que vous avez besoin de savoir
pour le moment, c'est que <code>T</code> représente le type de valeur imbriquée dans la
variante <code>Ok</code> qui sera retournée dans le cas d'un succès, et <code>E</code> représente le
type d'erreur imbriquée dans la variante <code>Err</code> qui sera retournée dans le cas
d'un échec. Comme <code>Result</code> a ces paramètres de type génériques, nous pouvons
utiliser le type <code>Result</code> et les fonctions que la bibliothèque standard lui a
associées dans différentes situations où la valeur de succès et la valeur
d'erreur peuvent varier.</p>
<!--
Let’s call a function that returns a `Result` value because the function could
fail. In Listing 9-3 we try to open a file.
-->
<p>Utilisons une fonction qui retourne une valeur de type <code>Result</code> car la fonction
peut échouer. Dans l'encart 9-3, nous essayons d'ouvrir un fichier :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 9-3: Opening a file</span>
-->
<p><span class="caption">Encart 9-3 : ouverture d'un fichier</span></p>
<!--
How do we know `File::open` returns a `Result`? We could look at the [standard
library API documentation](../std/index.html)<!-- ignore -- >, or we could ask
the compiler! If we give `f` a type annotation that we know is *not* the return
type of the function and then try to compile the code, the compiler will tell
us that the types don’t match. The error message will then tell us what the
type of `f` *is*. Let’s try it! We know that the return type of `File::open`
isn’t of type `u32`, so let’s change the `let f` statement to this:
-->
<p>Comment savons-nous que <code>File::open</code> retourne un <code>Result</code> ? Nous pouvons
consulter la <a href="https://doc.rust-lang.org/std/index.html">documentation de l'API de la bibliothèque
standard</a><!-- ignore -->, ou nous
pouvons demander au compilateur ! Si nous appliquons à <code>f</code> une annotation de
type dont nous savons qu'elle n'est <em>pas</em> le type de retour de la fonction et
que nous essayons ensuite de compiler le code, le compilateur va nous dire que
les types ne correspondent pas. Le message d'erreur va ensuite nous dire <em>quel
est le type</em> de <code>f</code>. Essayons cela ! Nous savons que le type de retour de
<code>File::open</code> n'est pas <code>u32</code>, alors essayons de changer l'instruction <code>let f</code>
par ceci :</p>
<!--
```rust,ignore,does_not_compile
# use std::fs::File;
# 
# fn main() {
    let f: u32 = File::open("hello.txt");
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let f: u32 = File::open(&quot;hello.txt&quot;);
<span class="boring">}
</span></code></pre>
<!--
Attempting to compile now gives us the following output:
-->
<p>Tenter de compiler ce code nous donne maintenant le résultat suivant :</p>
<!--
```console
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0308]: mismatched types
 -- > src/main.rs:4:18
  |
4 |     let f: u32 = File::open("hello.txt");
  |            ---   ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `Result`
  |            |
  |            expected due to this
  |
  = note: expected type `u32`
             found enum `Result<File, std::io::Error>`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `error-handling` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |            ---   ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `Result`
  |            |
  |            expected due to this
  |
  = note: expected type `u32`
             found enum `Result&lt;File, std::io::Error&gt;`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `error-handling` due to previous error
</code></pre>
<!--
This tells us the return type of the `File::open` function is a `Result<T, E>`.
The generic parameter `T` has been filled in here with the type of the success
value, `std::fs::File`, which is a file handle. The type of `E` used in the
error value is `std::io::Error`.
-->
<p>Cela nous dit que le type de retour de la fonction <code>File::open</code> est de la forme
<code>Result&lt;T, E&gt;</code>. Le paramètre générique <code>T</code> a été remplacé dans ce cas par le
type en cas de succès, <code>std::fs::File</code>, qui permet d'interagir avec le fichier.
Le <code>E</code> utilisé pour la valeur d'erreur est du type <code>std::io::Error</code>.</p>
<!--
This return type means the call to `File::open` might succeed and return a file
handle that we can read from or write to. The function call also might fail:
for example, the file might not exist, or we might not have permission to
access the file. The `File::open` function needs to have a way to tell us
whether it succeeded or failed and at the same time give us either the file
handle or error information. This information is exactly what the `Result` enum
conveys.
-->
<p>Ce type de retour veut dire que l'appel à <code>File::open</code> peut réussir et nous
retourner un manipulateur de fichier qui peut nous permettre de le lire ou d'y
écrire. L'utilisation de cette fonction peut aussi échouer : par exemple, si le
fichier n'existe pas, ou si nous n'avons pas le droit d'accéder au fichier. La
fonction <code>File::open</code> doit avoir un moyen de nous dire si son utilisation a
réussi ou échoué et en même temps nous fournir soit le manipulateur de fichier,
soit des informations sur l'erreur. C'est exactement ces informations que
l'énumération <code>Result</code> se charge de nous transmettre.</p>
<!--
In the case where `File::open` succeeds, the value in the variable `f` will be
an instance of `Ok` that contains a file handle. In the case where it fails,
the value in `f` will be an instance of `Err` that contains more information
about the kind of error that happened.
-->
<p>Dans le cas où <code>File::open</code> réussit, la valeur que nous obtiendrons dans la
variable <code>f</code> sera une instance de <code>Ok</code> qui contiendra un manipulateur de
fichier. Dans le cas où cela échoue, la valeur dans <code>f</code> sera une instance de
<code>Err</code> qui contiendra plus d'information sur le type d'erreur qui a eu lieu.</p>
<!--
We need to add to the code in Listing 9-3 to take different actions depending
on the value `File::open` returns. Listing 9-4 shows one way to handle the
`Result` using a basic tool, the `match` expression that we discussed in
Chapter 6.
-->
<p>Nous avons besoin d'ajouter différentes actions dans le code de l'encart 9-3 en
fonction de la valeur que <code>File::open</code> retourne. L'encart 9-4 montre une façon
de gérer le <code>Result</code> en utilisant un outil basique, l'expression <code>match</code> que
nous avons vue au chapitre 6.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,should_panic
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(fichier) =&gt; fichier,
        Err(erreur) =&gt; panic!(&quot;Erreur d'ouverture du fichier : {:?}&quot;, erreur),
    };
}
</code></pre></pre>
<!--
<span class="caption">Listing 9-4: Using a `match` expression to handle the
`Result` variants that might be returned</span>
-->
<p><span class="caption">Encart 9-4 : utilisation de l'expression <code>match</code> pour
gérer les variantes de <code>Result</code> qui peuvent être retournées</span></p>
<!--
Note that, like the `Option` enum, the `Result` enum and its variants have been
brought into scope by the prelude, so we don’t need to specify `Result::`
before the `Ok` and `Err` variants in the `match` arms.
-->
<p>Remarquez que, tout comme l'énumération <code>Option</code>, l'énumération <code>Result</code> et ses
variantes ont été importées par l'étape préliminaire, donc vous n'avez pas
besoin de préciser <code>Result::</code> devant les variantes <code>Ok</code> et <code>Err</code> dans les
branches du <code>match</code>.</p>
<!--
Here we tell Rust that when the result is `Ok`, return the inner `file` value
out of the `Ok` variant, and we then assign that file handle value to the
variable `f`. After the `match`, we can use the file handle for reading or
writing.
-->
<p>Ici, nous indiquons à Rust que quand le résultat est <code>Ok</code>, il faut retourner la
valeur <code>fichier</code> contenue dans la variante <code>Ok</code>, et nous assignons ensuite cette
valeur à la variable <code>f</code>. Après le <code>match</code>, nous pourrons ensuite utiliser le
manipulateur de fichier pour lire ou écrire.</p>
<!--
The other arm of the `match` handles the case where we get an `Err` value from
`File::open`. In this example, we’ve chosen to call the `panic!` macro. If
there’s no file named *hello.txt* in our current directory and we run this
code, we’ll see the following output from the `panic!` macro:
-->
<p>L'autre branche du bloc <code>match</code> gère le cas où nous obtenons un <code>Err</code> à l'appel
de <code>File::open</code>. Dans cet exemple, nous avons choisi de faire appel à la macro
<code>panic!</code>. S'il n'y a pas de fichier qui s'appelle <em>hello.txt</em> dans notre
répertoire actuel et que nous exécutons ce code, nous allons voir la sortie
suivante suite à l'appel de la macro <code>panic!</code> :</p>
<!--
```console
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: "No such file or directory" }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Erreur d'ouverture du fichier : Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:8:24
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
As usual, this output tells us exactly what has gone wrong.
-->
<p>Comme d'habitude, cette sortie nous explique avec précision ce qui s'est mal
passé.</p>
<!--
### Matching on Different Errors
-->
<h3 id="gérer-les-différentes-erreurs"><a class="header" href="#gérer-les-différentes-erreurs">Gérer les différentes erreurs</a></h3>
<!--
The code in Listing 9-4 will `panic!` no matter why `File::open` failed. What
we want to do instead is take different actions for different failure reasons:
if `File::open` failed because the file doesn’t exist, we want to create the
file and return the handle to the new file. If `File::open` failed for any
other reason—for example, because we didn’t have permission to open the file—we
still want the code to `panic!` in the same way as it did in Listing 9-4. Look
at Listing 9-5, which adds an inner `match` expression.
-->
<p>Le code dans l'encart 9-4 va faire un <code>panic!</code> peu importe la raison de l'échec
de <code>File::open</code>. Ce que nous voudrions plutôt faire est de réagir différemment
en fonction de différents cas d'erreurs : si <code>File::open</code> a échoué parce que le
fichier n'existe pas, nous voulons créer le fichier et retourner le manipulateur
de fichier pour ce nouveau fichier. Si <code>File::open</code> échoue pour toute autre
raison, par exemple si nous n'avons pas l'autorisation d'ouvrir le fichier,
nous voulons quand même que le code lance un <code>panic!</code> de la même manière qu'il
l'a fait dans l'encart 9-4. Dans l'encart 9-5, nous avons ajouté une expression
<code>match</code> imbriquée :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -- >
-->
<!--
```rust,ignore
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => {
                panic!("Problem opening the file: {:?}", other_error)
            }
        },
    };
}
```
-->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(fichier) =&gt; fichier,
        Err(erreur) =&gt; match erreur.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Erreur de création du fichier : {:?}&quot;, e),
            },
            autre_erreur =&gt; {
                panic!(&quot;Erreur d'ouverture du fichier : {:?}&quot;, autre_erreur)
            }
        },
    };
}
</code></pre>
<!--
<span class="caption">Listing 9-5: Handling different kinds of errors in
different ways</span>
-->
<p><span class="caption">Encart 9-5 : gestion des différents cas d'erreurs avec des
actions différentes</span></p>
<!--
The type of the value that `File::open` returns inside the `Err` variant is
`io::Error`, which is a struct provided by the standard library. This struct
has a method `kind` that we can call to get an `io::ErrorKind` value. The enum
`io::ErrorKind` is provided by the standard library and has variants
representing the different kinds of errors that might result from an `io`
operation. The variant we want to use is `ErrorKind::NotFound`, which indicates
the file we’re trying to open doesn’t exist yet. So we match on `f`, but we
also have an inner match on `error.kind()`.
-->
<p>La valeur de retour de <code>File::open</code> logée dans la variante <code>Err</code> est de type
<code>io::Error</code>, qui est une structure fournie par la bibliothèque standard. Cette
structure a une méthode <code>kind</code> que nous pouvons appeler pour obtenir une valeur
de type <code>io::ErrorKind</code>. L'énumération <code>io::ErrorKind</code> est fournie elle aussi
par la bibliothèque standard et a des variantes qui représentent les différents
types d'erreurs qui pourraient résulter d'une opération provenant du module
<code>io</code>. La variante que nous voulons utiliser est <code>ErrorKind::NotFound</code>, qui
indique que le fichier que nous essayons d'ouvrir n'existe pas encore. Donc nous
utilisons <code>match</code> sur <code>f</code>, mais nous avons dans celle-ci un autre <code>match</code> sur
<code>erreur.kind()</code>.</p>
<!--
The condition we want to check in the inner match is whether the value returned
by `error.kind()` is the `NotFound` variant of the `ErrorKind` enum. If it is,
we try to create the file with `File::create`. However, because `File::create`
could also fail, we need a second arm in the inner `match` expression. When the
file can’t be created, a different error message is printed. The second arm of
the outer `match` stays the same, so the program panics on any error besides
the missing file error.
-->
<p>Nous souhaitons vérifier dans le <code>match</code> interne si la valeur de retour de
<code>error.kind()</code> est la variante <code>NotFound</code> de l'énumération <code>ErrorKind</code>. Si c'est
le cas, nous essayons de créer le fichier avec <code>File::create</code>. Cependant, comme
<code>File::create</code> peut aussi échouer, nous avons besoin d'une seconde branche dans
le <code>match</code> interne. Lorsque le fichier ne peut pas être créé, un message
d'erreur différent est affiché. La seconde branche du <code>match</code> principal reste
inchangée, donc le programme panique lorsqu'on rencontre une autre erreur que
l'absence de fichier.</p>
<!--
That’s a lot of `match`! The `match` expression is very useful but also very
much a primitive. In Chapter 13, you’ll learn about closures; the `Result<T,
E>` type has many methods that accept a closure and are implemented using
`match` expressions. Using those methods will make your code more concise. A
more seasoned Rustacean might write this code instead of Listing 9-5:
-->
<p>Cela commence à faire beaucoup de <code>match</code> ! L'expression <code>match</code> est très utile
mais est aussi assez rudimentaire. Dans le chapitre 13, vous en apprendrez plus
sur les fermetures ; le type <code>Result&lt;T, E&gt;</code> a de nombreuses méthodes qui
acceptent une fermeture et qui sont implémentées en utilisant des expressions
<code>match</code>. L'utilisation de ces méthodes va rendre votre code plus concis. Un
Rustacé plus chevronné écrira ce code plutôt que celui de l'encart 9-5 :</p>
<!--
```rust,ignore
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}
```
-->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap_or_else(|erreur| {
        if erreur.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|erreur| {
                panic!(&quot;Erreur de création du fichier : {:?}&quot;, erreur);
            })
        } else {
            panic!(&quot;Erreur d'ouverture du fichier : {:?}&quot;, erreur);
        }
    });
}
</code></pre>
<!--
Although this code has the same behavior as Listing 9-5, it doesn’t contain any
`match` expressions and is cleaner to read. Come back to this example after
you’ve read Chapter 13, and look up the `unwrap_or_else` method in the standard
library documentation. Many more of these methods can clean up huge nested
`match` expressions when you’re dealing with errors.
-->
<p>Bien que ce code ait le même comportement que celui de l'encart 9-5, il ne
contient aucune expression <code>match</code> et est plus facile à lire. Revenez sur cet
exemple après avoir lu le chapitre 13, et renseignez-vous sur la méthode
<code>unwrap_or_else</code> dans la documentation de la bibliothèque standard. De
nombreuses méthodes de ce type peuvent clarifier de grosses expressions <code>match</code>
imbriquées lorsque vous traitez les erreurs.</p>
<!--
### Shortcuts for Panic on Error: `unwrap` and `expect`
-->
<h3 id="raccourcis-pour-faire-un-panic-lors-dune-erreur--unwrap-et-expect"><a class="header" href="#raccourcis-pour-faire-un-panic-lors-dune-erreur--unwrap-et-expect">Raccourcis pour faire un panic lors d'une erreur : <code>unwrap</code> et <code>expect</code></a></h3>
<!--
Using `match` works well enough, but it can be a bit verbose and doesn’t always
communicate intent well. The `Result<T, E>` type has many helper methods
defined on it to do various tasks. One of those methods, called `unwrap`, is a
shortcut method that is implemented just like the `match` expression we wrote in
Listing 9-4. If the `Result` value is the `Ok` variant, `unwrap` will return
the value inside the `Ok`. If the `Result` is the `Err` variant, `unwrap` will
call the `panic!` macro for us. Here is an example of `unwrap` in action:
-->
<p>L'utilisation de <code>match</code> fonctionne assez bien, mais elle peut être un peu
verbeuse et ne communique pas forcément bien son intention. Le type
<code>Result&lt;T, E&gt;</code> a de nombreuses méthodes qui lui ont été définies pour différents
cas. Une de ces méthodes, qui s'appelle <code>unwrap</code>, a été implémentée comme
l'expression <code>match</code> que nous avons écrite dans l'encart 9-4. Si la valeur de
<code>Result</code> est la variante <code>Ok</code>, <code>unwrap</code> va retourner la valeur contenue dans le
<code>Ok</code>. Si le <code>Result</code> est la variante <code>Err</code>, <code>unwrap</code> va appeler la macro
<code>panic!</code> pour nous. Voici un exemple de <code>unwrap</code> en action :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,should_panic
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<!--
If we run this code without a *hello.txt* file, we’ll see an error message from
the `panic!` call that the `unwrap` method makes:
-->
<p>Si nous exécutons ce code alors qu'il n'y a pas de fichier <em>hello.txt</em>, nous
allons voir un message d'erreur suite à l'appel à <code>panic!</code> que la méthode
<code>unwrap</code> a fait :</p>
<!--
```text
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: "No such file or directory" } }',
src/libcore/result.rs:906:4
```
-->
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<!--
Another method, `expect`, which is similar to `unwrap`, lets us also choose the
`panic!` error message. Using `expect` instead of `unwrap` and providing good
error messages can convey your intent and make tracking down the source of a
panic easier. The syntax of `expect` looks like this:
-->
<p>L'autre méthode, <code>expect</code>, qui ressemble à <code>unwrap</code>, nous donne la possibilité
de définir le message d'erreur du <code>panic!</code>. Utiliser <code>expect</code> plutôt que
<code>unwrap</code> et lui fournir un bon message d'erreur permet de mieux exprimer le
problème et faciliter la recherche de la source d'un panic. La syntaxe de
<code>expect</code> est la suivante :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,should_panic
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").expect("Failed to open hello.txt");
}
```
-->
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Échec à l'ouverture de hello.txt&quot;);
}
</code></pre></pre>
<!--
We use `expect` in the same way as `unwrap`: to return the file handle or call
the `panic!` macro. The error message used by `expect` in its call to `panic!`
will be the parameter that we pass to `expect`, rather than the default
`panic!` message that `unwrap` uses. Here’s what it looks like:
-->
<p>Nous utilisons <code>expect</code> de la même manière que <code>unwrap</code> : pour retourner le
manipulateur de fichier ou appeler la macro <code>panic!</code>. Le message d'erreur
utilisé par <code>expect</code> lors de son appel à <code>panic!</code> sera le paramètre que nous
avons passé à <code>expect</code>, plutôt que le message par défaut de <code>panic!</code> qu'utilise
<code>unwrap</code>. Voici ce que cela donne :</p>
<!--
```text
thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: "No such file or directory" } }', src/libcore/result.rs:906:4
```
-->
<pre><code class="language-text">thread 'main' panicked at 'Échec à l'ouverture de hello.txt: Error { repr: Os {
code: 2, message: &quot;No such file or directory&quot; } }', src/libcore/result.rs:906:4
</code></pre>
<!--
Because this error message starts with the text we specified, `Failed to open
hello.txt`, it will be easier to find where in the code this error message is
coming from. If we use `unwrap` in multiple places, it can take more time to
figure out exactly which `unwrap` is causing the panic because all `unwrap`
calls that panic print the same message.
-->
<p>Comme ce message d'erreur commence par le texte que nous avons précisé, <code>Échec à l'ouverture de hello.txt</code>, ce sera plus facile de trouver là d'où provient ce
message d'erreur dans le code. Si nous utilisons <code>unwrap</code> à plusieurs endroits,
cela peut prendre plus de temps de comprendre exactement quel <code>unwrap</code> a causé
le panic, car tous les appels à <code>unwrap</code> vont afficher le même message.</p>
<!--
### Propagating Errors
-->
<h3 id="propager-les-erreurs"><a class="header" href="#propager-les-erreurs">Propager les erreurs</a></h3>
<!--
When you’re writing a function whose implementation calls something that might
fail, instead of handling the error within this function, you can return the
error to the calling code so that it can decide what to do. This is known as
*propagating* the error and gives more control to the calling code, where there
might be more information or logic that dictates how the error should be
handled than what you have available in the context of your code.
-->
<p>Lorsque vous écrivez une fonction dont l'implémentation utilise quelque chose
qui peut échouer, au lieu de gérer l'erreur dans cette fonction, vous pouvez
retourner cette erreur au code qui l'appelle pour qu'il décide quoi faire. C'est
ce que l'on appelle <em>propager</em> l'erreur et donne ainsi plus de contrôle au code
qui appelle la fonction, dans lequel il peut y avoir plus d'informations ou
d'instructions pour traiter l'erreur que dans le contexte de votre code.</p>
<!--
For example, Listing 9-6 shows a function that reads a username from a file. If
the file doesn’t exist or can’t be read, this function will return those errors
to the code that called this function.
-->
<p>Par exemple, l'encart 9-6 montre une fonction qui lit un pseudo à partir d'un
fichier. Si ce fichier n'existe pas ou ne peut pas être lu, cette fonction va
retourner ces erreurs au code qui a appelé cette fonction.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -- >
-->
<!--
```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let f = File::open("hello.txt");

    let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn lire_pseudo_depuis_fichier() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(fichier) =&gt; fichier,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-6: A function that returns errors to the
calling code using `match`</span>
-->
<p><span class="caption">Encart 9-6 : une fonction qui retourne les erreurs au code
qui l'appelle en utilisant <code>match</code></span></p>
<!--
This function can be written in a much shorter way, but we’re going to start by
doing a lot of it manually in order to explore error handling; at the end,
we’ll show the shorter way. Let’s look at the return type of the function first:
`Result<String, io::Error>`. This means the function is returning a value of
the type `Result<T, E>` where the generic parameter `T` has been filled in
with the concrete type `String` and the generic type `E` has been filled in
with the concrete type `io::Error`. If this function succeeds without any
problems, the code that calls this function will receive an `Ok` value that
holds a `String`—the username that this function read from the file. If this
function encounters any problems, the code that calls this function will
receive an `Err` value that holds an instance of `io::Error` that contains
more information about what the problems were. We chose `io::Error` as the
return type of this function because that happens to be the type of the error
value returned from both of the operations we’re calling in this function’s
body that might fail: the `File::open` function and the `read_to_string`
method.
-->
<p>Cette fonction peut être écrite de façon plus concise, mais nous avons décidé de
commencer par faire un maximum de choses manuellement pour découvrir la gestion
d'erreurs ; mais à la fin, nous verrons comment raccourcir le code. Commençons
par regarder le type de retour de la fonction : <code>Result&lt;String, io::Error&gt;</code>.
Cela signifie que la fonction retourne une valeur de type <code>Result&lt;T, E&gt;</code> où le
paramètre générique <code>T</code> a été remplacé par le type <code>String</code> et le paramètre
générique <code>E</code> a été remplacé par le type <code>io::Error</code>. Si cette fonction réussit
sans problème, le code qui appelle cette fonction va obtenir une valeur <code>Ok</code> qui
contient une <code>String</code>, le pseudo que cette fonction lit dans le fichier. Si
cette fonction rencontre un problème, le code qui appelle cette fonction va
obtenir une valeur <code>Err</code> qui contient une instance de <code>io::Error</code> qui donne plus
d'informations sur la raison du problème. Nous avons choisi <code>io::Error</code> comme
type de retour de cette fonction parce qu'il se trouve que c'est le type
d'erreur de retour pour les deux opérations qui peuvent échouer que l'on utilise
dans le corps de cette fonction : la fonction <code>File::open</code> et la méthode
<code>read_to_string</code>.</p>
<!--
The body of the function starts by calling the `File::open` function. Then we
handle the `Result` value with a `match` similar to the `match` in Listing 9-4.
If `File::open` succeeds, the file handle in the pattern variable `file`
becomes the value in the mutable variable `f` and the function continues. In
the `Err` case, instead of calling `panic!`, we use the `return` keyword to
return early out of the function entirely and pass the error value from
`File::open`, now in the pattern variable `e`, back to the calling code as this
function’s error value.
-->
<p>Le corps de la fonction commence par appeler la fonction <code>File::open</code>. Ensuite,
nous gérons la valeur du <code>Result</code> avec un <code>match</code> similaire au <code>match</code> de
l'encart 9-4. Si le <code>File::open</code> est un succès, le manipulateur de fichier dans
la variable <code>fichier</code> du motif devient la valeur dans la variable mutable <code>f</code>
et la fonction continue son déroulement. Dans le cas d'un <code>Err</code>, au lieu
d'appeler <code>panic!</code>, nous utilisons <code>return</code> pour sortir prématurément de toute
la fonction et en passant la valeur du <code>File::open</code>, désormais dans la variable
<code>e</code>, au code appelant comme valeur de retour de cette fonction.</p>
<!--
So if we have a file handle in `f`, the function then creates a new `String` in
variable `s` and calls the `read_to_string` method on the file handle in `f` to
read the contents of the file into `s`. The `read_to_string` method also
returns a `Result` because it might fail, even though `File::open` succeeded.
So we need another `match` to handle that `Result`: if `read_to_string`
succeeds, then our function has succeeded, and we return the username from the
file that’s now in `s` wrapped in an `Ok`. If `read_to_string` fails, we return
the error value in the same way that we returned the error value in the `match`
that handled the return value of `File::open`. However, we don’t need to
explicitly say `return`, because this is the last expression in the function.
-->
<p>Donc si nous avons un manipulateur de fichier dans <code>f</code>, la fonction crée
ensuite une nouvelle <code>String</code> dans la variable <code>s</code> et nous appelons la méthode
<code>read_to_string</code> sur le manipulateur de fichier <code>f</code> pour extraire le contenu du
fichier dans <code>s</code>. La méthode <code>read_to_string</code> retourne aussi un <code>Result</code> car
elle peut échouer, même si <code>File::open</code> a réussi. Nous avons donc besoin d'un
nouveau <code>match</code> pour gérer ce <code>Result</code> : si <code>read_to_string</code> réussit, alors
notre fonction a réussi, et nous retournons le pseudo que nous avons extrait du
fichier qui est maintenant intégré dans un <code>Ok</code>, lui-même stocké dans <code>s</code>. Si
<code>read_to_string</code> échoue, nous retournons la valeur d'erreur de la même façon
que nous avons retourné la valeur d'erreur dans le <code>match</code> qui gérait la valeur
de retour de <code>File::open</code>. Cependant, nous n'avons pas besoin d'écrire
explicitement <code>return</code>, car c'est la dernière expression de la fonction.</p>
<!--
The code that calls this code will then handle getting either an `Ok` value
that contains a username or an `Err` value that contains an `io::Error`. We
don’t know what the calling code will do with those values. If the calling code
gets an `Err` value, it could call `panic!` and crash the program, use a
default username, or look up the username from somewhere other than a file, for
example. We don’t have enough information on what the calling code is actually
trying to do, so we propagate all the success or error information upward for
it to handle appropriately.
-->
<p>Le code qui appelle ce code va devoir ensuite gérer les cas où il récupère une
valeur <code>Ok</code> qui contient un pseudo, ou une valeur <code>Err</code> qui contient une
<code>io::Error</code>. Nous ne savons pas ce que va faire le code appelant avec ces
valeurs. Si le code appelant obtient une valeur <code>Err</code>, il peut appeler <code>panic!</code>
et faire planter le programme, utiliser un pseudo par défaut, ou chercher le
pseudo autre part que dans ce fichier, par exemple. Nous n'avons pas assez
d'informations sur ce que le code appelant a l'intention de faire, donc nous
remontons toutes les informations de succès ou d'erreur pour qu'elles soient
gérées correctement.</p>
<!--
This pattern of propagating errors is so common in Rust that Rust provides the
question mark operator `?` to make this easier.
-->
<p>Cette façon de propager les erreurs est si courante en Rust que Rust fournit
l'opérateur point d'interrogation <code>?</code> pour faciliter ceci.</p>
<!--
#### A Shortcut for Propagating Errors: the `?` Operator
-->
<h4 id="un-raccourci-pour-propager-les-erreurs--lopérateur-"><a class="header" href="#un-raccourci-pour-propager-les-erreurs--lopérateur-">Un raccourci pour propager les erreurs : l'opérateur <code>?</code></a></h4>
<!--
Listing 9-7 shows an implementation of `read_username_from_file` that has the
same functionality as it had in Listing 9-6, but this implementation uses the
`?` operator.
-->
<p>L'encart 9-7 montre une implémentation de <code>lire_pseudo_depuis_fichier</code> qui a les
mêmes fonctionnalités que dans l'encart 9-6, mais cette implémentation utilise
l'opérateur point d'interrogation :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -- >
-->
<!--
```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = File::open("hello.txt")?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn lire_pseudo_depuis_fichier() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-7: A function that returns errors to the
calling code using the `?` operator</span>
-->
<p><span class="caption">Encart 9-7 : une fonction qui retourne les erreurs au code
appelant en utilisant l'opérateur <code>?</code></span></p>
<!--
The `?` placed after a `Result` value is defined to work in almost the same way
as the `match` expressions we defined to handle the `Result` values in Listing
9-6. If the value of the `Result` is an `Ok`, the value inside the `Ok` will
get returned from this expression, and the program will continue. If the value
is an `Err`, the `Err` will be returned from the whole function as if we had
used the `return` keyword so the error value gets propagated to the calling
code.
-->
<p>Le <code>?</code> placé après une valeur <code>Result</code> est conçu pour fonctionner presque de la
même manière que les expressions <code>match</code> que nous avons définies pour gérer les
valeurs <code>Result</code> dans l'encart 9-6. Si la valeur du <code>Result</code> est un <code>Ok</code>, la
valeur dans le <code>Ok</code> sera retournée par cette expression et le programme
continuera. Si la valeur est un <code>Err</code>, le <code>Err</code> sera retourné par la fonction
comme si nous avions utilisé le mot-clé <code>return</code> afin que la valeur d'erreur
soit propagée au code appelant.</p>
<!--
There is a difference between what the `match` expression from Listing 9-6 does
and what the `?` operator does: error values that have the `?` operator called
on them go through the `from` function, defined in the `From` trait in the
standard library, which is used to convert errors from one type into another.
When the `?` operator calls the `from` function, the error type received is
converted into the error type defined in the return type of the current
function. This is useful when a function returns one error type to represent
all the ways a function might fail, even if parts might fail for many different
reasons. As long as there’s an `impl From<OtherError> for ReturnedError` to
define the conversion in the trait’s `from` function, the `?` operator takes
care of calling the `from` function automatically.
-->
<p>Il y a une différence entre ce que fait l'expression <code>match</code> de l'encart 9-6 et
ce que fait l'opérateur <code>?</code> : les valeurs d'erreurs sur lesquelles est utilisé
l'opérateur <code>?</code> passent par la fonction <code>from</code>, définie dans le trait <code>From</code> de
la bibliothèque standard, qui est utilisée pour convertir les erreurs d'un type
à un autre. Lorsque l'opérateur <code>?</code> appelle la fonction <code>from</code>, le type d'erreur
reçu est converti dans le type d'erreur déclaré dans le type de retour de la
fonction concernée. C'est utile lorsqu'une fonction retourne un type d'erreur
qui peut couvrir tous les cas d'échec de la fonction, même si certaines de ses
parties peuvent échouer pour différentes raisons. À partir du moment qu'il y a
un <code>impl From&lt;AutreErreur&gt;</code> sur <code>ErreurRetournee</code> pour expliquer la conversion
dans la fonction <code>from</code> du trait, l'opérateur <code>?</code> se charge d'appeler la
fonction <code>from</code> automatiquement.</p>
<!--
In the context of Listing 9-7, the `?` at the end of the `File::open` call will
return the value inside an `Ok` to the variable `f`. If an error occurs, the
`?` operator will return early out of the whole function and give any `Err`
value to the calling code. The same thing applies to the `?` at the end of the
`read_to_string` call.
-->
<p>Dans le cas de l'encart 9-7, le <code>?</code> à la fin de l'appel à <code>File::open</code> va
retourner la valeur à l'intérieur d'un <code>Ok</code> à la variable <code>f</code>. Si une erreur se
produit, l'opérateur <code>?</code> va quitter prématurément la fonction et retourner une
valeur <code>Err</code> au code appelant. La même chose se produira au <code>?</code> à la fin de
l'appel à <code>read_to_string</code>.</p>
<!--
The `?` operator eliminates a lot of boilerplate and makes this function’s
implementation simpler. We could even shorten this code further by chaining
method calls immediately after the `?`, as shown in Listing 9-8.
-->
<p>L'opérateur <code>?</code> allège l'écriture de code et facilite l'implémentation de la
fonction. Nous pouvons même encore plus réduire ce code en enchaînant
immédiatement les appels aux méthodes après le <code>?</code> comme dans l'encart 9-8 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -- >
-->
<!--
```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();

    File::open("hello.txt")?.read_to_string(&mut s)?;

    Ok(s)
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn lire_pseudo_depuis_fichier() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-8: Chaining method calls after the `?`
operator</span>
-->
<p><span class="caption">Encart 9-8 : enchaînement des appels aux méthodes après
l'opérateur <code>?</code></span></p>
<!--
We’ve moved the creation of the new `String` in `s` to the beginning of the
function; that part hasn’t changed. Instead of creating a variable `f`, we’ve
chained the call to `read_to_string` directly onto the result of
`File::open("hello.txt")?`. We still have a `?` at the end of the
`read_to_string` call, and we still return an `Ok` value containing the
username in `s` when both `File::open` and `read_to_string` succeed rather than
returning errors. The functionality is again the same as in Listing 9-6 and
Listing 9-7; this is just a different, more ergonomic way to write it.
-->
<p>Nous avons déplacé la création de la nouvelle <code>String</code> dans <code>s</code> au début de la
fonction ; cette partie n'a pas changé. Au lieu de créer la variable <code>f</code>, nous
enchaînons directement l'appel à <code>read_to_string</code> sur le résultat de
<code>File::open(&quot;hello.txt&quot;)?</code>. Nous avons toujours le <code>?</code> à la fin de l'appel à
<code>read_to_string</code>, et nous retournons toujours une valeur <code>Ok</code> contenant le
pseudo dans <code>s</code> lorsque <code>File::open</code> et <code>read_to_string</code> réussissent toutes les
deux plutôt que de retourner des erreurs. Cette fonctionnalité est toujours la
même que dans l'encart 9-6 et l'encart 9-7 ; c'est juste une façon différente et
plus ergonomique de l'écrire.</p>
<!--
Speaking of different ways to write this function, Listing 9-9 shows that
there’s a way to make this even shorter.
-->
<p>En parlant de différentes façons d'écrire cette fonction, l'encart 9-9 nous
montre qu'il y a une façon d'écrire encore moins de code.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -- >
-->
<!--
```rust
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn lire_pseudo_depuis_fichier() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-9: Using `fs::read_to_string` instead of
opening and then reading the file</span>
-->
<p><span class="caption">Encart 9-9 : utilisation de <code>fs::read_to_string</code> plutôt
que d'ouvrir puis lire le fichier</span></p>
<!--
Reading a file into a string is a fairly common operation, so Rust provides the
convenient `fs::read_to_string` function that opens the file, creates a new
`String`, reads the contents of the file, puts the contents into that `String`,
and returns it. Of course, using `fs::read_to_string` doesn’t give us the
opportunity to explain all the error handling, so we did it the longer way
first.
-->
<p>Récupérer le contenu d'un fichier dans une <code>String</code> est une opération assez
courante, donc Rust fournit la fonction <code>fs::read_to_string</code> assez pratique, qui
ouvre le fichier, crée une nouvelle <code>String</code>, lit le contenu du fichier, insère
ce contenu dans cette <code>String</code>, et la retourne. Évidemment, l'utilisation de
<code>fs:read_to_string</code> ne nous offre pas l'occasion d'expliquer toute la gestion
des erreurs, donc nous avons d'abord utilisé la façon qui est plus longue.</p>
<!--
#### Where The `?` Operator Can Be Used
-->
<h4 id="où-lopérateur--peut-être-utilisé"><a class="header" href="#où-lopérateur--peut-être-utilisé">Où l'opérateur <code>?</code> peut être utilisé</a></h4>
<!--
The `?` operator can only be used in functions that have a return type
compatible with the value the `?` is used on. This is because the `?` operator
is defined to perform an early return of a value out of the function, in the
same manner as the `match` expression we defined in Listing 9-6 did. In Listing
9-6, the `match` was using a `Result` value, and the early return arm returned
an `Err(e)` value. The return type of the function has to be a `Result` to be
compatible with this `return`.
-->
<p>L'opérateur <code>?</code> ne peut être utilisé uniquement dans des fonctions qui ont un
type de retour compatible avec ce sur quoi le <code>?</code> est utilisé. C'est parceque
l'opérateur <code>?</code> est conçu pour retourner prématurémment une valeur de la
fonction, de la même manière que le faisait l'expression <code>match</code> que nous avons
défini dans l'encart 9-6. Dans l'encart 9-6, le <code>match</code> utilisait une valeur de
type <code>Result</code>, et la branche de retour prématuré retournait une valeur de type
<code>Err(e)</code>. Le type de retour de cette fonction doit être un <code>Result</code> pour être
compatible avec ce <code>return</code>.</p>
<!--
In Listing 9-10, let’s look at the error we’ll get if we use the `?` operator
in a `main` function with a return type of `()`:
-->
<p>Dans l'encart 9-10, découvrons l'erreur que nous allons obtenir si nous
utilisons l'opérateur <code>?</code> dans une fonction <code>main</code> qui a un type de retour
<code>()</code> :</p>
<!--
```rust,ignore,does_not_compile
use std::fs::File;

fn main() {
    let f = File::open("hello.txt")?;
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<!--
<span class="caption">Listing 9-10: Attempting to use the `?` in the `main`
function that returns `()` won’t compile</span>
-->
<p><span class="caption">Encart 9-10 : tentative d'utilisation du <code>?</code> dans la
fonction <code>main</code> qui retourne un <code>()</code>, qui ne devrait pas pouvoir se
compiler</span></p>
<!--
This code opens a file, which might fail. The `?` operator follows the `Result`
value returned by `File::open`, but this `main` function has the return type of
`()`, not `Result`. When we compile this code, we get the following error
message:
-->
<p>Ce code ouvre un fichier, ce qui devrait échouer. L'opérateur <code>?</code> est placée
derrière la valeur de type <code>Result</code> retournée par <code>File::open</code>, mais cette
fonction <code>main</code> a un type de retour <code>()</code> et non pas <code>Result</code>. Lorsque nous
compilons ce code, nous obtenons le message d'erreur suivant :</p>
<!--
```console
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
   -- > src/main.rs:4:36
    |
3   | / fn main() {
4   | |     let f = File::open("hello.txt")?;
    | |                                    ^ cannot use the `?` operator in a function that returns `()`
5   | | }
    | |_- this function should return `Result` or `Option` to accept `?`
    |
    = help: the trait `FromResidual<Result<Infallible, std::io::Error>>` is not implemented for `()`
note: required by `from_residual`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
   --&gt; src/main.rs:4:36
    |
3   | / fn main() {
4   | |     let f = File::open(&quot;hello.txt&quot;)?;
    | |                                    ^ cannot use the `?` operator in a function that returns `()`
5   | | }
    | |_- this function should return `Result` or `Option` to accept `?`
    |
    = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`
note: required by `from_residual`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` due to previous error
</code></pre>
<!--
This error points out that we’re only allowed to use the `?` operator in a
function that returns `Result`, `Option`, or another type that implements
`FromResidual`. To fix this error, you have two choices. One technique is to
change the return type of your function to be `Result<T, E>` if you have no
restrictions preventing that. The other technique is to use a `match` or one of
the `Result<T, E>` methods to handle the `Result<T, E>` in whatever way is
appropriate.
-->
<p>Cette erreur explique que nous sommes autorisés à utiliser l'opérateur <code>?</code>
uniquement dans une fonction qui retourne <code>Result</code>, <code>Option</code>, ou un autre type
qui implémente <code>FromResidual</code>. Pour corriger cette erreur, vous avez deux
choix. La première est de changer le type de retour de votre fonction en
<code>Result&lt;T, E&gt;</code> si vous pouvez le faire. L'autre solution est d'utiliser un
<code>match</code> ou une des méthodes de <code>Result&lt;T, E&gt;</code> pour gérer le <code>Result&lt;T, E&gt;</code> de
la manière la plus appropriée.</p>
<!--
The error message also mentioned that `?` can be used with `Option<T>` values
as well. As with using `?` on `Result`, you can only use `?` on `Option` in a
function that returns an `Option`. The behavior of the `?` operator when called
on an `Option<T>` is similar to its behavior when called on a `Result<T, E>`:
if the value is `None`, the `None` will be returned early from the function at
that point. If the value is `Some`, the value inside the `Some` is the
resulting value of the expression and the function continues. Listing 9-11 has
an example of a function that finds the last character of the first line in the
given text:
-->
<p>Le message d'erreur indique également que <code>?</code> peut aussi être utilisé avec des
valeurs de type <code>Option&lt;T&gt;</code>. Comme pour pouvoir utiliser <code>?</code> sur un <code>Result</code>,
vous devez utiliser <code>?</code> sur <code>Option</code> uniquement dans une fonction qui retourne
une <code>Option</code>. Le comportement de l'opérateur <code>?</code> sur une <code>Option&lt;T&gt;</code> est
identique au comportement sur un <code>Result&lt;T, E&gt;</code> : si la valeur est <code>None</code>, le
<code>None</code> sera retourné prématurémment à la fonction dans laquelle il est utilisé.
Si la valeur est <code>Some</code>, la valeur dans le <code>Some</code> sera la valeur résultante de
l'expression et la fonction continuera son déroulement. L'encart 9-11 est un
exemple de fonction qui trouve le dernier caractère de la première ligne dans
le texte qu'on lui fournit :</p>
<!--
```rust
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}
# 
# fn main() {
#     assert_eq!(
#         last_char_of_first_line("Hello, world\nHow are you today?"),
#         Some('d')
#     );
# 
#     assert_eq!(last_char_of_first_line(""), None);
#     assert_eq!(last_char_of_first_line("\nhi"), None);
# }
```
-->
<pre><pre class="playground"><code class="language-rust">fn dernier_caractere_de_la_premiere_ligne(texte: &amp;str) -&gt; Option&lt;char&gt; {
    texte.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        dernier_caractere_de_la_premiere_ligne(&quot;Et bonjour\nComment ca va, aujourd'hui ?&quot;),
</span><span class="boring">        Some('r')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(dernier_caractere_de_la_premiere_ligne(&quot;&quot;), None);
</span><span class="boring">    assert_eq!(dernier_caractere_de_la_premiere_ligne(&quot;\nsalut&quot;), None);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-11: Using the `?` operator on an `Option<T>`
value</span>
-->
<p><span class="caption">Encart 9-11 : utilisation de l'opérateur <code>?</code> sur une
valeur du type <code>Option&lt;T&gt;</code></span></p>
<!--
This function returns `Option<char>` because it might find a character at this
position, or there might be no character there. This code takes the `text`
string slice argument and calls the `lines` method on it, which returns an
iterator over the lines in the string. Because this function wants to examine
the first line, it calls `next` on the iterator to get the first value from the
iterator. If `text` is the empty string, this call to `next` will return
`None`, and here we can use `?` to stop and return `None` from
`last_char_of_first_line` if that is the case. If `text` is not the empty
string, `next` will return a `Some` value containing a string slice of the
first line in `text`.
-->
<p>Cette fonction retourne un type <code>Option&lt;char&gt;</code> car elle va peut-être trouver un
caractère à cet endroit, ou alors il n'y aura pas de caractère là-bas. Ce code
prends l'argument <code>texte</code> slice de chaîne de caractère et appelle sur elle la
méthode <code>lines</code>, qui retourne un itérateur des lignes dans la chaîne. Comme
cette fonction veut traiter la première ligne, elle appelle <code>next</code> sur
l'itérateur afin d'obtenir la première valeur de cet itérateur. Si <code>texte</code> est
une chaîne vide, cet appel à <code>next</code> va retourner <code>None</code>, et ici nous pouvons
utiliser <code>?</code> pour arrêter le déroulement de la fonction et retourner <code>None</code> si
c'est le cas. Si <code>texte</code> n'est pas une chaîne vide, <code>next</code> va retourner une
valeur de type <code>Some</code> contenant une slice de chaîne de caractères de la
première ligne de <code>texte</code>.</p>
<!--
The `?` extracts the string slice, and we can call `chars` on that string slice
to get an iterator of the characters in this string slice. We’re interested in
the last character in this first line, so we call `last` to return the last
item in the iterator over the characters. This is an `Option` because the first
line might be the empty string, if `text` starts with a blank line but has
characters on other lines, as in `"\nhi"`. However, if there is a last
character on the first line, it will be returned in the `Some` variant. The `?`
operator in the middle gives us a concise way to express this logic, and this
function can be implemented in one line. If we couldn’t use the `?` operator on
`Option`, we’d have to implement this logic using more method calls or a
`match` expression.
-->
<p>Le <code>?</code> extrait la slice de la chaîne de caractères, et nous pouvons ainsi
appeller <code>chars</code> sur cette slice de chaîne de caractères afin d'obtenir un
itérateur de caractères de cette slice de chaîne de caractères. Nous nous
intéressons au dernier caractère de cette première ligne, donc nous appelons
<code>last</code> pour retourner le dernier élément dans l'itérateur de caractères. C'est
une <code>Option</code> car la première ligne peut être une chaîne de caractères vide, si
<code>texte</code> commence par une ligne vide mais a des caractères sur les autres
lignes, comme par exemple <code>&quot;\nhi&quot;</code>. Cependant, si y a un caractère à la fin de
la première ligne, il sera retourné dans la variante <code>Some</code>. L'opérateur <code>?</code> au
millieu nous donne un moyen concret d'exprimer cette logique, et cette fonction
peut être implémentée en une ligne. Si nous n'aurions pas pu utiliser
l'opérateur <code>?</code> sur <code>Option</code>, nous aurions dû implémenter cette logique en
utilisant plus d'appels à des méthodes ou des expressions <code>match</code>.</p>
<!--
Note that you can use the `?` operator on a `Result` in a function that returns
`Result`, and you can use the `?` operator on an `Option` in a function that
returns `Option`, but you can’t mix and match. The `?` operator won’t
automatically convert a `Result` to an `Option` or vice versa; in those cases,
there are methods like the `ok` method on `Result` or the `ok_or` method on
`Option` that will do the conversion explicitly.
-->
<p>Notez bien que vous pouvez utiliser l'opérateur <code>?</code> sur un <code>Result</code> dans une
fonction qui retourne <code>Result</code>, et vous pouvez utiliser l'opérateur <code>?</code> sur une
<code>Option</code> dans une fonction qui retourne une <code>Option</code>, mais vous ne pouvez pas
mélanger les deux. L'opérateur <code>?</code> ne va pas convertir un <code>Result</code> en <code>Option</code>
et vice-versa ; dans ce cas, il a des méthodes comme la méthode <code>ok</code> sur
<code>Result</code> ou la méthode <code>ok_or</code> sur <code>Option</code> qui devrait explicitement faire la
conversion.</p>
<!--
So far, all the `main` functions we’ve used return `()`. The `main` function is
special because it’s the entry and exit point of executable programs, and there
are restrictions on what its return type can be for the programs to behave as
expected. Executables written in C return integers when they exit, and Rust
executables follow this convention as well: programs that exit successfully
return the integer `0`, and programs that error return some integer other than
`0`. When `main` returns `()`, Rust executables will return `0` if `main`
returns and a nonzero value if the program panics before reaching the end of
`main`.
-->
<p>Jusqu'ici, toutes les fonctions <code>main</code> que nous avons utilisé retournent <code>()</code>.
La fonction <code>main</code> est spéciale car c'est le point d'entrée et de sortie des
programmes exécutables, et il y a quelques limitations sur ce que peuvent être
le type de retour pour que les programmes se comportent correctement. Les
exécutables écris en C retournent des entiers lorsqu'ils se terminent, et les
exécutables écris en Rust suivent également cette convention : les programmes
qui se terminent avec succès retournent l'entier <code>0</code>, et les programmes qui
sont en erreur retournent un entier autre que <code>0</code>. Lorsque <code>main</code> retourne
<code>()</code>, les exécutables Rust vont retourner <code>0</code> si <code>main</code> retourne quelque chose
et une valeur différente de zéro si le programme panique avant d'atteindre la
fin du <code>main</code>.</p>
<!--
Another return type `main` can have is `Result<(), E>`. Listing 9-12 has the
code from Listing 9-10 but we’ve changed the return type of `main` to be
`Result<(), Box<dyn Error>>` and added a return value `Ok(())` to the end. This
code will now compile:
-->
<p>Un autre type de retour que le <code>main</code> puisse avoir est <code>Result&lt;(), E&gt;</code>.
L'encart 9-12 reprends le code de l'encart 9-10 mais nous avons changé le
type de retour du <code>main</code> pour être <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> et nous avons
ajouté la valeur de retour <code>Ok(())</code> à la fin. Ce code devrait maintenant
pouvoir se compiler :</p>
<!--
```rust,ignore
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let f = File::open("hello.txt")?;

    Ok(())
}
```
-->
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let f = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}
</code></pre>
<!--
<span class="caption">Listing 9-12: Changing `main` to return `Result<(), E>`
allows the use of the `?` operator on `Result` values</span>
-->
<p><span class="caption">Encart 9-12 : changement du <code>main</code> pour qu'elle retourne
un <code>Result&lt;(), E&gt;</code> permet d'utiliser l'opérateur <code>?</code> sur des valeurs de type
<code>Result</code></span></p>
<!--
The `Box<dyn Error>` type is called a trait object, which we’ll talk about in
the [“Using Trait Objects that Allow for Values of Different
Types”][trait-objects]<!-- ignore -- > section in Chapter 17. For now, you can
read `Box<dyn Error>` to mean “any kind of error.” Using `?` on a `Result`
value in a `main` function with this return type is allowed, because now an
`Err` value can be returned early. When a `main` function returns a `Result<(),
E>`, the executable will exit with a value of `0` if `main` returns `Ok(())`
and will exit with a nonzero value if `main` returns an `Err` value.
-->
<p>Le type <code>Box&lt;dyn Error&gt;</code> est ce qu'on appelle un objet trait, que nous verrons
dans une section du <a href="ch17-02-trait-objects.html">chapitre 17</a><!-- ignore -->. Pour l'instant,
vous pouvez interpréter <code>Box&lt;dyn Error&gt;</code> en “tout type d'erreur”. L'utilisation
de <code>?</code> sur une valeur type <code>Result</code> dans la fonction <code>main</code> avec ce type de
retour est donc permise, car maintenant une valeur type <code>Err</code> peut être
retournée prématurément. Lorsqu'une fonction <code>main</code> retourne un
<code>Result&lt;(), E&gt;</code>, l'exécutable va terminer son exécution avec une valeur de <code>0</code>
si le <code>main</code> retourne <code>Ok(())</code> et va se terminer avec une valeur différente de
zéro si <code>main</code> retourne une valeur <code>Err</code>.</p>
<!--
The types that `main` may return are those that implement [the
`std::process::Termination` trait][termination]<!-- ignore -- >. As of this
writing, the `Termination` trait is an unstable feature only available in
Nightly Rust, so you can’t yet implement it for your own types in Stable Rust,
but you might be able to someday!
-->
<p>Les types que <code>main</code> peut retourner sont ceux qui implémentent <a href="https://doc.rust-lang.org/std/process/trait.Termination.html">le trait
<code>std::process::Termination</code></a><!-- ignore -->. Au moment de
l'écriture de ces mots, le trait <code>Termination</code> est une fonctionnalité instable
seulement disponible avec la version expérimentale de Rust, donc vous ne pouvez
pas l'implémenter sur vos propres types avec la version stable de Rust, mais
vous pourrez peut-être le faire un jour !</p>
<!--
Now that we’ve discussed the details of calling `panic!` or returning `Result`,
let’s return to the topic of how to decide which is appropriate to use in which
cases.
-->
<p>Maintenant que nous avons vu les détails pour utiliser <code>panic!</code> ou retourner
<code>Result</code>, voyons maintenant comment choisir ce qu'il faut faire en fonction des
cas.</p>
<!--
[trait-objects]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[termination]: ../std/process/trait.Termination.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## To `panic!` or Not to `panic!`
-->
<h2 id="paniquer-ou-ne-pas-paniquer-telle-est-la-question"><a class="header" href="#paniquer-ou-ne-pas-paniquer-telle-est-la-question">Paniquer ou ne pas paniquer, telle est la question</a></h2>
<!--
So how do you decide when you should call `panic!` and when you should return
`Result`? When code panics, there’s no way to recover. You could call `panic!`
for any error situation, whether there’s a possible way to recover or not, but
then you’re making the decision on behalf of the code calling your code that a
situation is unrecoverable. When you choose to return a `Result` value, you
give the calling code options rather than making the decision for it. The
calling code could choose to attempt to recover in a way that’s appropriate for
its situation, or it could decide that an `Err` value in this case is
unrecoverable, so it can call `panic!` and turn your recoverable error into an
unrecoverable one. Therefore, returning `Result` is a good default choice when
you’re defining a function that might fail.
-->
<p>Comment décider si vous devez utiliser <code>panic!</code> ou si vous devez retourner un
<code>Result</code> ? Quand un code panique, il n'y a pas de moyen de récupérer la
situation. Vous pourriez utiliser <code>panic!</code> pour n'importe quelle situation
d'erreur, peu importe s'il est possible de récupérer la situation ou non, mais
vous prenez alors la décision de tout arrêter à la place du code qui appelle
votre code. Lorsque vous choisissez de retourner une valeur <code>Result</code>, vous
donnez plus de choix au code appelant plutôt que de prendre des décisions à sa
place. Le code appelant peut choisir d'essayer de récupérer l'erreur de manière
appropriée à la situation, ou il peut décider que dans ce cas une valeur <code>Err</code>
est irrécupérable, et va donc utiliser <code>panic!</code> et transformer votre erreur
récupérable en erreur irrécupérable. Ainsi, retourner <code>Result</code> est un bon choix
par défaut lorsque vous définissez une fonction qui peut échouer.</p>
<!--
In rare situations, it’s more appropriate to write code that panics instead of
returning a `Result`. Let’s explore why it’s appropriate to panic in examples,
prototype code, and tests. Then we’ll discuss situations in which the compiler
can’t tell that failure is impossible, but you as a human can. The chapter will
conclude with some general guidelines on how to decide whether to panic in
library code.
-->
<p>Dans certaines situations, il est plus approprié d'écrire du code qui panique
plutôt que de retourner un <code>Result</code>. Nous allons voir pourquoi il est approprié
de paniquer dans les exemples, les prototypes et les tests. Ensuite, nous
verrons des situations dans lesquelles vous savez en tant qu'humain qu'un
code ne peut pas échouer, mais que le compilateur ne peut pas le déduire par
lui-même. Puis nous allons conclure le chapitre par quelques lignes directrices
générales pour décider s'il faut paniquer dans le code d'une bibliothèque.</p>
<!--
### Examples, Prototype Code, and Tests
-->
<h3 id="les-exemples-les-prototypes-et-les-tests"><a class="header" href="#les-exemples-les-prototypes-et-les-tests">Les exemples, les prototypes et les tests</a></h3>
<!--
When you’re writing an example to illustrate some concept, having robust
error-handling code in the example as well can make the example less clear. In
examples, it’s understood that a call to a method like `unwrap` that could
panic is meant as a placeholder for the way you’d want your application to
handle errors, which can differ based on what the rest of your code is doing.
-->
<p>Lorsque vous écrivez un exemple pour illustrer un concept, avoir un code de
gestion des erreurs très résilient peut nuire à la clarté de l'exemple. Dans
les exemples, il est courant d'utiliser une méthode comme <code>unwrap</code> (qui peut
faire un panic) pour remplacer le code de gestion de l'erreur que vous
utiliseriez en temps normal dans votre application, et qui peut changer en
fonction de ce que le reste de votre code va faire.</p>
<!--
Similarly, the `unwrap` and `expect` methods are very handy when prototyping,
before you’re ready to decide how to handle errors. They leave clear markers in
your code for when you’re ready to make your program more robust.
-->
<p>De la même manière, les méthodes <code>unwrap</code> et <code>expect</code> sont très pratiques pour
coder des prototypes, avant même de décider comment gérer les erreurs. Ce sont
des indicateurs clairs dans votre code pour plus tard quand vous serez prêt à
rendre votre code plus résilient aux échecs.</p>
<!--
If a method call fails in a test, you’d want the whole test to fail, even if
that method isn’t the functionality under test. Because `panic!` is how a test
is marked as a failure, calling `unwrap` or `expect` is exactly what should
happen.
-->
<p>Si l'appel à une méthode échoue dans un test, nous voulons que tout le test
échoue, même si cette méthode n'est pas la fonctionnalité que nous testons.
Puisque c'est <code>panic!</code> qui indique qu'un test a échoué, utiliser <code>unwrap</code> ou
<code>expect</code> est exactement ce qu'il faut faire.</p>
<!--
### Cases in Which You Have More Information Than the Compiler
-->
<h3 id="les-cas-où-vous-avez-plus-dinformations-que-le-compilateur"><a class="header" href="#les-cas-où-vous-avez-plus-dinformations-que-le-compilateur">Les cas où vous avez plus d'informations que le compilateur</a></h3>
<!--
It would also be appropriate to call `unwrap` when you have some other logic
that ensures the `Result` will have an `Ok` value, but the logic isn’t
something the compiler understands. You’ll still have a `Result` value that you
need to handle: whatever operation you’re calling still has the possibility of
failing in general, even though it’s logically impossible in your particular
situation. If you can ensure by manually inspecting the code that you’ll never
have an `Err` variant, it’s perfectly acceptable to call `unwrap`. Here’s an
example:
-->
<p>Vous pouvez utiliser <code>unwrap</code> lorsque vous avez une certaine logique qui
garantit que le <code>Result</code> sera toujours une valeur <code>Ok</code>, mais que ce n'est pas le
genre de logique que le compilateur arrive à comprendre. Vous aurez quand même
une valeur <code>Result</code> à gérer : l'opération que vous utilisez peut échouer de
manière générale, même si dans votre cas c'est logiquement impossible. Si en
inspectant manuellement le code vous vous rendez compte que vous n'aurez jamais
une variante <code>Err</code>, vous pouvez tout à fait utiliser <code>unwrap</code>. Voici un
exemple :</p>
<!--
```rust
# fn main() {
    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1".parse().unwrap();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<!--
We’re creating an `IpAddr` instance by parsing a hardcoded string. We can see
that `127.0.0.1` is a valid IP address, so it’s acceptable to use `unwrap`
here. However, having a hardcoded, valid string doesn’t change the return type
of the `parse` method: we still get a `Result` value, and the compiler will
still make us handle the `Result` as if the `Err` variant is a possibility
because the compiler isn’t smart enough to see that this string is always a
valid IP address. If the IP address string came from a user rather than being
hardcoded into the program and therefore *did* have a possibility of failure,
we’d definitely want to handle the `Result` in a more robust way instead.
-->
<p>Nous créons une instance de <code>IpAddr</code> en interprétant une chaîne de caractères
codée en dur dans le code. Nous savons que <code>127.0.0.1</code> est une adresse IP
valide, donc il est acceptable d'utiliser <code>unwrap</code> ici. Toutefois, avoir une
chaîne de caractères valide et codée en dur ne change pas le type de retour de
la méthode <code>parse</code> : nous obtenons toujours une valeur de type <code>Result</code> et le
compilateur va nous demander de gérer le <code>Result</code> comme si on pouvait obtenir la
variante <code>Err</code>, car le compilateur n'est pas suffisamment intelligent pour
comprendre que cette chaîne de caractères est toujours une adresse IP valide. Si
le texte de l'adresse IP provient de l'utilisateur au lieu d'être codé en dur
dans le programme et donc qu'il y a désormais une possibilité d'erreur, alors
nous devrions vouloir gérer le <code>Result</code> d'une manière plus résiliente.</p>
<!--
### Guidelines for Error Handling
-->
<h3 id="recommandations-pour-gérer-les-erreurs"><a class="header" href="#recommandations-pour-gérer-les-erreurs">Recommandations pour gérer les erreurs</a></h3>
<!--
It’s advisable to have your code panic when it’s possible that your code
could end up in a bad state. In this context, a *bad state* is when some
assumption, guarantee, contract, or invariant has been broken, such as when
invalid values, contradictory values, or missing values are passed to your
code—plus one or more of the following:
-->
<p>Il est recommandé de faire paniquer votre code dès qu'il risque d'aboutir à un
état invalide. Dans ce contexte, un <em>état invalide</em> est lorsqu'un postulat, une
garantie, un contrat ou un invariant a été rompu, comme des valeurs invalides,
contradictoires ou manquantes qui sont fournies à votre code, ainsi qu'un ou
plusieurs des éléments suivants :</p>
<!--
* The bad state is something that is unexpected, as opposed to something that
  will likely happen occasionally, like a user entering data in the wrong
  format.
* Your code after this point needs to rely on not being in this bad state,
  rather than checking for the problem at every step.
* There’s not a good way to encode this information in the types you use. We’ll
  work through an example of what we mean in the [“Encoding States and Behavior
  as Types”][encoding]<!-- ignore -- > section of Chapter 17.
-->
<ul>
<li>L'état invalide est quelque chose qui est inattendu, contrairement à quelque
chose qui devrait arriver occasionnellement, comme par exemple un utilisateur
qui saisit une donnée dans un mauvais format.</li>
<li>Après cette instruction, votre code a besoin de ne pas être dans cet état
invalide, plutôt que d'avoir à vérifier le problème à chaque étape.</li>
<li>Il n'y a pas de bonne façon d'encoder cette information dans les types que
vous utilisez. Nous allons pratiquer ceci via un exemple dans <a href="ch17-03-oo-design-patterns.html">une section du
chapitre 17</a><!-- ignore -->.</li>
</ul>
<!--
If someone calls your code and passes in values that don’t make sense, the best
choice might be to call `panic!` and alert the person using your library to the
bug in their code so they can fix it during development. Similarly, `panic!` is
often appropriate if you’re calling external code that is out of your control
and it returns an invalid state that you have no way of fixing.
-->
<p>Si une personne utilise votre bibliothèque et lui fournit des valeurs qui n'ont
pas de sens, la meilleure des choses à faire est d'utiliser <code>panic!</code> et
d'avertir cette personne du bogue dans son code afin qu'elle le règle pendant la
phase de développement. De la même manière, <code>panic!</code> est parfois approprié si
vous appelez du code externe sur lequel vous n'avez pas la main, et qu'il
retourne un état invalide que vous ne pouvez pas corriger.</p>
<!--
However, when failure is expected, it’s more appropriate to return a `Result`
than to make a `panic!` call. Examples include a parser being given malformed
data or an HTTP request returning a status that indicates you have hit a rate
limit. In these cases, returning a `Result` indicates that failure is an
expected possibility that the calling code must decide how to handle.
-->
<p>Cependant, si l'on s'attend à rencontrer des échecs, il est plus approprié de
retourner un <code>Result</code> plutôt que de faire appel à <code>panic!</code>. Il peut s'agir par
exemple d'un interpréteur qui reçoit des données erronées, ou une requête HTTP
qui retourne un statut qui indique que vous avez atteint une limite de débit.
Dans ces cas-là, vous devriez indiquer qu'il est possible que cela puisse
échouer en retournant un <code>Result</code> afin que le code appelant puisse décider quoi
faire pour gérer le problème.</p>
<!--
When your code performs operations on values, your code should verify the
values are valid first and panic if the values aren’t valid. This is mostly for
safety reasons: attempting to operate on invalid data can expose your code to
vulnerabilities. This is the main reason the standard library will call
`panic!` if you attempt an out-of-bounds memory access: trying to access memory
that doesn’t belong to the current data structure is a common security problem.
Functions often have *contracts*: their behavior is only guaranteed if the
inputs meet particular requirements. Panicking when the contract is violated
makes sense because a contract violation always indicates a caller-side bug and
it’s not a kind of error you want the calling code to have to explicitly
handle. In fact, there’s no reasonable way for calling code to recover; the
calling *programmers* need to fix the code. Contracts for a function,
especially when a violation will cause a panic, should be explained in the API
documentation for the function.
-->
<p>Lorsque votre code effectue des opérations sur des valeurs, votre code devrait
d'abord vérifier que ces valeurs sont valides, et faire un panic si les valeurs
ne sont pas correctes. C'est essentiellement pour des raisons de sécurité :
tenter de travailler avec des données invalides peut exposer votre code à des
vulnérabilités. C'est la principale raison pour laquelle la bibliothèque
standard va appeler <code>panic!</code> si vous essayez d'accéder à la mémoire hors
limite : essayer d'accéder à de la mémoire qui n'appartient pas à la structure
de données actuelle est un problème de sécurité fréquent. Les fonctions ont
souvent des <em>contrats</em> : leur comportement est garanti uniquement si les données
d'entrée remplissent des conditions particulières. Paniquer lorsque le contrat
est violé est justifié, car une violation de contrat signifie toujours un bogue
du côté de l'appelant, et ce n'est pas le genre d'erreur que vous voulez que le
code appelant gère explicitement. En fait, il n'y a aucun moyen rationnel pour
que le code appelant se corrige : le <em>développeur</em> du code appelant doit
corriger le code. Les contrats d'une fonction, en particulier lorsqu'une
violation va causer un panic, doivent être expliqués dans la documentation de
l'API de ladite fonction.</p>
<!--
However, having lots of error checks in all of your functions would be verbose
and annoying. Fortunately, you can use Rust’s type system (and thus the type
checking the compiler does) to do many of the checks for you. If your function
has a particular type as a parameter, you can proceed with your code’s logic
knowing that the compiler has already ensured you have a valid value. For
example, if you have a type rather than an `Option`, your program expects to
have *something* rather than *nothing*. Your code then doesn’t have to handle
two cases for the `Some` and `None` variants: it will only have one case for
definitely having a value. Code trying to pass nothing to your function won’t
even compile, so your function doesn’t have to check for that case at runtime.
Another example is using an unsigned integer type such as `u32`, which ensures
the parameter is never negative.
-->
<p>Cependant, avoir beaucoup de vérifications d'erreurs dans toutes vos fonctions
serait verbeux et pénible. Heureusement, vous pouvez utiliser le système de
types de Rust (et donc la vérification de type que fait le compilateur) pour
assurer une partie des vérifications à votre place. Si votre fonction a un
paramètre d'un type précis, vous pouvez continuer à écrire votre code en sachant
que le compilateur s'est déjà assuré que vous avez une valeur valide. Par
exemple, si vous obtenez un type de valeur plutôt qu'une <code>Option</code>, votre
programme s'attend à obtenir <em>quelque chose</em> plutôt que <em>rien</em>. Votre code n'a
donc pas à gérer les deux cas de variantes <code>Some</code> et <code>None</code> : la seule
possibilité est qu'il y a une valeur. Du code qui essaye de ne rien fournir à
votre fonction ne compilera même pas, donc votre fonction n'a pas besoin de
vérifier ce cas-là lors de l'exécution. Un autre exemple est d'utiliser un type
d'entier non signé comme <code>u32</code>, qui garantit que le paramètre n'est jamais
strictement négatif.</p>
<!--
### Creating Custom Types for Validation
-->
<h3 id="créer-des-types-personnalisés-pour-la-vérification"><a class="header" href="#créer-des-types-personnalisés-pour-la-vérification">Créer des types personnalisés pour la vérification</a></h3>
<!--
Let’s take the idea of using Rust’s type system to ensure we have a valid value
one step further and look at creating a custom type for validation. Recall the
guessing game in Chapter 2 in which our code asked the user to guess a number
between 1 and 100. We never validated that the user’s guess was between those
numbers before checking it against our secret number; we only validated that
the guess was positive. In this case, the consequences were not very dire: our
output of “Too high” or “Too low” would still be correct. But it would be a
useful enhancement to guide the user toward valid guesses and have different
behavior when a user guesses a number that’s out of range versus when a user
types, for example, letters instead.
-->
<p>Allons plus loin dans l'idée d'utiliser le système de types de Rust pour
s'assurer d'avoir une valeur valide en créant un type personnalisé pour la
vérification. Souvenez-vous du jeu du plus ou du moins du chapitre 2 dans lequel
notre code demandait à l'utilisateur de deviner un nombre entre 1 et 100. Nous
n'avons jamais validé que le nombre saisi par l'utilisateur était entre ces
nombres avant de le comparer à notre nombre secret ; nous avons seulement
vérifié que le nombre était positif. Dans ce cas, les conséquences ne sont pas
très graves : notre résultat “C'est plus !” ou “C'est moins !” sera toujours
correct. Mais ce serait une amélioration utile pour aider l'utilisateur à faire
des suppositions valides et pour avoir un comportement différent selon qu'un
utilisateur propose un nombre en dehors des limites ou qu'il saisit, par
exemple, des lettres à la place.</p>
<!--
One way to do this would be to parse the guess as an `i32` instead of only a
`u32` to allow potentially negative numbers, and then add a check for the
number being in range, like so:
-->
<p>Une façon de faire cela serait de stocker le nombre saisi dans un <code>i32</code> plutôt
que dans un <code>u32</code> afin de permettre d'obtenir potentiellement des nombres
négatifs, et ensuite vérifier que le nombre est dans la plage autorisée, comme
ceci :</p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Devinez le nombre !");
# 
#     let nombre_secret = rand::thread_rng().gen_range(1..101);
# 
    loop {
        // -- partie masquée ici --

#         println!("Veuillez saisir un nombre.");
# 
#         let mut supposition = String::new();
# 
#         io::stdin()
#             .read_line(&mut supposition)
#             .expect("Échec de la lecture de la saisie");
# 
        let supposition: i32 = match supposition.trim().parse() {
            Ok(nombre) => nombre,
            Err(_) => continue,
        };

        if supposition < 1 || supposition > 100 {
            println!("Le nombre secret est entre 1 et 100.");
            continue;
        }

        match supposition.cmp(&nombre_secret) {
            // -- partie masquée ici --
#             Ordering::Less => println!("C'est plus !"),
#             Ordering::Greater => println!("C'est moins !"),
#             Ordering::Equal => {
#                 println!("Gagné !");
#                 break;
#             }
#         }
    }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span>    loop {
        // -- partie masquée ici --

<span class="boring">        println!(&quot;Veuillez saisir un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut supposition)
</span><span class="boring">            .expect(&quot;Échec de la lecture de la saisie&quot;);
</span><span class="boring">
</span>        let supposition: i32 = match supposition.trim().parse() {
            Ok(nombre) =&gt; nombre,
            Err(_) =&gt; continue,
        };

        if supposition &lt; 1 || supposition &gt; 100 {
            println!(&quot;Le nombre secret est entre 1 et 100.&quot;);
            continue;
        }

        match supposition.cmp(&amp;nombre_secret) {
            // -- partie masquée ici --
<span class="boring">            Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Gagné !&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}
</span></code></pre>
<!--
The `if` expression checks whether our value is out of range, tells the user
about the problem, and calls `continue` to start the next iteration of the loop
and ask for another guess. After the `if` expression, we can proceed with the
comparisons between `guess` and the secret number knowing that `guess` is
between 1 and 100.
-->
<p>L'expression <code>if</code> vérifie si la valeur est en dehors des limites et informe
l'utilisateur du problème le cas échéant, puis utilise <code>continue</code> pour passer à
la prochaine itération de la boucle et ainsi demander de saisir une nouvelle
supposition. Après l'expression <code>if</code>, nous pouvons continuer avec la comparaison
entre <code>supposition</code> et le nombre secret tout en sachant que <code>supposition</code> est
entre 1 et 100.</p>
<!--
However, this is not an ideal solution: if it was absolutely critical that the
program only operated on values between 1 and 100, and it had many functions
with this requirement, having a check like this in every function would be
tedious (and might impact performance).
-->
<p>Cependant, ce n'est pas une solution idéale : si c'était absolument critique
que le programme ne travaille qu'avec des valeurs entre 1 et 100 et qu'il aurait
de nombreuses fonctions qui reposent sur cette condition, cela pourrait être
fastidieux (et cela impacterait potentiellement la performance) de faire une
vérification comme celle-ci dans chacune de ces fonctions.</p>
<!--
Instead, we can make a new type and put the validations in a function to create
an instance of the type rather than repeating the validations everywhere. That
way, it’s safe for functions to use the new type in their signatures and
confidently use the values they receive. Listing 9-13 shows one way to define a
`Guess` type that will only create an instance of `Guess` if the `new` function
receives a value between 1 and 100.
-->
<p>À la place, nous pourrions construire un nouveau type et intégrer les
vérifications dans la fonction de création d'une instance de ce type plutôt que
de répéter partout les vérifications. Il est ainsi plus sûr pour les fonctions
d'utiliser ce nouveau type dans leurs signatures et d'utiliser avec confiance
les valeurs qu'elles reçoivent. L'encart 9-13 montre une façon de définir un
type <code>Supposition</code> qui ne créera une instance de <code>Supposition</code> que si la
fonction <code>new</code> reçoit une valeur entre 1 et 100 :</p>
<!--
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -- >
-->
<!--
```rust
pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 || valeur > 100 {
            panic!("Supposition valeur must be between 1 and 100, got {}.", valeur);
        }

        Supposition { valeur }
    }

    pub fn valeur(&self) -> i32 {
        self.valeur
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -&gt; Supposition {
        if valeur &lt; 1 || valeur &gt; 100 {
            panic!(&quot;Supposition valeur must be between 1 and 100, got {}.&quot;, valeur);
        }

        Supposition { valeur }
    }

    pub fn valeur(&amp;self) -&gt; i32 {
        self.valeur
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-13: A `Guess` type that will only continue with
values between 1 and 100</span>
-->
<p><span class="caption">Encart 9-13 : un type <code>Supposition</code> qui ne va continuer
que si la valeur est entre 1 et 100</span></p>
<!--
First, we define a struct named `Guess` that has a field named `value` that
holds an `i32`. This is where the number will be stored.
-->
<p>D'abord, nous définissons une structure qui s'appelle <code>Supposition</code> qui a un
champ <code>valeur</code> qui stocke un <code>i32</code>. C'est dans ce dernier que le nombre sera
stocké.</p>
<!--
Then we implement an associated function named `new` on `Guess` that creates
instances of `Guess` values. The `new` function is defined to have one
parameter named `value` of type `i32` and to return a `Guess`. The code in the
body of the `new` function tests `value` to make sure it’s between 1 and 100.
If `value` doesn’t pass this test, we make a `panic!` call, which will alert
the programmer who is writing the calling code that they have a bug they need
to fix, because creating a `Guess` with a `value` outside this range would
violate the contract that `Guess::new` is relying on. The conditions in which
`Guess::new` might panic should be discussed in its public-facing API
documentation; we’ll cover documentation conventions indicating the possibility
of a `panic!` in the API documentation that you create in Chapter 14. If
`value` does pass the test, we create a new `Guess` with its `value` field set
to the `value` parameter and return the `Guess`.
-->
<p>Ensuite, nous implémentons une fonction associée <code>new</code> sur <code>Supposition</code> qui
crée des instances de <code>Supposition</code>. La fonction <code>new</code> est conçue pour recevoir
un paramètre <code>valeur</code> de type <code>i32</code> et retourner une <code>Supposition</code>. Le code dans
le corps de la fonction <code>new</code> teste <code>valeur</code> pour s'assurer qu'elle est bien
entre 1 et 100. Si <code>valeur</code> échoue à ce test, nous faisons appel à <code>panic!</code>, qui
alertera le développeur qui écrit le code appelant qu'il a un bogue qu'il doit
régler, car créer une <code>Supposition</code> avec <code>valeur</code> en dehors de cette plage va
violer le contrat sur lequel s'appuie <code>Supposition::new</code>. Les conditions dans
lesquelles <code>Supposition::new</code> va paniquer devraient être expliquées dans la
documentation publique de l'API ; nous verrons les conventions pour indiquer
l'éventualité d'un <code>panic!</code> dans la documentation de l'API que vous créerez
au chapitre 14. Si <code>valeur</code> passe le test, nous créons une nouvelle
<code>Supposition</code> avec son champ <code>valeur</code> qui prend la valeur du paramètre <code>valeur</code>
et retourne cette <code>Supposition</code>.</p>
<!--
Next, we implement a method named `value` that borrows `self`, doesn’t have any
other parameters, and returns an `i32`. This kind of method is sometimes called
a *getter*, because its purpose is to get some data from its fields and return
it. This public method is necessary because the `value` field of the `Guess`
struct is private. It’s important that the `value` field be private so code
using the `Guess` struct is not allowed to set `value` directly: code outside
the module *must* use the `Guess::new` function to create an instance of
`Guess`, thereby ensuring there’s no way for a `Guess` to have a `value` that
hasn’t been checked by the conditions in the `Guess::new` function.
-->
<p>Enfin, nous implémentons une méthode <code>valeur</code> qui emprunte <code>self</code>, n'a aucun
autre paramètre, et retourne un <code>i32</code>. Ce genre de méthode est parfois appelé un
<em>accesseur</em>, car son rôle est d'accéder aux données des champs et de les
retourner. Cette méthode publique est nécessaire car le champ <code>valeur</code> de la
structure <code>Supposition</code> est privé. Il est important que le champ <code>valeur</code> soit
privé pour que le code qui utilise la structure <code>Supposition</code> ne puisse pas
directement assigner une valeur à <code>valeur</code> : le code en dehors du module <em>doit</em>
utiliser la fonction <code>Supposition::new</code> pour créer une instance de
<code>Supposition</code>, ce qui permet d'empêcher la création d'une <code>Supposition</code> avec un
champ <code>valeur</code> qui n'a pas été vérifié par les conditions dans la fonction
<code>Supposition:new</code>.</p>
<!--
A function that has a parameter or returns only numbers between 1 and 100 could
then declare in its signature that it takes or returns a `Guess` rather than an
`i32` and wouldn’t need to do any additional checks in its body.
-->
<p>Une fonction qui prend en paramètre ou qui retourne des nombres uniquement entre
1 et 100 peut ensuite déclarer dans sa signature qu'elle prend en paramètre ou
qu'elle retourne une <code>Supposition</code> plutôt qu'un <code>i32</code> et n'aura pas besoin de
faire de vérifications supplémentaires dans son corps.</p>
<!--
## Summary
-->
<h2 id="résumé-8"><a class="header" href="#résumé-8">Résumé</a></h2>
<!--
Rust’s error handling features are designed to help you write more robust code.
The `panic!` macro signals that your program is in a state it can’t handle and
lets you tell the process to stop instead of trying to proceed with invalid or
incorrect values. The `Result` enum uses Rust’s type system to indicate that
operations might fail in a way that your code could recover from. You can use
`Result` to tell code that calls your code that it needs to handle potential
success or failure as well. Using `panic!` and `Result` in the appropriate
situations will make your code more reliable in the face of inevitable problems.
-->
<p>Les fonctionnalités de gestion d'erreurs de Rust sont conçues pour vous aider à
écrire du code plus résilient. La macro <code>panic!</code> signale que votre programme
est dans un état qu'il ne peut pas gérer et vous permet de dire au processus de
s'arrêter au lieu d'essayer de continuer avec des valeurs invalides ou
incorrectes. L'énumération <code>Result</code> utilise le système de types de Rust pour
signaler que des opérations peuvent échouer de telle façon que votre code puisse
rattraper l'erreur. Vous pouvez utiliser <code>Result</code> pour dire au code qui appelle
votre code qu'il a besoin de gérer le résultat et aussi les potentielles
erreurs. Utiliser <code>panic!</code> et <code>Result</code> de manière appropriée rendra votre code
plus fiable face à des problèmes inévitables.</p>
<!--
Now that you’ve seen useful ways that the standard library uses generics with
the `Option` and `Result` enums, we’ll talk about how generics work and how you
can use them in your code.
-->
<p>Maintenant que vous avez vu la façon dont la bibliothèque standard tire parti de
la généricité avec les énumérations <code>Option</code> et <code>Result</code>, nous allons voir
comment la généricité fonctionne et comment vous pouvez l'utiliser dans votre code.</p>
<!--
[encoding]: ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Generic Types, Traits, and Lifetimes
-->
<h1 id="les-types-génériques-les-traits-et-les-durées-de-vie"><a class="header" href="#les-types-génériques-les-traits-et-les-durées-de-vie">Les types génériques, les traits et les durées de vie</a></h1>
<!--
Every programming language has tools for effectively handling the duplication
of concepts. In Rust, one such tool is *generics*. Generics are abstract
stand-ins for concrete types or other properties. When we’re writing code, we
can express the behavior of generics or how they relate to other generics
without knowing what will be in their place when compiling and running the code.
-->
<p>Tous les langages de programmation ont des outils pour gérer la duplication des
concepts. En Rust, un de ces outils est la <em>généricité</em>. La généricité permet
de remplacer des types concrets ou d'autres propriétés par des paramètres
abstraits appelés <em>génériques</em>. Lorsque nous écrivons du code, nous pouvons
exprimer le comportement des génériques, ou comment ils interagissent avec
d'autres génériques, sans savoir ce qu'il y aura à leur place lors de la
compilation et de l'exécution du code.</p>
<!--
Similar to the way a function takes parameters with unknown values to run the
same code on multiple concrete values, functions can take parameters of some
generic type instead of a concrete type, like `i32` or `String`. In fact, we’ve
already used generics in Chapter 6 with `Option<T>`, Chapter 8 with `Vec<T>`
and `HashMap<K, V>`, and Chapter 9 with `Result<T, E>`. In this chapter, you’ll
explore how to define your own types, functions, and methods with generics!
-->
<p>De la même manière qu'une fonction prend des paramètres avec des valeurs
inconnues pour exécuter le même code sur plusieurs valeurs concrètes, les
fonctions peuvent prendre des paramètres d'un type générique plutôt que d'un
type concret comme <code>i32</code> ou <code>String</code>. En fait, nous avons déjà utilisé des types
génériques au chapitre 6 avec <code>Option&lt;T&gt;</code>, au chapitre 8 avec <code>Vec&lt;T&gt;</code> et
<code>HashMap&lt;K, V&gt;</code>, et au chapitre 9 avec <code>Result&lt;T, E&gt;</code>. Dans ce chapitre, nous
allons voir comment définir nos propres types, fonctions et méthodes utilisant
des types génériques !</p>
<!--
First, we’ll review how to extract a function to reduce code duplication. Next,
we’ll use the same technique to make a generic function from two functions that
differ only in the types of their parameters. We’ll also explain how to use
generic types in struct and enum definitions.
-->
<p>Pour commencer, nous allons examiner comment construire une fonction pour
réduire la duplication de code. Ensuite, nous utiliserons la même technique pour
construire une fonction générique à partir de deux fonctions qui se distinguent
uniquement par le type de leurs paramètres. Nous expliquerons aussi comment
utiliser les types génériques dans les définitions de structures et
d'énumérations.</p>
<!--
Then you’ll learn how to use *traits* to define behavior in a generic way. You
can combine traits with generic types to constrain a generic type to only
those types that have a particular behavior, as opposed to just any type.
-->
<p>Ensuite, vous apprendrez comment utiliser les <em>traits</em> pour définir un
comportement de manière générique. Vous pouvez combiner les traits avec des
types génériques pour contraindre un type générique uniquement à des types qui
ont un comportement particulier, et non pas accepter n'importe quel type.</p>
<!--
Finally, we’ll discuss *lifetimes*, a variety of generics that give the
compiler information about how references relate to each other. Lifetimes allow
us to borrow values in many situations while still enabling the compiler to
check that the references are valid.
-->
<p>Enfin, nous verrons les <em>durées de vie</em>, un genre de générique qui indique au
compilateur comment les références s'articulent entre elles. Les durées de vie
nous permettent d'emprunter des valeurs dans différentes situations tout en
donnant les éléments au compilateur pour vérifier que les références sont
toujours valides.</p>
<!--
## Removing Duplication by Extracting a Function
-->
<h2 id="supprimer-les-doublons-en-construisant-une-fonction"><a class="header" href="#supprimer-les-doublons-en-construisant-une-fonction">Supprimer les doublons en construisant une fonction</a></h2>
<!--
Before diving into generics syntax, let’s first look at how to remove
duplication that doesn’t involve generic types by extracting a function. Then
we’ll apply this technique to extract a generic function! In the same way that
you recognize duplicated code to extract into a function, you’ll start to
recognize duplicated code that can use generics.
-->
<p>Avant de plonger dans la syntaxe des génériques, nous allons regarder comment
supprimer les doublons, sans utiliser de types génériques, en construisant une
fonction. Ensuite, nous allons appliquer cette technique pour construire une
fonction générique ! De la même manière que vous détectez du code dupliqué pour
l'extraire dans une fonction, vous allez commencer à reconnaître du code
dupliqué qui peut utiliser la généricité.</p>
<!--
Consider a short program that finds the largest number in a list, as shown in
Listing 10-1.
-->
<p>Imaginons un petit programme qui trouve le nombre le plus grand dans une liste,
comme dans l'encart 10-1.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier: src/main.rs</span></p>
<!--
```rust
fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let mut le_plus_grand = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre > le_plus_grand {
            le_plus_grand = nombre;
        }
    }

    println!("Le nombre le plus grand est {}", le_plus_grand);
#     assert_eq!(le_plus_grand, 100);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let mut le_plus_grand = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre &gt; le_plus_grand {
            le_plus_grand = nombre;
        }
    }

    println!(&quot;Le nombre le plus grand est {}&quot;, le_plus_grand);
<span class="boring">    assert_eq!(le_plus_grand, 100);
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 10-1: Code to find the largest number in a list
of numbers</span>
-->
<p><span class="caption">Encart 10-1 : le code pour trouver le nombre le plus grand
dans une liste de nombres</span></p>
<!--
This code stores a list of integers in the variable `number_list` and places
the first number in the list in a variable named `largest`. Then it iterates
through all the numbers in the list, and if the current number is greater than
the number stored in `largest`, it replaces the number in that variable.
However, if the current number is less than or equal to the largest number seen
so far, the variable doesn’t change, and the code moves on to the next number
in the list. After considering all the numbers in the list, `largest` should
hold the largest number, which in this case is 100.
-->
<p>Ce code stocke une liste de nombres entiers dans la variable <code>liste_de_nombres</code>
et place le premier nombre de la liste dans une variable qui s'appelle
<code>le_plus_grand</code>. Ensuite, il parcourt tous les nombres dans la liste, et si le
nombre courant est plus grand que le nombre stocké dans <code>le_plus_grand</code>, il
remplace le nombre dans cette variable. Cependant, si le nombre courant est
plus petit ou égal au nombre le plus grand trouvé précédemment, la variable ne
change pas, et le code passe au nombre suivant de la liste. Après avoir parcouru
tous les nombres de la liste, <code>le_plus_grand</code> devrait stocker le plus grand
nombre, qui est 100 dans notre cas.</p>
<!--
To find the largest number in two different lists of numbers, we can duplicate
the code in Listing 10-1 and use the same logic at two different places in the
program, as shown in Listing 10-2.
-->
<p>Pour trouver le nombre le plus grand dans deux listes de nombres différentes,
nous pourrions dupliquer le code de l'encart 10-1 et suivre la même logique à
deux endroits différents du programme, comme dans l'encart 10-2.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let mut le_plus_grand = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre > le_plus_grand {
            le_plus_grand = nombre;
        }
    }

    println!("Le nombre le plus grand est {}", le_plus_grand);

    let liste_de_nombres = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut le_plus_grand = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre > le_plus_grand {
            le_plus_grand = nombre;
        }
    }

    println!("Le nombre le plus grand est {}", le_plus_grand);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let mut le_plus_grand = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre &gt; le_plus_grand {
            le_plus_grand = nombre;
        }
    }

    println!(&quot;Le nombre le plus grand est {}&quot;, le_plus_grand);

    let liste_de_nombres = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut le_plus_grand = liste_de_nombres[0];

    for nombre in liste_de_nombres {
        if nombre &gt; le_plus_grand {
            le_plus_grand = nombre;
        }
    }

    println!(&quot;Le nombre le plus grand est {}&quot;, le_plus_grand);
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-2: Code to find the largest number in *two*
lists of numbers</span>
-->
<p><span class="caption">Encart 10-2 : le code pour trouver le plus grand nombre
dans <em>deux</em> listes de nombres</span></p>
<!--
Although this code works, duplicating code is tedious and error prone. We also
have to update the code in multiple places when we want to change it.
-->
<p>Bien que ce code fonctionne, la duplication de code est fastidieuse et source
d'erreurs. Nous devons aussi mettre à jour le code à plusieurs endroits si nous
souhaitons le modifier.</p>
<!--
To eliminate this duplication, we can create an abstraction by defining a
function that operates on any list of integers given to it in a parameter. This
solution makes our code clearer and lets us express the concept of finding the
largest number in a list abstractly.
-->
<p>Pour éviter cette duplication, nous pouvons créer un niveau d'abstraction en
définissant une fonction qui travaille avec n'importe quelle liste de nombres
entiers qu'on lui donne en paramètre. Cette solution rend notre code plus clair
et nous permet d'exprimer le concept de trouver le nombre le plus grand dans une
liste de manière abstraite.</p>
<!--
In Listing 10-3, we extracted the code that finds the largest number into a
function named `largest`. Unlike the code in Listing 10-1, which can find the
largest number in only one particular list, this program can find the largest
number in two different lists.
-->
<p>Dans l'encart 10-3, nous avons extrait le code qui trouve le nombre le plus
grand dans une fonction qui s'appelle <code>le_plus_grand</code>. Contrairement au code de
l'encart 10-1, qui pouvait trouver le nombre le plus grand dans une seule liste
en particulier, ce programme peut trouver le nombre le plus grand dans deux
listes différentes.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn le_plus_grand(liste: &[i32]) -> i32 {
    let mut le_plus_grand = liste[0];

    for &element in liste {
        if element > le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand(&liste_de_nombres);
    println!("Le nombre le plus grand est {}", resultat);
#     assert_eq!(resultat, 100);

    let liste_de_nombres = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let resultat = le_plus_grand(&liste_de_nombres);
    println!("Le nombre le plus grand est {}", resultat);
#     assert_eq!(resultat, 6000);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn le_plus_grand(liste: &amp;[i32]) -&gt; i32 {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand(&amp;liste_de_nombres);
    println!(&quot;Le nombre le plus grand est {}&quot;, resultat);
<span class="boring">    assert_eq!(resultat, 100);
</span>
    let liste_de_nombres = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let resultat = le_plus_grand(&amp;liste_de_nombres);
    println!(&quot;Le nombre le plus grand est {}&quot;, resultat);
<span class="boring">    assert_eq!(resultat, 6000);
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 10-3: Abstracted code to find the largest number
in two lists</span>
-->
<p><span class="caption">Encart 10-3 : du code abstrait qui trouve le plus grand
nombre dans deux listes</span></p>
<!--
The `largest` function has a parameter called `list`, which represents any
concrete slice of `i32` values that we might pass into the function. As a
result, when we call the function, the code runs on the specific values that we
pass in. Don’t worry about the syntax of the `for` loop for now. We aren’t
referencing a reference to an `i32` here; we’re pattern matching and
destructuring each `&i32` that the `for` loop gets so that `item` will be an
`i32` inside the loop body. We’ll cover pattern matching in detail in [Chapter
18][ch18]<!-- ignore -- >.
-->
<p>La fonction <code>le_plus_grand</code> a un paramètre qui s'appelle <code>liste</code>, qui représente
n'importe quelle slice concrète de valeurs <code>i32</code> que nous pouvons passer à la
fonction. Au final, lorsque nous appelons la fonction, le code s'exécute sur les
valeurs précises que nous lui avons fournies. Mais ne nous préoccupons pas de
la syntaxe de la boucle <code>for</code> pour l'instant. Ici, nous n'utilisons pas une
référence vers un <code>i32</code>, nous destructurons via le filtrage par motif chaque
<code>&amp;i32</code> afin que la boucle <code>for</code> utilise cet <code>element</code> en tant que <code>i32</code> dans le
corps de la boucle. Nous parlerons plus en détails du filtrage par motif au
<a href="ch18-00-patterns.html">chapitre 18</a><!-- ignore -->.</p>
<!--
In sum, here are the steps we took to change the code from Listing 10-2 to
Listing 10-3:
-->
<p>En résumé, voici les étapes que nous avons suivies pour changer le code de
l'encart 10-2 pour obtenir celui de l'encart 10-3 :</p>
<!--
1. Identify duplicate code.
2. Extract the duplicate code into the body of the function and specify the
   inputs and return values of that code in the function signature.
3. Update the two instances of duplicated code to call the function instead.
-->
<ol>
<li>Identification du code dupliqué.</li>
<li>Extraction du code dupliqué dans le corps de la fonction et ajout de
précisions sur les entrées et les valeurs de retour de ce code dans la
signature de la fonction.</li>
<li>Remplacement des deux instances du code dupliqué par des appels à la
fonction.</li>
</ol>
<!--
Next, we’ll use these same steps with generics to reduce code duplication in
different ways. In the same way that the function body can operate on an
abstract `list` instead of specific values, generics allow code to operate on
abstract types.
-->
<p>Ensuite, nous allons utiliser les mêmes étapes avec la généricité pour réduire
la duplication de code de différentes façons. De la même manière que le corps
d'une fonction peut opérer sur une <code>liste</code> abstraite plutôt que sur des valeurs
spécifiques, la généricité permet de travailler sur des types abstraits.</p>
<!--
For example, say we had two functions: one that finds the largest item in a
slice of `i32` values and one that finds the largest item in a slice of `char`
values. How would we eliminate that duplication? Let’s find out!
-->
<p>Par exemple, imaginons que nous ayons deux fonctions : une qui trouve l'élément
le plus grand dans une slice de valeurs <code>i32</code> et une qui trouve l'élément le
plus grand dans une slice de valeurs <code>char</code>. Comment pourrions-nous éviter la
duplication ? Voyons cela dès maintenant !</p>
<!--
[ch18]: ch18-00-patterns.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Generic Data Types
-->
<h2 id="les-types-de-données-génériques"><a class="header" href="#les-types-de-données-génériques">Les types de données génériques</a></h2>
<!--
We can use generics to create definitions for items like function signatures or
structs, which we can then use with many different concrete data types. Let’s
first look at how to define functions, structs, enums, and methods using
generics. Then we’ll discuss how generics affect code performance.
-->
<p>Nous pouvons utiliser la généricité pour créer des définitions pour des éléments
comme les signatures de fonctions ou les structures, que nous pouvons ensuite
utiliser sur de nombreux types de données concrets. Commençons par regarder
comment définir des fonctions, des structures, des énumérations, et des méthodes
en utilisant la généricité. Ensuite nous verrons comment la généricité impacte
la performance du code.</p>
<!--
### In Function Definitions
-->
<h3 id="dans-la-définition-dune-fonction"><a class="header" href="#dans-la-définition-dune-fonction">Dans la définition d'une fonction</a></h3>
<!--
When defining a function that uses generics, we place the generics in the
signature of the function where we would usually specify the data types of the
parameters and return value. Doing so makes our code more flexible and provides
more functionality to callers of our function while preventing code duplication.
-->
<p>Lorsque nous définissons une fonction en utilisant la généricité, nous utilisons
des types génériques dans la signature de la fonction là où nous précisons
habituellement
les types de données des paramètres et de la valeur de retour. Faire ainsi rend
notre code plus flexible et apporte plus de fonctionnalités au code appelant
notre fonction, tout en évitant la duplication de code.</p>
<!--
Continuing with our `largest` function, Listing 10-4 shows two functions that
both find the largest value in a slice.
-->
<p>Pour continuer avec notre fonction <code>le_plus_grand</code>, l'encart 10-4 nous montre
deux fonctions qui trouvent toutes les deux la valeur la plus grande dans une
slice.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn largest_i32(list: &[i32]) -> i32 {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &[char]) -> char {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&number_list);
    println!("The largest number is {}", result);
#     assert_eq!(result, 100);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&char_list);
    println!("The largest char is {}", result);
#     assert_eq!(result, 'y');
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn le_plus_grand_i32(liste: &amp;[i32]) -&gt; i32 {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste.iter() {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn le_plus_grand_caractere(liste: &amp;[char]) -&gt; char {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste.iter() {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand_i32(&amp;liste_de_nombres);
    println!(&quot;Le plus grand nombre est {}&quot;, resultat);
<span class="boring">    assert_eq!(resultat, 100);
</span>
    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];

    let resultat = le_plus_grand_caractere(&amp;liste_de_caracteres);
    println!(&quot;Le plus grand caractère est {}&quot;, resultat);
<span class="boring">    assert_eq!(resultat, 'y');
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 10-4: Two functions that differ only in their
names and the types in their signatures</span>
-->
<p><span class="caption">Encart 10-4 : deux fonctions qui se distinguent seulement
par leur nom et le type dans leur signature</span></p>
<!--
The `largest_i32` function is the one we extracted in Listing 10-3 that finds
the largest `i32` in a slice. The `largest_char` function finds the largest
`char` in a slice. The function bodies have the same code, so let’s eliminate
the duplication by introducing a generic type parameter in a single function.
-->
<p>La fonction <code>le_plus_grand_i32</code> est celle que nous avons construite à l'encart 10-3
lorsqu'elle trouvait le plus grand <code>i32</code> dans une slice. La fonction
<code>le_plus_grand_caractere</code> recherche le plus grand <code>char</code> dans une slice. Les
corps des fonctions ont le même code, donc essayons d'éviter cette duplication
en utilisant un paramètre de type générique dans une seule et unique fonction.</p>
<!--
To parameterize the types in the new function we’ll define, we need to name the
type parameter, just as we do for the value parameters to a function. You can
use any identifier as a type parameter name. But we’ll use `T` because, by
convention, parameter names in Rust are short, often just a letter, and Rust’s
type-naming convention is CamelCase. Short for “type,” `T` is the default
choice of most Rust programmers.
-->
<p>Pour paramétrer les types dans la nouvelle fonction que nous allons définir,
nous avons besoin de donner un nom au paramètre de type, comme nous l'avons
fait pour les paramètres de valeur des fonctions. Vous pouvez utiliser
n'importe quel identificateur pour nommer le paramètre de type. Mais ici nous allons
utiliser <code>T</code> car, par convention, les noms de paramètres en Rust sont courts,
souvent même une seule lettre, et la convention de nommage des types en Rust est
d'utiliser le CamelCase. Et puisque la version courte de “type” est <code>T</code>, c'est
le choix par défaut de nombreux développeurs Rust.</p>
<!--
When we use a parameter in the body of the function, we have to declare the
parameter name in the signature so the compiler knows what that name means.
Similarly, when we use a type parameter name in a function signature, we have
to declare the type parameter name before we use it. To define the generic
`largest` function, place type name declarations inside angle brackets, `<>`,
between the name of the function and the parameter list, like this:
-->
<p>Lorsqu'on utilise un paramètre dans le corps de la fonction, nous devons
déclarer le nom du paramètre dans la signature afin que le compilateur puisse
savoir à quoi réfère ce nom. De la même manière, lorsqu'on utilise un nom de
paramètre de type dans la signature d'une fonction, nous devons déclarer le nom
du paramètre de type avant de pouvoir l'utiliser. Pour déclarer la fonction
générique <code>le_plus_grand</code>, il faut placer la déclaration du nom du type entre
des chevrons <code>&lt;&gt;</code>, le tout entre le nom de la fonction et la liste des
paramètres, comme ceci :</p>
<!--
```rust,ignore
fn largest<T>(list: &[T]) -> T {
```
-->
<pre><code class="language-rust ignore">fn le_plus_grand&lt;T&gt;(liste: &amp;[T]) -&gt; &amp;T {
</code></pre>
<!--
We read this definition as: the function `largest` is generic over some type
`T`. This function has one parameter named `list`, which is a slice of values
of type `T`. The `largest` function will return a value of the
same type `T`.
-->
<p>Cette définition se lit comme ceci : la fonction <code>le_plus_grand</code> est générique
en fonction du type <code>T</code>. Cette fonction a un paramètre qui s'appelle <code>liste</code>,
qui est une slice de valeurs de type <code>T</code>. Cette fonction <code>le_plus_grand</code> va
retourner une référence vers la valeur du même type <code>T</code>.</p>
<!--
Listing 10-5 shows the combined `largest` function definition using the generic
data type in its signature. The listing also shows how we can call the function
with either a slice of `i32` values or `char` values. Note that this code won’t
compile yet, but we’ll fix it later in this chapter.
-->
<p>L'encart 10-5 nous montre la combinaison de la définition de la fonction
<code>le_plus_grand</code> avec le type de données générique présent dans sa signature.
L'encart montre aussi que nous pouvons appeler la fonction avec une slice soit
de valeurs <code>i32</code>, soit de valeurs <code>char</code>. Notez que ce code ne se compile pas
encore, mais nous allons y remédier plus tard dans ce chapitre.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn le_plus_grand&lt;T&gt;(liste: &amp;[T]) -&gt; T {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand(&amp;liste_de_nombres);
    println!(&quot;Le nombre le plus grand est {}&quot;, resultat);

    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];

    let resultat = le_plus_grand(&amp;liste_de_caracteres);
    println!(&quot;Le plus grand caractère est {}&quot;, resultat);
}
</code></pre>
<!--
<span class="caption">Listing 10-5: A definition of the `largest` function that
uses generic type parameters but doesn’t compile yet</span>
-->
<p><span class="caption">Encart 10-5 : une définition de la fonction
<code>le_plus_grand</code> qui utilise des paramètres de type génériques, mais qui ne
compile pas encore</span></p>
<!--
If we compile this code right now, we’ll get this error:
-->
<p>Si nous essayons de compiler ce code dès maintenant, nous aurons l'erreur
suivante :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 -- > src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if element &gt; le_plus_grand {
  |            ------- ^ ------------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn le_plus_grand&lt;T: std::cmp::PartialOrd&gt;(liste: &amp;[T]) -&gt; T {
  |                  ^^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
<!--
The note mentions `std::cmp::PartialOrd`, which is a *trait*. We’ll talk about
traits in the next section. For now, this error states that the body of
`largest` won’t work for all possible types that `T` could be. Because we want
to compare values of type `T` in the body, we can only use types whose values
can be ordered. To enable comparisons, the standard library has the
`std::cmp::PartialOrd` trait that you can implement on types (see Appendix C
for more on this trait). You’ll learn how to specify that a generic type has a
particular trait in the [“Traits as Parameters”][traits-as-parameters]<!--
ignore -- > section, but let’s first explore other ways of using generic type
parameters.
-->
<p>La note cite <code>std::cmp::PartialOrd</code>, qui est un <em>trait</em>. Nous allons voir les
traits dans la prochaine section. Pour le moment, cette erreur nous informe que
le corps de <code>le_plus_grand</code> ne va pas fonctionner pour tous les types possibles
que <code>T</code> peut représenter. Comme nous voulons comparer des valeurs de type <code>T</code>
dans le corps, nous pouvons utiliser uniquement des types dont les valeurs
peuvent être triées dans l'ordre. Pour effectuer des comparaisons, la bibliothèque
standard propose le trait <code>std::cmp::PartialOrd</code> que vous pouvez implémenter sur
des types (voir l'annexe C pour en savoir plus sur ce trait). Vous allez
apprendre à indiquer qu'un type générique a un trait spécifique dans la section
<a href="ch10-02-traits.html#des-traits-en-param%C3%A8tres">“Des traits en paramètres”</a><!-- ignore -->, mais d'abord
nous allons explorer d'autres manières d'utiliser les paramètres de types
génériques.</p>
<!--
### In Struct Definitions
-->
<h3 id="dans-la-définition-des-structures"><a class="header" href="#dans-la-définition-des-structures">Dans la définition des structures</a></h3>
<!--
We can also define structs to use a generic type parameter in one or more
fields using the `<>` syntax. Listing 10-6 shows how to define a `Point<T>`
struct to hold `x` and `y` coordinate values of any type.
-->
<p>Nous pouvons aussi définir des structures en utilisant des paramètres de type
génériques dans un ou plusieurs champs en utilisant la syntaxe <code>&lt;&gt;</code>. L'encart
10-6 nous montre comment définir une structure <code>Point&lt;T&gt;</code> pour stocker des
valeurs de coordonnées <code>x</code> et <code>y</code> de n'importe quel type.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let entiers = Point { x: 5, y: 10 };
    let flottants = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-6: A `Point<T>` struct that holds `x` and `y`
values of type `T`</span>
-->
<p><span class="caption">Encart 10-6 : une structure <code>Point&lt;T&gt;</code> qui stocke les
valeurs <code>x</code> et <code>y</code> de type <code>T</code></span></p>
<!--
The syntax for using generics in struct definitions is similar to that used in
function definitions. First, we declare the name of the type parameter inside
angle brackets just after the name of the struct. Then we can use the generic
type in the struct definition where we would otherwise specify concrete data
types.
-->
<p>La syntaxe pour l'utilisation des génériques dans les définitions de structures
est similaire à celle utilisée dans les définitions de fonctions. D'abord, on
déclare le nom du paramètre de type entre des chevrons juste après le nom de la
structure. Ensuite, on peut utiliser le type générique dans la définition de la
structure là où on indiquerait en temps normal des types de données concrets.</p>
<!--
Note that because we’ve used only one generic type to define `Point<T>`, this
definition says that the `Point<T>` struct is generic over some type `T`, and
the fields `x` and `y` are *both* that same type, whatever that type may be. If
we create an instance of a `Point<T>` that has values of different types, as in
Listing 10-7, our code won’t compile.
-->
<p>Notez que comme nous n'avons utilisé qu'un seul type générique pour définir
<code>Point&lt;T&gt;</code>, cette définition dit que la structure <code>Point&lt;T&gt;</code> est générique en
fonction d'un type <code>T</code>, et les champs <code>x</code> et <code>y</code> sont <em>tous les deux</em> de ce même
type, quel qu'il soit. Si nous créons une instance de <code>Point&lt;T&gt;</code> qui a des
valeurs de types différents, comme dans l'encart 10-7, notre code ne va pas se
compiler.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
```
-->
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let ne_fonctionnera_pas = Point { x: 5, y: 4.0 };
}
</code></pre>
<!--
<span class="caption">Listing 10-7: The fields `x` and `y` must be the same
type because both have the same generic data type `T`.</span>
-->
<p><span class="caption">Encart 10-7 : les champs <code>x</code> et <code>y</code> doivent être du même
type car ils ont tous les deux le même type de données générique <code>T</code>.</span></p>
<!--
In this example, when we assign the integer value 5 to `x`, we let the
compiler know that the generic type `T` will be an integer for this instance of
`Point<T>`. Then when we specify 4.0 for `y`, which we’ve defined to have the
same type as `x`, we’ll get a type mismatch error like this:
-->
<p>Dans cet exemple, lorsque nous assignons l'entier 5 à <code>x</code>, nous laissons
entendre au compilateur que le type générique <code>T</code> sera un entier pour cette
instance de <code>Point&lt;T&gt;</code>. Ensuite, lorsque nous assignons 4.0 à <code>y</code>, que nous avons
défini comme ayant le même type que <code>x</code>, nous obtenons une erreur d'incompatibilité de
type comme celle-ci :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 -- > src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let ne_fonctionnera_pas = Point { x: 5, y: 4.0 };
  |                                                ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
</code></pre>
<!--
To define a `Point` struct where `x` and `y` are both generics but could have
different types, we can use multiple generic type parameters. For example, in
Listing 10-8, we can change the definition of `Point` to be generic over types
`T` and `U` where `x` is of type `T` and `y` is of type `U`.
-->
<p>Pour définir une structure <code>Point</code> où <code>x</code> et <code>y</code> sont tous les deux génériques
mais peuvent avoir des types différents, nous pouvons utiliser plusieurs 
paramètres de types génériques différents. Par exemple, dans l'encart 10-8, 
nous pouvons changer la définition de <code>Point</code> pour être générique en 
fonction des types <code>T</code> et <code>U</code> où <code>x</code> est de type <code>T</code> et <code>y</code> est de type <code>U</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let deux_entiers = Point { x: 5, y: 10 };
    let deux_flottants = Point { x: 1.0, y: 4.0 };
    let un_entier_et_un_flottant = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-8: A `Point<T, U>` generic over two types so
that `x` and `y` can be values of different types</span>
-->
<p><span class="caption">Encart 10-8: un <code>Point&lt;T, U&gt;</code> générique en fonction de
deux types <code>x</code> et <code>y</code> qui peuvent être des valeurs de types différents</span></p>
<!--
Now all the instances of `Point` shown are allowed! You can use as many generic
type parameters in a definition as you want, but using more than a few makes
your code hard to read. When you need lots of generic types in your code, it
could indicate that your code needs restructuring into smaller pieces.
-->
<p>Maintenant, toutes les instances de <code>Point</code> montrées ici sont valides ! Vous
pouvez utiliser autant de paramètres de type génériques que vous souhaitez dans
la déclaration de la définition, mais en utiliser plus de quelques-uns rend
votre code difficile à lire. Lorsque vous avez besoin de nombreux types
génériques dans votre code, cela peut être un signe que votre code a besoin
d'être remanié en éléments plus petits.</p>
<!--
### In Enum Definitions
-->
<h3 id="dans-les-définitions-dénumérations"><a class="header" href="#dans-les-définitions-dénumérations">Dans les définitions d'énumérations</a></h3>
<!--
As we did with structs, we can define enums to hold generic data types in their
variants. Let’s take another look at the `Option<T>` enum that the standard
library provides, which we used in Chapter 6:
-->
<p>Comme nous l'avons fait avec les structures, nous pouvons définir des
énumérations qui utilisent des types de données génériques dans leurs variantes.
Commençons par regarder à nouveau l'énumération <code>Option&lt;T&gt;</code> que fournit la
bibliothèque standard, et que nous avons utilisée au chapitre 6 :</p>
<!--
```rust
enum Option<T> {
    Some(T),
    None,
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<!--
This definition should now make more sense to you. As you can see, `Option<T>`
is an enum that is generic over type `T` and has two variants: `Some`, which
holds one value of type `T`, and a `None` variant that doesn’t hold any value.
By using the `Option<T>` enum, we can express the abstract concept of having an
optional value, and because `Option<T>` is generic, we can use this abstraction
no matter what the type of the optional value is.
-->
<p>Cette définition devrait désormais avoir plus de sens pour vous. Comme vous pouvez le
constater, <code>Option&lt;T&gt;</code> est une énumération qui est générique en fonction du type
<code>T</code> et a deux variantes : <code>Some</code>, qui contient une valeur de type <code>T</code>, et une
variante <code>None</code> qui ne contient aucune valeur. En utilisant l'énumération
<code>Option&lt;T&gt;</code>, nous pouvons exprimer le concept abstrait d'avoir une valeur
optionnelle, et comme <code>Option&lt;T&gt;</code> est générique, nous pouvons utiliser cette
abstraction peu importe le type de la valeur optionnelle.</p>
<!--
Enums can use multiple generic types as well. The definition of the `Result`
enum that we used in Chapter 9 is one example:
-->
<p>Les énumérations peuvent aussi utiliser plusieurs types génériques. La
définition de l'énumération <code>Result</code> que nous avons utilisée au chapitre 9 en est
un exemple :</p>
<!--
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `Result` enum is generic over two types, `T` and `E`, and has two variants:
`Ok`, which holds a value of type `T`, and `Err`, which holds a value of type
`E`. This definition makes it convenient to use the `Result` enum anywhere we
have an operation that might succeed (return a value of some type `T`) or fail
(return an error of some type `E`). In fact, this is what we used to open a
file in Listing 9-3, where `T` was filled in with the type `std::fs::File` when
the file was opened successfully and `E` was filled in with the type
`std::io::Error` when there were problems opening the file.
-->
<p>L'énumération <code>Result</code> est générique en fonction de deux types, <code>T</code> et <code>E</code>, et a
deux variantes : <code>Ok</code>, qui contient une valeur de type <code>T</code>, et <code>Err</code>, qui
contient une valeur de type <code>E</code>. Cette définition rend possible l'utilisation de
l'énumération <code>Result</code> partout où nous avons une opération qui peut réussir (et
retourner une valeur du type <code>T</code>) ou échouer (et retourner une erreur du type
<code>E</code>). En fait, c'est ce qui est utilisé pour ouvrir un fichier dans l'encart
9-3, où <code>T</code> contenait un type <code>std::fs::File</code> lorsque le fichier était ouvert
avec succès et <code>E</code> contenait un type <code>std::io::Error</code> lorsqu'il y avait des
problèmes pour ouvrir le fichier.</p>
<!--
When you recognize situations in your code with multiple struct or enum
definitions that differ only in the types of the values they hold, you can
avoid duplication by using generic types instead.
-->
<p>Lorsque vous reconnaîtrez des cas dans votre code où vous aurez plusieurs
définitions de structures ou d'énumérations qui se distinguent uniquement par le
type de valeurs qu'elles stockent, vous pourrez éviter les doublons en utilisant
des types génériques à la place.</p>
<!--
### In Method Definitions
-->
<h3 id="dans-la-définition-des-méthodes"><a class="header" href="#dans-la-définition-des-méthodes">Dans la définition des méthodes</a></h3>
<!--
We can implement methods on structs and enums (as we did in Chapter 5) and use
generic types in their definitions, too. Listing 10-9 shows the `Point<T>`
struct we defined in Listing 10-6 with a method named `x` implemented on it.
-->
<p>Nous pouvons implémenter des méthodes sur des structures et des énumérations
(comme nous l'avons fait dans le chapitre 5) et aussi utiliser des types
génériques dans leurs définitions. L'encart 10-9 montre la structure <code>Point&lt;T&gt;</code>
que nous avons définie dans l'encart 10-6 avec une méthode qui s'appelle <code>x</code>
implémentée sur cette dernière.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-9: Implementing a method named `x` on the
`Point<T>` struct that will return a reference to the `x` field of type
`T`</span>
-->
<p><span class="caption">Encart 10-9 : implémentation d'une méthode <code>x</code> sur la
structure <code>Point&lt;T&gt;</code> qui va retourner une référence au champ <code>x</code>, de type <code>T</code>
</span></p>
<!--
Here, we’ve defined a method named `x` on `Point<T>` that returns a reference
to the data in the field `x`.
-->
<p>Ici, nous avons défini une méthode qui s'appelle <code>x</code> sur <code>Point&lt;T&gt;</code> qui retourne
une référence à la donnée présente dans le champ <code>x</code>.</p>
<!--
Note that we have to declare `T` just after `impl` so we can use it to specify
that we’re implementing methods on the type `Point<T>`.  By declaring `T` as a
generic type after `impl`, Rust can identify that the type in the angle
brackets in `Point` is a generic type rather than a concrete type.
-->
<p>Notez que nous devons déclarer <code>T</code> juste après <code>impl</code> afin de pouvoir l'utiliser
pour préciser que nous implémentons des méthodes sur le type <code>Point&lt;T&gt;</code>. En
déclarant <code>T</code> comme un type générique après <code>impl</code>, Rust peut comprendre que le
type entre les chevrons dans <code>Point</code> est un type générique plutôt qu'un type
concret.</p>
<!--
We could, for example, implement methods only on `Point<f32>` instances rather
than on `Point<T>` instances with any generic type. In Listing 10-10 we use the
concrete type `f32`, meaning we don’t declare any types after `impl`.
-->
<p>Nous pouvons par exemple implémenter des méthodes uniquement sur des instances
de <code>Point&lt;f32&gt;</code> plutôt que sur des instances de n'importe quel type <code>Point&lt;T&gt;</code>.
Dans l'encart 10-10, nous utilisons le type concret <code>f32</code>, ce qui veut dire que
nous n'avons pas besoin de déclarer un type après <code>impl</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# struct Point<T> {
#     x: T,
#     y: T,
# }
# 
# impl<T> Point<T> {
#     fn x(&self) -> &T {
#         &self.x
#     }
# }
# 
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
# 
# fn main() {
#     let p = Point { x: 5, y: 10 };
# 
#     println!("p.x = {}", p.x());
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_depuis_lorigine(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!(&quot;p.x = {}&quot;, p.x());
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-10: An `impl` block that only applies to a
struct with a particular concrete type for the generic type parameter `T`</span>
-->
<p><span class="caption">Encart 10-10 : un bloc <code>impl</code> qui ne s'applique que sur
une structure d'un type concret particulier pour le paramètre de type générique
<code>T</code>
</span></p>
<!--
This code means the type `Point<f32>` will have a method named
`distance_from_origin` and other instances of `Point<T>` where `T` is not of
type `f32` will not have this method defined. The method measures how far our
point is from the point at coordinates (0.0, 0.0) and uses mathematical
operations that are available only for floating point types.
-->
<p>Ce code signifie que le type <code>Point&lt;f32&gt;</code> va avoir une méthode qui s'appelle
<code>distance_depuis_lorigine</code> et les autres instances de <code>Point&lt;T&gt;</code> où <code>T</code> n'est
pas du type <code>f32</code> ne pourront pas appeler cette méthode. Cette méthode 
calcule la distance entre notre point et la coordonnée (0.0, 0.0) et utilise des
opérations mathématiques qui ne sont disponibles que pour les types de
flottants.</p>
<!--
Generic type parameters in a struct definition aren’t always the same as those
you use in that struct’s method signatures. For example, Listing 10-11 defines
the method `mixup` on the `Point<T, U>` struct from Listing 10-8. The method
takes another `Point` as a parameter, which might have different types from the
`self` `Point` we’re calling `mixup` on. The method creates a new `Point`
instance with the `x` value from the `self` `Point` (of type `T`) and the `y`
value from the passed-in `Point` (of type `W`).
-->
<p>Les paramètres de type génériques dans la définition d'une structure ne sont
pas toujours les mêmes que ceux qui sont utilisés dans la signature des
méthodes de cette structure. Par exemple, l'encart 10-11 définit la méthode
<code>melange</code> sur la structure <code>Point&lt;T, U&gt;</code> de l'encart 10-8. La méthode prend un
autre <code>Point</code> en paramètre, qui peut avoir des types différents du <code>Point</code>
<code>self</code> sur lequel nous appelons <code>melange</code>. La méthode crée une nouvelle
instance de <code>Point</code> avec la valeur de <code>x</code> provenant du <code>Point</code> <code>self</code> (de type
<code>T</code>) et la valeur de <code>y</code> provenant du <code>Point</code> en paramètre (de type <code>W</code>).</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
struct Point<T, U> {
    x: T,
    y: U,
}

impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn melange&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c' };

    let p3 = p1.melange(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-11: A method that uses different generic types
from its struct’s definition</span>
-->
<p><span class="caption">Encart 10-11 : une méthode qui utilise différents types
génériques provenant de la définition de la structure</span></p>
<!--
In `main`, we’ve defined a `Point` that has an `i32` for `x` (with value `5`)
and an `f64` for `y` (with value `10.4`). The `p2` variable is a `Point` struct
that has a string slice for `x` (with value `"Hello"`) and a `char` for `y`
(with value `c`). Calling `mixup` on `p1` with the argument `p2` gives us `p3`,
which will have an `i32` for `x`, because `x` came from `p1`. The `p3` variable
will have a `char` for `y`, because `y` came from `p2`. The `println!` macro
call will print `p3.x = 5, p3.y = c`.
-->
<p>Dans le <code>main</code>, nous avons défini un <code>Point</code> qui a un <code>i32</code> pour <code>x</code> (avec la
valeur <code>5</code>) et un <code>f64</code> pour <code>y</code> (avec la valeur 10.4). La variable <code>p2</code> est une
structure <code>Point</code> qui a une slice de chaine de caractères pour <code>x</code> (avec la
valeur <code>&quot;Hello&quot;</code>) et un caractère <code>char</code> pour <code>y</code> (avec la valeur <code>c</code>). L'appel
à <code>melange</code> sur <code>p1</code> avec l'argument <code>p2</code> nous donne <code>p3</code>, qui aura un <code>i32</code> pour
<code>x</code>, car <code>x</code> provient de <code>p1</code>. La variable <code>p3</code> aura un caractère <code>char</code> pour
<code>y</code>, car <code>y</code> provient de <code>p2</code>. L'appel à la macro <code>println!</code> va afficher
<code>p3.x = 5, p3.y = c</code>.</p>
<!--
The purpose of this example is to demonstrate a situation in which some generic
parameters are declared with `impl` and some are declared with the method
definition. Here, the generic parameters `T` and `U` are declared after `impl`,
because they go with the struct definition. The generic parameters `V` and `W`
are declared after `fn mixup`, because they’re only relevant to the method.
-->
<p>Le but de cet exemple est de montrer une situation dans laquelle des paramètres
génériques sont déclarés avec <code>impl</code> et d'autres sont déclarés dans la
définition de la méthode. Ici, les paramètres génériques <code>T</code> et <code>U</code> sont
déclarés après <code>impl</code>, car ils sont liés à la définition de la structure. Les
paramètres génériques <code>V</code> et <code>W</code> sont déclarés après <code>fn melange</code>, car ils ne
sont liés qu'à cette méthode.</p>
<!--
### Performance of Code Using Generics
-->
<h3 id="performance-du-code-utilisant-les-génériques"><a class="header" href="#performance-du-code-utilisant-les-génériques">Performance du code utilisant les génériques</a></h3>
<!--
You might be wondering whether there is a runtime cost when you’re using
generic type parameters. The good news is that Rust implements generics in such
a way that your code doesn’t run any slower using generic types than it would
with concrete types.
-->
<p>Vous vous demandez peut-être s'il y a un coût à l'exécution lorsque vous
utilisez des paramètres de type génériques. La bonne nouvelle est que Rust
implémente les génériques de manière à ce que votre code ne s'exécute pas plus
lentement que vous utilisiez les types génériques ou des types concrets.</p>
<!--
Rust accomplishes this by performing monomorphization of the code that is using
generics at compile time. *Monomorphization* is the process of turning generic
code into specific code by filling in the concrete types that are used when
compiled.
-->
<p>Rust accomplit cela en pratiquant la monomorphisation à la compilation du code
qui utilise les génériques. La <em>monomorphisation</em> est un processus qui transforme
du code générique en code spécifique en définissant au moment de la compilation les
types concrets utilisés dans le code.</p>
<!--
In this process, the compiler does the opposite of the steps we used to create
the generic function in Listing 10-5: the compiler looks at all the places
where generic code is called and generates code for the concrete types the
generic code is called with.
-->
<p>Dans ce processus, le compilateur fait l'inverse des étapes que nous avons suivies
pour créer la fonction générique de l'encart 10-5 : le compilateur cherche tous
les endroits où le code générique est utilisé et génère du code pour les types
concrets avec lesquels le code générique est appelé.</p>
<!--
Let’s look at how this works with an example that uses the standard library’s
`Option<T>` enum:
-->
<p>Regardons comment cela fonctionne avec un exemple qui utilise l'énumération
<code>Option&lt;T&gt;</code> de la bibliothèque standard :</p>
<!--
```rust
let integer = Some(5);
let float = Some(5.0);
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entier = Some(5);
let flottant = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<!--
When Rust compiles this code, it performs monomorphization. During that
process, the compiler reads the values that have been used in `Option<T>`
instances and identifies two kinds of `Option<T>`: one is `i32` and the other
is `f64`. As such, it expands the generic definition of `Option<T>` into
`Option_i32` and `Option_f64`, thereby replacing the generic definition with
the specific ones.
-->
<p>Lorsque Rust compile ce code, il applique la monomorphisation. Pendant ce
processus, le compilateur lit les valeurs qui ont été utilisées dans les
instances de <code>Option&lt;T&gt;</code> et en déduit les deux sortes de <code>Option&lt;T&gt;</code> : une est
<code>i32</code> et l'autre est <code>f64</code>. Ainsi, il décompose la définition générique de
<code>Option&lt;T&gt;</code> en <code>Option_i32</code> et en <code>Option_f64</code>, remplaçant ainsi la définition
générique par deux définitions concrètes.</p>
<!--
The monomorphized version of the code looks like the following. The generic
`Option<T>` is replaced with the specific definitions created by the compiler:
-->
<p>La version monomorphe du code ressemble à ce qui suit. Le <code>Option&lt;T&gt;</code> générique
est remplacé par deux définitions concrètes créées par le compilateur :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let entier = Option_i32::Some(5);
    let flottant = Option_f64::Some(5.0);
}
</code></pre></pre>
<!--
Because Rust compiles generic code into code that specifies the type in each
instance, we pay no runtime cost for using generics. When the code runs, it
performs just as it would if we had duplicated each definition by hand. The
process of monomorphization makes Rust’s generics extremely efficient at
runtime.
-->
<p>Comme Rust compile le code générique dans du code qui précise le type dans
chaque instance, l'utilisation des génériques n'a pas de conséquence sur les
performances de l'exécution. Quand le code s'exécute, il fonctionne comme il
devrait le faire si nous avions dupliqué chaque définition à la main. Le
processus de monomorphisation rend les génériques de Rust très performants au
moment de l'exécution.</p>
<!--
[traits-as-parameters]: ch10-02-traits.html#traits-as-parameters
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Traits: Defining Shared Behavior
-->
<h2 id="définir-des-comportements-partagés-avec-les-traits"><a class="header" href="#définir-des-comportements-partagés-avec-les-traits">Définir des comportements partagés avec les traits</a></h2>
<!--
A *trait* tells the Rust compiler about functionality a particular type has and
can share with other types. We can use traits to define shared behavior in an
abstract way. We can use trait bounds to specify that a generic type can be any
type that has certain behavior.
-->
<p>Un <em>trait</em> décrit une fonctionnalité qu'a un type particulier et qu'il peut
partager avec d'autres types, à destination du compilateur Rust. Nous pouvons
utiliser les traits pour définir un comportement partagé de manière abstraite.
Nous pouvons lier ces traits à un type générique pour exprimer le fait qu'il
puisse être de n'importe quel type à condition qu'il ai un comportement donné.</p>
<!--
> Note: Traits are similar to a feature often called *interfaces* in other
> languages, although with some differences.
-->
<blockquote>
<p>Remarque : les traits sont similaires à ce qu'on appelle parfois les
<em>interfaces</em> dans d'autres langages, malgré quelques différences.</p>
</blockquote>
<!--
### Defining a Trait
-->
<h3 id="définir-un-trait"><a class="header" href="#définir-un-trait">Définir un trait</a></h3>
<!--
A type’s behavior consists of the methods we can call on that type. Different
types share the same behavior if we can call the same methods on all of those
types. Trait definitions are a way to group method signatures together to
define a set of behaviors necessary to accomplish some purpose.
-->
<p>Le comportement d'un type s'exprime via les méthodes que nous pouvons appeler
sur ce type. Différents types peuvent partager le même comportement si nous
pouvons appeler les mêmes méthodes sur tous ces types. Définir un trait est une
manière de grouper ensemble les signatures des méthodes pour définir un
comportement nécessaire pour accomplir un objectif.</p>
<!--
For example, let’s say we have multiple structs that hold various kinds and
amounts of text: a `NewsArticle` struct that holds a news story filed in a
particular location and a `Tweet` that can have at most 280 characters along
with metadata that indicates whether it was a new tweet, a retweet, or a reply
to another tweet.
-->
<p>Par exemple, imaginons que nous avons plusieurs structures qui stockent
différents types et quantité de texte : une structure <code>ArticleDePresse</code>, qui
contient un reportage dans un endroit donné et un <code>Tweet</code> qui peut avoir jusqu'à
280 caractères maximum et des métadonnées qui indiquent si cela est un nouveau
tweet, un retweet, ou une réponse à un autre tweet.</p>
<!--
We want to make a media aggregator library that can display summaries of data
that might be stored in a `NewsArticle` or `Tweet` instance. To do this, we
need a summary from each type, and we need to request that summary by calling a
`summarize` method on an instance. Listing 10-12 shows the definition of a
`Summary` trait that expresses this behavior.
-->
<p>Nous voulons construire une bibliothèque pour des agrégateurs de médias qui peut
afficher le résumé des données stockées dans une instance de <code>ArticleDePresse</code>
ou de <code>Tweet</code>. Pour cela, nous avons besoin d'un résumé pour chaque type, et
nous pouvons demander ce résumé en appelant la méthode <code>resumer</code> sur une
instance. L'encart 10-12 nous montre la définition d'un trait <code>Resumable</code> qui
décrit ce comportement.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
pub trait Summary {
    fn summarize(&self) -> String;
}
```
-->
<pre><code class="language-rust noplayground">pub trait Resumable {
    fn resumer(&amp;self) -&gt; String;
}
</code></pre>
<!--
<span class="caption">Listing 10-12: A `Summary` trait that consists of the
behavior provided by a `summarize` method</span>
-->
<p><span class="caption">Encart 10-12 : un trait <code>Resumable</code> qui représente le
comportement fourni par une méthode <code>resumer</code></span></p>
<!--
Here, we declare a trait using the `trait` keyword and then the trait’s name,
which is `Summary` in this case. Inside the curly brackets, we declare the
method signatures that describe the behaviors of the types that implement this
trait, which in this case is `fn summarize(&self) -> String`.
-->
<p>Ici, nous déclarons un trait en utilisant le mot-clé <code>trait</code> et ensuite le nom
du trait, qui est <code>Resumable</code> dans notre cas. Entre les accolades, nous
déclarons la signature de la méthode qui décrit le comportement des types qui
implémentent ce trait, qui est dans notre cas <code>fn resumer(&amp;self) -&gt; String</code>.</p>
<!--
After the method signature, instead of providing an implementation within curly
brackets, we use a semicolon. Each type implementing this trait must provide
its own custom behavior for the body of the method. The compiler will enforce
that any type that has the `Summary` trait will have the method `summarize`
defined with this signature exactly.
-->
<p>A la fin de la signature de la méthode, au lieu de renseigner une implémentation
entre des accolades, nous utilisons un point-virgule. Chaque type qui implémente
ce trait doit renseigner son propre comportement dans le corps de la méthode. Le
compilateur va s'assurer que tous les types qui ont le trait <code>Resumable</code> auront
la méthode <code>resumer</code> défini avec cette signature précise.</p>
<!--
A trait can have multiple methods in its body: the method signatures are listed
one per line and each line ends in a semicolon.
-->
<p>Un trait peut avoir plusieurs méthodes dans son corps : les signatures des
méthodes sont ajoutées ligne par ligne et chaque ligne se termine avec un
point-virgule.</p>
<!--
### Implementing a Trait on a Type
-->
<h3 id="implémenter-un-trait-sur-un-type"><a class="header" href="#implémenter-un-trait-sur-un-type">Implémenter un trait sur un type</a></h3>
<!--
Now that we’ve defined the desired behavior using the `Summary` trait, we can
implement it on the types in our media aggregator. Listing 10-13 shows an
implementation of the `Summary` trait on the `NewsArticle` struct that uses the
headline, the author, and the location to create the return value of
`summarize`. For the `Tweet` struct, we define `summarize` as the username
followed by the entire text of the tweet, assuming that tweet content is
already limited to 280 characters.
-->
<p>Maintenant que nous avons défini le comportement souhaité du trait <code>Resumable</code>,
nous pouvons maintenant l'implémenter sur les types de notre agrégateur de
médias. L'encart 10-13 nous montre l'implémentation du trait <code>Resumable</code> sur la
structure <code>ArticleDePresse</code> qui utilise le titre, le nom de l'auteur, et le lieu
pour créer la valeur de retour de <code>resumer</code>. Pour la structure <code>Tweet</code>, nous
définissons <code>resumer</code> avec le nom d'utilisateur suivi par le texte entier du
tweet, en supposant que le contenu du tweet est déjà limité à 280 caractères.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct ArticleDePresse {
    pub titre: String,
    pub lieu: String,
    pub auteur: String,
    pub contenu: String,
}

impl Resumable for ArticleDePresse {
    fn resumer(&amp;self) -&gt; String {
        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
    }
}

pub struct Tweet {
    pub nom_utilisateur: String,
    pub contenu: String,
    pub reponse: bool,
    pub retweet: bool,
}

impl Resumable for Tweet {
    fn resumer(&amp;self) -&gt; String {
        format!(&quot;{} : {}&quot;, self.nom_utilisateur, self.contenu)
    }
}
</code></pre>
<!--
<span class="caption">Listing 10-13: Implementing the `Summary` trait on the
`NewsArticle` and `Tweet` types</span>
-->
<p><span class="caption">Encart 10-13 : implémentation du trait <code>Resumable</code> sur les
types <code>ArticleDePresse</code> et <code>Tweet</code></span></p>
<!--
Implementing a trait on a type is similar to implementing regular methods. The
difference is that after `impl`, we put the trait name that we want to
implement, then use the `for` keyword, and then specify the name of the type we
want to implement the trait for. Within the `impl` block, we put the method
signatures that the trait definition has defined. Instead of adding a semicolon
after each signature, we use curly brackets and fill in the method body with
the specific behavior that we want the methods of the trait to have for the
particular type.
-->
<p>L'implémentation d'un trait sur un type est similaire à l'implémentation d'une
méthode classique. La différence est que nous ajoutons le nom du trait que nous
voulons implémenter après le <code>impl</code>, et que nous utilisons ensuite le mot-clé
<code>for</code> ainsi que le nom du type sur lequel nous souhaitons implémenter le trait.
A l'intérieur du bloc <code>impl</code>, nous ajoutons les signatures des méthodes
présentes dans la définition du trait. Au lieu d'ajouter un point-virgule après
chaque signature, nous plaçons les accolades et on remplit le corps de la
méthode avec le comportement spécifique que nous voulons que les méthodes du
trait suive pour type en particulier.</p>
<!--
After implementing the trait, we can call the methods on instances of
`NewsArticle` and `Tweet` in the same way we call regular methods, like this:
-->
<p>Après avoir implémenté le trait, nous pouvons appeler les méthodes de
l'instance de <code>ArticleDePresse</code> et <code>Tweet</code> comme si elles étaient des méthodes
classiques, comme ceci :</p>
<!--
```rust,ignore
# use chapter10::{self, Summary, Tweet};
# 
# fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Resumable, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        nom_utilisateur: String::from(&quot;jean&quot;),
        contenu: String::from(&quot;Bien sûr, les amis, comme vous le savez probablement déjà&quot;),
        reponse: false,
        retweet: false,
    };
    
    println!(&quot;1 nouveau tweet : {}&quot;, tweet.resumer());
<span class="boring">}
</span></code></pre>
<!--
This code prints `1 new tweet: horse_ebooks: of course, as you probably already
know, people`.
-->
<p>Ce code affichera <code>1 nouveau tweet : jean : Bien sûr, les amis, comme vous le savez probablement déjà</code>.</p>
<!--
Note that because we defined the `Summary` trait and the `NewsArticle` and
`Tweet` types in the same *lib.rs* in Listing 10-13, they’re all in the same
scope. Let’s say this *lib.rs* is for a crate we’ve called `aggregator` and
someone else wants to use our crate’s functionality to implement the `Summary`
trait on a struct defined within their library’s scope. They would need to
bring the trait into their scope first. They would do so by specifying `use
aggregator::Summary;`, which then would enable them to implement `Summary` for
their type. The `Summary` trait would also need to be a public trait for
another crate to implement it, which it is because we put the `pub` keyword
before `trait` in Listing 10-12.
-->
<p>Remarquez que comme nous avons défini le trait <code>Resumable</code> et les types
<code>ArticleDePresse</code> et <code>Tweet</code> dans le même fichier <em>lib.rs</em> de l'encart 10-13,
ils sont tous dans la même portée. Disons que ce fichier <em>lib.rs</em> est utilisé
pour une crate que nous avons appelé <code>agregateur</code> et que quelqu'un d'autre
souhaite utiliser les fonctionnalités de notre crate pour implémenter le trait
<code>Resumable</code> sur une structure définie dans la portée de sa propre bibliothèque.
Il aura d'abord besoin d'importer le trait dans sa portée. Il pourra le faire en
utilisant <code>use agregateur::Resumable;</code>, ce qui lui permettra ensuite
d'implémenter <code>Resumable</code> sur le type souhaité. Le trait <code>Resumable</code> devra alors
être un trait public aux autres crates pour qu'elles puissent l'implémenter,
c'est pourquoi nous avons placé le mot-clé <code>pub</code> devant le <code>trait</code> dans l'encart
10-12.</p>
<!--
One restriction to note with trait implementations is that we can implement a
trait on a type only if either the trait or the type is local to our crate.
For example, we can implement standard library traits like `Display` on a
custom type like `Tweet` as part of our `aggregator` crate functionality,
because the type `Tweet` is local to our `aggregator` crate. We can also
implement `Summary` on `Vec<T>` in our `aggregator` crate, because the
trait `Summary` is local to our `aggregator` crate.
-->
<p>Il y a une limitation à souligner avec l'implémentation des traits, c'est que
nous ne pouvons implémenter un trait sur un type qu'à condition que le trait ou
le type soit défini localement dans notre crate. Par exemple, nous pouvons
implémenter des traits de la bibliothèque standard comme <code>Display</code> sur un type
personnalisé comme <code>Tweet</code> comme une fonctionnalité de notre crate <code>agregateur</code>,
car le type <code>Tweet</code> est défini localement dans notre crate <code>agregateur</code>. Nous
pouvons aussi implémenter <code>Resumable</code> sur <code>Vec&lt;T&gt;</code> dans notre crate
<code>agregateur</code>, car le trait <code>Resumable</code> est défini localement dans notre crate
<code>agregateur</code>.</p>
<!--
But we can’t implement external traits on external types. For example, we can’t
implement the `Display` trait on `Vec<T>` within our `aggregator` crate,
because `Display` and `Vec<T>` are defined in the standard library and aren’t
local to our `aggregator` crate. This restriction is part of a property of
programs called *coherence*, and more specifically the *orphan rule*, so named
because the parent type is not present. This rule ensures that other people’s
code can’t break your code and vice versa. Without the rule, two crates could
implement the same trait for the same type, and Rust wouldn’t know which
implementation to use.
-->
<p>Mais nous ne pouvons pas implémenter des traits externes sur des types externes.
Par exemple, nous ne pouvons pas implémenter le trait <code>Display</code> sur <code>Vec&lt;T&gt;</code> à
l'intérieur de notre crate <code>agregateur</code>, car <code>Display</code> et <code>Vec&lt;T&gt;</code> sont définis
dans la bibliothèque standard et ne sont donc pas définis localement dans notre
crate <code>agregateur</code>. Cette limitation fait partie d'une propriété des programmes
que l'on appelle la <em>cohérence</em>, et plus précisément la <em>règle de l'orphelin</em>,
qui s'appelle ainsi car le type parent n'est pas présent. Cette règle s'assure
que le code des autres personnes ne casse pas votre code et réciproquement.
Sans cette règle, deux crates peuvent implémenter le même trait sur le même
type, et Rust ne saura pas laquelle utiliser.</p>
<!--
### Default Implementations
-->
<h3 id="implémentations-par-défaut"><a class="header" href="#implémentations-par-défaut">Implémentations par défaut</a></h3>
<!--
Sometimes it’s useful to have default behavior for some or all of the methods
in a trait instead of requiring implementations for all methods on every type.
Then, as we implement the trait on a particular type, we can keep or override
each method’s default behavior.
-->
<p>Il est parfois utile d'avoir un comportement par défaut pour toutes ou une
partie des méthodes d'un trait plutôt que de demander l'implémentation de toutes
les méthodes sur chaque type. Ainsi, si nous implémentons le trait sur un type
particulier, nous pouvons garder ou réécrire le comportement par défaut de
chaque méthode. </p>
<!--
Listing 10-14 shows how to specify a default string for the `summarize` method
of the `Summary` trait instead of only defining the method signature, as we did
in Listing 10-12.
-->
<p>L'encart 10-14 nous montre comment préciser une String par défaut pour la
méthode <code>resumer</code> du trait <code>Resumable</code> plutôt que de définir uniquement la
signature de la méthode, comme nous l'avons fait dans l'encart 10-12.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {}
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
```
-->
<pre><code class="language-rust noplayground">pub trait Resumable {
    fn resumer(&amp;self) -&gt; String {
        String::from(&quot;(En savoir plus ...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-14: Definition of a `Summary` trait with a
default implementation of the `summarize` method</span>
-->
<p><span class="caption">Encart 10-14 : définition du trait <code>Resumable</code> avec une
implémentation par défaut de la méthode <code>resumer</code></span></p>
<!--
To use a default implementation to summarize instances of `NewsArticle` instead
of defining a custom implementation, we specify an empty `impl` block with
`impl Summary for NewsArticle {}`.
-->
<p>Pour pouvoir utiliser l'implémentation par défaut du résumé des instances de
<code>ArticleDePresse</code> plutôt que de devoir préciser un implémentation personnalisée,
nous précisons un bloc <code>impl</code> vide avec <code>impl Resumable for ArticleDePresse {}</code>.</p>
<!--
Even though we’re no longer defining the `summarize` method on `NewsArticle`
directly, we’ve provided a default implementation and specified that
`NewsArticle` implements the `Summary` trait. As a result, we can still call
the `summarize` method on an instance of `NewsArticle`, like this:
-->
<p>Même si nous n'avons pas défini directement la méthode <code>resumer</code> sur
<code>ArticleDePresse</code>, nous avons fourni une implémentation par défaut et précisé
que <code>ArticleDePresse</code> implémente le trait <code>Resumable</code>. Par conséquent, nous
pouvons toujours appeler la méthode <code>resumer</code> sur une instance de
<code>ArticleDePresse</code>, comme ceci :</p>
<!--
```rust,ignore
# use chapter10::{self, NewsArticle, Summary};
# 
# fn main() {
    let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, ArticleDePresse, Resumable};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = ArticleDePresse {
        titre: String::from(&quot;Les Pinguins ont gagné la Stanley Cup Championship !&quot;),
        lieu: String::from(&quot;Pittsburgh, PA, USA&quot;),
        auteur: String::from(&quot;Iceburgh&quot;),
        contenu: String::from(
            &quot;Les Pinguins de Pittsburgh sont une nouvelle fois la meilleure\
            équipe de hockey de la NHL.&quot;
        ),
    };
    
    println!(&quot;Nouvel article disponible ! {}&quot;, article.resumer());
<span class="boring">}
</span></code></pre>
<!--
This code prints `New article available! (Read more...)`.
-->
<p>Ce code va afficher <code>Nouvel article disponible ! (En savoir plus ...)</code>.</p>
<!--
Creating a default implementation for `summarize` doesn’t require us to change
anything about the implementation of `Summary` on `Tweet` in Listing 10-13. The
reason is that the syntax for overriding a default implementation is the same
as the syntax for implementing a trait method that doesn’t have a default
implementation.
-->
<p>La création d'une implémentation par défaut pour <code>resumer</code> n'a pas besoin que
nous modifions quelque chose dans l'implémentation de <code>Resumable</code> sur <code>Tweet</code>
dans l'encart 10-13. C'est parce que la syntaxe pour réécrire l'implémentation
par défaut est la même que la syntaxe pour implémenter une méthode qui n'a pas
d'implémentation par défaut.</p>
<!--
Default implementations can call other methods in the same trait, even if those
other methods don’t have a default implementation. In this way, a trait can
provide a lot of useful functionality and only require implementors to specify
a small part of it. For example, we could define the `Summary` trait to have a
`summarize_author` method whose implementation is required, and then define a
`summarize` method that has a default implementation that calls the
`summarize_author` method:
-->
<p>Les implémentations par défaut peuvent appeler d'autres méthodes du même trait,
même si ces autres méthodes n'ont pas d'implémentation par défaut. Ainsi, un
trait peut fournir de nombreuses fonctionnalités utiles et n'avoir besoin que
le développeur qui l'utilise n'en ai qu'une petite partie à implémenter. Par
exemple, nous pouvons définir le trait <code>Resumable</code> pour avoir une méthode
<code>resumer_auteur</code> dont l'implémentation est nécessaire, et ensuite définir une
méthode <code>resumer</code> qui a une implémentation par défaut qui appelle la méthode
<code>resumer_auteur</code> :</p>
<!--
```rust,noplayground
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize_author(&self) -> String {
#         format!("@{}", self.username)
#     }
# }
```
-->
<pre><code class="language-rust noplayground">pub trait Resumable {
    fn resumer_auteur(&amp;self) -&gt; String;

    fn resumer(&amp;self) -&gt; String {
        format!(&quot;(Lire plus d'éléments de {} ...)&quot;, self.resumer_auteur())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer_auteur(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;@{}&quot;, self.nom_utilisateur)
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
To use this version of `Summary`, we only need to define `summarize_author`
when we implement the trait on a type:
-->
<p>Pour pouvoir utiliser cette version de <code>Resumable</code>, nous avons seulement besoin
de définir <code>resumer_auteur</code> lorsqu'on implémente le trait sur le type :</p>
<!--
```rust,ignore
# pub trait Summary {
#     fn summarize_author(&self) -> String;
# 
#     fn summarize(&self) -> String {
#         format!("(Read more from {}...)", self.summarize_author())
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer_auteur(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Lire plus d'éléments de {} ...)&quot;, self.resumer_auteur())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Resumable for Tweet {
    fn resumer_auteur(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.nom_utilisateur)
    }
}
</code></pre>
<!--
After we define `summarize_author`, we can call `summarize` on instances of the
`Tweet` struct, and the default implementation of `summarize` will call the
definition of `summarize_author` that we’ve provided. Because we’ve implemented
`summarize_author`, the `Summary` trait has given us the behavior of the
`summarize` method without requiring us to write any more code.
-->
<p>Après avoir défini <code>resumer_auteur</code>, nous pouvons appeler <code>resumer</code> sur des
instances de la structure <code>Tweet</code>, et l'implémentation par défaut de <code>resumer</code>
va appeler <code>resumer_auteur</code>, que nous avons défini. Comme nous avons implémenté
<code>resumer_auteur</code>, le trait <code>Resumable</code> nous a donné le comportement de la
méthode <code>resumer</code> sans avoir besoin d'écrire aucune ligne de code
supplémentaire.</p>
<!--
```rust,ignore
# use chapter10::{self, Summary, Tweet};
# 
# fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Resumable, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        nom_utilisateur: String::from(&quot;jean&quot;),
        contenu: String::from(&quot;Bien sûr, les amis, comme vous le savez probablement déjà&quot;),
        reponse: false,
        retweet: false,
    };
    
    println!(&quot;1 nouveau tweet : {}&quot;, tweet.resumer());
<span class="boring">}
</span></code></pre>
<!--
This code prints `1 new tweet: (Read more from @horse_ebooks...)`.
-->
<p>Ce code affichera <code>1 nouveau tweet : (Lire plus d'éléments de @jean ...)</code>.</p>
<!--
Note that it isn’t possible to call the default implementation from an
overriding implementation of that same method.
-->
<p>Notez qu'il n'est pas possible d'appeler l'implémentation par défaut à partir
d'une réécriture de cette même méthode.</p>
<!--
### Traits as Parameters
-->
<h3 id="des-traits-en-paramètres"><a class="header" href="#des-traits-en-paramètres">Des traits en paramètres</a></h3>
<!--
Now that you know how to define and implement traits, we can explore how to use
traits to define functions that accept many different types.
-->
<p>Maintenant que vous savez comment définir et implémenter les traits, nous
pouvons regarder comment utiliser les traits pour définir des fonctions qui
acceptent plusieurs types différents.</p>
<!--
For example, in Listing 10-13, we implemented the `Summary` trait on the
`NewsArticle` and `Tweet` types. We can define a `notify` function that calls
the `summarize` method on its `item` parameter, which is of some type that
implements the `Summary` trait. To do this, we can use the `impl Trait`
syntax, like this:
-->
<p>Par exemple, dans l'encart 10-13, nous implémentons le trait <code>Resumable</code> sur les
types <code>ArticleDePresse</code> et <code>Tweet</code>. Nous pouvons définir une fonction <code>notifier</code>
qui va appeler la fonction <code>resumer</code> sur son paramètre <code>element</code>, qui est d'un
type qui implémente le trait <code>Resumable</code>. Pour faire ceci, nous pouvons utiliser
la syntaxe <code>impl Trait</code>, comme ceci :</p>
<!--
```rust,ignore
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {
#     fn summarize(&self) -> String {
#         format!("{}, by {} ({})", self.headline, self.author, self.location)
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
# 
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{} : {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notifier(element: &amp;impl Resumable) {
    println!(&quot;Flash-info ! {}&quot;, element.resumer());
}
</code></pre>
<!--
Instead of a concrete type for the `item` parameter, we specify the `impl`
keyword and the trait name. This parameter accepts any type that implements the
specified trait. In the body of `notify`, we can call any methods on `item`
that come from the `Summary` trait, such as `summarize`. We can call `notify`
and pass in any instance of `NewsArticle` or `Tweet`. Code that calls the
function with any other type, such as a `String` or an `i32`, won’t compile
because those types don’t implement `Summary`.
-->
<p>Au lieu d'un type concret pour le paramètre <code>element</code>, nous précisons le mot-clé
<code>impl</code> et le nom du trait. Ce paramètre accepte n'importe quel type qui
implémente le trait spécifié. Dans le corps de <code>notifier</code>, nous pouvons appeler
toutes les méthodes sur <code>element</code> qui proviennent du trait <code>Resumable</code>, comme
<code>resumer</code>. Nous pouvons appeler <code>notifier</code> et passer une instance de
<code>ArticleDePresse</code> ou de <code>Tweet</code>. Le code qui appellera la fonction avec un autre
type, comme une <code>String</code> ou un <code>i32</code>, ne va pas se compiler car ces types
n'implémentent pas <code>Resumable</code>.</p>
<!--
#### Trait Bound Syntax
-->
<h4 id="la-syntaxe-du-trait-lié"><a class="header" href="#la-syntaxe-du-trait-lié">La syntaxe du trait lié</a></h4>
<!--
The `impl Trait` syntax works for straightforward cases but is actually
syntax sugar for a longer form, which is called a *trait bound*; it looks like
this:
-->
<p>La syntaxe <code>impl Trait</code> fonctionne bien pour des cas simples, mais est en
réalité du sucre syntaxique pour une forme plus longue, qui s'appelle le
<em>trait lié</em> ; qui ressemble à ceci :</p>
<!--
```rust,ignore
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```
-->
<pre><code class="language-rust ignore">pub fn notifier&lt;T: Resumable&gt;(element: &amp;T) {
    println!(&quot;Flash-info ! {}&quot;, element.resumer());
}
</code></pre>
<!--
This longer form is equivalent to the example in the previous section but is
more verbose. We place trait bounds with the declaration of the generic type
parameter after a colon and inside angle brackets.
-->
<p>Cette forme plus longue est équivalente à l'exemple dans la section précédente,
mais est plus verbeuse. Nous plaçons les traits liés dans la déclaration des
paramètres de type générique après les double-points dans les chevrons.</p>
<!--
The `impl Trait` syntax is convenient and makes for more concise code in simple
cases. The trait bound syntax can express more complexity in other cases. For
example, we can have two parameters that implement `Summary`. Using the `impl
Trait` syntax looks like this:
-->
<p>La syntaxe <code>impl Trait</code> est pratique pour rendre du code plus concis dans des
cas simples. La syntaxe du trait lié exprime plus de complexité dans certains
cas. Par exemple, nous pouvons avoir deux paramètres qui implémentent
<code>Resumable</code>. En utilisant la syntaxe <code>impl Trait</code>, nous aurons ceci :</p>
<!--
```rust,ignore
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier(element1: &amp;impl Resumable, element2: &amp;impl Resumable) {
</code></pre>
<!--
If we wanted this function to allow `item1` and `item2` to have different
types, using `impl Trait` would be appropriate (as long as both types implement
`Summary`). If we wanted to force both parameters to have the same type, that’s
only possible to express using a trait bound, like this:
-->
<p>Si nous souhaitons permettre à <code>element1</code> et <code>element2</code> d'avoir des types
différents, l'utilisation de <code>impl Trait</code> est approprié (du moment que chacun de
ces types implémentent <code>Resumable</code>). Mais si nous souhaitons forcer les deux
paramètres d'être du même type, cela n'est possible à exprimer qu'avec un trait
lié, comme ceci :</p>
<!--
```rust,ignore
pub fn notify<T: Summary>(item1: &T, item2: &T) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier&lt;T: Resumable&gt;(element1: &amp;T, element2: &amp;T) {
</code></pre>
<!--
The generic type `T` specified as the type of the `item1` and `item2`
parameters constrains the function such that the concrete type of the value
passed as an argument for `item1` and `item2` must be the same.
-->
<p>Le type générique <code>T</code> renseigné comme type des paramètres <code>element1</code> et
<code>element2</code> contraint la fonction de manière à ce que les types concrets des
valeurs passées en arguments pour <code>element1</code> et <code>element2</code> soient identiques.</p>
<!--
#### Specifying Multiple Trait Bounds with the `+` Syntax
-->
<h4 id="renseigner-plusieurs-traits-liés-avec-la-syntaxe-"><a class="header" href="#renseigner-plusieurs-traits-liés-avec-la-syntaxe-">Renseigner plusieurs traits liés avec la syntaxe <code>+</code></a></h4>
<!--
We can also specify more than one trait bound. Say we wanted `notify` to use
display formatting on `item` as well as the `summarize` method: we specify in
the `notify` definition that `item` must implement both `Display` and
`Summary`. We can do so using the `+` syntax:
-->
<p>Nous pouvons aussi préciser que nous attendons plus d'un trait lié. Imaginons
que nous souhaitons que <code>notifier</code> utilise le formatage d'affichage sur
<code>element</code> ainsi que la méthode <code>resumer</code> : nous indiquons dans la définition de
<code>notify</code> que <code>element</code> doit implémenter <code>Affichable</code> et <code>Resumable</code>. Nous
pouvons faire ceci avec la syntaxe <code>+</code> :</p>
<!--
```rust,ignore
pub fn notify(item: &(impl Summary + Display)) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier(element: &amp;(impl Resumable + Display)) {
</code></pre>
<!--
The `+` syntax is also valid with trait bounds on generic types:
-->
<p>La syntaxe <code>+</code> fonctionne aussi avec les traits liés sur des types génériques :</p>
<!--
```rust,ignore
pub fn notify<T: Summary + Display>(item: &T) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier&lt;T: Resumable + Display&gt;(element: &amp;T) {
</code></pre>
<!--
With the two trait bounds specified, the body of `notify` can call `summarize`
and use `{}` to format `item`.
-->
<p>Avec les deux traits liés renseignés, le corps de <code>notifier</code> va appeler
<code>resumer</code> et utiliser <code>{}</code> pour formater <code>element</code>.</p>
<!--
#### Clearer Trait Bounds with `where` Clauses
-->
<h4 id="des-traits-liés-plus-clairs-avec-linstruction-where"><a class="header" href="#des-traits-liés-plus-clairs-avec-linstruction-where">Des traits liés plus clairs avec l'instruction <code>where</code></a></h4>
<!--
Using too many trait bounds has its downsides. Each generic has its own trait
bounds, so functions with multiple generic type parameters can contain lots of
trait bound information between the function’s name and its parameter list,
making the function signature hard to read. For this reason, Rust has alternate
syntax for specifying trait bounds inside a `where` clause after the function
signature. So instead of writing this:
-->
<p>L'utilisation de trop nombreux traits liés a aussi ses désavantages. Chaque
générique a ses propres traits liés, donc les fonctions avec plusieurs
paramètres de types génériques peuvent aussi avoir de nombreuses informations de
traits liés entre le nom de la fonction et la liste de ses paramètres, ce qui
rend la signature de la fonction difficile à lire. Pour cette raison, Rust a une
syntaxe alternative pour renseigner les traits liés, dans une instruction
<code>where</code> après la signature de la fonction. Donc, à la place d'écrire ceci ...</p>
<!--
```rust,ignore
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
```
-->
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
<!--
we can use a `where` clause, like this:
-->
<p>... nous pouvons utiliser l'instruction <code>where</code>, comme ceci :</p>
<!--
```rust,ignore
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{
```
-->
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<!--
This function’s signature is less cluttered: the function name, parameter list,
and return type are close together, similar to a function without lots of trait
bounds.
-->
<p>La signature de cette fonction est moins encombrée : le nom de la fonction, la
liste des paramètres, et le type de retour sont plus proches l'un de l'autre,
comme une fonction sans traits liés.</p>
<!--
### Returning Types that Implement Traits
-->
<h3 id="retourner-des-types-qui-implémentent-des-traits"><a class="header" href="#retourner-des-types-qui-implémentent-des-traits">Retourner des types qui implémentent des traits</a></h3>
<!--
We can also use the `impl Trait` syntax in the return position to return a
value of some type that implements a trait, as shown here:
-->
<p>Nous pouvons aussi utiliser la syntaxe <code>impl Trait</code> à la place du type de retour afin
de retourner une valeur d'un type qui implémente un trait, comme ci-dessous :</p>
<!--
```rust,ignore
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {
#     fn summarize(&self) -> String {
#         format!("{}, by {} ({})", self.headline, self.author, self.location)
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
# 
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{} : {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn retourne_resumable() -&gt; impl Resumable {
    Tweet {
        nom_utilisateur: String::from(&quot;jean&quot;),
        contenu: String::from(&quot;Bien sûr, les amis, comme vous le savez probablement déjà&quot;),
        reponse: false,
        retweet: false,
    }
}
</code></pre>
<!--
By using `impl Summary` for the return type, we specify that the
`returns_summarizable` function returns some type that implements the `Summary`
trait without naming the concrete type. In this case, `returns_summarizable`
returns a `Tweet`, but the code calling this function doesn’t know that.
-->
<p>En utilisant <code>impl Resumable</code> pour le type de retour, nous indiquons que la
fonction <code>retourne_resumable</code>retourne un type qui implémente le trait
<code>Resumable</code> sans avoir à écrire le nom du type concret. Dans notre cas,
<code>retourne_resumable</code> retourne un <code>Tweet</code>, mais le code qui appellera cette
fonction ne le saura pas.</p>
<!--
The ability to return a type that is only specified by the trait it implements
is especially useful in the context of closures and iterators, which we cover
in Chapter 13. Closures and iterators create types that only the compiler knows
or types that are very long to specify. The `impl Trait` syntax lets you
concisely specify that a function returns some type that implements the
`Iterator` trait without needing to write out a very long type.
-->
<p>La capacité de retourner un type qui est uniquement caractérisé par le trait
qu'il implémente est tout particulièrement utile dans le cas des fermetures et
des itérateurs, que nous allons voir au chapitre 13. Les fermetures et les
itérateurs créent des types que seul le compilateur est en mesure de comprendre
ou alors des types qui sont très longs à définir. La syntaxe <code>impl Trait</code> vous
permet de renseigner de manière concise qu'une fonction retourne un type
particulier qui implémente le trait <code>Iterator</code> sans avoir à écrire un très long
type.</p>
<!--
However, you can only use `impl Trait` if you’re returning a single type. For
example, this code that returns either a `NewsArticle` or a `Tweet` with the
return type specified as `impl Summary` wouldn’t work:
-->
<p>Cependant, vous pouvez seulement utiliser <code>impl Trait</code> si vous retournez un
seul type possible. Par exemple, ce code va retourner soit un <code>ArticleDePresse</code>,
soit un <code>Tweet</code>, alors que le type de retour avec <code>impl Resumable</code> ne va pas
fonctionner :</p>
<!--
```rust,ignore,does_not_compile
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {
#     fn summarize(&self) -> String {
#         format!("{}, by {} ({})", self.headline, self.author, self.location)
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
# 
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        Tweet {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
            reply: false,
            retweet: false,
        }
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{} : {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn retourne_resumable(estArticle: bool) -&gt; impl Resumable {
    if estArticle {
        ArticleDePresse {
            titre: String::from(&quot;Les Pinguins ont gagné la Stanley Cup Championship !&quot;),
            lieu: String::from(&quot;Pittsburgh, PA, USA&quot;),
            auteur: String::from(&quot;Iceburgh&quot;),
            contenu: String::from(&quot;Les Pinguins de Pittsburgh sont une nouvelle fois la
            meilleure équipe de hockey de la NHL.&quot;),
        }
    } else {
        Tweet {
            nom_utilisateur: String::from(&quot;jean&quot;),
            contenu: String::from(&quot;Bien sûr, les amis, comme vous le savez probablement déjà&quot;),
            reponse: false,
            retweet: false,
        }
    }
}
</code></pre>
<!--
Returning either a `NewsArticle` or a `Tweet` isn’t allowed due to restrictions
around how the `impl Trait` syntax is implemented in the compiler. We’ll cover
how to write a function with this behavior in the [“Using Trait Objects That
Allow for Values of Different
Types”][using-trait-objects-that-allow-for-values-of-different-types]<!--
ignore -- > section of Chapter 17.
-->
<p>Retourner soit un <code>ArticleDePresse</code>, soit un <code>Tweet</code> n'est pas autorisé à cause
des restrictions sur comment la syntaxe <code>impl Trait</code> est implémentée dans le
compilateur. Nous allons voir comment écrire une fonction avec ce comportement
dans une section du
<a href="ch17-02-trait-objects.html">chapitre 17</a><!--
ignore -->.</p>
<!--
### Fixing the `largest` Function with Trait Bounds
-->
<h3 id="résoudre-la-fonction-le_plus_grand-avec-les-traits-liés"><a class="header" href="#résoudre-la-fonction-le_plus_grand-avec-les-traits-liés">Résoudre la fonction <code>le_plus_grand</code> avec les traits liés</a></h3>
<!--
Now that you know how to specify the behavior you want to use using the generic
type parameter’s bounds, let’s return to Listing 10-5 to fix the definition of
the `largest` function that uses a generic type parameter! Last time we tried
to run that code, we received this error:
-->
<p>Maintenant que vous savez comment renseigner le comportement que vous souhaitez
utiliser en utilisant les paramètres de types génériques liés, retournons à
l'encart 10-5 pour résoudre la définition de la fonction <code>le_plus_grand</code> qui
utilise un paramètre de type générique ! La dernière fois qu'on a essayé de
lancer ce code, nous avions l'erreur suivante :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 -- > src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if element &gt; le_plus_grand {
  |            ------- ^ ------------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn le_plus_grand&lt;T: std::cmp::PartialOrd&gt;(liste: &amp;[T]) -&gt; T {
  |                  ^^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
<!--
In the body of `largest` we wanted to compare two values of type `T` using the
greater than (`>`) operator. Because that operator is defined as a default
method on the standard library trait `std::cmp::PartialOrd`, we need to specify
`PartialOrd` in the trait bounds for `T` so the `largest` function can work on
slices of any type that we can compare. We don’t need to bring `PartialOrd`
into scope because it’s in the prelude. Change the signature of `largest` to
look like this:
-->
<p>Dans le corps de <code>le_plus_grand</code> nous voulions comparer les deux valeurs du
type <code>T</code> en utilisant l'opérateur <em>plus grand que</em> (<code>&gt;</code>). Comme cet opérateur
est défini comme une méthode par défaut dans le trait de la bibliothèque
standard <code>std::cmp::PartialOrd</code>, nous devons préciser <code>PartialOrd</code> dans les
traits liés pour <code>T</code> afin que la fonction <code>le_plus_grand</code> puisse fonctionner sur
les slices de n'importe quel type que nous pouvons comparer. Nous n'avons pas
besoin d'importer <code>PartialOrd</code> dans la portée car il est importé dans l'étape
préliminaire. Changez la signature de <code>le_plus_grand</code> par quelque chose comme
ceci :</p>
<!--
```rust,ignore
fn largest<T: PartialOrd>(list: &[T]) -> T {
#     let mut largest = list[0];
# 
#     for &item in list {
#         if item > largest {
#             largest = item;
#         }
#     }
# 
#     largest
# }
# 
# fn main() {
#     let number_list = vec![34, 50, 25, 100, 65];
# 
#     let result = largest(&number_list);
#     println!("The largest number is {}", result);
# 
#     let char_list = vec!['y', 'm', 'a', 'q'];
# 
#     let result = largest(&char_list);
#     println!("The largest char is {}", result);
# }
```
-->
<pre><code class="language-rust ignore">fn le_plus_grand&lt;T: PartialOrd&gt;(liste: &amp;[T]) -&gt; T {
<span class="boring">    let mut le_plus_grand = liste[0];
</span><span class="boring">
</span><span class="boring">    for &amp;element in liste {
</span><span class="boring">        if element &gt; le_plus_grand {
</span><span class="boring">            le_plus_grand = element;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    le_plus_grand
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let liste_de_nombres = vec![34, 50, 25, 100, 65];
</span><span class="boring">
</span><span class="boring">    let resultat = le_plus_grand(&amp;liste_de_nombres);
</span><span class="boring">    println!(&quot;Le plus grand nombre est {}&quot;, resultat);
</span><span class="boring">
</span><span class="boring">    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];
</span><span class="boring">
</span><span class="boring">    let resultat = le_plus_grand(&amp;liste_de_caracteres);
</span><span class="boring">    println!(&quot;Le plus grand caractère est {}&quot;, resultat);
</span><span class="boring">}
</span></code></pre>
<!--
This time when we compile the code, we get a different set of errors:
-->
<p>Cette fois, lorsque nous allons compiler le code, nous aurons un ensemble
d'erreurs différent :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 -- > src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&list[0]`

error[E0507]: cannot move out of a shared reference
 -- > src/main.rs:4:18
  |
4 |     for &item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&`: `item`

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10` due to 2 previous errors
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 -- &gt; src/main.rs:2:23
  |
2 |     let mut le_plus_grand = liste[0];
  |                             ^^^^^^^^
  |                             |
  |                             cannot move out of here
  |                             move occurs because `liste[_]` has type `T`, which does not implement the `Copy` trait
  |                             help: consider borrowing here: `&amp;liste[0]`

error[E0507]: cannot move out of a shared reference
 -- &gt; src/main.rs:4:18
  |
4 |     for &amp;element in liste {
  |         --------    ^^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `element` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&amp;`: `element`

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10` due to 2 previous errors
</code></pre>
<!--
The key line in this error is `cannot move out of type [T], a non-copy slice`.
With our non-generic versions of the `largest` function, we were only trying to
find the largest `i32` or `char`. As discussed in the [“Stack-Only Data:
Copy”][stack-only-data-copy]<!-- ignore -- > section in Chapter 4, types like
`i32` and `char` that have a known size can be stored on the stack, so they
implement the `Copy` trait. But when we made the `largest` function generic,
it became possible for the `list` parameter to have types in it that don’t
implement the `Copy` trait. Consequently, we wouldn’t be able to move the
value out of `list[0]` and into the `largest` variable, resulting in this
error.
-->
<p>L'élement-clé dans ces erreurs est <code>cannot move out of type [T], a non-copy slice</code>. Avec notre version non générique de la fonction <code>le_plus_grand</code>, nous
avions essayé de trouver le plus grand <code>i32</code> ou <code>char</code>. Comme nous l'avons vu
dans la section
<a href="ch04-01-what-is-ownership.html#donn%C3%A9es-uniquement-sur-la-pile--la-copie">“Données uniquement sur la pile : la copie”</a><!--
ignore --> du chapitre 4, les types comme <code>i32</code> et <code>char</code> ont une taille connue
et peuvent être stockés sur la pile, donc ils implémentent le trait <code>Copy</code>. Par
conséquent, nous ne pouvons pas forcément déplacer la valeur de <code>list[0]</code> dans
notre variable <code>le_plus_grand</code>, ce qui engendre cette erreur.</p>
<!--
To call this code with only those types that implement the `Copy` trait, we can
add `Copy` to the trait bounds of `T`! Listing 10-15 shows the complete code of
a generic `largest` function that will compile as long as the types of the
values in the slice that we pass into the function implement the `PartialOrd`
*and* `Copy` traits, like `i32` and `char` do.
-->
<p>Pour pouvoir appeler ce code avec seulement les types qui implémentent le trait
<code>Copy</code>, nous pouvons ajouter <code>Copy</code> aux traits liés de <code>T</code> ! L'encart 10-15 nous
montre le code complet d'une fonction générique <code>le_plus_grand</code> qui va se
compiler tant que les types valeurs dans la slice que nous passons dans la
fonction implémente les traits <code>PartialOrd</code> <em>et</em> <code>Copy</code>, comme le font <code>i32</code> et
<code>char</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn le_plus_grand&lt;T: PartialOrd + Copy&gt;(liste: &amp;[T]) -&gt; T {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand(&amp;liste_de_nombres);
    println!(&quot;Le nombre le plus grand est {}&quot;, resultat);

    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];

    let resultat = le_plus_grand(&amp;liste_de_caracteres);
    println!(&quot;Le plus grand caractère est {}&quot;, resultat);
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-15: A working definition of the `largest`
function that works on any generic type that implements the `PartialOrd` and
`Copy` traits</span>
-->
<p><span class="caption">Encart 10-15 : une définition de la fonction
<code>le_plus_grand</code> qui fonctionne et s'applique sur n'importe quel type générique
qui implémente les traits <code>PartialOrd</code> et <code>Copy</code></span></p>
<!--
If we don’t want to restrict the `largest` function to the types that implement
the `Copy` trait, we could specify that `T` has the trait bound `Clone` instead
of `Copy`. Then we could clone each value in the slice when we want the
`largest` function to have ownership. Using the `clone` function means we’re
potentially making more heap allocations in the case of types that own heap
data like `String`, and heap allocations can be slow if we’re working with
large amounts of data.
-->
<p>Si nous ne souhaitons pas restreindre la fonction <code>le_plus_grand</code> aux types qui
implémentent le trait <code>Copy</code>, nous pouvons préciser que <code>T</code> a le trait lié
<code>Clone</code> plutôt que <code>Copy</code>. Ainsi, nous pouvons cloner chaque valeur dans la
slice lorsque nous souhaitons que la fonction <code>le_plus_grand</code> en prenne
possession. L'utilisation de la fonction <code>clone</code> signifie que nous allons
potentiellement allouer plus d'espace sur le tas dans le cas des types qui
possèdent des données sur le tas, comme <code>String</code>, et les allocations sur le tas
peuvent être lentes si nous travaillons avec des grandes quantités de données.</p>
<!--
Another way we could implement `largest` is for the function to return a
reference to a `T` value in the slice. If we change the return type to `&T`
instead of `T`, thereby changing the body of the function to return a
reference, we wouldn’t need the `Clone` or `Copy` trait bounds and we could
avoid heap allocations. Try implementing these alternate solutions on your own!
If you get stuck with errors having to do with lifetimes, keep reading: the
“Validating References with Lifetimes” section coming up will explain, but
lifetimes aren’t required to solve these challenges.
-->
<p>Une autre façon d'implémenter <code>le_plus_grand</code> est de faire en sorte que la
fonction retourne une référence à une valeur <code>T</code> de la slice. Si nous changeons
le type de retour en <code>&amp;T</code> à la place de <code>T</code>, ainsi qu'adapter le corps de la
fonction afin de retourner une référence, nous n'aurions alors plus besoin des
traits liés <code>Clone</code> ou <code>Copy</code> et nous pourrions ainsi éviter l'allocation sur
le tas. Essayez d'implémenter cette solution alternative par vous-même !
Si vous bloquez sur des erreurs à propos des durées de vie <em>(lifetimes)</em>, lisez
la suite : la section suivante, “La conformité des références avec les durées
de vies” vous expliquera cela, mais les durées de vie ne sont pas nécessaires
pour résoudre ces exercices.</p>
<!--
### Using Trait Bounds to Conditionally Implement Methods
-->
<h3 id="utiliser-les-traits-liés-pour-conditionner-limplémentation-des-méthodes"><a class="header" href="#utiliser-les-traits-liés-pour-conditionner-limplémentation-des-méthodes">Utiliser les traits liés pour conditionner l'implémentation des méthodes</a></h3>
<!--
By using a trait bound with an `impl` block that uses generic type parameters,
we can implement methods conditionally for types that implement the specified
traits. For example, the type `Pair<T>` in Listing 10-16 always implements the
`new` function. But `Pair<T>` only implements the `cmp_display` method if its
inner type `T` implements the `PartialOrd` trait that enables comparison *and*
the `Display` trait that enables printing.
-->
<p>En utilisant un trait lié avec un bloc <code>impl</code> qui utilise les paramètres de type
générique, nous pouvons implémenter des méthodes en fonction des types
qu'implémentent des traits particuliers. Par exemple, le type <code>Pair&lt;T&gt;</code> de
l'encart 10-16 implémente toujours la fonction <code>new</code>. Mais <code>Pair&lt;T&gt;</code> implémente
la méthode <code>affiche_comparaison</code> uniquement si son type interne <code>T</code>
implémente le trait <code>PartialOrd</code> qui active la comparaison <em>et</em> le trait
<code>Display</code> qui permet l'affichage.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```
-->
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn affiche_comparaison(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;Le plus grand élément est x = {}&quot;, self.x);
        } else {
            println!(&quot;Le plus grand élément est y = {}&quot;, self.y);
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 10-16: Conditionally implement methods on a
generic type depending on trait bounds</span>
-->
<p><span class="caption">Encart 10-16 : implémentation de méthodes sur un type
générique en fonction du trait lié</span></p>
<!--
We can also conditionally implement a trait for any type that implements
another trait. Implementations of a trait on any type that satisfies the trait
bounds are called *blanket implementations* and are extensively used in the
Rust standard library. For example, the standard library implements the
`ToString` trait on any type that implements the `Display` trait. The `impl`
block in the standard library looks similar to this code:
-->
<p>Nous pouvons également appliquer un trait sur un type qui applique un autre
trait. L'implémentation d'un trait sur n'importe quel type qui a un trait lié
est appelée <em>implémentation générale</em> et est largement utilisée dans la
bibliothèque standard Rust. Par exemple, la bibliothèque standard implémente le
trait <code>ToString</code> sur tous les types qui implémentent le trait <code>Display</code>. Le bloc
<code>impl</code> de la bibliothèque standard ressemble au code suivant :</p>
<!--
```rust,ignore
impl<T: Display> ToString for T {
    // --snip--
}
```
-->
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // -- partie masquée ici --
}
</code></pre>
<!--
Because the standard library has this blanket implementation, we can call the
`to_string` method defined by the `ToString` trait on any type that implements
the `Display` trait. For example, we can turn integers into their corresponding
`String` values like this because integers implement `Display`:
-->
<p>Comme la bibliothèque standard a cette implémentation générale, nous pouvons
appeler la méthode <code>to_string</code> définie par le trait <code>ToString</code> sur n'importe
quel type qui implémente le trait <code>Display</code>. Par exemple, nous pouvons
transformer les entiers en leur équivalent dans une <code>String</code> comme ci-dessous
car les entiers implémentent <code>Display</code> :</p>
<!--
```rust
let s = 3.to_string();
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<!--
Blanket implementations appear in the documentation for the trait in the
“Implementors” section.
-->
<p>Les implémentations générales sont décrites dans la documentation du trait, dans
la section “Implementors”.</p>
<!--
Traits and trait bounds let us write code that uses generic type parameters to
reduce duplication but also specify to the compiler that we want the generic
type to have particular behavior. The compiler can then use the trait bound
information to check that all the concrete types used with our code provide the
correct behavior. In dynamically typed languages, we would get an error at
runtime if we called a method on a type which didn’t define the method. But Rust
moves these errors to compile time so we’re forced to fix the problems before
our code is even able to run. Additionally, we don’t have to write code that
checks for behavior at runtime because we’ve already checked at compile time.
Doing so improves performance without having to give up the flexibility of
generics.
-->
<p>Les traits et les traits liés nous permettent d'écrire du code qui utilise des
paramètres de type générique pour réduire la duplication de code, mais aussi
pour indiquer au compilateur que nous voulons que le type générique ait un
comportement particulier. Le compilateur peut ensuite utiliser les informations
liées aux traits pour vérifier que tous les types concrets utilisés dans notre
code suivent le comportement souhaité. Dans les langages typés dynamiquement,
nous aurons une erreur à l'exécution si nous appelions une méthode sur un type
qui n'implémentait pas la méthode. Mais Rust décale l'apparition de ces erreurs
au moment de la compilation afin de nous forcer à résoudre les problèmes avant
même que notre code soit capable de s'exécuter. De plus, nous n'avons pas besoin
d'écrire un code qui vérifie le comportement lors de l'exécution car nous
l'avons déjà vérifié au moment de la compilation. Cela permet d'améliorer les
performances sans avoir à sacrifier la flexibilité des génériques.</p>
<!--
Another kind of generic that we’ve already been using is called *lifetimes*.
Rather than ensuring that a type has the behavior we want, lifetimes ensure
that references are valid as long as we need them to be. Let’s look at how
lifetimes do that.
-->
<p>Un autre type de générique que nous avons déjà utilisé est la <em>durée de vie</em>.
Plutôt que de s'assurer qu'un type a le comportement que nous voulons, la durée
de vie s'assure que les références sont en vigueur aussi longtemps que nous
avons besoin qu'elles le soient. Nous allons voir à la page suivante comment la
durée de vie fait cela.</p>
<!-- markdownlint-disable -->
<!--
[stack-only-data-copy]:
ch04-01-what-is-ownership.html#stack-only-data-copy
[using-trait-objects-that-allow-for-values-of-different-types]:
ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
-->
<!-- markdownlint-restore -->
<div style="break-before: page; page-break-before: always;"></div><!--
## Validating References with Lifetimes
-->
<h2 id="la-conformité-des-références-avec-les-durées-de-vies"><a class="header" href="#la-conformité-des-références-avec-les-durées-de-vies">La conformité des références avec les durées de vies</a></h2>
<!--
One detail we didn’t discuss in the [“References and
Borrowing”][references-and-borrowing]<!-- ignore -- > section in Chapter 4 is
that every reference in Rust has a *lifetime*, which is the scope for which
that reference is valid. Most of the time, lifetimes are implicit and
inferred, just like most of the time, types are inferred. We must annotate
types when multiple types are possible. In a similar way, we must annotate
lifetimes when the lifetimes of references could be related in a few different
ways. Rust requires us to annotate the relationships using generic lifetime
parameters to ensure the actual references used at runtime will definitely be
valid.
-->
<p>Il reste un détail que nous n'avons pas abordé dans la section <a href="ch04-02-references-and-borrowing.html#les-r%C3%A9f%C3%A9rences-et-lemprunt">“Les références
et l'emprunt”</a><!-- ignore --> du chapitre 4, c'est que
toutes les références ont une <em>durée de vie</em> dans Rust, qui est la portée pour
laquelle cette référence est en vigueur. La plupart du temps, les durées de
vies sont implicites et sont déduit automatiquement, comme pour la plupart du
temps les types sont déduits. Nous devons renseigner le type lorsque plusieurs
types sont possibles. De la même manière, nous devons renseigner les durées de
vie lorsque les durées de vies des références peuvent être déduites de
différentes manières. Rust nécessite que nous renseignons ces relations en
utilisant des paramètres de durée de vie génériques pour s'assurer que les
références utilisées au moment de la compilation restent bien en vigueur.</p>
<!--
The concept of lifetimes is somewhat different from tools in other programming
languages, arguably making lifetimes Rust’s most distinctive feature. Although
we won’t cover lifetimes in their entirety in this chapter, we’ll discuss
common ways you might encounter lifetime syntax so you can become familiar with
the concepts.
-->
<p>Le concept de la durée de vie est quelque chose de radicalement différent de ce
que l'on retrouve dans les outils des autres langages de programmation, à un
tel point que la durée de vie est la fonctionnalité qui distingue Rust des
autres. Bien que nous ne puissions couvrir l'intégralité de la durée de vie dans
ce chapitre, nous allons voir les cas les plus courants où vous allez
rencontrer la syntaxe de la durée de vie, afin de vous familiariser avec ses
concepts.</p>
<!--
### Preventing Dangling References with Lifetimes
-->
<h3 id="eviter-les-références-pendouillantes-avec-les-durées-de-vie"><a class="header" href="#eviter-les-références-pendouillantes-avec-les-durées-de-vie">Eviter les références pendouillantes avec les durées de vie</a></h3>
<!--
The main aim of lifetimes is to prevent dangling references, which cause a
program to reference data other than the data it’s intended to reference.
Consider the program in Listing 10-17, which has an outer scope and an inner
scope.
-->
<p>L'objectif principal des durées de vies est d'éviter les références
pendouillantes qui font qu'un programme pointe des données autres que celles sur
lesquelles il était censé pointer. Admettons le programme de l'encart 10-17, qui
a une portée externe et une portée interne.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    {
        let r;

        {
            let x = 5;
            r = &x;
        }

        println!("r: {}", r);
    }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    {
        let r;

        {
            let x = 5;
            r = &amp;x;
        }

        println!(&quot;r: {}&quot;, r);
    }
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-17: An attempt to use a reference whose value
has gone out of scope</span>
-->
<p><span class="caption">Encart 10-17 : tentative d'utiliser une référence vers
une valeur qui est sortie de la portée</span></p>
<!--
> Note: The examples in Listings 10-17, 10-18, and 10-24 declare variables
> without giving them an initial value, so the variable name exists in the
> outer scope. At first glance, this might appear to be in conflict with Rust’s
> having no null values. However, if we try to use a variable before giving it
> a value, we’ll get a compile-time error, which shows that Rust indeed does
> not allow null values.
-->
<blockquote>
<p>Remarque : Les exemples dans les encarts 10-17, 10-18 et 10-24 déclarent des
variables sans initialiser leur valeur, donc les noms de ces variables
existent dans la portée externe. A première vue, cela semble être en conflit
avec le fonctionnement de Rust qui n'utilise pas les valeurs nulles.
Cependant, si nous essayons d'utiliser une variable avant de lui donner une
valeur, nous aurons une erreur au moment de la compilation, qui confirme que
Rust ne fonctionne pas avec des valeurs nulles.</p>
</blockquote>
<!--
The outer scope declares a variable named `r` with no initial value, and the
inner scope declares a variable named `x` with the initial value of 5. Inside
the inner scope, we attempt to set the value of `r` as a reference to `x`. Then
the inner scope ends, and we attempt to print the value in `r`. This code won’t
compile because the value `r` is referring to has gone out of scope before we
try to use it. Here is the error message:
-->
<p>La portée externe déclare une variable <code>r</code> sans valeur initiale, et la portée
interne déclare une variable <code>x</code> avec la valeur initiale à <code>5</code>. Au sein de la
portée interne, nous essayons d'assigner la valeur de <code>r</code> comme étant une
référence à <code>x</code>. Puis la portée interne se ferme, et nous essayons d'afficher la
valeur dans <code>r</code>. Ce code ne va pas se compiler car la valeur <code>r</code> se réfère à
quelque chose qui est sortie de la portée avant que nous essayons de l'utiliser.
Voici le message d'erreur :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  -- > src/main.rs:7:17
   |
7  |             r = &x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  | 
10 |         println!("r: {}", r);
   |                           - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:7:17
   |
7  |             r = &amp;x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  | 
10 |         println!(&quot;r: {}&quot;, r);
   |                           - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
</code></pre>
<!--
The variable `x` doesn’t “live long enough.” The reason is that `x` will be out
of scope when the inner scope ends on line 7. But `r` is still valid for the
outer scope; because its scope is larger, we say that it “lives longer.” If
Rust allowed this code to work, `r` would be referencing memory that was
deallocated when `x` went out of scope, and anything we tried to do with `r`
wouldn’t work correctly. So how does Rust determine that this code is invalid?
It uses a borrow checker.
-->
<p>La variable <code>x</code> n'existe plus (“does not live long enough”). La raison à cela
est que <code>x</code> est sortie de la portée lorsque la portée interne s'est fermée à la
ligne 7. Mais <code>r</code> reste en vigueur dans la portée externe ; car sa portée est
plus grande, on dit qu'il “vit plus longtemps”. Si Rust avait permis à ce code de
s'exécuter, <code>r</code> pointerait sur de la mémoire désallouée dès que <code>x</code> est sortie
de la portée, ainsi tout ce que nous pourrions faire avec <code>r</code> ne fonctionnerait
pas correctement. Mais comment Rust détecte que ce code est invalide ? Il
utilise le vérificateur d'emprunt.</p>
<!--
### The Borrow Checker
-->
<h3 id="le-vérificateur-demprunt"><a class="header" href="#le-vérificateur-demprunt">Le vérificateur d'emprunt</a></h3>
<!--
The Rust compiler has a *borrow checker* that compares scopes to determine
whether all borrows are valid. Listing 10-18 shows the same code as Listing
10-17 but with annotations showing the lifetimes of the variables.
-->
<p>Le compilateur de Rust embarque un <em>vérificateur d'emprunt</em> (borrow checker) qui
compare les portées pour déterminer si les emprunts sont valides. L'encart 10-18
montre le même code que l'encart 10-17, mais avec des commentaires qui montrent
les durées de vies des variables.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &x;           //  |       |
        }                     // -+       |
                              //          |
        println!("r: {}", r); //          |
    }                         // ---------+
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &amp;x;           //  |       |
        }                     // -+       |
                              //          |
        println!(&quot;r: {}&quot;, r); //          |
    }                         // ---------+
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-18: Annotations of the lifetimes of `r` and
`x`, named `'a` and `'b`, respectively</span>
-->
<p><span class="caption">Encart 10-18 : commentaires pour montrer les durées de vie
de <code>r</code> et <code>x</code>, qui s'appellent respectivement <code>'a</code> et <code>'b</code></span></p>
<!--
Here, we’ve annotated the lifetime of `r` with `'a` and the lifetime of `x`
with `'b`. As you can see, the inner `'b` block is much smaller than the outer
`'a` lifetime block. At compile time, Rust compares the size of the two
lifetimes and sees that `r` has a lifetime of `'a` but that it refers to memory
with a lifetime of `'b`. The program is rejected because `'b` is shorter than
`'a`: the subject of the reference doesn’t live as long as the reference.
-->
<p>Ici, nous avons montré la durée de vie de <code>r</code> avec <code>'a</code> et la durée de vie de
<code>x</code> avec <code>'b</code>. Comme vous pouvez le constater, le bloc interne <code>'b</code> est bien
plus petit que le bloc externe <code>'a</code>. Au moment de la compilation, Rust compare
les tailles des deux durées de vies et constate que <code>r</code> a la durée de vie <code>'a</code>
mais fait référence à de la mémoire qui a une durée de vie de <code>'b</code>. Ce programme
est refusé car <code>'b</code> est plus court que <code>'a</code> : l'élément pointé par la référence
n'existe pas aussi longtemps que la référence.</p>
<!--
Listing 10-19 fixes the code so it doesn’t have a dangling reference and
compiles without any errors.
-->
<p>L'encart 10-19 résout le code afin qu'il n'ai plus de référence pendouillante et
qu'il se compile sans erreur.</p>
<!--
```rust
# fn main() {
    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &x;           // --+-- 'a  |
                              //   |       |
        println!("r: {}", r); //   |       |
                              // --+       |
    }                         // ----------+
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &amp;x;           // --+-- 'a  |
                              //   |       |
        println!(&quot;r: {}&quot;, r); //   |       |
                              // --+       |
    }                         // ----------+
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-19: A valid reference because the data has a
longer lifetime than the reference</span>
-->
<p><span class="caption">Encart 10-19 : la référence est valide puisque la donnée a
une durée de vie plus longue que la référence</span></p>
<!--
Here, `x` has the lifetime `'b`, which in this case is larger than `'a`. This
means `r` can reference `x` because Rust knows that the reference in `r` will
always be valid while `x` is valid.
-->
<p>Ici, <code>x</code> a la durée de vie <code>'b</code>, qui est plus grand dans ce cas que <code>'a</code>. Cela
signifie que <code>r</code> peut référencer <code>x</code> car Rust sait que la référence présente
dans <code>r</code> sera toujours valide du moment que <code>x</code> est en vigueur.</p>
<!--
Now that you know where the lifetimes of references are and how Rust analyzes
lifetimes to ensure references will always be valid, let’s explore generic
lifetimes of parameters and return values in the context of functions.
-->
<p>Maintenant que vous savez où se situent les durées de vie des références et
comment Rust analyse les durées de vies pour s'assurer que les références soient
toujours en vigueur, découvrons les durées de vies génériques des paramètres et
des valeurs de retour dans le cas des fonctions.</p>
<!--
### Generic Lifetimes in Functions
-->
<h3 id="les-durées-de-vies-génériques-dans-les-fonctions"><a class="header" href="#les-durées-de-vies-génériques-dans-les-fonctions">Les durées de vies génériques dans les fonctions</a></h3>
<!--
Let’s write a function that returns the longer of two string slices. This
function will take two string slices and return a string slice. After we’ve
implemented the `longest` function, the code in Listing 10-20 should print `The
longest string is abcd`.
-->
<p>Ecrivons une fonction qui retourne la plus longue des slice d'une chaîne de
caractères. Cette fonction va prendre en argument deux slices de chaîne de
caractères et retourner une slice d'une chaîne de caractères. Après avoir
implémenté la fonction <code>la_plus_longue</code>, le code de l'encart 10-20 devrait
afficher <code>La plus grande chaîne est abcd</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```
-->
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let resultat = la_plus_longue(string1.as_str(), string2);
    println!(&quot;La plus grande chaîne est {}&quot;, resultat);
}
</code></pre>
<!--
<span class="caption">Listing 10-20: A `main` function that calls the `longest`
function to find the longer of two string slices</span>
-->
<p><span class="caption">Encart 10-20 : une fonction <code>main</code> qui appelle la
fonction <code>la_plus_longue</code> pour trouver la plus grande des deux slices de chaîne
de caractères
</span></p>
<!--
Note that we want the function to take string slices, which are references,
because we don’t want the `longest` function to take ownership of its
parameters. Refer to the [“String Slices as
Parameters”][string-slices-as-parameters]<!-- ignore -- > section in Chapter 4
for more discussion about why the parameters we use in Listing 10-20 are the
ones we want.
-->
<p>Remarquez que nous souhaitons que la fonction prenne deux slices de chaînes de
caractères, qui sont des références, car nous ne voulons pas que la fonction
<code>la_plus_longue</code> prenne possession de ses paramètres. Rendez-vous à la section
<a href="ch04-03-slices.html#les-slices-de-cha%C3%AEnes-de-caract%C3%A8res-en-param%C3%A8tres">“Les slices de chaînes de caractères en
paramètres”</a><!-- ignore --> du chapitre 4 pour
savoir pourquoi nous utilisons ce type de paramètre dans l'encart 10-20.</p>
<!--
If we try to implement the `longest` function as shown in Listing 10-21, it
won’t compile.
-->
<p>Si nous essayons d'implémenter la fonction <code>la_plus_longue</code> comme dans l'encart
10-21, cela ne va pas se compiler.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "xyz";
# 
#     let result = longest(string1.as_str(), string2);
#     println!("The longest string is {}", result);
# }
# 
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;La plus grande chaîne est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>fn la_plus_longue(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<!--
<span class="caption">Listing 10-21: An implementation of the `longest`
function that returns the longer of two string slices but does not yet
compile</span>
-->
<p><span class="caption">Encart 10-21 : une implémentation de la fonction
<code>la_plus_longue</code> qui retourne la plus longue des deux slices de chaînes de
caractères, mais ne se compile pas encore</span></p>
<!--
Instead, we get the following error that talks about lifetimes:
-->
<p>A la place, nous obtenons l'erreur suivante qui nous parle de durées de vie :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 -- > src/main.rs:9:33
  |
9 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  |           ^^^^    ^^^^^^^     ^^^^^^^     ^^^

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn la_plus_longue(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                      ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |                  ^^^^    ^^^^^^^     ^^^^^^^     ^^^

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` due to previous error
</code></pre>
<!--
The help text reveals that the return type needs a generic lifetime parameter
on it because Rust can’t tell whether the reference being returned refers to
`x` or `y`. Actually, we don’t know either, because the `if` block in the body
of this function returns a reference to `x` and the `else` block returns a
reference to `y`!
-->
<p>La partie “help” nous explique que le type de retour a besoin d'un paramètre de
durée de vie générique car Rust ne sait pas si la référence retournée est liée à
<code>x</code> ou à <code>y</code>. Pour le moment, nous ne le savons pas nous non plus, car le bloc
<code>if</code> dans le corps de cette fonction retourne une référence à <code>x</code> et le bloc
<code>else</code> retourne une référence à <code>y</code> !</p>
<!--
When we’re defining this function, we don’t know the concrete values that will
be passed into this function, so we don’t know whether the `if` case or the
`else` case will execute. We also don’t know the concrete lifetimes of the
references that will be passed in, so we can’t look at the scopes as we did in
Listings 10-18 and 10-19 to determine whether the reference we return will
always be valid. The borrow checker can’t determine this either, because it
doesn’t know how the lifetimes of `x` and `y` relate to the lifetime of the
return value. To fix this error, we’ll add generic lifetime parameters that
define the relationship between the references so the borrow checker can
perform its analysis.
-->
<p>Lorsque nous définissons cette fonction, nous ne connaissons pas les valeurs
concrètes qui vont passer dans cette fonction, donc nous ne savons pas si nous
allons exécuter le cas du <code>if</code> ou du <code>else</code>. Nous ne connaissons pas non plus les
durées de vie des références qui vont passer dans la fonction, donc nous ne
pouvons pas vérifier les portées comme nous l'avons fait dans les encarts 10-18
et 10-19 pour déterminer que la référence que nous allons retourner sera
toujours en vigueur. Le vérificateur d'emprunt ne va pas pouvoir non plus
déterminer cela, car il ne sait comment les durées de vie de <code>x</code> et de <code>y</code> sont
reliées à la durée de vie de la valeur de retour. Pour résoudre cette erreur,
nous allons ajouter des paramètres de durée de vie génériques qui définissent
la relation entre les références, afin que le vérificateur d'emprunt puisse
faire cette analyse.</p>
<!--
### Lifetime Annotation Syntax
-->
<h3 id="la-syntaxe-pour-annoter-les-durées-de-vies"><a class="header" href="#la-syntaxe-pour-annoter-les-durées-de-vies">La syntaxe pour annoter les durées de vies</a></h3>
<!--
Lifetime annotations don’t change how long any of the references live. Just
as functions can accept any type when the signature specifies a generic type
parameter, functions can accept references with any lifetime by specifying a
generic lifetime parameter. Lifetime annotations describe the relationships of
the lifetimes of multiple references to each other without affecting the
lifetimes.
-->
<p>L'annotation des durées de vie ne change pas la longueur de leur durée de vie.
Comme une fonction accepte n'importe quel type lorsque la signature utilise un
paramètre de type générique, les fonctions peuvent accepter des références avec
n'importe quelle durée de vie en précisant un paramètre de durée de vie
générique. L'annotation des durées de vie décrit la relation des durées de vies
de plusieurs références entre elles sans influencer les durées de vie.</p>
<!--
Lifetime annotations have a slightly unusual syntax: the names of lifetime
parameters must start with an apostrophe (`'`) and are usually all lowercase and
very short, like generic types. Most people use the name `'a`. We place
lifetime parameter annotations after the `&` of a reference, using a space to
separate the annotation from the reference’s type.
-->
<p>L'annotation des durées de vies a une syntaxe un peu inhabituelle : le nom des
paramètres de durées de vies doit commencer par une apostrophe (<code>'</code>) et sont
habituellement en minuscule et très court, comme les types génériques. La
plupart des personnes utilisent le nom <code>'a</code>. Nous plaçons le paramètre de type
après le <code>&amp;</code> d'une référence, en utilisant un espace pour séparer l'annotation
du type de la référence.</p>
<!--
Here are some examples: a reference to an `i32` without a lifetime parameter, a
reference to an `i32` that has a lifetime parameter named `'a`, and a mutable
reference to an `i32` that also has the lifetime `'a`.
-->
<p>Voici quelques exemples : une référence à un <code>i32</code> sans paramètre de durée de
vie, une référence à un <code>i32</code> qui a un paramètre de durée de vie <code>'a</code>, et une
référence mutable à un <code>i32</code> qui a aussi la durée de vie <code>'a</code>.</p>
<!--
```rust,ignore
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```
-->
<pre><code class="language-rust ignore">&amp;i32        // une référence
&amp;'a i32     // une référence avec une durée de vie explicite
&amp;'a mut i32 // une référence mutable avec une durée de vie explicite
</code></pre>
<!--
One lifetime annotation by itself doesn’t have much meaning, because the
annotations are meant to tell Rust how generic lifetime parameters of multiple
references relate to each other. For example, let’s say we have a function with
the parameter `first` that is a reference to an `i32` with lifetime `'a`. The
function also has another parameter named `second` that is another reference to
an `i32` that also has the lifetime `'a`. The lifetime annotations indicate
that the references `first` and `second` must both live as long as that generic
lifetime.
-->
<p>Une annotation de durée de vie toute seule n'a pas vraiment de sens, car les
annotations sont faites pour indiquer à Rust quels paramètres de durée de vie
génériques de plusieurs références sont liés aux autres. Par exemple, disons que
nous avons une fonction avec le paramètre <code>premier</code> qui est une référence à un
<code>i32</code> avec la durée de vie <code>'a</code>. La fonction a aussi un autre paramètre <code>second</code>
qui est une autre référence à un <code>i32</code> qui a aussi la durée de vie <code>'a</code>. Les
annotations de durée de vie indiquent que les références <code>premier</code> et <code>second</code>
doivent tous les deux exister aussi longtemps que la durée de vie générique.</p>
<!--
### Lifetime Annotations in Function Signatures
-->
<h3 id="les-annotations-de-durée-de-vie-dans-les-signatures-des-fonctions"><a class="header" href="#les-annotations-de-durée-de-vie-dans-les-signatures-des-fonctions">Les annotations de durée de vie dans les signatures des fonctions</a></h3>
<!--
Now let’s examine lifetime annotations in the context of the `longest`
function. As with generic type parameters, we need to declare generic lifetime
parameters inside angle brackets between the function name and the parameter
list. The constraint we want to express in this signature is that all the
references in the parameters and the return value must have the same lifetime.
We’ll name the lifetime `'a` and then add it to each reference, as shown in
Listing 10-22.
-->
<p>Maintenant, examinons les annotations de durée de vie dans contexte de la
fonction <code>la_plus_longue</code>. Comme avec les paramètres de type génériques, nous
devons déclarer les paramètres de durée de vie génériques dans des chevrons
entre le nom de la fonction et la liste des paramètres. Nous souhaitons
contraindre toutes les références dans les paramètres de cette fonction ainsi
que sa valeur de retour aient tous la même durée de vie. Nous allons appeler la
durée de vie <code>'a</code> et ensuite l'ajouter à chaque référence, comme nous le faisons
dans l'encart 10-22.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "xyz";
# 
#     let result = longest(string1.as_str(), string2);
#     println!("The longest string is {}", result);
# }
# 
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;La plus grande chaîne est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-22: The `longest` function definition
specifying that all the references in the signature must have the same lifetime
`'a`</span>
-->
<p><span class="caption">Encart 10-22 : définition de la fonction <code>la_plus_longue</code>
qui indique que toutes les références présentes dans la signature doivent avoir
la même durée de vie <code>'a</code></span></p>
<!--
This code should compile and produce the result we want when we use it with the
`main` function in Listing 10-20.
-->
<p>Le code devrait se compiler et devrait produire le résultat que nous souhaitions
lorsque nous l'utilisions dans la fonction <code>main</code> de l'encart 10-20.</p>
<!--
The function signature now tells Rust that for some lifetime `'a`, the function
takes two parameters, both of which are string slices that live at least as
long as lifetime `'a`. The function signature also tells Rust that the string
slice returned from the function will live at least as long as lifetime `'a`.
In practice, it means that the lifetime of the reference returned by the
`longest` function is the same as the smaller of the lifetimes of the
references passed in. These constraints are what we want Rust to enforce.
Remember, when we specify the lifetime parameters in this function signature,
we’re not changing the lifetimes of any values passed in or returned. Rather,
we’re specifying that the borrow checker should reject any values that don’t
adhere to these constraints. Note that the `longest` function doesn’t need to
know exactly how long `x` and `y` will live, only that some scope can be
substituted for `'a` that will satisfy this signature.
-->
<p>La signature de la fonction indique maintenant à Rust que pour la durée de vie
<code>'a</code>, la fonction prend deux paramètres, les deux étant des slices de chaîne de
caractère qui vivent aussi longtemps que la durée de vie <code>'a</code>. La signature de
la fonction indique également à Rust que la slice de chaîne de caractère qui est
retournée par la fonction vivra au moins aussi longtemps que la durée de vie
<code>'a</code>. Dans la pratique, cela veut dire que durée de vie de la référence
retournée par la fonction <code>la_plus_longue</code> est la même que celle de la plus
petite des durées de vies des références qu'on lui donne. Ces restrictions sont
celles que nous voulons que Rust fasse respecter. Souvenez-vous, lorsque nous
précisons les paramètres de durée de vie dans la signature de cette fonction,
nous ne changons pas les durées de vies des valeurs qui lui sont envoyées ou
qu'elle retourne. Ce que nous faisons, c'est plutôt indiquer au vérificateur
d'emprunt qu'il doit rejeter toute valeur qui ne répond pas à ces conditions.
Notez que la fonction <code>la_plus_longue</code> n'a pas besoin de savoir exactement
combien de temps <code>x</code> et <code>y</code> vont exister, mais seulement que cette portée peut
être substituée par <code>'a</code>, qui satisfera cette signature.</p>
<!--
When annotating lifetimes in functions, the annotations go in the function
signature, not in the function body. Rust can analyze the code within the
function without any help. However, when a function has references to or from
code outside that function, it becomes almost impossible for Rust to figure out
the lifetimes of the parameters or return values on its own. The lifetimes
might be different each time the function is called. This is why we need to
annotate the lifetimes manually.
-->
<p>Lorsqu'on précise les durées de vie dans les fonctions, les annotations se
placent dans la signature de la fonction, pas dans le corps de la fonction. Rust
peut analyser le code à l'intérieur du corps sans aucune aide. Cependant,
lorsqu'une fonction a des références vers du code externe ou que ce code
réutilise une référence retournée par cette fonction, il devient presque
impossible pour Rust de déduire tout seul les durées de vie des paramètres ou
des valeurs de retour. Les durées de vies peuvent être différentes à chaque fois
que la fonction est appelée. C'est pourquoi nous avons besoin d'indiquer les
durées de vie manuellement.</p>
<!--
When we pass concrete references to `longest`, the concrete lifetime that is
substituted for `'a` is the part of the scope of `x` that overlaps with the
scope of `y`. In other words, the generic lifetime `'a` will get the concrete
lifetime that is equal to the smaller of the lifetimes of `x` and `y`. Because
we’ve annotated the returned reference with the same lifetime parameter `'a`,
the returned reference will also be valid for the length of the smaller of the
lifetimes of `x` and `y`.
-->
<p>Lorsque nous donnons une référence concrète à <code>la_plus_longue</code>, la durée de vie
concrète qui est modélisée par <code>'a</code> est la partie de la portée de <code>x</code> qui se
chevauche avec la portée de <code>y</code>. Autrement dit, la durée vie générique <code>'a</code> aura
la durée de vie concrète qui est égale à la plus petite des durées de vies entre
<code>x</code> et <code>y</code>. Comme nous avons marqué la référence retournée avec le même
paramètre de durée de vie <code>'a</code>, la référence retournée sera toujours en vigueur
pour la durée de la plus petite des durées de vies de <code>x</code> et de <code>y</code>.</p>
<!--
Let’s look at how the lifetime annotations restrict the `longest` function by
passing in references that have different concrete lifetimes. Listing 10-23 is
a straightforward example.
-->
<p>Regardons comment les annotations de durée de vie restreignent la fonction
<code>la_plus_longue</code> en y passant des références qui ont des durées de vies
concrètement différentes. L'encart 10-23 en est un exemple.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
}
# 
# fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
#     if x.len() > y.len() {
#         x
#     } else {
#         y
#     }
# }
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;une longue chaîne est longue&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let resultat = la_plus_longue(string1.as_str(), string2.as_str());
        println!(&quot;La chaîne la plus longue est {}&quot;, resultat);
    }
}
<span class="boring">
</span><span class="boring">fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-23: Using the `longest` function with
references to `String` values that have different concrete lifetimes</span>
-->
<p><span class="caption">Encart 10-23 : utilisation de la fonction <code>la_plus_longue</code>
sur des références à des valeurs <code>String</code> qui ont concrètement des durées de vie
différentes</span></p>
<!--
In this example, `string1` is valid until the end of the outer scope, `string2`
is valid until the end of the inner scope, and `result` references something
that is valid until the end of the inner scope. Run this code, and you’ll see
that the borrow checker approves of this code; it will compile and print `The
longest string is long string is long`.
-->
<p>Dans cet exemple, <code>string1</code> est en vigueur jusqu'à la fin de la portée externe,
<code>string2</code> n'est valide que jusqu'à la fin de la portée interne, et <code>resultat</code>
est une référence vers quelque chose qui est en vigueur jusqu'à la fin de la
portée interne. Lorsque vous lancez ce code, vous constaterez que le
vérificateur d'emprunt accepte ce code ; il va se compiler et afficher
<code>La chaîne la plus longue est une longue chaîne est longue</code>.</p>
<!--
Next, let’s try an example that shows that the lifetime of the reference in
`result` must be the smaller lifetime of the two arguments. We’ll move the
declaration of the `result` variable outside the inner scope but leave the
assignment of the value to the `result` variable inside the scope with
`string2`. Then we’ll move the `println!` that uses `result` outside the inner
scope, after the inner scope has ended. The code in Listing 10-24 will not
compile.
-->
<p>Maintenant, essayons un exemple qui fait en sorte que la durée de vie de la
référence dans <code>resultat</code> sera plus petite que celles des deux arguments. Nous
allons déplacer la déclaration de la variable <code>resultat</code> à l'extérieur de la
portée interne mais on va laisser l'affectation de la valeur de la variable
<code>resultat</code> à l'intérieur de la portée de <code>string2</code>. Nous allons ensuite déplacer
le <code>println!</code>, qui utilise <code>resultat</code>, à l'extérieur de la portée interne, après
que la portée soit terminée. Le code de l'encart 10-24 ne va pas se compiler.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}
# 
# fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
#     if x.len() > y.len() {
#         x
#     } else {
#         y
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from(&quot;une longue chaîne est longue&quot;);
    let resultat;
    {
        let string2 = String::from(&quot;xyz&quot;);
        resultat = la_plus_longue(string1.as_str(), string2.as_str());
    }
    println!(&quot;La chaîne la plus longue est {}&quot;, resultat);
}
<span class="boring">
</span><span class="boring">fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-24: Attempting to use `result` after `string2`
has gone out of scope</span>
-->
<p><span class="caption">Encart 10-24 : tentative d'utilisation de <code>resultat</code> après
<code>string2</code>, qui est sortie de la portée</span></p>
<!--
When we try to compile this code, we’ll get this error:
-->
<p>Lorsque nous essayons de compiler ce code, nous aurons cette erreur :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 -- > src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {}", result);
  |                                          ------ borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
6 |         result = la_plus_longue(string1.as_str(), string2.as_str());
  |                                                   ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;La chaîne la plus longue est {}&quot;, resultat);
  |                                                 -------- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
</code></pre>
<!--
The error shows that for `result` to be valid for the `println!` statement,
`string2` would need to be valid until the end of the outer scope. Rust knows
this because we annotated the lifetimes of the function parameters and return
values using the same lifetime parameter `'a`.
-->
<p>L'erreur explique que pour que <code>resultat</code> soit en vigueur pour l'instruction
<code>println!</code>, <code>string2</code> doit toujours être valide jusqu'à la fin de la portée
externe. Rust en a déduit cela car nous avons précisé les durées de vie des
paramètres de la fonction et des valeurs de retour en utilisant le même
paramètre de durée de vie <code>'a</code>.</p>
<!--
As humans, we can look at this code and see that `string1` is longer than
`string2` and therefore `result` will contain a reference to `string1`.
Because `string1` has not gone out of scope yet, a reference to `string1` will
still be valid for the `println!` statement. However, the compiler can’t see
that the reference is valid in this case. We’ve told Rust that the lifetime of
the reference returned by the `longest` function is the same as the smaller of
the lifetimes of the references passed in. Therefore, the borrow checker
disallows the code in Listing 10-24 as possibly having an invalid reference.
-->
<p>En tant qu'humain, nous pouvons lire ce code et constater que <code>string1</code> est plus
grand que <code>string2</code> et ainsi que <code>resultat</code> contiendra une référence vers
<code>string1</code>. Comme <code>string1</code> n'est pas encore sorti de portée, une référence vers
<code>string1</code> sera toujours valide pour l'instruction <code>println!</code>. Cependant, le
compilateur ne peut pas déduire que la référence est valide dans notre cas. Nous
avons dit à Rust que la durée de vie de la référence qui est retournée par la
fonction <code>la_plus_longue</code> est la même que la plus petite des durées de vie des
références qu'on lui passe en argument. C'est pourquoi le vérificateur d'emprunt
rejette le code de l'encart 10-24 car il a potentiellement une référence
invalide.</p>
<!--
Try designing more experiments that vary the values and lifetimes of the
references passed in to the `longest` function and how the returned reference
is used. Make hypotheses about whether or not your experiments will pass the
borrow checker before you compile; then check to see if you’re right!
-->
<p>Essayez d'expérimenter d'autres situations en variant les valeurs et durées de
vie des références passées en argument de la fonction <code>la_plus_longue</code>, et
aussi comment on utilise la référence retournée. Faites des hypothèses si ces
situations vont passer ou non le vérificateur d'emprunt avant que vous
compiliez ; et vérifiez ensuite si vous avez raison !</p>
<!--
### Thinking in Terms of Lifetimes
-->
<h3 id="penser-en-termes-de-durées-de-vie"><a class="header" href="#penser-en-termes-de-durées-de-vie">Penser en termes de durées de vie</a></h3>
<!--
The way in which you need to specify lifetime parameters depends on what your
function is doing. For example, if we changed the implementation of the
`longest` function to always return the first parameter rather than the longest
string slice, we wouldn’t need to specify a lifetime on the `y` parameter. The
following code will compile:
-->
<p>La façon dont vous avez à préciser les paramètres de durées de vie dépend de ce
que fait votre fonction. Par exemple, si nous changions l'implémentation de la
fonction <code>la_plus_longue</code> pour qu'elle retourne systématiquement le premier
paramètre plutôt que la slice de chaîne de caractères la plus longue, nous
n'aurions pas besoin de renseigner une durée de vie sur le paramètre <code>y</code>. Le
code suivant se compile :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "efghijklmnopqrstuvwxyz";
# 
#     let result = longest(string1.as_str(), string2);
#     println!("The longest string is {}", result);
# }
# 
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;efghijklmnopqrstuvwxyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;La chaîne la plus longue est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>fn la_plus_longue&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</code></pre></pre>
<!--
In this example, we’ve specified a lifetime parameter `'a` for the parameter
`x` and the return type, but not for the parameter `y`, because the lifetime of
`y` does not have any relationship with the lifetime of `x` or the return value.
-->
<p>Dans cet exemple, nous avons précisé un paramètre de durée de vie <code>'a</code> sur le
paramètre <code>x</code> et sur le type de retour, mais pas sur le paramètre <code>y</code>, car la
durée de vie de <code>y</code> n'a pas de lien avec la durée de vie de <code>x</code> ou de la valeur
de retour.</p>
<!--
When returning a reference from a function, the lifetime parameter for the
return type needs to match the lifetime parameter for one of the parameters. If
the reference returned does *not* refer to one of the parameters, it must refer
to a value created within this function, which would be a dangling reference
because the value will go out of scope at the end of the function. Consider
this attempted implementation of the `longest` function that won’t compile:
-->
<p>Lorsqu'on retourne une référence à partir d'une fonction, le paramètre de la
durée de vie pour le type de retour doit correspondre à une des durées des
paramètres. Si la référence retournée ne se réfère <em>pas</em> à un de ses paramètres,
elle se réfère probablement à une valeur crée à l'intérieur de cette fonction,
et elle deviendra une référence pendouillante car sa valeur va sortir de la
portée à la fin de la fonction. Imaginons cette tentative d'implémentation de
la fonction <code>la_plus_longue</code> qui ne se compile pas :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "xyz";
# 
#     let result = longest(string1.as_str(), string2);
#     println!("The longest string is {}", result);
# }
# 
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;La chaîne la plus longue est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>fn la_plus_longue&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let resultat = String::from(&quot;très longue chaîne&quot;);
    resultat.as_str()
}
</code></pre>
<!--
Here, even though we’ve specified a lifetime parameter `'a` for the return
type, this implementation will fail to compile because the return value
lifetime is not related to the lifetime of the parameters at all. Here is the
error message we get:
-->
<p>Ici, même si nous avons précisé un paramètre de durée de vie <code>'a</code> sur le type de
retour, cette implémentation va échouer à la compilation car la durée de vie de
la valeur de retour n'est pas du tout liée à la durée de vie des paramètres.
Voici le message d'erreur que nous obtenons :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  -- > src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `resultat`
  --&gt; src/main.rs:11:5
   |
11 |     resultat.as_str()
   |     --------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `resultat` is borrowed here

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` due to previous error
</code></pre>
<!--
The problem is that `result` goes out of scope and gets cleaned up at the end
of the `longest` function. We’re also trying to return a reference to `result`
from the function. There is no way we can specify lifetime parameters that
would change the dangling reference, and Rust won’t let us create a dangling
reference. In this case, the best fix would be to return an owned data type
rather than a reference so the calling function is then responsible for
cleaning up the value.
-->
<p>Le problème est que <code>resultat</code> sort de la portée et est effacée à la fin de la
fonction <code>la_plus_longue</code>. Nous avons aussi essayé de retourner une référence
vers <code>resultat</code> à partir de la fonction. Il n'existe aucune façon d'écrire les
paramètres de durée de vie de telle manière que cela changerait la référence
pendouillante, et Rust ne nous laissera pas créer une référence pendouillante.
Dans notre cas, la meilleure solution est de retourner un type de donnée dont on
va prendre possession plutôt qu'une référence, ainsi le code appelant sera
responsable du nettoyage de la valeur.</p>
<!--
Ultimately, lifetime syntax is about connecting the lifetimes of various
parameters and return values of functions. Once they’re connected, Rust has
enough information to allow memory-safe operations and disallow operations that
would create dangling pointers or otherwise violate memory safety.
-->
<p>Enfin, la syntaxe de la durée de vie sert à interconnecter les durées de vie de
plusieurs paramètres ainsi que les valeurs de retour des fonctions. Une fois
interconnectés, Rust a assez d'informations pour autoriser les opérations
sécurisées dans la mémoire et refuser les opérations qui pourraient créer des
pointeurs pendouillants ou alors enfreindre la sécurité de la mémoire.</p>
<!--
### Lifetime Annotations in Struct Definitions
-->
<h3 id="lajout-des-durées-de-vies-dans-les-définitions-des-structures"><a class="header" href="#lajout-des-durées-de-vies-dans-les-définitions-des-structures">L'ajout des durées de vies dans les définitions des structures</a></h3>
<!--
So far, we’ve only defined structs to hold owned types. It’s possible for
structs to hold references, but in that case we would need to add a lifetime
annotation on every reference in the struct’s definition. Listing 10-25 has a
struct named `ImportantExcerpt` that holds a string slice.
-->
<p>Jusqu'à présent, nous avons défini des structures pour contenir des types qui
sont possédés par elles-mêmes. Il est possible qu'une structure puisse contenir
des références, mais dans ce cas nous devons préciser une durée de vie sur
chaque référence dans la définition de la structure. L'encart 10-25 montre une
structure <code>ExtraitImportant</code> qui stocke une slice de chaîne de caractères.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct ExtraitImportant&lt;'a&gt; {
    partie: &amp;'a str,
}

fn main() {
    let roman = String::from(&quot;Appelez-moi Ismaël. Il y a quelques années ...&quot;);
    let premiere_phrase = roman.split('.')
        .next()
        .expect(&quot;Impossible de trouver un '.'&quot;);
    let i = ExtraitImportant { partie: premiere_phrase };
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-25: A struct that holds a reference, so its
definition needs a lifetime annotation</span>
-->
<p><span class="caption">Encart 10-25 : une structure qui stocke une référence,
par conséquent sa définition a besoin d'une annotation de durée de vie</span></p>
<!--
This struct has one field, `part`, that holds a string slice, which is a
reference. As with generic data types, we declare the name of the generic
lifetime parameter inside angle brackets after the name of the struct so we can
use the lifetime parameter in the body of the struct definition. This
annotation means an instance of `ImportantExcerpt` can’t outlive the reference
it holds in its `part` field.
-->
<p>Cette structure a un champ, <code>partie</code>, qui stocke une slice de chaîne de
caractères, qui est une référence. Comme pour les types de données génériques,
nous déclarons le nom du paramètre de durée de vie générique entre des chevrons
après le nom de la structure pour que nous puissions utiliser le paramètre de
durée de vie dans le corps de la définition de la structure. Cette annotation
signifie qu'une instance de <code>ExtraitImportant</code> ne peut pas vivre plus longtemps
que la référence qu'elle stocke dans son champ <code>partie</code>.</p>
<!--
The `main` function here creates an instance of the `ImportantExcerpt` struct
that holds a reference to the first sentence of the `String` owned by the
variable `novel`. The data in `novel` exists before the `ImportantExcerpt`
instance is created. In addition, `novel` doesn’t go out of scope until after
the `ImportantExcerpt` goes out of scope, so the reference in the
`ImportantExcerpt` instance is valid.
-->
<p>La fonction <code>main</code> crée ici une instance de la structure <code>ExtraitImportant</code> qui
stocke une référence vers la première phrase de la <code>String</code> possédée par la
variable <code>roman</code>. Les données dans <code>roman</code> existent avant que l'instance de
<code>ExtraitImportant</code> soit crée. De plus, <code>roman</code> ne sort pas de la portée avant
que l'instance de <code>ExtraitImportant</code> sorte de la portée, donc la référence dans
l'instance de <code>ExtraitImportant</code> est toujours valide.</p>
<!--
### Lifetime Elision
-->
<h3 id="lélision-des-durées-de-vie"><a class="header" href="#lélision-des-durées-de-vie">L'élision des durées de vie</a></h3>
<!--
You’ve learned that every reference has a lifetime and that you need to specify
lifetime parameters for functions or structs that use references. However, in
Chapter 4 we had a function in Listing 4-9, which is shown again in Listing
10-26, that compiled without lifetime annotations.
-->
<p>Vous avez appris que toute référence a une durée de vie et que vous devez
renseigner des paramètres de durée de vie sur des fonctions ou des structures
qui utilisent des références. Cependant, dans le chapitre 4 nous avions une
fonction dans l'encart 4-9, qui est montrée à nouveau dans l'encart 10-26, qui
compilait sans informations de durée de vie.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
# 
# fn main() {
#     let my_string = String::from("hello world");
# 
#     // first_word works on slices of `String`s
#     let word = first_word(&my_string[..]);
# 
#     let my_string_literal = "hello world";
# 
#     // first_word works on slices of string literals
#     let word = first_word(&my_string_literal[..]);
# 
#     // Because string literals *are* string slices already,
#     // this works too, without the slice syntax!
#     let word = first_word(my_string_literal);
# }
```
-->
<pre><pre class="playground"><code class="language-rust">fn premier_mot(s: &amp;str) -&gt; &amp;str {
    let octets = s.as_bytes();

    for (i, &amp;element) in octets.iter().enumerate() {
        if element == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = premier_mot(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = premier_mot(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = premier_mot(my_string_literal);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-26: A function we defined in Listing 4-9 that
compiled without lifetime annotations, even though the parameter and return
type are references</span>
-->
<p><span class="caption">Encart 10-26 : une fonction que nous avons défini dans
l'encart 4-9 qui se compilait sans avoir d'indications sur la durée de vie, même
si les paramètres et le type de retour sont des références</span></p>
<!--
The reason this function compiles without lifetime annotations is historical:
in early versions (pre-1.0) of Rust, this code wouldn’t have compiled because
every reference needed an explicit lifetime. At that time, the function
signature would have been written like this:
-->
<p>La raison pour laquelle cette fonction se compile sans annotation de durée de
vie est historique : dans les premières versions de Rust (avant la 1.0), ce code
ne se serait pas compilé parce que chaque référence devait avoir une durée de
vie explicite. A l'époque, la signature de la fonction devait être écrite
ainsi :</p>
<!--
```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<!--
After writing a lot of Rust code, the Rust team found that Rust programmers
were entering the same lifetime annotations over and over in particular
situations. These situations were predictable and followed a few deterministic
patterns. The developers programmed these patterns into the compiler’s code so
the borrow checker could infer the lifetimes in these situations and wouldn’t
need explicit annotations.
-->
<p>Après avoir écrit une grande quantité de code Rust, l'équipe de Rust s'est rendu
compte que les développeurs Rust saisissaient toujours les mêmes durées de vie
encore et encore dans des situations spécifiques. Ces situations étaient
prévisibles et suivaient des schémas prédéterminés. Les développeurs ont
programmé ces schémas dans le code du compilateur afin que le vérificateur
d'emprunt puisse deviner les durées de vie dans ces situations et n'auront plus
besoin d'annotations explicites.</p>
<!--
This piece of Rust history is relevant because it’s possible that more
deterministic patterns will emerge and be added to the compiler. In the future,
even fewer lifetime annotations might be required.
-->
<p>Cette partie de l'histoire de Rust est intéressante car il est possible que
d'autres modèles prédéterminés émergent et soient ajoutés au compilateur. A
l'avenir, il est possible qu'encore moins d'annotations de durée de vie soient
nécessaires.</p>
<!--
The patterns programmed into Rust’s analysis of references are called the
*lifetime elision rules*. These aren’t rules for programmers to follow; they’re
a set of particular cases that the compiler will consider, and if your code
fits these cases, you don’t need to write the lifetimes explicitly.
-->
<p>Les schémas programmés dans l'analyse des références de Rust s'appellent les
<em>règles d'élision des durées de vie</em>. Ce ne sont pas des règles que les
développeurs doivent suivre ; c'est un jeu de cas particuliers que le
compilateur va essayer de comparer à votre code, et s'il y a une correspondance
alors vous n'aurez pas besoin d'écrire explicitement les durées de vie.</p>
<!--
The elision rules don’t provide full inference. If Rust deterministically
applies the rules but there is still ambiguity as to what lifetimes the
references have, the compiler won’t guess what the lifetime of the remaining
references should be. In this case, instead of guessing, the compiler will give
you an error that you can resolve by adding the lifetime annotations that
specify how the references relate to each other.
-->
<p>Les règles d'élision ne permettent pas de faire des déductions complètes. Si
Rust applique les règles de façon stricte, mais qu'il existe toujours une
ambiguïté quant à la durée de vie des références, le compilateur ne devinera pas
quel devrait être la durée de vie des autres références. Dans ce cas, au lieu de
tenter de deviner, le compilateur va vous afficher une erreur que vous devrez
résoudre en précisant les durées de vie qui clarifieront les liens entre chaque
référence.</p>
<!--
Lifetimes on function or method parameters are called *input lifetimes*, and
lifetimes on return values are called *output lifetimes*.
-->
<p>Les durées de vies sur les fonctions ou les paramètres des fonctions sont
appelées les <em>durées de vie des entrées</em>, et les durées de vie sur les valeurs
de retour sont appelées les <em>durées de vie des sorties</em>.</p>
<!--
The compiler uses three rules to figure out what lifetimes references have when
there aren’t explicit annotations. The first rule applies to input lifetimes,
and the second and third rules apply to output lifetimes. If the compiler gets
to the end of the three rules and there are still references for which it can’t
figure out lifetimes, the compiler will stop with an error. These rules apply
to `fn` definitions as well as `impl` blocks.
-->
<p>Le compilateur utilise trois règles pour déterminer quelles seraient les durées
de vie des références si cela n'est pas indiqué explicitement. La première règle
s'applique sur les durées de vie des entrées, et la seconde et troisième règle
s'appliquent sur les durées de vie des sorties. Si le compilateur arrive à la
fin des trois règles et qu'il y a encore des références pour lesquelles il ne
peut pas savoir leur durée de vie, le compilateur s'arrête avec une erreur. Ces
règles s'appliquent sur les définitions des <code>fn</code> ainsi que sur celles des blocs
<code>impl</code>.</p>
<!--
The first rule is that each parameter that is a reference gets its own lifetime
parameter. In other words, a function with one parameter gets one lifetime
parameter: `fn foo<'a>(x: &'a i32)`; a function with two parameters gets two
separate lifetime parameters: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`; and so
on.
-->
<p>La première règle dit que chaque paramètre qui est une référence a sa propre
durée de vie. Autrement dit, une fonction avec un seul paramètre va avoir un
seul paramètre de durée de vie : <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code> ; une fonction avec
deux paramètres va avoir deux paramètres de durée de vie séparées :
<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code> ; et ainsi de suite.</p>
<!--
The second rule is if there is exactly one input lifetime parameter, that
lifetime is assigned to all output lifetime parameters: `fn foo<'a>(x: &'a i32)
-> &'a i32`.
-->
<p>La seconde règle dit que s'il y a exactement un seul paramètre de durée de vie
d'entrée, cette durée de vie est assignée à tous les paramètres de durée de vie
des sorties : <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<!--
The third rule is if there are multiple input lifetime parameters, but one of
them is `&self` or `&mut self` because this is a method, the lifetime of `self`
is assigned to all output lifetime parameters. This third rule makes methods
much nicer to read and write because fewer symbols are necessary.
-->
<p>La troisième règle est que lorsque nous avons plusieurs paramètres de durée de
vie, mais qu'un d'entre eux est <code>&amp;self</code> ou <code>&amp;mut self</code> parce que c'est une
méthode, la durée de vie de <code>self</code> sera associée à tous les paramètres de durée
de vie des sorties. Cette troisième règle rend les méthodes plus faciles à lire
et à écrire car il y a moins de caractères nécessaires.</p>
<!--
Let’s pretend we’re the compiler. We’ll apply these rules to figure out what
the lifetimes of the references in the signature of the `first_word` function
in Listing 10-26 are. The signature starts without any lifetimes associated
with the references:
-->
<p>Imaginons que nous soyons le compilateur. Nous allons appliquer ces règles pour
déduire quelles seront les durées de vie des références dans la signature de la
fonction <code>premier_mot</code> de l'encart 10-26.</p>
<!--
```rust,ignore
fn first_word(s: &str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;str) -&gt; &amp;str {
</code></pre>
<!--
Then the compiler applies the first rule, which specifies that each parameter
gets its own lifetime. We’ll call it `'a` as usual, so now the signature is
this:
-->
<p>Ensuite, le compilateur applique la première règle, qui dit que chaque référence
a sa propre durée de vie. Appellons-la <code>'a</code> comme d'habitude, donc maintenant la
signature devient ceci :</p>
<!--
```rust,ignore
fn first_word<'a>(s: &'a str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<!--
The second rule applies because there is exactly one input lifetime. The second
rule specifies that the lifetime of the one input parameter gets assigned to
the output lifetime, so the signature is now this:
-->
<p>La seconde règle s'applique car il y a exactement une durée de vie d'entrée ici.
La seconde règle dit que la durée de vie du seul paramètre d'entrée est affectée
à la durée de vie des sorties, donc la signature est maintenant ceci :</p>
<!--
```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<!--
Now all the references in this function signature have lifetimes, and the
compiler can continue its analysis without needing the programmer to annotate
the lifetimes in this function signature.
-->
<p>Maintenant, toutes les références de cette signature de fonction ont des
durées de vie, et le compilateur peut continuer son analyse sans avoir besoin
que le développeur renseigne les durées de vie dans les signatures de ces
fonctions.</p>
<!--
Let’s look at another example, this time using the `longest` function that had
no lifetime parameters when we started working with it in Listing 10-21:
-->
<p>Voyons un autre exemple, qui utilise cette fois la fonction <code>la_plus_longue</code> qui
n'avait pas de paramètres de durée de vie lorsque nous avons commencé à
l'utiliser dans l'encart 10-21 :</p>
<!--
```rust,ignore
fn longest(x: &str, y: &str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn la_plus_longue(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<!--
Let’s apply the first rule: each parameter gets its own lifetime. This time we
have two parameters instead of one, so we have two lifetimes:
-->
<p>Appliquons la première règle : chaque référence a sa propre durée de vie. Cette
fois, nous avons avons deux références au lieu d'une seule, donc nous avons deux
durées de vie :</p>
<!--
```rust,ignore
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn la_plus_longue&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<!--
You can see that the second rule doesn’t apply because there is more than one
input lifetime. The third rule doesn’t apply either, because `longest` is a
function rather than a method, so none of the parameters are `self`. After
working through all three rules, we still haven’t figured out what the return
type’s lifetime is. This is why we got an error trying to compile the code in
Listing 10-21: the compiler worked through the lifetime elision rules but still
couldn’t figure out all the lifetimes of the references in the signature.
-->
<p>Vous pouvez constater que la seconde règle ne s'applique pas car il y a plus
qu'une seule durée de vie. La troisième ne s'applique pas non plus, car
<code>la_plus_longue</code> est une fonction et non pas une méthode, donc aucun de ses
paramètres ne sont <code>self</code>. Après avoir utilisé ces trois règles, nous n'avons
pas pu en déduire la durée de vie de la valeur de retour. C'est pourquoi nous
obtenons une erreur en essayant de compiler le code dans l'encart 10-21 : le
compilateur a utilisé les règles d'élision des durées de vie mais n'est pas
capable d'en déduire toutes les durées de vie des références présentes dans la
signature.</p>
<!--
Because the third rule really only applies in method signatures, we’ll look at
lifetimes in that context next to see why the third rule means we don’t have to
annotate lifetimes in method signatures very often.
-->
<p>Comme la troisième règle ne s'applique que sur les signatures des méthodes, nous
allons examiner les durées de vie dans ce contexte pour comprendre pourquoi la
troisième règle signifie que nous n'avons pas souvent besoin d'annoter les
durées de vie dans les signatures des méthodes.</p>
<!--
### Lifetime Annotations in Method Definitions
-->
<h3 id="informations-de-durée-de-vie-dans-les-définitions-des-méthodes"><a class="header" href="#informations-de-durée-de-vie-dans-les-définitions-des-méthodes">Informations de durée de vie dans les définitions des méthodes</a></h3>
<!--
When we implement methods on a struct with lifetimes, we use the same syntax as
that of generic type parameters shown in Listing 10-11. Where we declare and
use the lifetime parameters depends on whether they’re related to the struct
fields or the method parameters and return values.
-->
<p>Lorsque nous implémentons des méthodes sur une structure avec des durées de vie,
nous utilisons la même syntaxe que les paramètres de type génériques que nous
avons vu dans l'encart 10-11. L'endroit où nous déclarons et utilisons les
paramètres de durée de vie dépend de s'ils sont reliés aux champs des structures
ou aux paramètres de la méthode et les valeurs de retour.</p>
<!--
Lifetime names for struct fields always need to be declared after the `impl`
keyword and then used after the struct’s name, because those lifetimes are part
of the struct’s type.
-->
<p>Les noms des durées de vie pour les champs de structure ont toujours besoin
d'être déclarés après le mot-clé <code>impl</code> et sont ensuite utilisés après le nom de
la structure, car ces durées vie font partie du type de la structure.</p>
<!--
In method signatures inside the `impl` block, references might be tied to the
lifetime of references in the struct’s fields, or they might be independent. In
addition, the lifetime elision rules often make it so that lifetime annotations
aren’t necessary in method signatures. Let’s look at some examples using the
struct named `ImportantExcerpt` that we defined in Listing 10-25.
-->
<p>Sur les signatures des méthodes à l'intérieur du bloc <code>impl</code>, les références
peuvent avoir la durée de vie des références des champs de la structure, ou
elles peuvent être indépendantes. De plus, les règles d'élision des durées de
vie le font parfois, ce qui fait que l'ajout des durées de vie n'est parfois pas
nécessaire dans les signatures des méthodes. Voyons quelques exemples en
utilisant la structure <code>ExtraitImportant</code> que nous avons défini dans l'encart
10-25.</p>
<!--
First, we’ll use a method named `level` whose only parameter is a reference to
`self` and whose return value is an `i32`, which is not a reference to anything:
-->
<p>Premièrement, nous allons utiliser une méthode <code>niveau</code> dont le seul paramètre
est une référence à <code>self</code> et dont la valeur de retour sera un <code>i32</code>, qui n'est
pas une référence :</p>
<!--
```rust
# struct ImportantExcerpt<'a> {
#     part: &'a str,
# }
# 
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
# 
# impl<'a> ImportantExcerpt<'a> {
#     fn announce_and_return_part(&self, announcement: &str) -> &str {
#         println!("Attention please: {}", announcement);
#         self.part
#     }
# }
# 
# fn main() {
#     let novel = String::from("Call me Ishmael. Some years ago...");
#     let first_sentence = novel.split('.').next().expect("Could not find a '.'");
#     let i = ImportantExcerpt {
#         part: first_sentence,
#     };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ExtraitImportant&lt;'a&gt; {
</span><span class="boring">    partie: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ExtraitImportant&lt;'a&gt; {
    fn niveau(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ExtraitImportant&lt;'a&gt; {
</span><span class="boring">    fn annoncer_et_retourner_partie(&amp;self, annonce: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!(&quot;Votre attention s'il vous plaît : {}&quot;, annonce);
</span><span class="boring">        self.partie
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ExtraitImportant {
</span><span class="boring">        partie: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<!--
The lifetime parameter declaration after `impl` and its use after the type name
are required, but we’re not required to annotate the lifetime of the reference
to `self` because of the first elision rule.
-->
<p>La déclaration du paramètre de durée de vie après <code>impl</code> et son utilisation
après le nom du type sont nécessaires, mais nous n'avons pas à préciser la durée
de vie de la référence à <code>self</code> grâce à la première règle d'élision.</p>
<!--
Here is an example where the third lifetime elision rule applies:
-->
<p>Voici un exemple où la troisième règle d'élision des durées de vie s'applique :</p>
<!--
```rust
# struct ImportantExcerpt<'a> {
#     part: &'a str,
# }
# 
# impl<'a> ImportantExcerpt<'a> {
#     fn level(&self) -> i32 {
#         3
#     }
# }
# 
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
# 
# fn main() {
#     let novel = String::from("Call me Ishmael. Some years ago...");
#     let first_sentence = novel.split('.').next().expect("Could not find a '.'");
#     let i = ImportantExcerpt {
#         part: first_sentence,
#     };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ExtraitImportant&lt;'a&gt; {
</span><span class="boring">    partie: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ExtraitImportant&lt;'a&gt; {
</span><span class="boring">    fn niveau(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ExtraitImportant&lt;'a&gt; {
    fn annoncer_et_retourner_partie(&amp;self, annonce: &amp;str) -&gt; &amp;str {
        println!(&quot;Votre attention s'il vous plaît : {}&quot;, annonce);
        self.partie
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ExtraitImportant {
</span><span class="boring">        partie: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<!--
There are two input lifetimes, so Rust applies the first lifetime elision rule
and gives both `&self` and `announcement` their own lifetimes. Then, because
one of the parameters is `&self`, the return type gets the lifetime of `&self`,
and all lifetimes have been accounted for.
-->
<p>Il y a deux durées de vies des entrées, donc Rust applique la première règle
d'élision des durées de vie et donne à chacun de <code>&amp;self</code> et <code>annonce</code> leur
propre durée de vie. Ensuite, comme un des paramètres est <code>&amp;self</code>, le type de
retour obtient la durée de vie de <code>&amp;self</code>, et ainsi toutes les durées de vie ont
été calculées.</p>
<!--
### The Static Lifetime
-->
<h3 id="la-durée-de-vie-statique"><a class="header" href="#la-durée-de-vie-statique">La durée de vie statique</a></h3>
<!--
One special lifetime we need to discuss is `'static`, which means that this
reference *can* live for the entire duration of the program. All string
literals have the `'static` lifetime, which we can annotate as follows:
-->
<p>Une durée de vie particulière que nous devons aborder est <code>'static</code>, qui
signifie que cette référence <em>peut</em> vivre pendant la totalité de la durée du
programme. Tous les littéraux de chaînes de caractères ont la durée de vie
<code>'static</code>, que nous pouvons écrire comme ceci :</p>
<!--
```rust
let s: &'static str = "I have a static lifetime.";
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;J'ai une durée de vie statique.&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The text of this string is stored directly in the program’s binary, which
is always available. Therefore, the lifetime of all string literals is
`'static`.
-->
<p>Le texte de cette chaîne de caractères est stocké directement dans le binaire du
programme, qui est toujours disponible. C'est pourquoi la durée de vie de tous
les littéraux de chaînes de caractères est <code>'static</code>.</p>
<!--
You might see suggestions to use the `'static` lifetime in error messages. But
before specifying `'static` as the lifetime for a reference, think about
whether the reference you have actually lives the entire lifetime of your
program or not. You might consider whether you want it to live that long, even
if it could. Most of the time, the problem results from attempting to create a
dangling reference or a mismatch of the available lifetimes. In such cases, the
solution is fixing those problems, not specifying the `'static` lifetime.
-->
<p>Il se peut que voyez des suggestions pour utiliser la durée de vie <code>'static</code>
dans les messages d'erreur. Mais avant d'utiliser <code>'static</code> comme durée de vie
pour une référence, demandez-vous si la référence en question vit bien pendant
toute la vie de votre programme, ou non. Vous devriez vous demander si vous
voulez qu'elle vive aussi longtemps, même si si c'était possible. La plupart du
temps, le problème résulte d'une tentative de création d'une référence
pendouillante ou d'une inadéquation des durées de vie disponibles. Dans de ces
cas-là, la solution est de résoudre ces problèmes, et non pas de renseigner la
durée de vie comme étant <code>'static</code>.</p>
<!--
## Generic Type Parameters, Trait Bounds, and Lifetimes Together
-->
<h2 id="les-paramètres-de-type-génériques-les-traits-liés-et-les-durées-de-vies-ensemble"><a class="header" href="#les-paramètres-de-type-génériques-les-traits-liés-et-les-durées-de-vies-ensemble">Les paramètres de type génériques, les traits liés, et les durées de vies ensemble</a></h2>
<!--
Let’s briefly look at the syntax of specifying generic type parameters, trait
bounds, and lifetimes all in one function!
-->
<p>Regardons brièvement la syntaxe pour renseigner tous les paramètres de type
génériques, les traits liés, et les durées de vies sur une seule fonction !</p>
<!--
```rust
# fn main() {
#     let string1 = String::from("abcd");
#     let string2 = "xyz";
# 
#     let result = longest_with_an_announcement(
#         string1.as_str(),
#         string2,
#         "Today is someone's birthday!",
#     );
#     println!("The longest string is {}", result);
# }
# 
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let resultat = la_plus_longue_avec_annonce(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        &quot;Aujourd'hui, c'est l'anniversaire de quelqu'un !&quot;,
</span><span class="boring">    );
</span><span class="boring">    println!(&quot;La chaîne la plus longue est {}&quot;, resultat);
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn la_plus_longue_avec_annonce&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str
    where T: Display
{
    println!(&quot;Annonce ! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<!--
This is the `longest` function from Listing 10-22 that returns the longer of
two string slices. But now it has an extra parameter named `ann` of the generic
type `T`, which can be filled in by any type that implements the `Display`
trait as specified by the `where` clause. This extra parameter will be printed
before the function compares the lengths of the string slices, which is why the
`Display` trait bound is necessary. Because lifetimes are a type of generic,
the declarations of the lifetime parameter `'a` and the generic type parameter
`T` go in the same list inside the angle brackets after the function name.
-->
<p>C'est la fonction <code>la_plus_longue</code> de l'encart 10-22 qui retourne la plus grande
de deux slices de chaînes de caractères. Mais maintenant elle a un paramètre
supplémentaire <code>ann</code> de type générique <code>T</code>, qui peut être remplacé par n'importe
quel type qui implémente le trait <code>Display</code> comme le précise la clause <code>where</code>.
Ce paramètre supplémentaire sera affiché avant que la fonction compare les
longueurs des slices de chaînes de caractères, c'est pourquoi le trait lié
<code>Display</code> est nécessaire. Comme les durées de vie sont un type de génériques,
les déclarations du paramètre de durée de vie <code>'a</code> et le paramètre de type
générique <code>T</code> vont dans la même liste à l'intérieur des chevrons après le nom de
la fonction.</p>
<!--
## Summary
-->
<h2 id="résumé-9"><a class="header" href="#résumé-9">Résumé</a></h2>
<!--
We covered a lot in this chapter! Now that you know about generic type
parameters, traits and trait bounds, and generic lifetime parameters, you’re
ready to write code without repetition that works in many different situations.
Generic type parameters let you apply the code to different types. Traits and
trait bounds ensure that even though the types are generic, they’ll have the
behavior the code needs. You learned how to use lifetime annotations to ensure
that this flexible code won’t have any dangling references. And all of this
analysis happens at compile time, which doesn’t affect runtime performance!
-->
<p>Nous avons vu beaucoup de choses dans ce chapitre ! Maintenant que vous en savez
plus sur les paramètres de type génériques, les traits et les traits liés, et
les paramètres de durée de vie génériques, vous pouvez maintenant écrire du code
en évitant les doublons qui va bien fonctionner dans de nombreuses situations.
Les paramètres de type génériques vous permet d'appliquer du code à différents
types. Les traits et les traits liés s'assurent que bien que les types soient
génériques, ils auront un comportement particulier sur lequel le code peut
compter. Vous avez appris comment utiliser les indications de durée de vie pour
s'assurer que ce code flexible n'aura pas de références pendouillantes. Et
toutes ces vérifications se font au moment de la compilation, ce qui n'influe
pas sur les performances au moment de l'exécution du programme !</p>
<!--
Believe it or not, there is much more to learn on the topics we discussed in
this chapter: Chapter 17 discusses trait objects, which are another way to use
traits. There are also more complex scenarios involving lifetime annotations
that you will only need in very advanced scenarios; for those, you should read
the [Rust Reference][reference]. But next, you’ll learn how to write tests in
Rust so you can make sure your code is working the way it should.
-->
<p>Croyez-le ou non, mais il y a encore des choses à apprendre sur les sujets que
nous avons traités dans ce chapitre : le chapitre 17 expliquera les objets de
trait, qui est une façon d'utiliser les traits. Il existe aussi des scénarios
plus complexes qui nécessitent des indications de durée de vie ainsi que
d'utiliser, uniquement pour ces ces scénarios avancés, certaines fonctionnalités
avancées du système de type ; pour ces cas-là, vous devriez consulter la
<a href="https://doc.rust-lang.org/reference/index.html">Référence de Rust</a>. Maintenant, nous allons voir au chapitre suivant
comment écrire des tests en Rust afin que vous puissiez vous assurer que votre
code fonctionne comme il devrait le faire.</p>
<!--
[references-and-borrowing]:
ch04-02-references-and-borrowing.html#references-and-borrowing
[string-slices-as-parameters]:
ch04-03-slices.html#string-slices-as-parameters
[reference]: ../reference/index.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Writing Automated Tests
-->
<h1 id="ecrire-des-tests-automatisés"><a class="header" href="#ecrire-des-tests-automatisés">Ecrire des tests automatisés</a></h1>
<!--
In his 1972 essay “The Humble Programmer,” Edsger W. Dijkstra said that
“Program testing can be a very effective way to show the presence of bugs, but
it is hopelessly inadequate for showing their absence.” That doesn’t mean we
shouldn’t try to test as much as we can!
-->
<p>Dans son essai de 1972 “The Humble Programmer”, Edsger W. Dijkstra a dit qu'un
“test de programme peut être une manière très efficace de prouver la présence de
bogues, mais qu'il est totalement inadéquat pour prouver leur absence”. Mais
cela ne veut pas dire que nous ne devrions pas tester notre programme autant que
faire se peut !</p>
<!--
Correctness in our programs is the extent to which our code does what we intend
it to do. Rust is designed with a high degree of concern about the correctness
of programs, but correctness is complex and not easy to prove. Rust’s type
system shoulders a huge part of this burden, but the type system cannot catch
every kind of incorrectness. As such, Rust includes support for writing
automated software tests within the language.
-->
<p>L'exactitude de nos programmes est le niveau de conformité de notre code par
rapport à ce que nous voulons qu'il fasse. Rust est conçu dans un grand souci
d'exactitude des programmes, mais l'exactitude est complexe et difficile à
confirmer. Le système de type de Rust endosse une grande partie de cette charge,
mais le système de type ne peut pas détecter tous les genres d'erreurs. Ainsi,
Rust embarque des fonctionnalités pour écrire des tests automatisés de logiciels
à l'intérieur du langage.</p>
<!--
As an example, say we write a function called `add_two` that adds 2 to whatever
number is passed to it. This function’s signature accepts an integer as a
parameter and returns an integer as a result. When we implement and compile
that function, Rust does all the type checking and borrow checking that you’ve
learned so far to ensure that, for instance, we aren’t passing a `String` value
or an invalid reference to this function. But Rust *can’t* check that this
function will do precisely what we intend, which is return the parameter plus 2
rather than, say, the parameter plus 10 or the parameter minus 50! That’s where
tests come in.
-->
<p>Par exemple, imaginons que nous écrivons une fonction <code>ajouter_deux</code> qui ajoute
2 à n'importe quel nombre qu'on lui envoie. La signature de cette fonction
prend un entier en paramètre et retourne un entier comme résultat. Lorsque nous
implémentons et compilons cette fonction, Rust fait toutes les vérifications de
type et d'emprunt que vous avez appris précédemment afin de s'assurer que, par
exemple, nous ne passions pas une valeur de type <code>String</code> ou une référence
invalide à cette fonction. Mais Rust <em>ne peut pas</em> vérifier que cette fonction
va faire précisément ce que nous avions prévu qu'elle fasse, qui en l'occurence
est de retourner le paramètre incrémenté de 2 plutôt que d'ajouter 10 ou
d'enlever 50, par exemple ! C'est pour cette situation que les tests sont
utiles.</p>
<!--
We can write tests that assert, for example, that when we pass `3` to the
`add_two` function, the returned value is `5`. We can run these tests whenever
we make changes to our code to make sure any existing correct behavior has not
changed.
-->
<p>Nous pouvons écrire des tests qui vérifient, par exemple, que lorsque nous
donnons <code>3</code> à la fonction <code>ajouter_deux</code>, elle retourne bien <code>5</code>. Nous pouvons
lancer ces tests à chaque fois que nous modifions notre code pour s'assurer
qu'aucun comportement existant et satisfaisant n'ai changé.</p>
<!--
Testing is a complex skill: although we can’t cover every detail about how to
write good tests in one chapter, we’ll discuss the mechanics of Rust’s testing
facilities. We’ll talk about the annotations and macros available to you when
writing your tests, the default behavior and options provided for running your
tests, and how to organize tests into unit tests and integration tests.
-->
<p>Les tests restent une discipline complexe : bien que nous ne puissions couvrir
chaque détail sur l'écriture de bons tests en un seul chapitre, nous allons
découvrir les  mécanismes des moyens de test de Rust. Nous allons voir les
annotations et les macros que vous pourrez utiliser lorsque vous écrirez vos
tests, le comportement par défaut et les options disponibles pour lancer vos
tests, et comment organiser les tests en tests unitaires et tests d'intégration.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## How to Write Tests
-->
<h2 id="comment-écrire-des-tests"><a class="header" href="#comment-écrire-des-tests">Comment écrire des tests</a></h2>
<!--
Tests are Rust functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform these three
actions:
-->
<p>Les tests sont des fonctions Rust qui vérifient que le code qui n'est pas un
test se comporte bien de la manière attendue. Les corps des fonctions de test
effectuent généralement ces trois actions :</p>
<!--
1. Set up any needed data or state.
2. Run the code you want to test.
3. Assert the results are what you expect.
-->
<ol>
<li>Initialiser toutes les données ou les états,</li>
<li>Lancer le code que vous voulez tester,</li>
<li>Vérifier que les résultats correspondent bien à ce que vous souhaitez.</li>
</ol>
<!--
Let’s look at the features Rust provides specifically for writing tests that
take these actions, which include the `test` attribute, a few macros, and the
`should_panic` attribute.
-->
<p>Découvrons les fonctionnalités spécifiques qu'offre Rust pour écrire des tests
qui font ces actions, dans lesquelles on retrouve l'attribut <code>test</code>, quelques
macros, et l'attribut <code>should_panic</code>.</p>
<!--
### The Anatomy of a Test Function
-->
<h3 id="lanatomie-dune-fonction-de-test"><a class="header" href="#lanatomie-dune-fonction-de-test">L'anatomie d'une fonction de test</a></h3>
<!--
At its simplest, a test in Rust is a function that’s annotated with the `test`
attribute. Attributes are metadata about pieces of Rust code; one example is
the `derive` attribute we used with structs in Chapter 5. To change a function
into a test function, add `#[test]` on the line before `fn`. When you run your
tests with the `cargo test` command, Rust builds a test runner binary that runs
the functions annotated with the `test` attribute and reports on whether each
test function passes or fails.
-->
<p>Dans la forme la plus simple, un test en Rust est une fonction qui est marquée
avec l'attribut <code>test</code>. Les attributs sont des métadonnées sur des parties de
code Rust ; un exemple est l'attribut <code>derive</code> que nous avons utilisé sur les
structures au chapitre 5. Pour transformer une fonction en une fonction de test,
il faut ajouter <code>#[test]</code> dans la ligne avant le <code>fn</code>. Lorsque vous lancez vos
tests avec la commande <code>cargo test</code>, Rust construit un binaire d'exécution de tests
qui exécute les fonctions marquées avec l'attribut <code>test</code> et fait un rapport sur
quelles fonctions ont réussi ou échoué.</p>
<!--
When we make a new library project with Cargo, a test module with a test
function in it is automatically generated for us. This module helps you start
writing your tests so you don’t have to look up the exact structure and syntax
of test functions every time you start a new project. You can add as many
additional test functions and as many test modules as you want!
-->
<p>Lorsque nous créons une nouvelle bibliothèque avec Cargo, un module de tests
qui contient une fonction de test est automatiquement créé pour nous. Ce module
vous aide à démarrer l'écriture de vos tests afin que vous n'ayez pas à chercher
la structure et la syntaxe exacte d'une fonction de test à chaque fois que vous
débutez un nouveau projet. Vous pouvez ajouter autant de fonctions de test et
autant de modules de test que vous le souhaitez !</p>
<!--
We’ll explore some aspects of how tests work by experimenting with the template
test generated for us without actually testing any code. Then we’ll write some
real-world tests that call some code that we’ve written and assert that its
behavior is correct.
-->
<p>Nous allons découvrir quelques aspects du fonctionnement des tests en
expérimentant avec le modèle de test généré pour nous, mais qui ne teste aucun
code pour le moment. Ensuite, nous écrirons quelques tests plus proches de la
réalité, qui utilisera du code que nous avons écrit et qui validera son bon
comportement.</p>
<!--
Let’s create a new library project called `adder`:
-->
<p>Commençons par créer un nouveau projet de bibliothèque que nous appellerons
<code>addition</code> :</p>
<!--
```console
$ cargo new adder --lib
     Created library `adder` project
$ cd adder
```
-->
<pre><code class="language-console">$ cargo new addition --lib
     Created library `addition` project
$ cd addition
</code></pre>
<!--
The contents of the *src/lib.rs* file in your `adder` library should look like
Listing 11-1.
-->
<p>Le contenu de votre fichier <em>src/lib.rs</em> dans votre bibliothèque <code>addition</code>
devrait ressembler à l'encart 11-1.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
```
-->
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-1: The test module and function generated
automatically by `cargo new`</span>
-->
<p><span class="caption">Encart 11-1 : le module de test et la fonction générées
automatiquement par <code>cargo new</code></span></p>
<!--
For now, let’s ignore the top two lines and focus on the function to see how it
works. Note the `#[test]` annotation before the `fn` line: this attribute
indicates this is a test function, so the test runner knows to treat this
function as a test. We could also have non-test functions in the `tests` module
to help set up common scenarios or perform common operations, so we need to
indicate which functions are tests by using the `#[test]` attribute.
-->
<p>Pour l'instant, ignorons les deux premières lignes et concentrons-nous sur la
fonction pour voir comment elle fonctionne. Remarquez l'annotation <code>#[test]</code>
avant la ligne <code>fn</code> : cet attribut indique que c'est une fonction de test, donc
l'exécuteur de tests sait qu'il doit considérer cette fonction comme étant un
test. Nous pouvons aussi avoir des fonctions qui ne font pas de tests dans le
module <code>tests</code> afin de régler des scénarios en commun ou pour procéder à des
opérations en commun, c'est pourquoi nous devons indiquer quelles fonctions sont
des tests en utilisant l'attribut <code>#[test]</code>.</p>
<!--
The function body uses the `assert_eq!` macro to assert that 2 + 2 equals 4.
This assertion serves as an example of the format for a typical test. Let’s run
it to see that this test passes.
-->
<p>Le corps de la fonction utilise la macro <code>assert_eq!</code> pour vérifier que 2 + 2
vaut bien 4. Cette vérification sert d'exemple pour expliquer le format d'un
test classique. Lançons-le pour vérifier si ce test est validé.</p>
<!--
The `cargo test` command runs all tests in our project, as shown in Listing
11-2.
-->
<p>La commande <code>cargo test</code> lance tous les tests présents dans votre projet, comme
le montre l'encart 11-2.</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
<span class="caption">Listing 11-2: The output from running the automatically
generated test</span>
-->
<p><span class="caption">Encart 11-2 : le résultat du lancement des tests sur le
test généré automatiquement</span></p>
<!--
Cargo compiled and ran the test. After the `Compiling`, `Finished`, and
`Running` lines is the line `running 1 test`. The next line shows the name
of the generated test function, called `it_works`, and the result of running
that test, `ok`. The overall summary of running the tests appears next. The
text `test result: ok.` means that all the tests passed, and the portion that
reads `1 passed; 0 failed` totals the number of tests that passed or failed.
-->
<p>Cargo a compilé et lancé le test. Après les lignes <code>Compiling</code>, <code>Finished</code>, et
<code>Running</code>, on trouve la ligne <code>running 1 test</code>. La ligne suivante montre le nom
de la fonction de test <code>it_works</code>, qui a été généré précédemment, et le résultat de
l'exécution de ce test, <code>ok</code>. Le résumé général de l'exécution des tests
s'affiche ensuite. Le texte <code>test result: ok.</code> signifie que tous les tests ont
réussi, et la partie <code>1 passed; 0 failed</code> compte le nombre total de tests qui
ont réussi ou échoué.</p>
<!--
Because we don’t have any tests we’ve marked as ignored, the summary shows `0
ignored`. We also haven’t filtered the tests being run, so the end of the
summary shows `0 filtered out`. We’ll talk about ignoring and filtering out
tests in the next section, [“Controlling How Tests Are
Run.”][controlling-how-tests-are-run]<!-- ignore -- >
-->
<p>Comme nous n'avons aucun test que nous avons marqué comme ignoré, le résumé
affiche <code>0 ignored</code>. Nous n'avons pas non plus filtré les tests qui ont été
exécutés, donc la fin du résumé affiche <code>0 filtered out</code>. Nous verrons comment
ignorer et filtrer les tests dans la prochaine section, <a href="ch11-02-running-tests.html">“Contrôler comment les
tests sont exécutés”</a><!-- ignore -->.</p>
<!--
The `0 measured` statistic is for benchmark tests that measure performance.
Benchmark tests are, as of this writing, only available in nightly Rust. See
[the documentation about benchmark tests][bench] to learn more.
-->
<p>La statistique <code>0 measured</code> sert pour des tests de benchmark qui mesurent les
performances. Les tests de benchmark ne sont disponibles pour le moment que dans
la version expérimentale de Rust (nighly), au moment de cette écriture.
Rendez-vous sur <a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">la documentation sur les tests de benchmark</a> pour en
savoir plus.</p>
<!--
[bench]: ../unstable-book/library-features/test.html
-->
<!--
The next part of the test output, which starts with `Doc-tests adder`, is for
the results of any documentation tests. We don’t have any documentation tests
yet, but Rust can compile any code examples that appear in our API
documentation. This feature helps us keep our docs and our code in sync! We’ll
discuss how to write documentation tests in the [“Documentation Comments as
Tests”][doc-comments]<!-- ignore -- > section of Chapter 14. For now, we’ll
ignore the `Doc-tests` output.
-->
<p>La partie suivante du résultat du test, qui commence par <code>Doc-tests addition</code>,
concerne les résultats de tous les tests présents dans la documentation. Nous
n'avons pas de tests dans la documentation pour le moment, mais Rust peut
compiler tous les exemples de code qui sont présents dans la documentation de
notre API. Cette fonctionnalité nous aide à garder synchronisé notre
documentation et notre code ! Nous verrons comment écrire nos tests dans la
documentation dans une section du chapitre 14. Pour le moment, nous allons
ignorer la partie <code>Doc-tests</code> du résultat.</p>
<!--
Let’s change the name of our test to see how that changes the test output.
Change the `it_works` function to a different name, such as `exploration`, like
so:
-->
<p>Changeons le nom de notre test pour voir comment cela change le résultat du
test. Changeons le nom de la fonction <code>it_works</code> pour un nom différent, comme
<code>exploration</code> ci-dessous :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
```
-->
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<!--
Then run `cargo test` again. The output now shows `exploration` instead of
`it_works`:
-->
<p>Lancez ensuite à nouveau <code>cargo test</code>. Le résultat affiche désormais
<code>exploration</code> plutôt que <code>it_works</code> :</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
Let’s add another test, but this time we’ll make a test that fails! Tests fail
when something in the test function panics. Each test is run in a new thread,
and when the main thread sees that a test thread has died, the test is marked
as failed. We talked about the simplest way to cause a panic in Chapter 9,
which is to call the `panic!` macro. Enter the new test, `another`, so your
*src/lib.rs* file looks like Listing 11-3.
-->
<p>Ajoutons un autre test, mais cette fois nous allons construire un test qui
échoue ! Les tests échouent lorsque quelque chose dans la fonction de test
panique. Chaque test est lancé dans une nouvelle tâche, et lorsque la tâche
principale voit qu'une tâche de test est mort, le test est considéré
comme échoué. Nous avons vu la façon la plus simple de faire paniquer au
chapitre 9, qui consiste à appeler la macro <code>panic!</code>. Ecrivez ce nouveau test,
<code>un_autre</code>, de sorte que votre fichier <code>src/lib.rs</code> ressemble à ceci :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,panics,noplayground
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn un_autre() {
        panic!("Fait échouer ce test");
    }
}
```
-->
<pre><code class="language-rust panics noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn un_autre() {
        panic!(&quot;Fait échouer ce test&quot;);
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-3: Adding a second test that will fail because
we call the `panic!` macro</span>
-->
<p><span class="caption">Encart 11-3 : ajout d'un second test qui va échouer car
nous appelons la macro <code>panic!</code></span></p>
<!--
Run the tests again using `cargo test`. The output should look like Listing
11-4, which shows that our `exploration` test passed and `another` failed.
-->
<p>Lancez à nouveau les tests en utilisant <code>cargo test</code>. Le résultat devrait
ressembler à l'encart 11-4, qui va afficher que notre test <code>exploration</code> a
réussi et que <code>un_autre</code> va échouer.</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::un_autre ... FAILED
test tests::exploration ... ok

failures:

---- tests::un_autre stdout ----
thread 'main' panicked at 'Fait échouer ce test', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::un_autre

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::un_autre ... FAILED
test tests::exploration ... ok

failures:

---- tests::un_autre stdout ----
thread 'main' panicked at 'Fait échouer ce test', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::un_autre

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
<span class="caption">Listing 11-4: Test results when one test passes and one
test fails</span>
-->
<p><span class="caption">Encart 11-4 : les résultats de tests lorsque un test
réussit et un autre test échoue</span></p>
<!--
Instead of `ok`, the line `test tests::another` shows `FAILED`. Two new
sections appear between the individual results and the summary: the first
section displays the detailed reason for each test failure. In this case,
`another` failed because it `panicked at 'Make this test fail'`, which happened
on line 10 in the *src/lib.rs* file. The next section lists just the names of
all the failing tests, which is useful when there are lots of tests and lots of
detailed failing test output. We can use the name of a failing test to run just
that test to more easily debug it; we’ll talk more about ways to run tests in
the [“Controlling How Tests Are Run”][controlling-how-tests-are-run]<!-- ignore
-- > section.
-->
<p>A la place du <code>ok</code>, la ligne <code>test tests:un_autre</code> affiche <code>FAILED</code>. Deux
nouvelles sections apparaissent entre la liste des tests et le résumé : la
première section affiche les raisons détaillées de chaque échec de test. Dans
notre cas, <code>un_autre</code> a échoué car il a paniqué à 'Fait échouer ce test', qui
est placé à la ligne 10 du fichier <em>src/lib.rs</em>. La partie suivante liste
simplement les noms de tous les tests qui ont échoué, ce qui est utile lorsqu'il
y a de nombreux tests et beaucoup de détails provenant des tests qui échouent.
Nous pouvons utiliser le nom d'un test qui échoue pour lancer uniquement ce test
afin de déboguer plus facilement ; nous allons voir plus de façons de lancer
des tests dans la <a href="ch11-02-running-tests.html">section suivante</a><!-- ignore
-->.</p>
<!--
The summary line displays at the end: overall, our test result is `FAILED`.
We had one test pass and one test fail.
-->
<p>La ligne de résumé s'affiche à la fin : au final, le résultat de nos tests est
au statut <code>FAILED</code> (échoué). Nous avons un test réussi et un test échoué.</p>
<!--
Now that you’ve seen what the test results look like in different scenarios,
let’s look at some macros other than `panic!` that are useful in tests.
-->
<p>Maintenant que vous avez vu à quoi ressemblent les résultats de tests dans
différents scénarios, voyons d'autres macros que <code>panic!</code> qui nous serons utiles
pour les tests.</p>
<!--
### Checking Results with the `assert!` Macro
-->
<h3 id="vérifier-les-résultats-avec-la-macro-assert"><a class="header" href="#vérifier-les-résultats-avec-la-macro-assert">Vérifier les résultats avec la macro <code>assert!</code></a></h3>
<!--
The `assert!` macro, provided by the standard library, is useful when you want
to ensure that some condition in a test evaluates to `true`. We give the
`assert!` macro an argument that evaluates to a Boolean. If the value is
`true`, `assert!` does nothing and the test passes. If the value is `false`,
the `assert!` macro calls the `panic!` macro, which causes the test to fail.
Using the `assert!` macro helps us check that our code is functioning in the
way we intend.
-->
<p>La macro <code>assert!</code>, fournie par la bibliothèque standard, est utile lorsque vous
voulez vous assurer qu'une condition dans un test vaut <code>true</code>. Nous fournissons
à la macro <code>assert!</code> un argument qui donne un Booléen une fois interprété. Si la
valeur est <code>true</code>, <code>assert!</code> ne fait rien et le test est réussi. Si la valeur
est <code>false</code>, la macro <code>assert!</code> appelle la macro <code>panic!</code>, qui fait échouer le
test. L'utilisation de la macro <code>assert!</code> nous aide à vérifier que notre code
fonctionne bien comme nous le souhaitions.</p>
<!--
In Chapter 5, Listing 5-15, we used a `Rectangle` struct and a `can_hold`
method, which are repeated here in Listing 11-5. Let’s put this code in the
*src/lib.rs* file and write some tests for it using the `assert!` macro.
-->
<p>Dans le chapitre 5, dans l'encart 5-15, nous avons utilisé une structure
<code>Rectangle</code> et une méthode <code>peut_contenir</code>, qui sont recopiés dans l'encart 11-5
ci-dessous. Ajoutons ce code dans le fichier <em>src/lib.rs</em> et écrivons quelques
tests en utilisant la macro <code>assert!</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

impl Rectangle {
    fn peut_contenir(&self, other: &Rectangle) -> bool {
        self.largeur > other.largeur && self.hauteur > other.hauteur
    }
}
```
-->
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

impl Rectangle {
    fn peut_contenir(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.largeur &gt; other.largeur &amp;&amp; self.hauteur &gt; other.hauteur
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-5: Using the `Rectangle` struct and its
`can_hold` method from Chapter 5</span>
-->
<p><span class="caption">Encart 11-5 : utilisation de la structure <code>Rectangle</code> et
sa méthode <code>peut_contenir</code> du chapitre 5</span></p>
<!--
The `can_hold` method returns a Boolean, which means it’s a perfect use case
for the `assert!` macro. In Listing 11-6, we write a test that exercises the
`can_hold` method by creating a `Rectangle` instance that has a width of 8 and
a height of 7 and asserting that it can hold another `Rectangle` instance that
has a width of 5 and a height of 1.
-->
<p>La méthode <code>peut_contenir</code> retourne un Booléen, ce qui veut dire que c'est un
cas parfait pour tester la macro <code>assert!</code>. Dans l'encart 11-6, nous écrivons un
test qui s'applique sur la méthode <code>peut_contenir</code> en créant une instance de
<code>Rectangle</code> qui a une largeur de 8 et une hauteur de 7, et qui vérifie qu'il
peut contenir une autre instance de <code>Rectangle</code> qui a une largeur de 6 et une
hauteur de 1.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
# #[derive(Debug)]
# struct Rectangle {
#     largeur: u32,
#     hauteur: u32,
# }
# 
# impl Rectangle {
#     fn peut_contenir(&self, other: &Rectangle) -> bool {
#         self.largeur > other.largeur && self.hauteur > other.hauteur
#     }
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_grand_peut_contenir_un_petit() {
        let le_grand = Rectangle { largeur: 8, hauteur: 7 };
        let le_petit = Rectangle { largeur: 5, hauteur: 1 };

        assert!(le_grand.peut_contenir(&le_petit));
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn peut_contenir(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.largeur &gt; other.largeur &amp;&amp; self.hauteur &gt; other.hauteur
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_grand_peut_contenir_un_petit() {
        let le_grand = Rectangle { largeur: 8, hauteur: 7 };
        let le_petit = Rectangle { largeur: 5, hauteur: 1 };

        assert!(le_grand.peut_contenir(&amp;le_petit));
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-6: A test for `can_hold` that checks whether a
larger rectangle can indeed hold a smaller rectangle</span>
-->
<p><span class="caption">Encart 11-6 : un test pour <code>peut_contenir</code> qui vérifie le
cas où un grand rectangle peut contenir un plus petit rectangle</span></p>
<!--
Note that we’ve added a new line inside the `tests` module: `use super::*;`.
The `tests` module is a regular module that follows the usual visibility rules
we covered in Chapter 7 in the [“Paths for Referring to an Item in the Module
Tree”][paths-for-referring-to-an-item-in-the-module-tree]<!-- ignore -- >
section. Because the `tests` module is an inner module, we need to bring the
code under test in the outer module into the scope of the inner module. We use
a glob here so anything we define in the outer module is available to this
`tests` module.
-->
<p>Remarquez que nous avons ajouté une nouvelle ligne à l'intérieur du module
<code>test</code> : <code>use super::*;</code>. Le module <code>tests</code> est un module classique qui suit les
règles de visibilité que nous avons vu au chapitre 7 dans la section <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Les
chemins pour désigner un élément dans l'arborescence de
module”</a><!-- ignore -->.
Comme le module <code>tests</code> est un module interne, nous avons besoin de ramener le
code à tester qui se trouve dans son module parent dans la portée du module à
l'intérieur. Nous utilisons ici un opérateur global afin que tout ce que nous
avons défini dans le module parent soit disponible dans le module <code>tests</code>.</p>
<!--
We’ve named our test `larger_can_hold_smaller`, and we’ve created the two
`Rectangle` instances that we need. Then we called the `assert!` macro and
passed it the result of calling `larger.can_hold(&smaller)`. This expression
is supposed to return `true`, so our test should pass. Let’s find out!
-->
<p>Nous avons nommé notre test <code>un_grand_peut_contenir_un_petit</code>, et nous avons
créé les deux instances <code>Rectangle</code> que nous avions besoin. Ensuite, nous avons
appelé la macro <code>assert!</code> et nous lui avons passé le résultat de l'appel à
<code>le_grand.peut_contenir(&amp;le_petit)</code>. Cette expression est censée retourner
<code>true</code>, donc notre test devrait réussir. Vérifions cela !</p>
<!--
```console
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::un_grand_peut_contenir_un_petit ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::un_grand_peut_contenir_un_petit ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
It does pass! Let’s add another test, this time asserting that a smaller
rectangle cannot hold a larger rectangle:
-->
<p>Il a réussi ! Ajoutons maintenant un autre test, qui vérifie cette fois qu'un
petit rectangle ne peut contenir un rectangle plus grand :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
# #[derive(Debug)]
# struct Rectangle {
#     largeur: u32,
#     hauteur: u32,
# }
# 
# impl Rectangle {
#     fn peut_contenir(&self, other: &Rectangle) -> bool {
#         self.largeur > other.largeur && self.hauteur > other.hauteur
#     }
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_grand_peut_contenir_un_petit() {
        // --snip--
#         let le_grand = Rectangle {
#             largeur: 8,
#             hauteur: 7,
#         };
#         let le_petit = Rectangle {
#             largeur: 5,
#             hauteur: 1,
#         };
# 
#         assert!(le_grand.peut_contenir(&le_petit));
    }

    #[test]
    fn un_petit_ne_peut_pas_contenir_un_plus_grand() {
        let le_grand = Rectangle {
            largeur: 8,
            hauteur: 7,
        };
        let le_petit = Rectangle {
            largeur: 5,
            hauteur: 1,
        };

        assert!(!le_petit.peut_contenir(&le_grand));
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn peut_contenir(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.largeur &gt; other.largeur &amp;&amp; self.hauteur &gt; other.hauteur
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_grand_peut_contenir_un_petit() {
        // --snip--
<span class="boring">        let le_grand = Rectangle {
</span><span class="boring">            largeur: 8,
</span><span class="boring">            hauteur: 7,
</span><span class="boring">        };
</span><span class="boring">        let le_petit = Rectangle {
</span><span class="boring">            largeur: 5,
</span><span class="boring">            hauteur: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(le_grand.peut_contenir(&amp;le_petit));
</span>    }

    #[test]
    fn un_petit_ne_peut_pas_contenir_un_plus_grand() {
        let le_grand = Rectangle {
            largeur: 8,
            hauteur: 7,
        };
        let le_petit = Rectangle {
            largeur: 5,
            hauteur: 1,
        };

        assert!(!le_petit.peut_contenir(&amp;le_grand));
    }
}
</code></pre>
<!--
Because the correct result of the `can_hold` function in this case is `false`,
we need to negate that result before we pass it to the `assert!` macro. As a
result, our test will pass if `can_hold` returns `false`:
-->
<p>Comme le résultat correct de la fonction <code>peut_contenir</code> dans ce cas doit être
<code>false</code>, nous devons faire un négatif de cette fonction avant de l'envoyer à la
macro <code>assert!</code>. Cela aura pour effet de faire réussir notre test si
<code>peut_contenir</code> retourne <code>false</code> :</p>
<!--
```console
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::un_grand_peut_contenir_un_petit ... ok
test tests::un_petit_ne_peut_pas_contenir_un_plus_grand ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```
-->
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::un_grand_peut_contenir_un_petit ... ok
test tests::un_petit_ne_peut_pas_contenir_un_plus_grand ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
Two tests that pass! Now let’s see what happens to our test results when we
introduce a bug in our code. Let’s change the implementation of the `can_hold`
method by replacing the greater than sign with a less than sign when it
compares the widths:
-->
<p>Voilà deux tests qui réussissent ! Maintenant, voyons ce qu'il se passe dans les
résultats de nos tests lorsque nous introduisons un bogue dans notre code.
Changeons l'implémentation de la méthode <code>peut_contenir</code> en remplaçant
l'opérateur <em>plus grand que</em> par un <em>plus petit que</em> au moment de la comparaison
des largeurs :</p>
<!--
```rust,not_desired_behavior,noplayground
# #[derive(Debug)]
# struct Rectangle {
#     largeur: u32,
#     hauteur: u32,
# }
# 
// -- partie masquée ici --
impl Rectangle {
    fn peut_contenir(&self, other: &Rectangle) -> bool {
        self.largeur < other.largeur && self.hauteur > other.hauteur
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn un_grand_peut_contenir_un_petit() {
#         let le_grand = Rectangle {
#             largeur: 8,
#             hauteur: 7,
#         };
#         let le_petit = Rectangle {
#             largeur: 5,
#             hauteur: 1,
#         };
# 
#         assert!(le_grand.peut_contenir(&le_petit));
#     }
# 
#     #[test]
#     fn un_petit_ne_peut_pas_contenir_un_plus_grand() {
#         let le_grand = Rectangle {
#             largeur: 8,
#             hauteur: 7,
#         };
#         let le_petit = Rectangle {
#             largeur: 5,
#             hauteur: 1,
#         };
# 
#         assert!(!le_petit.peut_contenir(&le_grand));
#     }
# }
```
-->
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquée ici --
impl Rectangle {
    fn peut_contenir(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.largeur &lt; other.largeur &amp;&amp; self.hauteur &gt; other.hauteur
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_grand_peut_contenir_un_petit() {
</span><span class="boring">        let le_grand = Rectangle {
</span><span class="boring">            largeur: 8,
</span><span class="boring">            hauteur: 7,
</span><span class="boring">        };
</span><span class="boring">        let le_petit = Rectangle {
</span><span class="boring">            largeur: 5,
</span><span class="boring">            hauteur: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(le_grand.peut_contenir(&amp;le_petit));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_petit_ne_peut_pas_contenir_un_plus_grand() {
</span><span class="boring">        let le_grand = Rectangle {
</span><span class="boring">            largeur: 8,
</span><span class="boring">            hauteur: 7,
</span><span class="boring">        };
</span><span class="boring">        let le_petit = Rectangle {
</span><span class="boring">            largeur: 5,
</span><span class="boring">            hauteur: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!le_petit.peut_contenir(&amp;le_grand));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Running the tests now produces the following:
-->
<p>Le lancement des tests donne maintenant le résultat suivant :</p>
<!--
```console
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::un_grand_peut_contenir_un_petit ... FAILED
test tests::un_petit_ne_peut_pas_contenir_un_plus_grand ... ok

failures:

---- tests::un_grand_peut_contenir_un_petit stdout ----
thread 'main' panicked at 'assertion failed: le_grand.can_hold(&le_petit)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::un_grand_peut_contenir_un_petit

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::un_grand_peut_contenir_un_petit ... FAILED
test tests::un_petit_ne_peut_pas_contenir_un_plus_grand ... ok

failures:

---- tests::un_grand_peut_contenir_un_petit stdout ----
thread 'main' panicked at 'assertion failed: le_grand.can_hold(&amp;le_petit)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::un_grand_peut_contenir_un_petit

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Our tests caught the bug! Because `larger.width` is 8 and `smaller.width` is
5, the comparison of the widths in `can_hold` now returns `false`: 8 is not
less than 5.
-->
<p>Nos tests ont repéré le bogue ! Comme <code>le_grand.largeur</code> est 8 et
<code>le_petit.largeur</code> est 5, la comparaison des largeurs dans <code>peut_contenir</code>
retourne maintenant <code>false</code> : 8 n'est pas plus petit que 5.</p>
<!--
### Testing Equality with the `assert_eq!` and `assert_ne!` Macros
-->
<h3 id="tester-légalité-avec-les-macros-assert_eq-et-assert_ne"><a class="header" href="#tester-légalité-avec-les-macros-assert_eq-et-assert_ne">Tester l'égalité avec les macros <code>assert_eq!</code> et <code>assert_ne!</code></a></h3>
<!--
A common way to test functionality is to compare the result of the code under
test to the value you expect the code to return to make sure they’re equal. You
could do this using the `assert!` macro and passing it an expression using the
`==` operator. However, this is such a common test that the standard library
provides a pair of macros—`assert_eq!` and `assert_ne!`—to perform this test
more conveniently. These macros compare two arguments for equality or
inequality, respectively. They’ll also print the two values if the assertion
fails, which makes it easier to see *why* the test failed; conversely, the
`assert!` macro only indicates that it got a `false` value for the `==`
expression, not the values that led to the `false` value.
-->
<p>Une façon courante de tester des fonctionnalités est de comparer le résultat du
code à tester par rapport à une valeur que vous souhaitez que le code retourne,
afin de vous assurer qu'elles soient bien égales. Vous pouvez faire cela avec la
macro <code>assert!</code> et en lui passant une expression qui utilise l'opérateur <code>==</code>.
Cependant, c'est un test si courant que la bibliothèque standard fournit une
paire de macros (<code>assert_eq!</code> et <code>assert_ne!</code>) pour procéder à ce test plus
facilement. Les macros comparent respectivement l'égalité ou la non égalité de
deux arguments. Elles vont aussi afficher les deux valeurs si la vérification
échoue, ce qui va nous aider à comprendre <em>pourquoi</em> le test a échoué ;
paradoxalement, la macro <code>assert!</code> indique seulement qu'elle a obtenu une valeur
<code>false</code> de l'expression avec le <code>==</code>, mais n'affiche pas les valeurs qui l'ont
mené à la valeur <code>false</code>.</p>
<!--
In Listing 11-7, we write a function named `add_two` that adds `2` to its
parameter and returns the result. Then we test this function using the
`assert_eq!` macro.
-->
<p>Dans l'encart 11-7, nous écrivons une fonction <code>ajouter_deux</code> qui ajoute <code>2</code> à
son paramètre et retourne le résultat. Ensuite, nous testons cette fonction en
utilisant la macro <code>assert_eq!</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
pub fn ajouter_deux(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn cela_ajoute_deux() {
        assert_eq!(4, ajouter_deux(2));
    }
}
```
-->
<pre><code class="language-rust noplayground">pub fn ajouter_deux(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn cela_ajoute_deux() {
        assert_eq!(4, ajouter_deux(2));
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-7: Testing the function `add_two` using the
`assert_eq!` macro</span>
-->
<p><span class="caption">Encart 11-7 : test de la fonction <code>ajouter_deux</code> en
utilisant la macro <code>assert_eq!</code>.</span></p>
<!--
Let’s check that it passes!
-->
<p>Vérifions si cela fonctionne !</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
The first argument we gave to the `assert_eq!` macro, `4`, is equal to the
result of calling `add_two(2)`. The line for this test is `test
tests::it_adds_two ... ok`, and the `ok` text indicates that our test passed!
-->
<p>Le premier argument que nous avons donné à la macro <code>assert_eq!</code>, <code>4</code>, est bien
égal au résultat de l'appel à <code>ajouter_deux</code>. La ligne correspondant à ce test
est <code>test tests::cela_ajoute_deux ... ok</code>, et le texte <code>ok</code> indique que notre
test a réussi !</p>
<!--
Let’s introduce a bug into our code to see what it looks like when a test that
uses `assert_eq!` fails. Change the implementation of the `add_two` function to
instead add `3`:
-->
<p>Ajoutons un bogue dans notre code pour voir ce qu'il se passe lorsque un test
qui utilise <code>assert_eq!</code> échoue. Changez l'implémentation de la fonction
<code>ajouter_deux</code> pour ajouter plutôt <code>3</code> :</p>
<!--
```rust,not_desired_behavior,noplayground
pub fn ajouter_deux(a: i32) -> i32 {
    a + 3
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn cela_ajoute_deux() {
#         assert_eq!(4, ajouter_deux(2));
#     }
# }
```
-->
<pre><code class="language-rust not_desired_behavior noplayground">pub fn ajouter_deux(a: i32) -&gt; i32 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn cela_ajoute_deux() {
</span><span class="boring">        assert_eq!(4, ajouter_deux(2));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Run the tests again:
-->
<p>Lancez à nouveau les tests :</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::cela_ajoute_deux ... FAILED

failures:

---- tests::cela_ajoute_deux stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::cela_ajoute_deux

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::cela_ajoute_deux ... FAILED

failures:

---- tests::cela_ajoute_deux stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::cela_ajoute_deux

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Our test caught the bug! The `it_adds_two` test failed, displaying the message
`` assertion failed: `(left == right)` `` and showing that `left` was `4` and
`right` was `5`. This message is useful and helps us start debugging: it means
the `left` argument to `assert_eq!` was `4` but the `right` argument, where we
had `add_two(2)`, was `5`.
-->
<p>Notre test a détecté le bogue ! Le test <code>cela_ajoute_deux</code> a échoué, ce qui a
affiché le message <code>assertion failed: `(left == right)`</code> qui nous explique
qu'à gauche nous avions <code>4</code> et qu'à droite nous avions <code>5</code>. Ce message utile
nous aide au déboguage : cela veut dire que l'argument de gauche de <code>assert_eq!</code>
valait <code>4</code> mais que l'argument de droite, où nous avions <code>ajouter_deux(2)</code>,
valait <code>5</code>.</p>
<!--
Note that in some languages and test frameworks, the parameters to the
functions that assert two values are equal are called `expected` and `actual`,
and the order in which we specify the arguments matters. However, in Rust,
they’re called `left` and `right`, and the order in which we specify the value
we expect and the value that the code under test produces doesn’t matter. We
could write the assertion in this test as `assert_eq!(add_two(2), 4)`, which
would result in a failure message that displays `` assertion failed: `(left ==
right)` `` and that `left` was `5` and `right` was `4`.
-->
<p>Notez que dans certains langages et environnements de test, les paramètres des
fonctions qui vérifient que deux valeurs soient égales sont appelés <code>attendu</code> et
<code>effectif</code>, et l'ordre dans lesquels nous renseignons les arguments est
important. Cependant, dans Rust, on les appelle <code>gauche</code> et <code>droite</code>, et l'ordre
dans lesquels nous renseignons la valeur que nous attendons et la valeur que
produit le code à tester n'est pas important. Nous pouvons écrire la
vérification de ce test dans la forme <code>assert_eq!(ajouter_deux(2), 4)</code>, ce qui
donnera un message d'échec qui affichera <code>assertion failed: `(left == right)`</code> et que gauche vaudra <code>5</code> et droit vaudra <code>4</code>.</p>
<!--
The `assert_ne!` macro will pass if the two values we give it are not equal and
fail if they’re equal. This macro is most useful for cases when we’re not sure
what a value *will* be, but we know what the value definitely *won’t* be if our
code is functioning as we intend. For example, if we’re testing a function that
is guaranteed to change its input in some way, but the way in which the input
is changed depends on the day of the week that we run our tests, the best thing
to assert might be that the output of the function is not equal to the input.
-->
<p>La macro <code>assert_ne!</code> va réussir si les deux valeurs que nous lui donnons ne
sont pas égales et va échouer si elles sont égales. Cette macro est utile dans
les cas où nous ne sommes pas sûr de ce que <em>devrait</em> valoir une valeur, mais
que nous savons ce que la valeur ne devrait surtout <em>pas</em> être si notre code
fonctionne comme nous le souhaitons. Par exemple, si nous testons une fonction
qui doit transformer sa valeur d'entrée de manière à ce qu'elle dépend du jour
de la semaine où nous lançons nos tests, la meilleure façon de vérifier serait
que la sortie de la fonction ne soit pas égale à son entrée.</p>
<!--
Under the surface, the `assert_eq!` and `assert_ne!` macros use the operators
`==` and `!=`, respectively. When the assertions fail, these macros print their
arguments using debug formatting, which means the values being compared must
implement the `PartialEq` and `Debug` traits. All the primitive types and most
of the standard library types implement these traits. For structs and enums
that you define, you’ll need to implement `PartialEq` to assert that values of
those types are equal or not equal. You’ll need to implement `Debug` to print
the values when the assertion fails. Because both traits are derivable traits,
as mentioned in Listing 5-12 in Chapter 5, this is usually as straightforward
as adding the `#[derive(PartialEq, Debug)]` annotation to your struct or enum
definition. See Appendix C, [“Derivable Traits,”][derivable-traits]<!-- ignore
-- > for more details about these and other derivable traits.
-->
<p>Sous la surface, les macros <code>assert_eq!</code> et <code>assert_ne!</code> utilisent
respectivement les opérateurs <code>==</code> et <code>!=</code>. Lorsque les vérifications échouent,
ces macros affichent leurs arguments en utilisant le formatage de déboguage, ce
qui veut dire que les valeurs comparées doivent implémenter les traits
<code>PartialEq</code> et <code>Debug</code>. Tous les types primitifs et la plupart des types de
la bibliothèque standard implémentent ces traits. Concernant les structures et
les énumérations que vous définissez, vous allez avoir besoin de leur
implémenter <code>Debug</code> pour afficher les valeurs lorsque les vérifications
échouent. Comme ces traits sont des traits dérivables, comme nous l'avons évoqué
dans l'encart 5-12 du chapitre 5, il suffit généralement de simplement ajouter
l'annotation <code>#[derive(PartialEq, Debug)]</code> sur les définitions de vos structures
ou énumérations. Rendez-vous à <a href="appendix-03-derivable-traits.html">l'annexe C</a><!-- ignore -->
pour en savoir plus sur ces derniers et les autres traits dérivables.</p>
<!--
### Adding Custom Failure Messages
-->
<h3 id="ajouter-des-messages-déchec-personnalisés"><a class="header" href="#ajouter-des-messages-déchec-personnalisés">Ajouter des messages d'échec personnalisés</a></h3>
<!--
You can also add a custom message to be printed with the failure message as
optional arguments to the `assert!`, `assert_eq!`, and `assert_ne!` macros. Any
arguments specified after the one required argument to `assert!` or the two
required arguments to `assert_eq!` and `assert_ne!` are passed along to the
`format!` macro (discussed in Chapter 8 in the [“Concatenation with the `+`
Operator or the `format!`
Macro”][concatenation-with-the--operator-or-the-format-macro]<!-- ignore -- >
section), so you can pass a format string that contains `{}` placeholders and
values to go in those placeholders. Custom messages are useful to document
what an assertion means; when a test fails, you’ll have a better idea of what
the problem is with the code.
-->
<p>Vous pouvez aussi ajouter un message personnalisé qui peut être affiché avec le
message d'échec comme un argument optionnel aux macros <code>assert!</code>, <code>assert_eq!</code>,
et <code>assert_ne!</code>. Tous les arguments renseignés après celui qui est obligatoire
dans <code>assert!</code> ou les deux arguments obligatoires de <code>assert_eq!</code> et
<code>assert_ne!</code> sont envoyés à la macro <code>format!</code> (que nous avons vu dans une
section du
<a href="ch08-02-strings.html">chapitre
8</a><!-- ignore -->), ainsi
vous pouvez passer une chaine de caractères de formatage qui contient des espaces
réservés <code>{}</code> et les valeurs iront dans ces espaces réservés. Les messages
personnalisés sont utiles pour documenter ce que fait une vérification ;
lorsqu'un test échoue, vous aurez une idée plus précise du problème avec ce
code.</p>
<!--
For example, let’s say we have a function that greets people by name and we
want to test that the name we pass into the function appears in the output:
-->
<p>Par exemple, disons que nous avons une fonction qui accueille les gens par leur
nom et que nous voulons tester que le nom que nous envoyons à la fonction
apparaît dans le résultat :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
pub fn accueil(nom: &str) -> String {
    format!("Salut, {} !", nom)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn accueil_contient_le_nom() {
        let resultat = accueil("Carole");
        assert!(resultat.contains("Carole"));
    }
}
```
-->
<pre><code class="language-rust noplayground">pub fn accueil(nom: &amp;str) -&gt; String {
    format!(&quot;Salut, {} !&quot;, nom)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn accueil_contient_le_nom() {
        let resultat = accueil(&quot;Carole&quot;);
        assert!(resultat.contains(&quot;Carole&quot;));
    }
}
</code></pre>
<!--
The requirements for this program haven’t been agreed upon yet, and we’re
pretty sure the `Hello` text at the beginning of the greeting will change. We
decided we don’t want to have to update the test when the requirements change,
so instead of checking for exact equality to the value returned from the
`greeting` function, we’ll just assert that the output contains the text of the
input parameter.
-->
<p>Les spécifications de ce programme n'ont pas été validées entièrement pour le
moment, et on est quasiment sûr que le texte <code>Salut</code> au début va changer. Nous
avons décidé que nous ne devrions pas à avoir à changer le test si les
spécifications changent, donc plutôt que de vérifier l'égalité exacte de la
valeur retournée par la fonction <code>accueil</code>, nous allons uniquement vérifier que
le résultat contient le texte correspondant au paramètre d'entrée de la
fonction.</p>
<!--
Let’s introduce a bug into this code by changing `greeting` to not include
`name` to see what this test failure looks like:
-->
<p>Introduisons un bogue dans ce code en changeant <code>accueil</code> pour ne pas
ajouter <code>nom</code> afin de voir ce que donne l'échec de ce test :</p>
<!--
```rust,not_desired_behavior,noplayground
pub fn accueil(name: &str) -> String {
    String::from("Salut !")
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn accueil_contient_le_nom() {
#         let resultat = accueil("Carole");
#         assert!(resultat.contains("Carole"));
#     }
# }
```
-->
<pre><code class="language-rust not_desired_behavior noplayground">pub fn accueil(name: &amp;str) -&gt; String {
    String::from(&quot;Salut !&quot;)
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn accueil_contient_le_nom() {
</span><span class="boring">        let resultat = accueil(&quot;Carole&quot;);
</span><span class="boring">        assert!(resultat.contains(&quot;Carole&quot;));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Running this test produces the following:
-->
<p>L'exécution du test va donner ceci :</p>
<!--
```console
$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::accueil_contient_le_nom ... FAILED

failures:

---- tests::accueil_contient_le_nom stdout ----
thread 'main' panicked at 'assertion failed: resultat.contains(\"Carole\")', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::accueil_contient_le_nom

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::accueil_contient_le_nom ... FAILED

failures:

---- tests::accueil_contient_le_nom stdout ----
thread 'main' panicked at 'assertion failed: resultat.contains(\&quot;Carole\&quot;)', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::accueil_contient_le_nom

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
This result just indicates that the assertion failed and which line the
assertion is on. A more useful failure message in this case would print the
value we got from the `greeting` function. Let’s change the test function,
giving it a custom failure message made from a format string with a placeholder
filled in with the actual value we got from the `greeting` function:
-->
<p>Ce résultat indique simplement que la vérification a échoué, et à quel endroit.
Le message d'échec serait plus utile dans notre cas s'il affichait la valeur
que nous obtenons de la fonction <code>accueil</code>. Changeons la fonction de test, pour
lui donner un message d'erreur personnalisé, qui est une chaîne de caractères
de formatage avec un espace réservé qui contiendra la valeur que
nous avons obtenue de la fonction <code>accueil</code> :</p>
<!--
```rust,ignore
# pub fn accueil(nom: &str) -> String {
#     String::from("Salut !")
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
    #[test]
    fn accueil_contient_le_nom() {
        let resultat = accueil("Carole");
        assert!(
            resultat.contains("Carole"),
            "Le message d'accueil ne contient pas le nom, il vaut `{}`",
            resultat
        );
    }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub fn accueil(nom: &amp;str) -&gt; String {
</span><span class="boring">    String::from(&quot;Salut !&quot;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn accueil_contient_le_nom() {
        let resultat = accueil(&quot;Carole&quot;);
        assert!(
            resultat.contains(&quot;Carole&quot;),
            &quot;Le message d'accueil ne contient pas le nom, il vaut `{}`&quot;,
            resultat
        );
    }
<span class="boring">}
</span></code></pre>
<!--
Now when we run the test, we’ll get a more informative error message:
-->
<p>Maintenant, lorsque nous lançons à nouveau le test, nous obtenons un message
d'échec plus explicite :</p>
<!--
```console
$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::accueil_contient_le_nom ... FAILED

failures:

---- tests::accueil_contient_le_nom stdout ----
thread 'main' panicked at 'Le message d'accueil ne contient pas le nom, il vaut `Salut !`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::accueil_contient_le_nom

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::accueil_contient_le_nom ... FAILED

failures:

---- tests::accueil_contient_le_nom stdout ----
thread 'main' panicked at 'Le message d'accueil ne contient pas le nom, il vaut `Salut !`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::accueil_contient_le_nom

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
We can see the value we actually got in the test output, which would help us
debug what happened instead of what we were expecting to happen.
-->
<p>Nous pouvons voir la valeur que nous avons obtenue lors de la lecture du
résultat du test, ce qui va nous aider à déboguer ce qui s'est passé à la
place de ce que nous voulions qu'il se passe.</p>
<!--
### Checking for Panics with `should_panic`
-->
<h3 id="vérifier-le-fonctionnement-des-paniques-avec-should_panic"><a class="header" href="#vérifier-le-fonctionnement-des-paniques-avec-should_panic">Vérifier le fonctionnement des paniques avec <code>should_panic</code></a></h3>
<!--
In addition to checking that our code returns the correct values we expect,
it’s also important to check that our code handles error conditions as we
expect. For example, consider the `Guess` type that we created in Chapter 9,
Listing 9-13. Other code that uses `Guess` depends on the guarantee that `Guess`
instances will contain only values between 1 and 100. We can write a test that
ensures that attempting to create a `Guess` instance with a value outside that
range panics.
-->
<p>En plus de vérifier que notre code retourne bien les valeurs que nous
souhaitons, il est aussi important de vérifier que notre code gère bien les cas
d'erreurs comme nous le souhaitons. Par exemple, utilisons le type <code>Supposition</code>
que nous avons créé au chapitre 9, dans l'encart 9-13. Les autres codes qui
utilisent <code>Supposition</code> reposent sur la garantie que les instances de
<code>Supposition</code> contiennent uniquement des valeurs entre 1 et 100. Nous pouvons
écrire un test qui s'assure que la création d'une instance de <code>Supposition</code>
avec une valeur en dehors de cette intervalle va faire paniquer le programme.</p>
<!--
We do this by adding another attribute, `should_panic`, to our test function.
This attribute makes a test pass if the code inside the function panics; the
test will fail if the code inside the function doesn’t panic.
-->
<p>Nous allons vérifier cela en ajoutant un autre attribut, <code>should_panic</code>, à notre
fonction de test. Cet attribut fait réussir le test si le code à l'intérieur
de la fonction fait paniquer ; le test va échouer si le code à l'intérieur de
la fonction ne panique pas.</p>
<!--
Listing 11-8 shows a test that checks that the error conditions of `Guess::new`
happen when we expect them to.
-->
<p>L'encart 11-8 nous montre un test qui vérifie que les conditions d'erreur de
<code>Supposition::new</code> fonctionne bien comme nous l'avons prévu.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 || valeur > 100 {
            panic!("La supposition doit se trouver entre 1 et 100, et nous avons {}.", valeur);
        }

        Supposition { valeur }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn plus_grand_que_100() {
        Supposition::new(200);
    }
}
```
-->
<pre><code class="language-rust noplayground">pub struct Supposition {
    valeur: i32,
}

impl Supposition {
    pub fn new(valeur: i32) -&gt; Supposition {
        if valeur &lt; 1 || valeur &gt; 100 {
            panic!(&quot;La supposition doit se trouver entre 1 et 100, et nous avons {}.&quot;, valeur);
        }

        Supposition { valeur }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn plus_grand_que_100() {
        Supposition::new(200);
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-8: Testing that a condition will cause a
`panic!`</span>
-->
<p><span class="caption">Encart 11-8 : tester qu'une condition va faire un <code>panic</code>
</span></p>
<!--
We place the `#[should_panic]` attribute after the `#[test]` attribute and
before the test function it applies to. Let’s look at the result when this test
passes:
-->
<p>Nous plaçons l'attribut <code>#[should_panic]</code> après l'attribut <code>#[test]</code> et avant
la fonction de test sur laquelle il s'applique. Voyons le résultat lorsque ce
test réussit :</p>
<!--
```console
$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
Looks good! Now let’s introduce a bug in our code by removing the condition
that the `new` function will panic if the value is greater than 100:
-->
<p>Ca fonctionne ! Maintenant, ajoutons un bogue dans notre code en enlevant
la condition dans laquelle la fonction <code>new</code> panique lorsque la valeur est
plus grande que 100 :</p>
<!--
```rust,not_desired_behavior,noplayground
# pub struct Supposition {
#     valeur: i32,
# }
# 
// -- partie masquée ici --
impl Supposition {
    pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 {
            panic!("La supposition doit se trouver entre 1 et 100, et nous avons {}.", valeur);
        }

        Supposition { valeur }
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     #[should_panic]
#     fn plus_grand_que_100() {
#         Supposition::new(200);
#     }
# }
```
-->
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Supposition {
</span><span class="boring">    valeur: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquée ici --
impl Supposition {
    pub fn new(valeur: i32) -&gt; Supposition {
        if valeur &lt; 1 {
            panic!(&quot;La supposition doit se trouver entre 1 et 100, et nous avons {}.&quot;, valeur);
        }

        Supposition { valeur }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn plus_grand_que_100() {
</span><span class="boring">        Supposition::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
When we run the test in Listing 11-8, it will fail:
-->
<p>Lorsque nous lançons le test de l'encart 11-8, il va échouer :</p>
<!--
```console
$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... FAILED

failures:

---- tests::plus_grand_que_100 stdout ----
note: test did not panic as expected

failures:
    tests::plus_grand_que_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... FAILED

failures:

---- tests::plus_grand_que_100 stdout ----
note: test did not panic as expected

failures:
    tests::plus_grand_que_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
We don’t get a very helpful message in this case, but when we look at the test
function, we see that it’s annotated with `#[should_panic]`. The failure we got
means that the code in the test function did not cause a panic.
-->
<p>Dans ce cas, nous n'obtenons pas de message très utile, mais lorsque nous
regardons la fonction de test, nous constatons qu'elle est marquée avec
<code>#[should_panic]</code>. L'échec que nous obtenons signifie que le code dans la
fonction de test n'a pas fait paniquer.</p>
<!--
Tests that use `should_panic` can be imprecise because they only indicate that
the code has caused some panic. A `should_panic` test would pass even if the
test panics for a different reason from the one we were expecting to happen. To
make `should_panic` tests more precise, we can add an optional `expected`
parameter to the `should_panic` attribute. The test harness will make sure that
the failure message contains the provided text. For example, consider the
modified code for `Guess` in Listing 11-9 where the `new` function panics with
different messages depending on whether the value is too small or too large.
-->
<p>Les tests qui utilisent <code>should_panic</code> ne sont parfois pas assez explicites car
ils indiquent seulement que le code a paniqué. Un test <code>should_panic</code> peut
réussir, même si le test panique pour une raison différente à celle que nous
attendions. Pour rendre les tests <code>should_panic</code> plus précis, nous pouvons
ajouter un paramètre optionnel <code>expected</code> à l'attribut <code>should_panic</code>. Le
système de test va s'assurer que le message d'échec contient bien le texte
renseigné. Par exemple, imaginons le code modifié de <code>Supposition</code> dans
l'encart 11-9 où la fonction <code>new</code> panique avec des messages différents si la
valeur est trop petite ou trop grande.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
# pub struct Supposition {
#     valeur: i32,
# }
# 
// -- partie masquée ici --
impl Supposition {
    pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 {
            panic!(
                "La supposition doit être plus grande ou égale à 1, et nous avons {}.",
                valeur
            );
        } else if valeur > 100 {
            panic!(
                "La supposition doit être plus petite ou égale à 100, et nous avons {}.",
                valeur
            );
        }

        Supposition { valeur }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "La supposition doit être plus petite ou égale à 100")]
    fn plus_grand_que_100() {
        Supposition::new(200);
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub struct Supposition {
</span><span class="boring">    valeur: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquée ici --
impl Supposition {
    pub fn new(valeur: i32) -&gt; Supposition {
        if valeur &lt; 1 {
            panic!(
                &quot;La supposition doit être plus grande ou égale à 1, et nous avons {}.&quot;,
                valeur
            );
        } else if valeur &gt; 100 {
            panic!(
                &quot;La supposition doit être plus petite ou égale à 100, et nous avons {}.&quot;,
                valeur
            );
        }

        Supposition { valeur }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;La supposition doit être plus petite ou égale à 100&quot;)]
    fn plus_grand_que_100() {
        Supposition::new(200);
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-9: Testing that a condition will cause a
`panic!` with a particular panic message</span>
-->
<p><span class="caption">Encart 11-9 : on vérifie qu'une situation va provoquer un
<code>panic!</code> avec un message de panique bien précis</span></p>
<!--
This test will pass because the value we put in the `should_panic` attribute’s
`expected` parameter is a substring of the message that the `Guess::new`
function panics with. We could have specified the entire panic message that we
expect, which in this case would be `Guess value must be less than or equal to
100, got 200.` What you choose to specify in the expected parameter for
`should_panic` depends on how much of the panic message is unique or dynamic
and how precise you want your test to be. In this case, a substring of the
panic message is enough to ensure that the code in the test function executes
the `else if value > 100` case.
-->
<p>Ce test va réussir car la valeur que nous insérons dans l'attribut <code>expected</code>
de <code>should_panic</code> est une partie du message de panique de la fonction
<code>Supposition::new</code>. Nous aurions pu renseigner le message de panique en entier
que nous attendions, qui dans ce cas est <code>La supposition doit être plus petite ou égale à 100, et nous avons 200.</code>. Ce que vous choisissez de renseigner dans
le paramètre <code>expected</code> de <code>should_panic</code> dépend de la mesure dans laquelle le
message de panique est unique ou dynamique et de la précision de votre test que
vous souhaitez appliquer. Dans ce cas, un extrait du message de panique est
suffisant pour s'assurer que le code de la fonction de test s'exécute dans le
cas du <code>else if valeur &gt; 100</code>.</p>
<!--
To see what happens when a `should_panic` test with an `expected` message
fails, let’s again introduce a bug into our code by swapping the bodies of the
`if value < 1` and the `else if value > 100` blocks:
-->
<p>Pour voir ce qui se passe lorsqu'un test <code>should_panic</code> qui a un message
<code>expected</code> qui échoue, essayons à nouveau d'introduire un bogue dans notre code
en permutant les corps des blocs de <code>if valeur &lt; 1</code> et de
<code>else if valeur &gt; 100</code> :</p>
<!--
```rust,ignore,not_desired_behavior
# pub struct Supposition {
#     valeur: i32,
# }
# 
# impl Supposition {
#     pub fn new(valeur: i32) -> Supposition {
        if valeur < 1 {
            panic!(
                "La supposition doit être plus petite ou égale à 100, et nous avons {}.",
                valeur
            );
        } else if valeur > 100 {
            panic!(
                "La supposition doit être plus grande ou égale à 1, et nous avons {}.",
                valeur
            );
        }
# 
#         Supposition { valeur }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     #[should_panic(expected = "La supposition doit être plus petite ou égale à 100")]
#     fn plus_grand_que_100() {
#         Supposition::new(200);
#     }
# }
```
-->
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Supposition {
</span><span class="boring">    valeur: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Supposition {
</span><span class="boring">    pub fn new(valeur: i32) -&gt; Supposition {
</span>        if valeur &lt; 1 {
            panic!(
                &quot;La supposition doit être plus petite ou égale à 100, et nous avons {}.&quot;,
                valeur
            );
        } else if valeur &gt; 100 {
            panic!(
                &quot;La supposition doit être plus grande ou égale à 1, et nous avons {}.&quot;,
                valeur
            );
        }
<span class="boring">
</span><span class="boring">        Supposition { valeur }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = &quot;La supposition doit être plus petite ou égale à 100&quot;)]
</span><span class="boring">    fn plus_grand_que_100() {
</span><span class="boring">        Supposition::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
This time when we run the `should_panic` test, it will fail:
-->
<p>Cette fois, lorsque nous lançons le test avec <code>should_panic</code>, il devrait
échouer :</p>
<!--
```console
$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... FAILED

failures:

---- tests::plus_grand_que_100 stdout ----
thread 'main' panicked at 'La supposition doit être plus grande ou égale à 1, et nous avons 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `"La supposition doit être plus grande ou égale à 1, et nous avons 200."`,
 expected substring: `"La supposition doit être plus petite ou égale à 100"`

failures:
    tests::plus_grand_que_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::plus_grand_que_100 - should panic ... FAILED

failures:

---- tests::plus_grand_que_100 stdout ----
thread 'main' panicked at 'La supposition doit être plus grande ou égale à 1, et nous avons 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `&quot;La supposition doit être plus grande ou égale à 1, et nous avons 200.&quot;`,
 expected substring: `&quot;La supposition doit être plus petite ou égale à 100&quot;`

failures:
    tests::plus_grand_que_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
The failure message indicates that this test did indeed panic as we expected,
but the panic message did not include the expected string `'Guess value must be
less than or equal to 100'`. The panic message that we did get in this case was
`Guess value must be greater than or equal to 1, got 200.` Now we can start
figuring out where our bug is!
-->
<p>Le message d'échec nous informe que ce test a paniqué comme prévu, mais que le
message de panique n'inclus pas la chaîne de caractères prévue <code>'La supposition doit être plus petite ou égale à 100'</code>. Le message de panique que nous avons
obtenu dans ce cas était <code>La supposition doit être plus grande ou égale à 1, et nous avons 200.</code>. Maintenant, on comprend mieux où est le bogue !</p>
<!--
### Using `Result<T, E>` in Tests
-->
<h3 id="utiliser-resultt-e-dans-les-tests"><a class="header" href="#utiliser-resultt-e-dans-les-tests">Utiliser <code>Result&lt;T, E&gt;</code> dans les tests</a></h3>
<!--
So far, we’ve written tests that panic when they fail. We can also write tests
that use `Result<T, E>`! Here’s the test from Listing 11-1, rewritten to use
`Result<T, E>` and return an `Err` instead of panicking:
-->
<p>Précédemment, nous avons écrit des tests qui paniquent lorsqu'ils échouent.
Nous pouvons également écrire des tests qui utilisent <code>Result&lt;T, E&gt;</code> ! Voici
le test de l'encart 11-1, réécris pour utiliser <code>Result&lt;T, E&gt;</code> et retourner
une <code>Err</code> au lieu de paniquer :</p>
<!--
```rust,noplayground
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("deux plus deux ne vaut pas quatre"))
        }
    }
}
```
-->
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;deux plus deux ne vaut pas quatre&quot;))
        }
    }
}
</code></pre>
<!--
The `it_works` function now has a return type, `Result<(), String>`. In the
body of the function, rather than calling the `assert_eq!` macro, we return
`Ok(())` when the test passes and an `Err` with a `String` inside when the test
fails.
-->
<p>La fonction <code>it_works</code> a maintenant un type de retour, <code>Result&lt;(), String&gt;</code>.
Dans le corps de la fonction, plutôt que d'appeler la macro <code>assert_eq!</code>, nous
retournons <code>Ok(())</code> lorsque le test réussit et une <code>Err</code> avec une <code>String</code> à
l'intérieur lorsque le test échoue.</p>
<!--
Writing tests so they return a `Result<T, E>` enables you to use the question
mark operator in the body of tests, which can be a convenient way to write
tests that should fail if any operation within them returns an `Err` variant.
-->
<p>Ecrire vos tests afin qu'ils retournent un <code>Result&lt;T, E&gt;</code> vous permet
d'utiliser l'opérateur <em>point d'interrogation</em> dans le corps des tests, ce
qui est un outil facile à utiliser pour écrire des tests qui peuvent échouer
si n'importe quelle opération en son sein retourne une variante de <code>Err</code>.</p>
<!--
You can’t use the `#[should_panic]` annotation on tests that use `Result<T,
E>`. Instead, you should return an `Err` value directly when the test should
fail.
-->
<p>Vous ne pouvez pas utiliser l'annotation <code>#[should_panic]</code> sur les tests qui
utilisent <code>Result&lt;T, E&gt;</code>. Mais à la place, vous devez retourner directement
une valeur <code>Err</code> lorsque le test échoue.</p>
<!--
Now that you know several ways to write tests, let’s look at what is happening
when we run our tests and explore the different options we can use with `cargo
test`.
-->
<p>Maintenant que vous avez appris différentes manières d'écrire des tests, voyons
ce qui se passe lorsque nous lançons nos tests et explorons les différentes
options que nous pouvons utiliser avec <code>cargo test</code>.</p>
<!--
[concatenation-with-the--operator-or-the-format-macro]:
ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro
[controlling-how-tests-are-run]:
ch11-02-running-tests.html#controlling-how-tests-are-run
[derivable-traits]: appendix-03-derivable-traits.html
[doc-comments]: ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests
[paths-for-referring-to-an-item-in-the-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Controlling How Tests Are Run
-->
<h2 id="gérer-lexécution-des-tests"><a class="header" href="#gérer-lexécution-des-tests">Gérer l'exécution des tests</a></h2>
<!--
Just as `cargo run` compiles your code and then runs the resulting binary,
`cargo test` compiles your code in test mode and runs the resulting test
binary. You can specify command line options to change the default behavior of
`cargo test`. For example, the default behavior of the binary produced by
`cargo test` is to run all the tests in parallel and capture output generated
during test runs, preventing the output from being displayed and making it
easier to read the output related to the test results.
-->
<p>Comme <code>cargo run</code> qui compile votre code et qui exécute ensuite le binaire qui
en résulte, <code>cargo test</code> compile votre code en mode test et lance le binaire de
tests qu'il produit. Vous pouvez rajouter des options en ligne de commande pour
changer le comportement par défaut de <code>cargo test</code>. Par exemple, le
comportement par défaut des binaires produits par <code>cargo test</code> est de lancer
tous les tests en parallèle et de capturer la sortie pendant l'exécution des
tests, ce qui évite à la sortie d'être affichée sur l'écran pendant ce temps et
facilite la lecture de la sortie concernant le résultat de l'exécution des
tests.</p>
<!--
Some command line options go to `cargo test`, and some go to the resulting test
binary. To separate these two types of arguments, you list the arguments that
go to `cargo test` followed by the separator `--` and then the ones that go to
the test binary. Running `cargo test --help` displays the options you can use
with `cargo test`, and running `cargo test -- --help` displays the options you
can use after the separator `--`.
-->
<p>Certaines options de la ligne de commande s'appliquent à <code>cargo test</code>, et
certaines au binaire de tests qui en résulte. Pour séparer ces types
d'arguments, il faut lister les arguments qui s'appliquent à <code>cargo test</code>,
suivis du séparateur <code>--</code>, puis ajouter ceux qui s'appliquent au binaire
de tests. L'exécution de <code>cargo test --help</code> affiche les options que vous
pouvez utiliser sur <code>cargo test</code>, et l'exécution de <code>cargo test -- --help</code>
affiche les options que vous pouvez utiliser après le séparateur <code>--</code>.</p>
<!--
### Running Tests in Parallel or Consecutively
-->
<h3 id="lancer-les-tests-en-parallèle-ou-en-séquence"><a class="header" href="#lancer-les-tests-en-parallèle-ou-en-séquence">Lancer les tests en parallèle ou en séquence</a></h3>
<!--
When you run multiple tests, by default they run in parallel using threads.
This means the tests will finish running faster so you can get feedback quicker
on whether or not your code is working. Because the tests are running at the
same time, make sure your tests don’t depend on each other or on any shared
state, including a shared environment, such as the current working directory or
environment variables.
-->
<p>Lorsque vous lancez de nombreux tests, par défaut ils s'exécutent en parallèle
dans des tâches. Cela veut dire que tous les tests vont finir de s'exécuter plus
rapidement afin que vous sachiez si votre code fonctionne ou non. Comme mes
tests s'exécutent en même temps, il faut s'assurer que vos tests ne dépendent
pas l'un de l'autre ou d'un état partagé, y compris un environnement partagé,
comme le dossier de travail actuel ou des variables d'environnement.</p>
<!--
For example, say each of your tests runs some code that creates a file on disk
named *test-output.txt* and writes some data to that file. Then each test reads
the data in that file and asserts that the file contains a particular value,
which is different in each test. Because the tests run at the same time, one
test might overwrite the file between when another test writes and reads the
file. The second test will then fail, not because the code is incorrect but
because the tests have interfered with each other while running in parallel.
One solution is to make sure each test writes to a different file; another
solution is to run the tests one at a time.
-->
<p>Par exemple, disons que chacun de vos tests exécute du code qui crée un fichier
<em>test-sortie.txt</em> sur le disque-dur et qu'il écrit quelques données dans ce
fichier. Ensuite, chaque test lit les données de ce fichier et vérifie que le
fichier contient une valeur précise, qui est différente dans chaque test. Comme
les tests sont lancés en même temps, un test risque d'écraser le contenu du
fichier entre le moment où un autre test lit et écrit sur ce fichier. Le second
test va ensuite échouer, non pas parce que le code est incorrect mais parce
que les tests se sont perturbés mutuellement pendant qu'ils s'exécutaient en
parallèle. Une solution serait de s'assurer que chaque test écrit dans un
fichier différent ; une autre serait de lancer les tests les uns après les autres.</p>
<!--
If you don’t want to run the tests in parallel or if you want more fine-grained
control over the number of threads used, you can send the `--test-threads` flag
and the number of threads you want to use to the test binary. Take a look at
the following example:
-->
<p>Si vous ne souhaitez pas exécuter les tests en parallèle ou si vous voulez un
contrôle plus précis du nombre de tâches utilisés, vous pouvez envoyer le
drapeau <code>--test-threads</code> ainsi que le nombre de tâches que vous souhaitez
utiliser sur le binaire de test. Regardez cet exemple :</p>
<!--
```console
$ cargo test -- --test-threads=1
```
-->
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<!--
We set the number of test threads to `1`, telling the program not to use any
parallelism. Running the tests using one thread will take longer than running
them in parallel, but the tests won’t interfere with each other if they share
state.
-->
<p>Nous avons réglé le nombre de tâches à <code>1</code>, ce qui indique au programme de ne
pas utiliser le parallélisme. Exécuter ces tests en utilisant une seule tâche va
prendre plus de temps que de les lancer en parallèle, mais les tests ne vont pas
s'influencer mutuellement s'ils partagent le même état.</p>
<!--
### Showing Function Output
-->
<h3 id="afficher-la-sortie-de-la-fonction"><a class="header" href="#afficher-la-sortie-de-la-fonction">Afficher la sortie de la fonction</a></h3>
<!--
By default, if a test passes, Rust’s test library captures anything printed to
standard output. For example, if we call `println!` in a test and the test
passes, we won’t see the `println!` output in the terminal; we’ll see only the
line that indicates the test passed. If a test fails, we’ll see whatever was
printed to standard output with the rest of the failure message.
-->
<p>Par défaut, si un test réussit, la bibliothèque de test de Rust récupère tout
ce qui est affiché sur la sortie standard. Par exemple, si nous appelons
<code>println!</code> dans un test et que le test réussit, nous ne verrons pas la sortie
correspondant au <code>println!</code> dans le terminal ; on verra seulement la ligne qui
indique que le test a réussi. Si un test échoue, nous verrons ce qui a été
affiché sur la sortie standard avec le reste des messages d'erreur.</p>
<!--
As an example, Listing 11-10 has a silly function that prints the value of its
parameter and returns 10, as well as a test that passes and a test that fails.
-->
<p>Par exemple, l'encart 11-10 a une fonction stupide qui affiche la valeur de ses
paramètres et retourne 10, ainsi qu'un test qui réussit et un test qui échoue.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,panics,noplayground
fn affiche_et_retourne_10(a: i32) -> i32 {
    println!("J'ai obtenu la valeur {}", a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ce_test_reussit() {
        let valeur = affiche_et_retourne_10(4);
        assert_eq!(10, valeur);
    }

    #[test]
    fn ce_test_echoue() {
        let valeur = affiche_et_retourne_10(8);
        assert_eq!(5, valeur);
    }
}
```
-->
<pre><code class="language-rust panics noplayground">fn affiche_et_retourne_10(a: i32) -&gt; i32 {
    println!(&quot;J'ai obtenu la valeur {}&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ce_test_reussit() {
        let valeur = affiche_et_retourne_10(4);
        assert_eq!(10, valeur);
    }

    #[test]
    fn ce_test_echoue() {
        let valeur = affiche_et_retourne_10(8);
        assert_eq!(5, valeur);
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-10: Tests for a function that calls
`println!`</span>
-->
<p><span class="caption">Encart 11-10 : tests d'une fonction qui fait appel à
<code>println!</code></span></p>
<!--
When we run these tests with `cargo test`, we’ll see the following output:
-->
<p>Lorsque nous lançons ces tests avec <code>cargo test</code>, nous voyons cette sortie :</p>
<!--
```console
$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::ce_test_echoue ... FAILED
test tests::ce_test_reussit ... ok

failures:

---- tests::ce_test_echoue stdout ----
I got the value 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::ce_test_echoue

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::ce_test_echoue ... FAILED
test tests::ce_test_reussit ... ok

failures:

---- tests::ce_test_echoue stdout ----
I got the value 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::ce_test_echoue

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Note that nowhere in this output do we see `I got the value 4`, which is what
is printed when the test that passes runs. That output has been captured. The
output from the test that failed, `I got the value 8`, appears in the section
of the test summary output, which also shows the cause of the test failure.
-->
<p>Remarquez que nous n'avons jamais vu <code>J'ai obtenu la valeur 4</code> dans cette
sortie, qui est ce qui est affiché lors de l'exécution du test qui réussit.
Cette sortie a été capturée. La sortie pour le test qui a échoué,
<code>J'ai obtenu la valeur 8</code>, s'affiche dans la section de la sortie
correspondante au résumé des tests, qui affiche aussi les causes de l'échec
du test.</p>
<!--
If we want to see printed values for passing tests as well, we can tell Rust
to also show the output of successful tests at the end with `--show-output`.
-->
<p>Si nous voulons aussi voir les valeurs affichées pour les tests réussis, nous
pouvons demander à Rust d'afficher également la sortie des tests fructueux en
lui rajoutant à la fin <code>--show-output</code>.</p>
<!--
```console
$ cargo test -- --show-output
```
-->
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<!--
When we run the tests in Listing 11-10 again with the `--show-output` flag, we
see the following output:
-->
<p>Lorsque nous lançons à nouveau les tests de l'encart 11-10 avec le drapeau
<code>--show-output</code>, nous voyons la sortie suivante :</p>
<!--
```console
$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::ce_test_echoue ... FAILED
test tests::ce_test_reussit ... ok

successes:

---- tests::ce_test_reussit stdout ----
J'ai obtenu la valeur 4


successes:
    tests::ce_test_reussit

failures:

---- tests::ce_test_echoue stdout ----
J'ai obtenu la valeur 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::ce_test_echoue

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::ce_test_echoue ... FAILED
test tests::ce_test_reussit ... ok

successes:

---- tests::ce_test_reussit stdout ----
J'ai obtenu la valeur 4


successes:
    tests::ce_test_reussit

failures:

---- tests::ce_test_echoue stdout ----
J'ai obtenu la valeur 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::ce_test_echoue

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
### Running a Subset of Tests by Name
-->
<h3 id="exécuter-un-sous-ensemble-de-tests-en-fonction-de-son-nom"><a class="header" href="#exécuter-un-sous-ensemble-de-tests-en-fonction-de-son-nom">Exécuter un sous-ensemble de tests en fonction de son nom</a></h3>
<!--
Sometimes, running a full test suite can take a long time. If you’re working on
code in a particular area, you might want to run only the tests pertaining to
that code. You can choose which tests to run by passing `cargo test` the name
or names of the test(s) you want to run as an argument.
-->
<p>Parfois, lancer une suite de tests entière peut prendre beaucoup de temps. Si
vous travaillez sur du code d'un périmètre bien défini, vous pourriez avoir
besoin d'exécuter uniquement les tests relatifs à ce code. Vous pouvez choisir
quels tests exécuter en envoyant le ou les noms des test(s) que vous souhaitez
exécuter en argument de <code>cargo test</code>.</p>
<!--
To demonstrate how to run a subset of tests, we’ll create three tests for our
`add_two` function, as shown in Listing 11-11, and choose which ones to run.
-->
<p>Dans le but de démontrer comment lancer un sous-ensemble de tests, nous allons
créer trois tests pour notre fonction <code>ajouter_deux</code> dans l'encart 11-11, et
choisir lesquels nous allons exécuter.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
pub fn ajouter_deux(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ajouter_deux_a_deux() {
        assert_eq!(4, ajouter_deux(2));
    }

    #[test]
    fn ajouter_deux_a_trois() {
        assert_eq!(5, ajouter_deux(3));
    }

    #[test]
    fn cent() {
        assert_eq!(102, ajouter_deux(100));
    }
}
```
-->
<pre><code class="language-rust noplayground">pub fn ajouter_deux(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ajouter_deux_a_deux() {
        assert_eq!(4, ajouter_deux(2));
    }

    #[test]
    fn ajouter_deux_a_trois() {
        assert_eq!(5, ajouter_deux(3));
    }

    #[test]
    fn cent() {
        assert_eq!(102, ajouter_deux(100));
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-11: Three tests with three different
names</span>
-->
<p><span class="caption">Encart 11-11 : trois tests avec trois noms différents
</span></p>
<!--
If we run the tests without passing any arguments, as we saw earlier, all the
tests will run in parallel:
-->
<p>Si nous exécutons les tests sans ajouter d'arguments, comme nous l'avons vu
précédemment, tous les tests vont s'exécuter en parallèle :</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::ajouter_deux_a_trois ... ok
test tests::ajouter_deux_a_deux ... ok
test tests::cent ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::ajouter_deux_a_trois ... ok
test tests::ajouter_deux_a_deux ... ok
test tests::cent ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
#### Running Single Tests
-->
<h4 id="exécuter-des-tests-individuellement"><a class="header" href="#exécuter-des-tests-individuellement">Exécuter des tests individuellement</a></h4>
<!--
We can pass the name of any test function to `cargo test` to run only that test:
-->
<p>Nous pouvons donner le nom de n'importe quelle fonction de test à <code>cargo test</code>
afin d'exécuter uniquement ce test :</p>
<!--
```console
$ cargo test cent
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::cent ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test cent
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::cent ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

</code></pre>
<!--
Only the test with the name `one_hundred` ran; the other two tests didn’t match
that name. The test output lets us know we had more tests than what this
command ran by displaying `2 filtered out` at the end of the summary line.
-->
<p>Le test avec le nom <code>cent</code> est le seul exécuté ; les deux autres tests ne
correspondent pas à ce nom. La sortie du test nous indique que nous avons
d'autres tests en plus de celui que cette commande a exécuté en affichant
<code>2 filtered out</code> à la fin de la ligne de résumé.</p>
<!--
We can’t specify the names of multiple tests in this way; only the first value
given to `cargo test` will be used. But there is a way to run multiple tests.
-->
<p>Nous ne pouvons pas renseigner plusieurs noms de tests de cette manière ; il
n'y a que la première valeur fournie à <code>cargo test</code> qui sera utilisée. Mais
il existe un moyen d'exécuter plusieurs tests.</p>
<!--
#### Filtering to Run Multiple Tests
-->
<h4 id="filtrer-pour-exécuter-plusieurs-tests"><a class="header" href="#filtrer-pour-exécuter-plusieurs-tests">Filtrer pour exécuter plusieurs tests</a></h4>
<!--
We can specify part of a test name, and any test whose name matches that value
will be run. For example, because two of our tests’ names contain `add`, we can
run those two by running `cargo test add`:
-->
<p>Nous pouvons renseigner qu'une partie d'un nom de test, et tous les tests dont
les noms correspondent à cette valeur vont être exécutés. Par exemple, comme
deux de nos noms de tests contiennent <code>ajouter</code>, nous pouvons exécuter ces deux
en lançant <code>cargo test ajouter</code> :</p>
<!--
```console
$ cargo test ajouter
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::ajouter_deux_a_trois ... ok
test tests::ajouter_deux_a_deux ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s
```
-->
<pre><code class="language-console">$ cargo test ajouter
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::ajouter_deux_a_trois ... ok
test tests::ajouter_deux_a_deux ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s
</code></pre>
<!--
This command ran all tests with `add` in the name and filtered out the test
named `one_hundred`. Also note that the module in which a test appears becomes
part of the test’s name, so we can run all the tests in a module by filtering
on the module’s name.
-->
<p>Cette commande a lancé tous les tests qui contiennent <code>ajouter</code> dans leur nom
et a filtré le test <code>cent</code>. Notez aussi que le module dans lequel un test est
présent fait partie du nom du test, ainsi nous pouvons exécuter tous les tests
d'un module en filtrant avec le nom du module.</p>
<!--
### Ignoring Some Tests Unless Specifically Requested
-->
<h3 id="ignorer-certains-tests-sauf-sils-sont-demandés-explicitement"><a class="header" href="#ignorer-certains-tests-sauf-sils-sont-demandés-explicitement">Ignorer certains tests sauf s'ils sont demandés explicitement</a></h3>
<!--
Sometimes a few specific tests can be very time-consuming to execute, so you
might want to exclude them during most runs of `cargo test`. Rather than
listing as arguments all tests you do want to run, you can instead annotate the
time-consuming tests using the `ignore` attribute to exclude them, as shown
here:
-->
<p>Parfois, certains tests spécifiques peuvent prendre beaucoup de temps à
s'exécuter, de sorte que vous voulez les exclure de la majorité des exécutions
de <code>cargo test</code>. Plutôt que de lister en argument tous les tests que vous
souhaitez exécuter, vous pouvez plutôt faire une annotation sur les tests qui
prennent du temps en utilisant l'attribut <code>ignore</code> pour les exclure, comme
ci-dessous :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn test_long() {
    // du code qui prend une heure à s'exécuter
}
```
-->
<pre><code class="language-rust noplayground">#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn test_long() {
    // du code qui prend une heure à s'exécuter
}
</code></pre>
<!--
After `#[test]` we add the `#[ignore]` line to the test we want to exclude. Now
when we run our tests, `it_works` runs, but `expensive_test` doesn’t:
-->
<p>Après <code>#[test]</code>, nous avons ajouté la ligne <code>#[ignore]</code> pour le test que nous
souhaitons exclure. Maintenant lorsque nous exécutons nos tests, <code>it_works</code>
s'exécute, mais pas <code>test_long</code> :</p>
<!--
```console
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test test_long ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test test_long ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
The `expensive_test` function is listed as `ignored`. If we want to run only
the ignored tests, we can use `cargo test -- --ignored`:
-->
<p>La fonction <code>test_long</code> est listée comme <code>ignored</code>. Si nous voulons exécuter
uniquement les tests ignorés, nous pouvons utiliser <code>cargo test -- --ignored</code> :</p>
<!--
```console
$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test test_long ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test test_long ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
By controlling which tests run, you can make sure your `cargo test` results
will be fast. When you’re at a point where it makes sense to check the results
of the `ignored` tests and you have time to wait for the results, you can run
`cargo test -- --ignored` instead.
-->
<p>En gérant quels tests sont exécutés, vous pouvez vous assurer que vos résultats
de <code>cargo test</code> seront rapides. Lorsque vous arrivez à un stade où il est
justifié de vérifier le résultat des tests <code>ignored</code> et que vous avez le temps
d'attendre ces résultats, vous pouvez lancer à la place
<code>cargo test -- --ignored</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Test Organization
-->
<h2 id="lorganisation-des-tests"><a class="header" href="#lorganisation-des-tests">L'organisation des tests</a></h2>
<!--
As mentioned at the start of the chapter, testing is a complex discipline, and
different people use different terminology and organization. The Rust community
thinks about tests in terms of two main categories: *unit tests* and
*integration tests*. Unit tests are small and more focused, testing one module
in isolation at a time, and can test private interfaces. Integration tests are
entirely external to your library and use your code in the same way any other
external code would, using only the public interface and potentially exercising
multiple modules per test.
-->
<p>Comme nous l'avons évoqué au début du chapitre, le test est une discipline
complexe, et différentes personnes utilisent des terminologies et organisations
différentes. La communauté Rust a conçu les tests dans deux catégories
principales : <em>les tests unitaires</em> et <em>les tests d'intégration</em>. Les tests
unitaires sont petits et plus précis, testent un module isolé à la fois, et
peuvent tester les interfaces privées. Les tests d'intégration sont uniquement
externes à notre bibliothèque et consomme notre code exactement de la même
manière que tout autre code externe le ferait, en utilisant uniquement
l'interface publique et éventuellement en utilisant plusieurs modules dans un
test.</p>
<!--
Writing both kinds of tests is important to ensure that the pieces of your
library are doing what you expect them to, separately and together.
-->
<p>L'écriture de ces deux types de tests est importante pour s'assurer que chaque
élément de notre bibliothèque fait bien ce que vous attendiez d'eux, de
manière isolée et conjuguée avec d'autres.</p>
<!--
### Unit Tests
-->
<h3 id="les-tests-unitaires"><a class="header" href="#les-tests-unitaires">Les tests unitaires</a></h3>
<!--
The purpose of unit tests is to test each unit of code in isolation from the
rest of the code to quickly pinpoint where code is and isn’t working as
expected. You’ll put unit tests in the *src* directory in each file with the
code that they’re testing. The convention is to create a module named `tests`
in each file to contain the test functions and to annotate the module with
`cfg(test)`.
-->
<p>Le but des tests unitaires est de tester chaque élément du code de manière
séparée du reste du code pour identifier rapidement où le code fonctionne
ou non comme prévu. Vous devriez insérer les tests unitaires dans le
dossier <em>src</em> de chaque fichier, à côté du code qu'ils testent. La convention
est de créer un module <code>tests</code> dans chaque fichier qui contient les fonctions
de test et de marquer le module avec <code>cfg(test)</code>.</p>
<!--
#### The Tests Module and `#[cfg(test)]`
-->
<h4 id="les-modules-de-tests-et-cfgtest"><a class="header" href="#les-modules-de-tests-et-cfgtest">Les modules de tests et <code>#[cfg(test)]</code></a></h4>
<!--
The `#[cfg(test)]` annotation on the tests module tells Rust to compile and run
the test code only when you run `cargo test`, not when you run `cargo build`.
This saves compile time when you only want to build the library and saves space
in the resulting compiled artifact because the tests are not included. You’ll
see that because integration tests go in a different directory, they don’t need
the `#[cfg(test)]` annotation. However, because unit tests go in the same files
as the code, you’ll use `#[cfg(test)]` to specify that they shouldn’t be
included in the compiled result.
-->
<p>L'annotation <code>#[cfg(test)]</code> sur les modules de tests indiquent à Rust de
compiler et d'exécuter le code de test seulement lorsque vous lancez
<code>cargo test</code>, et non pas lorsque vous lancez <code>cargo build</code>. Cela diminue la
durée de compilation lorsque vous souhaitez uniquement compiler la bibliothèque
et cela réduit la taille dans l'artefact compilé qui en résulte car les tests
n'y sont pas intégrés. Vous verrez plus tard que comme les tests d'intégration
se placent dans un répertoire différent, ils n'ont pas besoin de l'annotation
<code>#[cfg(test)]</code>. Cependant, comme les tests unitaires vont dans les mêmes
fichiers que le code, vous devriez utiliser <code>#[cfg(test)]</code> pour marquer qu'ils
ne devraient pas être inclus dans les résultats de compilation.</p>
<!--
Recall that when we generated the new `adder` project in the first section of
this chapter, Cargo generated this code for us:
-->
<p>Souvenez-vous, lorsque nous avons généré le nouveau projet <code>addition</code> dans la
première section de ce chapitre, Cargo a généré ce code pour nous :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
```
-->
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<!--
This code is the automatically generated test module. The attribute `cfg`
stands for *configuration* and tells Rust that the following item should only
be included given a certain configuration option. In this case, the
configuration option is `test`, which is provided by Rust for compiling and
running tests. By using the `cfg` attribute, Cargo compiles our test code only
if we actively run the tests with `cargo test`. This includes any helper
functions that might be within this module, in addition to the functions
annotated with `#[test]`.
-->
<p>Ce code est le module de test généré automatiquement. L'attribut <code>cfg</code> est
l'abréviation de <em>configuration</em> et indique à rust que l'élément suivant ne
doit être intégré que dans une certaine option de configuration donnée. Dans
ce cas, l'option de configuration est <code>test</code>, qui est fourni par Rust pour la
compilation et l'exécution des tests. En utilisant l'attribut <code>cfg</code>, Cargo
compile notre code de tests uniquement si nous avons exécuté les tests avec
<code>cargo test</code>. Cela inclut toutes les fonctions auxiliaires qui pourraient se
trouver dans ce module, en plus des fonctions marquées d'un <code>#[test]</code>.</p>
<!--
#### Testing Private Functions
-->
<h4 id="tester-des-fonctions-privées"><a class="header" href="#tester-des-fonctions-privées">Tester des fonctions privées</a></h4>
<!--
There’s debate within the testing community about whether or not private
functions should be tested directly, and other languages make it difficult or
impossible to test private functions. Regardless of which testing ideology you
adhere to, Rust’s privacy rules do allow you to test private functions.
Consider the code in Listing 11-12 with the private function `internal_adder`.
-->
<p>Il existe un débat dans la communauté des testeurs au sujet de la nécessité ou non
de tester directement les fonctions privées, et d'autres langages rendent
difficile, voir impossible, de tester les fonctions privées. Quelle que soit
votre approche des tests, les règles de protection de Rust vous permettent de
tester des fonctions privées. Imaginons le code de l'encart 11-12 qui contient
la fonction privée <code>addition_interne</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
pub fn ajouter_deux(a: i32) -> i32 {
    addition_interne(a, 2)
}

fn addition_interne(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn interne() {
        assert_eq!(4, addition_interne(2, 2));
    }
}
```
-->
<pre><code class="language-rust noplayground">pub fn ajouter_deux(a: i32) -&gt; i32 {
    addition_interne(a, 2)
}

fn addition_interne(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn interne() {
        assert_eq!(4, addition_interne(2, 2));
    }
}
</code></pre>
<!--
<span class="caption">Listing 11-12: Testing a private function</span>
-->
<p><span class="caption">Encart 11-12 : test d'une fonction privée</span></p>
<!--
Note that the `internal_adder` function is not marked as `pub`. Tests are just
Rust code, and the `tests` module is just another module. As we discussed in
the [“Paths for Referring to an Item in the Module Tree”][paths]<!-- ignore -- >
section, items in child modules can use the items in their ancestor modules. In
this test, we bring all of the `test` module’s parent’s items into scope with
`use super::*`, and then the test can call `internal_adder`. If you don’t think
private functions should be tested, there’s nothing in Rust that will compel
you to do so.
-->
<p>Remarquez que la fonction <code>addition_interne</code> n'est pas marquée comme <code>pub</code>. Les
tests sont uniquement du code Rust, et le module <code>test</code> est simplement un autre
module. Comme nous l'avons vu dans <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">une section</a>&lt;:-- ignore --&gt;, les
éléments dans les modules enfant peuvent utiliser les éléments dans leurs
modules parents. Dans ce test, nous importons dans la portée tous les éléments
du parent du module <code>test</code> grâce à <code>use super::*;</code>, puis ensuite le test peut
faire appel à <code>addition_interne</code>. Si vous pensez qu'une fonction privée ne doit
pas être testée, il n'y a rien qui vous y force avec Rust.</p>
<!--
### Integration Tests
-->
<h3 id="les-tests-dintégration"><a class="header" href="#les-tests-dintégration">Les tests d'intégration</a></h3>
<!--
In Rust, integration tests are entirely external to your library. They use your
library in the same way any other code would, which means they can only call
functions that are part of your library’s public API. Their purpose is to test
whether many parts of your library work together correctly. Units of code that
work correctly on their own could have problems when integrated, so test
coverage of the integrated code is important as well. To create integration
tests, you first need a *tests* directory.
-->
<p>En Rust, les tests d'intégration sont exclusivement externes à votre
bibliothèque. Ils consomment votre bibliothèque de la même manière que n'importe
quel autre code, ce qui signifie qu'ils ne peuvent appeler uniquement les
fonctions qui font partie de l'interface de programmation applicative (API)
publique de votre bibliothèque. Leur but est de tester si les multiples parties
de votre bibliothèque fonctionnent correctement ensemble. Les portions de code
qui fonctionnent bien toutes seules pourraient rencontrer des problèmes une fois
imbriquées avec d'autres, donc les tests qui couvrent l'intégration du code est
aussi important. Pour créer des tests d'intégration, vous avez d'abord besoin
d'un dossier <em>tests</em>.</p>
<!--
#### The *tests* Directory
-->
<h4 id="le-dossier-tests"><a class="header" href="#le-dossier-tests">Le dossier <em>tests</em></a></h4>
<!--
We create a *tests* directory at the top level of our project directory, next
to *src*. Cargo knows to look for integration test files in this directory. We
can then make as many test files as we want to in this directory, and Cargo
will compile each of the files as an individual crate.
-->
<p>Nous créons un dossier <em>tests</em> au niveau le plus haut de notre dossier de
projet, juste à côté de <em>src</em>. Cargo sait qu'il doit rechercher les fichiers de
test d'intégration dans ce dossier. Nous pouvons ensuite construire autant de
fichiers de test que nous souhaitons dans ce dossier, et Cargo va compiler
chacun des fichiers comme une crate individuelle.</p>
<!--
Let’s create an integration test. With the code in Listing 11-12 still in the
*src/lib.rs* file, make a *tests* directory, create a new file named
*tests/integration_test.rs*, and enter the code in Listing 11-13.
-->
<p>Commençons à créer un test d'intégration. Avec le code de l'encart 11-12
toujours présent dans le fichier <em>src/lib.rs</em>, créons un dossier <em>tests</em>, puis
un nouveau fichier <em>tests/test_integration.rs</em>, et insérez-y le code de l'encart
11-13.</p>
<!--
<span class="filename">Filename: tests/integration_test.rs</span>
-->
<p><span class="filename">Fichier : tests/test_integration.rs</span></p>
<!--
```rust,ignore
use addition;

#[test]
fn cela_ajoute_deux() {
    assert_eq!(4, addition::ajouter_deux(2));
}
```
-->
<pre><code class="language-rust ignore">use addition;

#[test]
fn cela_ajoute_deux() {
    assert_eq!(4, addition::ajouter_deux(2));
}
</code></pre>
<!--
<span class="caption">Listing 11-13: An integration test of a function in the
`adder` crate</span>
-->
<p><span class="caption">Encart 11-13 : un test d'intégration d'une fonction
présente dans la crate <code>addition</code></span></p>
<!--
We’ve added `use adder` at the top of the code, which we didn’t need in the
unit tests. The reason is that each file in the `tests` directory is a separate
crate, so we need to bring our library into each test crate’s scope.
-->
<p>Nous avons ajouté <code>use addition</code> en haut du code, ce que nous n'avions pas
besoin de faire dans les tests unitaires. La raison à cela est que chaque
fichier dans le dossier <code>tests</code> est une crate séparée, donc nous devons importer
notre bibliothèque dans la portée de chaque crate de test.</p>
<!--
We don’t need to annotate any code in *tests/integration_test.rs* with
`#[cfg(test)]`. Cargo treats the `tests` directory specially and compiles files
in this directory only when we run `cargo test`. Run `cargo test` now:
-->
<p>Nous n'avons pas besoin de marquer du code avec <code>#[cfg(test)]</code> dans
<em>tests/test_integration.rs</em>. Cargo traite le dossier <code>tests</code> de manière
particulière et compile les fichiers présents dans ce dossier uniquement si nous
lançons <code>cargo test</code>. Lancez dès maintenant <code>cargo test</code> :</p>
<!--
```console
$ cargo test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests (target/debug/deps/addition-1082c4b063a8fbe6)

running 1 test
test tests::interne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests addition

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests (target/debug/deps/addition-1082c4b063a8fbe6)

running 1 test
test tests::interne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests addition

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
The three sections of output include the unit tests, the integration test, and
the doc tests. The first section for the unit tests is the same as we’ve been
seeing: one line for each unit test (one named `internal` that we added in
Listing 11-12) and then a summary line for the unit tests.
-->
<p>Les trois sections de la sortie concernent les tests unitaires, les tests
d'intégration, et les tests de documentation. La première section à propos des
tests unitaires est la même que nous avons déjà vu : une ligne pour chaque test
unitaire (celui qui s'appelle <code>interne</code> que nous avons inséré dans l'encart
11-12) et ensuite une ligne de résumé des tests unitaires.</p>
<!--
The integration tests section starts with the line `Running
target/debug/deps/integration_test-1082c4b063a8fbe6` (the hash at the end of
your output will be different). Next, there is a line for each test function in
that integration test and a summary line for the results of the integration
test just before the `Doc-tests adder` section starts.
-->
<p>La section des tests d'intégration commence avec la ligne <code>Running target/debug/deps/test_integration-1082c4b063a8fbe6</code> (le hachage à la fin de
votre sortie pourrait être différent). Ensuite, il y a une ligne pour chaque
fonction de test présente dans ce test d'intégration et une ligne de résumé pour
les résultats des tests d'intégration, juste avant que la section
<code>Doc-tests addition</code> commence.</p>
<!--
Similarly to how adding more unit test functions adds more result lines to the
unit tests section, adding more test functions to the integration test file
adds more result lines to this integration test file’s section. Each
integration test file has its own section, so if we add more files in the
*tests* directory, there will be more integration test sections.
-->
<p>De la même façon que plus vous ajoutez de fonctions de tests unitaires et plus
vous avez des lignes de résultats dans la section des tests unitaires, plus
vous ajoutez des fonctions de tests aux fichiers de tests d'intégration et plus
vous aurez des lignes de résultat à cette section correspondante aux fichiers
de test d'intégration. Chaque fichier de test d'intégration a sa propre section,
donc si nous ajoutons plus de fichiers dans le dossier <em>tests</em>, il y aura plus
de sections de tests d'intégration.</p>
<!--
We can still run a particular integration test function by specifying the test
function’s name as an argument to `cargo test`. To run all the tests in a
particular integration test file, use the `--test` argument of `cargo test`
followed by the name of the file:
-->
<p>Nous pouvons aussi exécuter une fonction de test d'intégration précise en
utilisant le nom de la fonction de test comme argument à <code>cargo test</code>. Pour
exécuter tous les tests d'un fichier de tests d'intégration précis, utilisez
l'argument <code>--test</code> de <code>cargo test</code> suivi du nom du fichier :</p>
<!--
```console
$ cargo test --test integration_test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
This command runs only the tests in the *tests/integration_test.rs* file.
-->
<p>Cette commande exécute seulement les tests dans le fichier
<em>tests/test_integration.rs</em>.</p>
<!--
#### Submodules in Integration Tests
-->
<h4 id="les-sous-modules-des-tests-dintégration"><a class="header" href="#les-sous-modules-des-tests-dintégration">Les sous-modules des tests d'intégration</a></h4>
<!--
As you add more integration tests, you might want to make more than one file in
the *tests* directory to help organize them; for example, you can group the
test functions by the functionality they’re testing. As mentioned earlier, each
file in the *tests* directory is compiled as its own separate crate.
-->
<p>Au fur et à mesure que vous ajouterez des tests d'intégration, vous pourriez
avoir besoin de les diviser en plusieurs fichiers dans le dossier <em>tests</em> pour
vous aider à les organiser ; par exemple, vous pouvez regrouper les fonctions
de test par fonctionnalités qu'elles testent. Comme mentionné précédemment,
chaque fichier dans le dossier <em>tests</em> est compilé comme étant sa propre crate
séparée de tous les autres.</p>
<!--
Treating each integration test file as its own crate is useful to create
separate scopes that are more like the way end users will be using your crate.
However, this means files in the *tests* directory don’t share the same
behavior as files in *src* do, as you learned in Chapter 7 regarding how to
separate code into modules and files.
-->
<p>Le fait que chaque fichier de test d'intégration soit sa propre crate est utile
pour créer des portées séparées qui ressemblent à la manière dont les
développeurs vont consommer votre crate. Cependant, cela veut aussi dire que
les fichiers dans le dossier <em>tests</em> ne partagent pas le même comportement que les
les fichiers dans <em>src</em>, comme vous l'avez appris au chapitre 7 à
propos de la manière de séparer le code dans des modules et des fichiers.</p>
<!--
The different behavior of files in the *tests* directory is most noticeable
when you have a set of helper functions that would be useful in multiple
integration test files and you try to follow the steps in the [“Separating
Modules into Different Files”][separating-modules-into-files]<!-- ignore -- >
section of Chapter 7 to extract them into a common module. For example, if we
create *tests/common.rs* and place a function named `setup` in it, we can add
some code to `setup` that we want to call from multiple test functions in
multiple test files:
-->
<p>Ce comportement différent des fichiers dans le dossier <em>tests</em> est encore plus
remarquable lorsque vous avez un jeu de fonctions d'aide qui s'avèrent utiles
pour plusieurs fichiers de test d'intégration et que vous essayez de suivre les
étapes de la section <a href="ch07-05-separating-modules-into-different-files.html">“Séparer les modules dans différents
fichiers”</a><!-- ignore --> du chapitre 7 afin de
les extraire dans un module en commun. Par exemple, si nous créons
<em>tests/commun.rs</em> et que nous y plaçons une fonction <code>parametrage</code> à
l'intérieur, nous pourrions ajouter du code à <code>parametrage</code> que nous voudrions
appeler à partir de différentes fonctions de test dans différents fichiers de
test :</p>
<!--
<span class="filename">Filename: tests/common.rs</span>
-->
<p><span class="filename">Fichier : tests/commun.rs</span></p>
<!--
```rust
pub fn parametrage() {
    // code de paramétrage spécifique à vos tests de votre bibliothèque ici
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn parametrage() {
    // code de paramétrage spécifique à vos tests de votre bibliothèque ici
}
<span class="boring">}
</span></code></pre></pre>
<!--
When we run the tests again, we’ll see a new section in the test output for the
*common.rs* file, even though this file doesn’t contain any test functions nor
did we call the `setup` function from anywhere:
-->
<p>Lorsque nous lançons les tests à nouveau, nous allons voir une nouvelle section
dans la sortie des tests, correspondant au fichier <em>commun.rs</em>, même si ce
fichier ne contient aucune fonction de test et que nous n'avons utilisé nulle
part la fonction <code>parametrage</code> :</p>
<!--
```console
$ cargo test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests (target/debug/deps/addition-92948b65e88960b4)

running 1 test
test tests::interne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests addition

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling addition v0.1.0 (file:///projects/addition)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests (target/debug/deps/addition-92948b65e88960b4)

running 1 test
test tests::interne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test cela_ajoute_deux ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests addition

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
Having `common` appear in the test results with `running 0 tests` displayed for
it is not what we wanted. We just wanted to share some code with the other
integration test files.
-->
<p>Nous ne voulons pas que <code>commun</code> apparaisse dans les résultats, ni que cela
affiche <code>running 0 tests</code>. Nous voulons juste partager du code avec les autres
fichiers de test d'intégration.</p>
<!--
To avoid having `common` appear in the test output, instead of creating
*tests/common.rs*, we’ll create *tests/common/mod.rs*. This is an alternate
naming convention that Rust also understands. Naming the file this way tells
Rust not to treat the `common` module as an integration test file. When we move
the `setup` function code into *tests/common/mod.rs* and delete the
*tests/common.rs* file, the section in the test output will no longer appear.
Files in subdirectories of the *tests* directory don’t get compiled as separate
crates or have sections in the test output.
-->
<p>Pour éviter que <code>commun</code> s'affiche sur la sortie de test, au lieu de créer le
fichier <em>tests/commun.rs</em>, nous allons créer <em>tests/commun/mod.rs</em>. C'est
une convention de nommage alternative que Rust comprends aussi. Nommer le
fichier ainsi indique à Rust de ne pas traiter le module <code>commun</code> comme un
fichier de test d'intégration. Lorsque nous déplaçons le code de la fonction
<code>parametrage</code> dans <em>tests/commun/mod.rs</em> et que nous supprimons le fichier
<em>tests/commun.rs</em>, la section dans la sortie des tests ne va plus s'afficher.
Les fichiers dans les sous-répertoires du dossier <em>tests</em> ne seront pas
compilés comme étant une crate séparée et n'auront pas de sections dans la
sortie des tests.</p>
<!--
After we’ve created *tests/common/mod.rs*, we can use it from any of the
integration test files as a module. Here’s an example of calling the `setup`
function from the `it_adds_two` test in *tests/integration_test.rs*:
-->
<p>Après avoir créé <em>tests/commun/mod.rs</em>, nous pouvons l'utiliser à partir de
n'importe quel fichier de test d'intégration comme un module. Voici un
exemple d'appel à la fonction <code>parametrage</code> à partir du test
<code>cela_ajoute_deux</code> dans <em>tests/test_integration.rs</em> :</p>
<!--
<span class="filename">Filename: tests/integration_test.rs</span>
-->
<p><span class="filename">Fichier : tests/integration_test.rs</span></p>
<!--
```rust,ignore
use addition;

mod common;

#[test]
fn cela_ajoute_deux() {
    common::parametrage();
    assert_eq!(4, addition::ajouter_deux(2));
}
```
-->
<pre><code class="language-rust ignore">use addition;

mod common;

#[test]
fn cela_ajoute_deux() {
    common::parametrage();
    assert_eq!(4, addition::ajouter_deux(2));
}
</code></pre>
<!--
Note that the `mod common;` declaration is the same as the module declaration
we demonstrated in Listing 7-21. Then in the test function, we can call the
`common::setup()` function.
-->
<p>Remarquez que la déclaration <code>mod commun;</code> est la même que la déclaration d'un
module que nous avons démontré dans l'encart 7-21. Ensuite, dans la fonction
de tests, nous pouvons appeler la fonction <code>commun::parametrage</code>.</p>
<!--
#### Integration Tests for Binary Crates
-->
<h4 id="tests-dintégration-pour-les-crates-binaires"><a class="header" href="#tests-dintégration-pour-les-crates-binaires">Tests d'intégration pour les crates binaires</a></h4>
<!--
If our project is a binary crate that only contains a *src/main.rs* file and
doesn’t have a *src/lib.rs* file, we can’t create integration tests in the
*tests* directory and bring functions defined in the *src/main.rs* file into
scope with a `use` statement. Only library crates expose functions that other
crates can use; binary crates are meant to be run on their own.
-->
<p>Si notre projet est une crate binaire qui contient uniquement un fichier
<em>src/main.rs</em> et n'a pas de fichier <em>src/lib.rs</em>, nous ne pouvons pas créer
de tests d'intégration dans le dossier <em>tests</em> et importer les fonctions
définies dans le fichier <em>src/main.rs</em> dans notre portée avec une instruction
<code>use</code>. Seules les crates de bibliothèque exposent des fonctions que les autres
crates peuvent utiliser ; les crates binaires sont conçues pour être exécutées
de manière isolée.</p>
<!--
This is one of the reasons Rust projects that provide a binary have a
straightforward *src/main.rs* file that calls logic that lives in the
*src/lib.rs* file. Using that structure, integration tests *can* test the
library crate with `use` to make the important functionality available.
If the important functionality works, the small amount of code in the
*src/main.rs* file will work as well, and that small amount of code doesn’t
need to be tested.
-->
<p>C'est une des raisons pour lesquelles les projets Rust qui fournissent un
binaire ont un simple fichier <em>src/main.rs</em> qui fait appel à la logique
présente dans le fichier <em>src/lib.rs</em>. En utilisant cette structure, les tests
d'intégration <em>peuvent</em> tester la crate de bibliothèque avec le <code>use</code> pour
importer les importantes fonctionnalités disponibles. Si les fonctionnalités
importantes fonctionnent, la petite portion de code dans le fichier
<em>src/main.rs</em> va fonctionner, et cette petite partie de code n'a pas besoin
d'être testée.</p>
<!--
## Summary
-->
<h2 id="résumé-10"><a class="header" href="#résumé-10">Résumé</a></h2>
<!--
Rust’s testing features provide a way to specify how code should function to
ensure it continues to work as you expect, even as you make changes. Unit tests
exercise different parts of a library separately and can test private
implementation details. Integration tests check that many parts of the library
work together correctly, and they use the library’s public API to test the code
in the same way external code will use it. Even though Rust’s type system and
ownership rules help prevent some kinds of bugs, tests are still important to
reduce logic bugs having to do with how your code is expected to behave.
-->
<p>Les fonctionnalités de test de Rust permettent de spécifier comment le code
doit fonctionner pour garantir qu'il va continuer à fonctionner comme vous le
souhaitez, même si vous faites des changements. Les tests unitaires permettent
de tester séparément différentes parties d'une bibliothèque et peuvent tester
l'implémentation des éléments privés. Les tests d'intégration vérifient que de
nombreuses parties de la bibliothèque fonctionnent correctement ensemble, et
ils utilisent l'API publique de la bibliothèque pour tester le code, de la même
manière  que le ferait du code externe qui l'utiliserait. Même si le système de
type de Rust et les règles de possession aident à prévenir certains types de
bogues, les tests restent toujours importants pour réduire les bogues de
logique concernant le comportement attendu de votre code.</p>
<!--
Let’s combine the knowledge you learned in this chapter and in previous
chapters to work on a project!
-->
<p>Et maintenant, combinons le savoir que vous avez accumulé dans ce chapitre et
dans les chapitres précédents en travaillant sur un nouveau projet !</p>
<!--
[paths]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
[separating-modules-into-files]:
ch07-05-separating-modules-into-different-files.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# An I/O Project: Building a Command Line Program
-->
<h1 id="un-projet-dentréesortie--construire-un-programme-en-ligne-de-commande"><a class="header" href="#un-projet-dentréesortie--construire-un-programme-en-ligne-de-commande">Un projet d'entrée/sortie : construire un programme en ligne de commande</a></h1>
<!--
This chapter is a recap of the many skills you’ve learned so far and an
exploration of a few more standard library features. We’ll build a command line
tool that interacts with file and command line input/output to practice some of
the Rust concepts you now have under your belt.
-->
<p>Ce chapitre est un résumé de toutes les nombreuses compétences que vous avez
apprises précédemment et une découverte de quelques fonctionnalités
supplémentaires de la bibliothèque standard. Nous allons construire un outil en
ligne de commande qui interagit avec des fichiers et les entrées/sorties de la
ligne de commande pour mettre en pratique certains concepts Rust que vous avez
maintenant en votre connaissance.</p>
<!--
Rust’s speed, safety, single binary output, and cross-platform support make it
an ideal language for creating command line tools, so for our project, we’ll
make our own version of the classic command line tool `grep` (**g**lobally
search a **r**egular **e**xpression and **p**rint). In the simplest use case,
`grep` searches a specified file for a specified string. To do so, `grep` takes
as its arguments a filename and a string. Then it reads the file, finds lines
in that file that contain the string argument, and prints those lines.
-->
<p>Les fonctionnalités de rapidité, sécurité, de sortie binaire unique, et du
support multi-plateforme de Rust en font le langage idéal pour créer des outils
en ligne de commande, donc pour notre projet, nous allons construire notre
version de l'outil en ligne de commande <code>grep</code> (qui signifie <strong>g</strong>lobally
search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint, soit <em>recherche globale et
affichage d'une expression régulière</em>). Dans des cas d'usage très simple,
<code>grep</code> recherche une chaîne de caractère précise dans un fichier précis. Pour
faire ainsi, <code>grep</code> prend en argument un nom de fichier et une chaîne de
caractères. Ensuite, il lit le fichier, trouve les lignes de ce fichier qui
contient la chaîne de caractères envoyé en argument, et affiche ces lignes.</p>
<!--
Along the way, we’ll show how to make our command line tool use features of the
terminal that many command line tools use. We’ll read the value of an
environment variable to allow the user to configure the behavior of our tool.
We’ll also print error messages to the standard error console stream (`stderr`)
instead of standard output (`stdout`), so, for example, the user can redirect
successful output to a file while still seeing error messages onscreen.
-->
<p>Sur la route, nous allons vous montrer comment utiliser dans votre outil en
ligne de commande les fonctionnalités des terminaux que de nombreux outils en
ligne de commande utilisent. Nous allons lire la valeur d'une variable
d'environnement pour permettre à l'utilisateur de configurer le comportement de
notre outil. Nous allons aussi afficher des messages d'erreur vers le flux
d'erreur standard de la console (<code>stderr</code>) plutôt que la sortie standard
(<code>stdout</code>), pour, par exemple, que l'utilisateur puisse rediriger la sortie
fructueuse vers un fichier, tout en affichant les messages d'erreur à l'écran.</p>
<!--
One Rust community member, Andrew Gallant, has already created a fully
featured, very fast version of `grep`, called `ripgrep`. By comparison, our
version of `grep` will be fairly simple, but this chapter will give you some of
the background knowledge you need to understand a real-world project such as
`ripgrep`.
-->
<p>Un membre de la communauté Rust, Andrew Gallant, a déjà créé une version
complète et très performante de <code>grep</code>, qu'il a appelé <code>ripgrep</code>. En
comparaison, notre version de <code>grep</code> sera plutôt simple, mais ce chapitre va
vous donner les connaissances de base dont vous avez besoin pour appréhender
un projet réel comme <code>ripgrep</code>.</p>
<!--
Our `grep` project will combine a number of concepts you’ve learned so far:
-->
<p>Notre projet <code>grep</code> va combiner un certain nombre de concepts que vous avez
acquis jusqu'à présent :</p>
<!--
* Organizing code (using what you learned about modules in [Chapter 7][ch7]<!--
  ignore -- >)
* Using vectors and strings (collections, [Chapter 8][ch8]<!-- ignore -- >)
* Handling errors ([Chapter 9][ch9]<!-- ignore -- >)
* Using traits and lifetimes where appropriate ([Chapter 10][ch10]<!-- ignore
  -- >)
* Writing tests ([Chapter 11][ch11]<!-- ignore -- >)
-->
<ul>
<li>Organiser le code (en utilisant ce que vous avez appris sur les modules au
<a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">chapitre 7</a><!-- ignore -->)</li>
<li>Utiliser les vecteurs et les chaînes de caractères (les collections du
<a href="ch08-00-common-collections.html">chapitre 8</a><!-- ignore -->)</li>
<li>Gérer les erreurs (<a href="ch09-00-error-handling.html">chapitre 9</a><!-- ignore -->)</li>
<li>Utiliser les traits et les durées de vie lorsque c'est approprié
(<a href="ch10-00-generics.html">chapitre 10</a><!-- ignore -->)</li>
<li>Ecrire les tests (<a href="ch11-00-testing.html">chapitre 11</a><!-- ignore -->)</li>
</ul>
<!--
We’ll also briefly introduce closures, iterators, and trait objects, which
Chapters [13][ch13]<!-- ignore -- > and [17][ch17]<!-- ignore -- > will cover in
detail.
-->
<p>Nous vous présenterons aussi brièvement les fermetures, les itérateurs, et les
objets de trait, que les chapitres <a href="ch13-00-functional-features.html">13</a><!-- ignore --> et
<a href="ch17-00-oop.html">17</a><!-- ignore --> vont traiter en détails.</p>
<!--
[ch7]: ch07-00-managing-growing-projects-with-packages-crates-and-modules.html
[ch8]: ch08-00-common-collections.html
[ch9]: ch09-00-error-handling.html
[ch10]: ch10-00-generics.html
[ch11]: ch11-00-testing.html
[ch13]: ch13-00-functional-features.html
[ch17]: ch17-00-oop.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Accepting Command Line Arguments
-->
<h2 id="récupérer-les-arguments-de-la-ligne-de-commande"><a class="header" href="#récupérer-les-arguments-de-la-ligne-de-commande">Récupérer les arguments de la ligne de commande</a></h2>
<!--
Let’s create a new project with, as always, `cargo new`. We’ll call our project
`minigrep` to distinguish it from the `grep` tool that you might already have
on your system.
-->
<p>Créons un nouveau projet comme à l'accoutumée avec <code>cargo new</code>. Appelons
notre projet <code>minigrep</code> pour le distinguer de l'outil <code>grep</code> que vous avez
probablement déjà sur votre système.</p>
<!--
```console
$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
```
-->
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<!--
The first task is to make `minigrep` accept its two command line arguments: the
filename and a string to search for. That is, we want to be able to run our
program with `cargo run`, a string to search for, and a path to a file to
search in, like so:
-->
<p>La première tâche est de faire en sorte que <code>minigrep</code> utilise ses deux
arguments en ligne de commande : le nom du fichier et la chaîne de caractères à
rechercher. Autrement dit, nous voulons pouvoir exécuter notre programme avec
<code>cargo run</code>, une chaîne de caractères à rechercher, et un chemin vers un
fichier dans lequel chercher, comme ceci :</p>
<!--
```console
$ cargo run searchstring example-filename.txt
```
-->
<pre><code class="language-console">$ cargo run chaine_a_chercher fichier-exemple.txt
</code></pre>
<!--
Right now, the program generated by `cargo new` cannot process arguments we
give it. Some existing libraries on [crates.io](https://crates.io/) can help
with writing a program that accepts command line arguments, but because you’re
just learning this concept, let’s implement this capability ourselves.
-->
<p>Pour l'instant, le programme généré par <code>cargo new</code> ne peut pas traiter les
arguments que nous lui donnons. Certaines bibliothèques qui existent sur
<a href="https://crates.io/">crates.io</a> peuvent vous aider à écrire un programme
qui prend des arguments en ligne de commande, mais comme vous apprenez
juste ce concept, implémentons cette capacité par nous-mêmes.</p>
<!--
### Reading the Argument Values
-->
<h3 id="lire-les-valeurs-des-arguments"><a class="header" href="#lire-les-valeurs-des-arguments">Lire les valeurs des arguments</a></h3>
<!--
To enable `minigrep` to read the values of command line arguments we pass to
it, we’ll need a function provided in Rust’s standard library, which is
`std::env::args`. This function returns an iterator of the command line
arguments that were given to `minigrep`. We’ll cover iterators fully in
[Chapter 13][ch13]<!-- ignore -- >. For now, you only need to know two details
about iterators: iterators produce a series of values, and we can call the
`collect` method on an iterator to turn it into a collection, such as a vector,
containing all the elements the iterator produces.
-->
<p>Pour permettre à <code>minigrep</code> de lire les valeurs des arguments de la ligne de
commande que nous lui envoyons, nous allons avoir besoin d'une fonction fournie
par la bibliothèque standard de Rust, qui est <code>std::env::args</code>. Cette fonction
retourne un itérateur des arguments de la ligne de commande qui ont été donnés
à <code>minigrep</code>. Nous verrons les itérateurs plus précisément au
<a href="ch13-00-functional-features.html">chapitre 13</a><!-- ignore -->. Pour l'instant, vous avez juste à savoir
deux choses à propos des itérateurs : les itérateurs engendrent une série de
valeurs, et nous pouvons appeler la méthode <code>collect</code> sur un itérateur pour le
transformer en collection, comme les vecteurs, qui contiennent tous les
éléments qu'un itérateur engendrent.</p>
<!--
Use the code in Listing 12-1 to allow your `minigrep` program to read any
command line arguments passed to it and then collect the values into a vector.
-->
<p>Utilisez le code de l'encart 12-1 pour permettre à votre programme <code>minigrep</code>
de lire tous les arguments qui lui sont envoyés et ensuite collecter les
valeurs dans un vecteur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    println!("{:?}", args);
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}
</code></pre></pre>
<!--
<span class="caption">Listing 12-1: Collecting the command line arguments into
a vector and printing them</span>
-->
<p><span class="caption">Encart 12-1 : Collecter les arguments de la ligne de
commande dans un vecteur et les afficher</span></p>
<!--
First, we bring the `std::env` module into scope with a `use` statement so we
can use its `args` function. Notice that the `std::env::args` function is
nested in two levels of modules. As we discussed in [Chapter
7][ch7-idiomatic-use]<!-- ignore -- >, in cases where the desired function is
nested in more than one module, it’s conventional to bring the parent module
into scope rather than the function. By doing so, we can easily use other
functions from `std::env`. It’s also less ambiguous than adding `use
std::env::args` and then calling the function with just `args`, because `args`
might easily be mistaken for a function that’s defined in the current module.
-->
<p>D'abord, nous importons le module <code>std::env</code> dans la portée avec une
instruction <code>use</code> afin que nous puissions utiliser sa fonction <code>args</code>. Notez
que la fonction <code>std::env::args</code> est imbriquée sur deux niveaux de modules.
Comme nous l'avons vu dans le <a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html">chapitre 7</a><!-- ignore -->,
il est courant d'importer le module parent dans la portée plutôt que la
fonction. En faisant ainsi, nous pouvons facilement utiliser les autres
fonctions de <code>std::env</code>. C'est aussi moins ambigü que d'importer uniquement
<code>std::env::args</code> et ensuite d'appeler la fonction avec seulement <code>args</code>, car
<code>args</code> peu facilement être confondu avec une fonction qui est définie dans le
module courant.</p>
<!--
> ### The `args` Function and Invalid Unicode
>
> Note that `std::env::args` will panic if any argument contains invalid
> Unicode. If your program needs to accept arguments containing invalid
> Unicode, use `std::env::args_os` instead. That function returns an iterator
> that produces `OsString` values instead of `String` values. We’ve chosen to
> use `std::env::args` here for simplicity, because `OsString` values differ
> per platform and are more complex to work with than `String` values.
-->
<blockquote>
<h3 id="la-fonction-args-et-lunicode-invalide"><a class="header" href="#la-fonction-args-et-lunicode-invalide">La fonction <code>args</code> et l'unicode invalide</a></h3>
<p>Notez que <code>std::env::args</code> va paniquer si un des arguments contient de
l'unicode invalide. Si votre programme a besoin d'utiliser des arguments qui
contiennent de l'unicode invalide, utilisez plutôt <code>std::env::args_os</code> à la
place. Cette fonction retourne un itérateur qui engendre des valeurs <code>OsString</code>
plutôt que des valeurs <code>String</code>. Nous avons choisi d'utiliser ici
<code>std::env::args</code> par simplicité, car les valeurs <code>OsString</code> diffèrent selon
la plateforme et c'est plus complexe de travailler avec par rapport aux
valeurs de type <code>String</code>.</p>
</blockquote>
<!--
On the first line of `main`, we call `env::args`, and we immediately use
`collect` to turn the iterator into a vector containing all the values produced
by the iterator. We can use the `collect` function to create many kinds of
collections, so we explicitly annotate the type of `args` to specify that we
want a vector of strings. Although we very rarely need to annotate types in
Rust, `collect` is one function you do often need to annotate because Rust
isn’t able to infer the kind of collection you want.
-->
<p>Dans la première ligne du <code>main</code>, nous appelons <code>env::args</code>, et nous utilisons
immédiatement <code>collect</code> pour retourner un itérateur dans un vecteur qui
contient toutes les valeurs engendrées par l'itérateur. Nous pouvons utiliser
la fonction <code>collect</code> pour créer n'importe quel genre de collection, donc nous
avons annoté explicitement le type de <code>args</code> pour préciser que nous attendions
un vecteur de chaînes de caractères. Bien que nous n'ayons que très
rarement d'annoter les types en Rust, <code>collect</code> est une fonction que vous
aurez souvent besoin d'annoter car Rust n'est pas capable de déduire le type
de collection que vous attendez.</p>
<!--
Finally, we print the vector using the debug formatter, `:?`. Let’s try running
the code first with no arguments and then with two arguments:
-->
<p>Enfin, nous affichons le vecteur en utilisant la chaîne de formatage <code>:?</code>.
Essayons d'abord de lancer le code sans arguments, puis ensuite avec deux
arguments :</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
["target/debug/minigrep"]
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[&quot;target/debug/minigrep&quot;]
</code></pre>
<!--
```console
$ cargo run aiguille botte_de_foin
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep aiguille botte_de_foin`
["target/debug/minigrep", "aiguille", "botte_de_foin"]
```
-->
<pre><code class="language-console">$ cargo run aiguille botte_de_foin
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep aiguille botte_de_foin`
[&quot;target/debug/minigrep&quot;, &quot;aiguille&quot;, &quot;botte_de_foin&quot;]
</code></pre>
<!--
Notice that the first value in the vector is `"target/debug/minigrep"`, which
is the name of our binary. This matches the behavior of the arguments list in
C, letting programs use the name by which they were invoked in their execution.
It’s often convenient to have access to the program name in case you want to
print it in messages or change behavior of the program based on what command
line alias was used to invoke the program. But for the purposes of this
chapter, we’ll ignore it and save only the two arguments we need.
-->
<p>Remarquez que la première valeur dans le vecteur est
<code>&quot;target/debug/minigrep&quot;</code>, qui est le nom de notre binaire. Cela correspond
au fonctionnement de la liste d'arguments en C, qui laissent les programmes
utiliser le nom sous lequel ils ont été invoqués dans leur exécution. C'est
parfois pratique pour avoir accès au nom du programme dans le cas où vous
souhaitez l'afficher dans des messages, ou changer le comportement du programme
en fonction de ce que l'alias de la ligne de commande utilise pour invoquer le
programme. Mais pour les besoins de ce chapitre, nous allons l'ignorer et
récupérer uniquement les deux arguments dont nous avons besoin.</p>
<!--
### Saving the Argument Values in Variables
-->
<h3 id="enregistrer-les-valeurs-des-arguments-dans-des-variables"><a class="header" href="#enregistrer-les-valeurs-des-arguments-dans-des-variables">Enregistrer les valeurs des arguments dans des variables</a></h3>
<!--
Printing the value of the vector of arguments illustrated that the program is
able to access the values specified as command line arguments. Now we need to
save the values of the two arguments in variables so we can use the values
throughout the rest of the program. We do that in Listing 12-2.
-->
<p>L'affichage des valeurs du vecteur des arguments nous a démontré que le
programme peut avoir accès aux valeurs envoyées en arguments d'une ligne de
commande. Maintenant, nous avons besoin d'enregistrer les valeurs des deux
arguments dans des variables afin que nous puissions utiliser les valeurs pour
le reste du programme. C'est que nous faisons dans l'encart 12-2.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,should_panic,noplayground
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    let recherche = &args[1];
    let nom_fichier = &args[2];

    println!("On recherche : {}", recherche);
    println!("Dans le fichier : {}", nom_fichier);
}
```
-->
<pre><code class="language-rust should_panic noplayground">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let recherche = &amp;args[1];
    let nom_fichier = &amp;args[2];

    println!(&quot;On recherche : {}&quot;, recherche);
    println!(&quot;Dans le fichier : {}&quot;, nom_fichier);
}
</code></pre>
<!--
<span class="caption">Listing 12-2: Creating variables to hold the query
argument and filename argument</span>
-->
<p><span class="caption">Encart 12-2 : Création de variables pour récupérer
les arguments recherche et nom_fichier</span></p>
<!--
As we saw when we printed the vector, the program’s name takes up the first
value in the vector at `args[0]`, so we’re starting at index `1`. The first
argument `minigrep` takes is the string we’re searching for, so we put a
reference to the first argument in the variable `query`. The second argument
will be the filename, so we put a reference to the second argument in the
variable `filename`.
-->
<p>Comme nous l'avons vu lorsque nous avons affiché le vecteur, le nom du
programme prend la première valeur dans le vecteur, dans <code>args[0]</code>, donc nous
allons commencer à l'indice <code>1</code>. Le premier argument que prend <code>minigrep</code> est
la chaîne de caractères que nous recherchons, donc nous insérons la référence
vers le premier argument dans la variable <code>recherche</code>. Le second argument sera
le nom du fichier, donc nous insérons une référence vers le second argument
dans la variable <code>nom_fichier</code>.</p>
<!--
We temporarily print the values of these variables to prove that the code is
working as we intend. Let’s run this program again with the arguments `test`
and `sample.txt`:
-->
<p>Nous affichons temporairement les valeurs de ces variables pour prouver que le
code fonctionne bien comme nous le souhaitons. Lançons à nouveau ce programme
avec les arguments <code>test</code> et <code>example.txt</code> :</p>
<!--
```console
$ cargo run test exemple.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test exemple.txt`
On recherche : test
Dans le fichier : exemple.txt
```
-->
<pre><code class="language-console">$ cargo run test exemple.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test exemple.txt`
On recherche : test
Dans le fichier : exemple.txt
</code></pre>
<!--
Great, the program is working! The values of the arguments we need are being
saved into the right variables. Later we’ll add some error handling to deal
with certain potential erroneous situations, such as when the user provides no
arguments; for now, we’ll ignore that situation and work on adding file-reading
capabilities instead.
-->
<p>Très bien, notre programme fonctionne ! Les valeurs des arguments dont nous
avons besoin sont enregistrées dans les bonnes variables. Plus tard, nous
allons ajouter de la gestion d'erreurs pour pallier aux potentielles situations
d'erreurs, comme lorsque l'utilisateur ne fournit pas d'arguments ; pour le
moment, nous allons ignorer ces situations et continuer à travailler pour
l'ajout d'une capacité de lecture de fichier, à la place.</p>
<!--
[ch13]: ch13-00-functional-features.html
[ch7-idiomatic-use]: ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Reading a File
-->
<h2 id="lire-un-fichier"><a class="header" href="#lire-un-fichier">Lire un fichier</a></h2>
<!--
Now we’ll add functionality to read the file that is specified in the
`filename` command line argument. First, we need a sample file to test it with:
the best kind of file to use to make sure `minigrep` is working is one with a
small amount of text over multiple lines with some repeated words. Listing 12-3
has an Emily Dickinson poem that will work well! Create a file called
*poem.txt* at the root level of your project, and enter the poem “I’m Nobody!
Who are you?”
-->
<p>Maintenant, nous allons ajouter une fonctionnalité pour lire le fichier qui est
renseigné dans l'argument <code>nom_fichier</code> de la ligne de commande. D'abord, nous
avons besoin d'un fichier d'exemple pour le tester : le meilleur type de
fichier pour s'assurer que <code>minigrep</code> fonctionne est un fichier avec une petite
quantité de texte sur plusieurs lignes avec quelques mots répétés. L'encart 12-3
présente un poème en Anglais de Emily Dickinson qui fonctionnera bien pour ce
test ! Créez un fichier <em>poem.txt</em> à la racine de votre projet, et saisissez ce
poème “I’m Nobody! Who are you?”.</p>
<!--
<span class="filename">Filename: poem.txt</span>
-->
<p><span class="filename">Filename: poem.txt</span></p>
<!--
```text
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
```
-->
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<!--
<span class="caption">Listing 12-3: A poem by Emily Dickinson makes a good test
case</span>
-->
<p><span class="caption">Encart 12-3 : Un poème Anglais d'Emily Dickinson qui fait
un bon sujet d'essai</span></p>
<!--
With the text in place, edit *src/main.rs* and add code to read the file, as
shown in Listing 12-4.
-->
<p>Une fois ce texte enregistré, éditez le <em>src/main.rs</em> et ajoutez-y le code pour
lire le fichier, comme indiqué dans l'encart 12-4.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,should_panic,noplayground
use std::env;
use std::fs;

fn main() {
    // --snip--
#     let args: Vec<String> = env::args().collect();
# 
#     let query = &args[1];
#     let filename = &args[2];
# 
#     println!("Searching for {}", query);
    println!("In file {}", filename);

    let contents = fs::read_to_string(filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents);
}
```
-->
<pre><code class="language-rust should_panic noplayground">use std::env;
use std::fs;

fn main() {
    // -- partie masquée ici --
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let recherche = &amp;args[1];
</span><span class="boring">    let nom_fichier = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!(&quot;On recherche : {}&quot;, recherche);
</span>    println!(&quot;Dans le fichier : {}&quot;, nom_fichier);

    let contenu = fs::read_to_string(nom_fichier)
        .expect(&quot;Quelque chose s'est mal passé lors de la lecture du fichier&quot;);

    println!(&quot;Dans le texte :\n{}&quot;, contenu);
}
</code></pre>
<!--
<span class="caption">Listing 12-4: Reading the contents of the file specified
by the second argument</span>
-->
<p><span class="caption">Encart 12-4 : Lecture du contenu du fichier renseigné en
second argument</span></p>
<!--
First, we add another `use` statement to bring in a relevant part of the
standard library: we need `std::fs` to handle files.
-->
<p>Premièrement, nous ajoutons une autre instruction <code>use</code> pour importer une
partie significative de la bibliothèque standard : nous avons besoin de
<code>std::fs</code> pour manipuler les fichiers.</p>
<!--
In `main`, we’ve added a new statement: `fs::read_to_string` takes the
`filename`, opens that file, and returns a `Result<String>` of the file’s
contents.
-->
<p>Dans le <code>main</code>, nous avons ajouté une nouvelle instruction :
<code>fs::read_to_string</code> qui prend le <code>nom_fichier</code>, ouvre ce fichier, et retourne
un <code>Result&lt;String&gt;</code> du contenu du fichier.</p>
<!--
After that statement, we’ve again added a temporary `println!` statement that
prints the value of `contents` after the file is read, so we can check that the
program is working so far.
-->
<p>Après cette instruction, nous avons ajouté à nouveau une instruction <code>println!</code>
qui affiche la valeur de <code>contenu</code> après la lecture de ce fichier, afin que
nous puissions vérifier que ce programme fonctionne correctement.</p>
<!--
Let’s run this code with any string as the first command line argument (because
we haven’t implemented the searching part yet) and the *poem.txt* file as the
second argument:
-->
<p>Exécutons ce code avec n'importe quelle chaîne de caractères dans le premier
argument de la ligne de commande (car nous n'avons pas encore implémenté la
partie de recherche pour l'instant), ainsi que le fichier <em>poem.txt</em> en
second argument :</p>
<!--
```console
$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

```
-->
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
On recherche : the
Dans le fichier : poem.txt
Dans le texte :
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<!--
Great! The code read and then printed the contents of the file. But the code
has a few flaws. The `main` function has multiple responsibilities: generally,
functions are clearer and easier to maintain if each function is responsible
for only one idea. The other problem is that we’re not handling errors as well
as we could. The program is still small, so these flaws aren’t a big problem,
but as the program grows, it will be harder to fix them cleanly. It’s good
practice to begin refactoring early on when developing a program, because it’s
much easier to refactor smaller amounts of code. We’ll do that next.
-->
<p>Très bien ! Notre code lit et affiche ensuite le contenu du fichier. Mais le
code a quelques défauts. La fonction <code>main</code> a plusieurs responsabilités :
généralement, les rôles des fonctions sont plus claires et faciles à entretenir
si chaque fonction est en charge d'une seule tâche. L'autre problème est que
nous ne gérons pas les erreurs correctement. Le programme est encore très
modeste, donc ces imperfections ne sont pas un gros problème, mais dès que le
programme va grossir, il sera plus difficile de les corriger proprement. Le
remaniement du code très tôt lors du développement d'un logiciel est une bonne
pratique, car c'est beaucoup plus facile de remanier des petites portions de
code. C'est ce que nous allons faire dès maintenant.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Refactoring to Improve Modularity and Error Handling
-->
<h2 id="remanier-le-code-pour-améliorer-sa-modularité-et-la-gestion-des-erreurs"><a class="header" href="#remanier-le-code-pour-améliorer-sa-modularité-et-la-gestion-des-erreurs">Remanier le code pour améliorer sa modularité et la gestion des erreurs</a></h2>
<!--
To improve our program, we’ll fix four problems that have to do with the
program’s structure and how it’s handling potential errors.
-->
<p>Pour améliorer notre programme, nous allons résoudre quatre problèmes liés
à la structure du programme et comment il gère de potentielles erreurs.</p>
<!--
First, our `main` function now performs two tasks: it parses arguments and
reads files. For such a small function, this isn’t a major problem. However, if
we continue to grow our program inside `main`, the number of separate tasks the
`main` function handles will increase. As a function gains responsibilities, it
becomes more difficult to reason about, harder to test, and harder to change
without breaking one of its parts. It’s best to separate functionality so each
function is responsible for one task.
-->
<p>Premièrement, notre fonction <code>main</code> assure deux tâches : elle interprète les
arguments et elle lit des fichiers. Pour une fonction aussi petite, ce n'est
pas un problème majeur. Cependant, si nous continuons à faire grossir notre
programme dans le <code>main</code>, le nombre des différentes tâches qu'assure la
fonction <code>main</code> va continuer à s'agrandir. Plus une fonction assure des
tâches différentes, plus cela devient difficile de la comprendre, de la tester,
et d'y faire des changements sans casser ses autres constituants. Cela est
mieux de séparer les fonctionnalités afin que chaque fonction n'assure qu'une
seule tâche.</p>
<!--
This issue also ties into the second problem: although `query` and `filename`
are configuration variables to our program, variables like `contents` are used
to perform the program’s logic. The longer `main` becomes, the more variables
we’ll need to bring into scope; the more variables we have in scope, the harder
it will be to keep track of the purpose of each. It’s best to group the
configuration variables into one structure to make their purpose clear.
-->
<p>Cette problématique est aussi liée au second problème : bien que <code>recherche</code> et
<code>nom_fichier</code> soient des variables de configuration de notre programme, les
variables telles que <code>contenu</code> sont utilisées pour appuyer la logique du
programme. Plus <code>main</code> est grand, plus nous aurons des variables à importer
dans la portée ; plus nous avons des variables dans notre portée, plus il sera
difficile de se souvenir à quoi elles servent. Il est préférable de regrouper
les variables de configuration dans une structure pour clarifier leur usage.</p>
<!--
The third problem is that we’ve used `expect` to print an error message when
reading the file fails, but the error message just prints `Something went wrong
reading the file`. Reading a file can fail in a number of ways: for example,
the file could be missing, or we might not have permission to open it. Right
now, regardless of the situation, we’d print the `Something went wrong reading
the file` error message, which wouldn’t give the user any information!
-->
<p>Le troisième problème est que nous avons utilisé <code>expect</code> pour afficher un
message d'erreur lorsque la lecture du fichier échoue, mais le message affiche
uniquement <code>Quelque chose s'est mal passé lors de la lecture du fichier</code>. Lire
un fichier peut échouer pour de nombreuses raisons : par exemple, le fichier
peut ne pas exister, ou nous n'avons pas le droit de l'ouvrir. Pour le moment,
quelle que soit la raison, nous affichons le message d'erreur <code>Quelque chose s'est mal passé lors de la lecture du fichier</code>, ce qui ne donne aucune
information à l'utilisateur !</p>
<!--
Fourth, we use `expect` repeatedly to handle different errors, and if the user
runs our program without specifying enough arguments, they’ll get an `index out
of bounds` error from Rust that doesn’t clearly explain the problem. It would
be best if all the error-handling code were in one place so future maintainers
had only one place to consult in the code if the error-handling logic needed to
change. Having all the error-handling code in one place will also ensure that
we’re printing messages that will be meaningful to our end users.
-->
<p>Quatrièmement, nous utilisons <code>expect</code> à répétition pour gérer les différentes
erreurs, et si l'utilisateur lance notre programme sans renseigner d'arguments,
il va avoir une erreur <code>index out of bounds</code> provenant de Rust, qui n'explique
pas clairement le problème. Il serait plus judicieux que tout le code de gestion
des erreurs se trouve au même endroit afin que les futurs mainteneurs n'aient
qu'un seul endroit à consulter dans le code si la logique de gestion des
erreurs doit être modifiée. Avoir tout le code de gestion des erreurs dans un
seul endroit va aussi garantir que nous affichons des messages qui ont du sens
pour les utilisateurs.</p>
<!--
Let’s address these four problems by refactoring our project.
-->
<p>Corrigeons ces quatre problèmes en remaniant notre projet.</p>
<!--
### Separation of Concerns for Binary Projects
-->
<h3 id="séparation-des-tâches-des-projets-de-binaires"><a class="header" href="#séparation-des-tâches-des-projets-de-binaires">Séparation des tâches des projets de binaires</a></h3>
<!--
The organizational problem of allocating responsibility for multiple tasks to
the `main` function is common to many binary projects. As a result, the Rust
community has developed a process to use as a guideline for splitting the
separate concerns of a binary program when `main` starts getting large. The
process has the following steps:
-->
<p>Le problème de l'organisation de la répartition des tâches multiples dans la
fonction <code>main</code> est commun à de nombreux projets binaires. En conséquence, la
communauté Rust a développé une procédure à utiliser comme ligne conductrice
pour partager les tâches d'un programme binaire lorsque <code>main</code> commence à
grossir. Le processus se décompose selon les étapes suivantes :</p>
<!--
* Split your program into a *main.rs* and a *lib.rs* and move your program’s
  logic to *lib.rs*.
* As long as your command line parsing logic is small, it can remain in
  *main.rs*.
* When the command line parsing logic starts getting complicated, extract it
  from *main.rs* and move it to *lib.rs*.
-->
<ul>
<li>Diviser votre programme dans un <em>main.rs</em> et un <em>lib.rs</em> et déplacer la
logique de votre programme dans <em>lib.rs</em>.</li>
<li>Tant que votre logique d'interprétation de la ligne de commande est peu
volumineuse, elle peut rester dans le <em>main.rs</em></li>
<li>Lorsque la logique d'interprétation de la ligne de commande commence à devenir
compliquée, il faut la déplacer du <em>main.rs</em> vers le <em>lib.rs</em>.</li>
</ul>
<!--
The responsibilities that remain in the `main` function after this process
should be limited to the following:
-->
<p>Les fonctionnalités qui restent dans la fonction <code>main</code> après cette procédure
seront les suivantes :</p>
<!--
* Calling the command line parsing logic with the argument values
* Setting up any other configuration
* Calling a `run` function in *lib.rs*
* Handling the error if `run` returns an error
-->
<ul>
<li>Appeler la logique d'interprétation de ligne de commande avec les valeurs des
arguments</li>
<li>Régler toutes les autres configurations</li>
<li>Appeler une fonction <code>run</code> de <em>lib.rs</em></li>
<li>Gérer l'erreur si <code>run</code> retourne une erreur</li>
</ul>
<!--
This pattern is about separating concerns: *main.rs* handles running the
program, and *lib.rs* handles all the logic of the task at hand. Because you
can’t test the `main` function directly, this structure lets you test all of
your program’s logic by moving it into functions in *lib.rs*. The only code
that remains in *main.rs* will be small enough to verify its correctness by
reading it. Let’s rework our program by following this process.
-->
<p>Cette structure permet de séparer les responsabilités : <em>main.rs</em> se charge de
lancer le programme, et <em>lib.rs</em> renferme toute la logique des tâches à
accomplir. Comme vous ne pouvez pas directement tester la fonction <code>main</code>, cette
structure vous permet de tester toute la logique de votre programme en les
déplaçant dans des fonctions dans <em>lib.rs</em>. Le seul code qui restera dans le
<em>main.rs</em> sera suffisamment petit pour s'assurer qu'il soit correct en le
lisant. Lançons-nous dans le remaniement de notre programme en suivant cette
procédure.</p>
<!--
#### Extracting the Argument Parser
-->
<h4 id="extraction-de-linterpréteur-des-arguments"><a class="header" href="#extraction-de-linterpréteur-des-arguments">Extraction de l'interpréteur des arguments</a></h4>
<!--
We’ll extract the functionality for parsing arguments into a function that
`main` will call to prepare for moving the command line parsing logic to
*src/lib.rs*. Listing 12-5 shows the new start of `main` that calls a new
function `parse_config`, which we’ll define in *src/main.rs* for the moment.
-->
<p>Nous allons déplacer la fonctionnalité de l'interprétation des arguments dans
une fonction que <code>main</code> va appeler afin de préparer le déplacement de la logique
de l'interpréteur dans <em>src/lib.rs</em>. L'encart 12-5 montre le nouveau début du
<code>main</code> qui appelle une nouvelle fonction <code>interpreter_config</code>, que nous allons
définir dans <em>src/main.rs</em> pour le moment.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let (query, filename) = parse_config(&args);

    // --snip--
# 
#     println!("Searching for {}", query);
#     println!("In file {}", filename);
# 
#     let contents = fs::read_to_string(filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
}

fn parse_config(args: &[String]) -> (&str, &str) {
    let query = &args[1];
    let filename = &args[2];

    (query, filename)
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (recherche, nom_fichier) = interpreter_config(&amp;args);

    // -- partie masquée ici --
<span class="boring">
</span><span class="boring">    println!(&quot;On recherche : {}&quot;, recherche);
</span><span class="boring">    println!(&quot;Dans le fichier : {}&quot;, nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal passé lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span>}

fn interpreter_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let recherche = &amp;args[1];
    let nom_fichier = &amp;args[2];

    (recherche, nom_fichier)
}
</code></pre>
<!--
<span class="caption">Listing 12-5: Extracting a `parse_config` function from
`main`</span>
-->
<p><span class="caption">Encart 12-5 : Extraction d'une fonction
<code>interpreter_config</code> à partir de <code>main</code></span></p>
<!--
We’re still collecting the command line arguments into a vector, but instead of
assigning the argument value at index 1 to the variable `query` and the
argument value at index 2 to the variable `filename` within the `main`
function, we pass the whole vector to the `parse_config` function. The
`parse_config` function then holds the logic that determines which argument
goes in which variable and passes the values back to `main`. We still create
the `query` and `filename` variables in `main`, but `main` no longer has the
responsibility of determining how the command line arguments and variables
correspond.
-->
<p>Nous continuons à récupérer les arguments de la ligne de commande dans un
vecteur, mais au lieu d'assigner la valeur de l'argument d'indice 1 à la
variable <code>recherche</code> et la valeur de l'argument d'indice 2 à la variable
<code>nom_fichier</code> dans la fonction <code>main</code>, nous passons le vecteur entier à la
fonction <code>interpreter_config</code>. La fonction <code>interpreter_config</code> renferme la
logique qui détermine quel argument va dans quelle variable et renvoie les
valeurs au <code>main</code>. Nous continuons à créer les variables <code>recherche</code> et
<code>nom_fichier</code> dans le <code>main</code>, mais <code>main</code> n'a plus la responsabilité de
déterminer quelles sont les variables qui correspondent aux arguments de la
ligne de commande.</p>
<!--
This rework may seem like overkill for our small program, but we’re refactoring
in small, incremental steps. After making this change, run the program again to
verify that the argument parsing still works. It’s good to check your progress
often, to help identify the cause of problems when they occur.
-->
<p>Ce remaniement peut sembler excessif pour notre petit programme, mais nous
remanions de manière incrémentale par de petites étapes. Après avoir fait
ces changements, lancez à nouveau le programme pour vérifier que l'envoi des
arguments fonctionne toujours. C'est une bonne chose de vérifier souvent lorsque
vous avancez, pour vous aider à mieux identifier les causes de problèmes
lorsqu'ils apparaissent.</p>
<!--
#### Grouping Configuration Values
-->
<h4 id="grouper-les-valeurs-de-configuration"><a class="header" href="#grouper-les-valeurs-de-configuration">Grouper les valeurs de configuration</a></h4>
<!--
We can take another small step to improve the `parse_config` function further.
At the moment, we’re returning a tuple, but then we immediately break that
tuple into individual parts again. This is a sign that perhaps we don’t have
the right abstraction yet.
-->
<p>Nous pouvons appliquer une nouvelle petite étape pour améliorer la fonction
<code>interpreter_config</code>. Pour le moment, nous retournons un tuple, mais ensuite
nous divisons immédiatement ce tuple à nouveau en plusieurs éléments. C'est un
signe que nous n'avons peut-être pas la bonne approche.</p>
<!--
Another indicator that shows there’s room for improvement is the `config` part
of `parse_config`, which implies that the two values we return are related and
are both part of one configuration value. We’re not currently conveying this
meaning in the structure of the data other than by grouping the two values into
a tuple; we could put the two values into one struct and give each of the
struct fields a meaningful name. Doing so will make it easier for future
maintainers of this code to understand how the different values relate to each
other and what their purpose is.
-->
<p>Un autre signe qui indique qu'il y a encore de la place pour de l'amélioration
est que la partie <code>config</code> de <code>interpreter_config</code>, ce qui sous-entend que les
deux valeurs que nous retournons sont liées et font partie d'une même valeur de
configuration. Actuellement, nous ne donnons pas de signification à cela dans la
structure des données autrement qu'en regroupant les deux valeurs dans un
tuple ; nous pourrions mettre les deux valeurs dans une seule structure et
donner un nom significatif à chacun des champs de la structure. Faire ainsi
permet de faciliter la compréhension du code par les futurs développeurs de ce
code pour comprendre le lien entre les deux et quels sont leurs rôles.</p>
<!--
> Note: Using primitive values when a complex type would be more appropriate is
> an anti-pattern known as *primitive obsession*.
-->
<blockquote>
<p>Remarque : l'utilisation de valeurs primitives à la place d'un type
sophistiqué lorsque c'est nécessaire est un anti-patron connu sous le nom
<em>d'obsession primitive</em>.</p>
</blockquote>
<!--
Listing 12-6 shows the improvements to the `parse_config` function.
-->
<p>L'encart 12-6 montre les améliorations apportées à la fonction
<code>interpreter_config</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,should_panic,noplayground
# use std::env;
# use std::fs;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = parse_config(&args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    // --snip--
# 
#     println!("With text:\n{}", contents);
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &[String]) -> Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
```
-->
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = interpreter_config(&amp;args);

    println!(&quot;On recherche : {}&quot;, config.recherche);
    println!(&quot;Dans le fichier : {}&quot;, config.nom_fichier);

    let contenu = fs::read_to_string(config.nom_fichier)
        .expect(&quot;Quelque chose s'est mal passé lors de la lecture du fichier&quot;);

    // -- partie masquée ici --
<span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span>}

struct Config {
    recherche: String,
    nom_fichier: String,
}

fn interpreter_config(args: &amp;[String]) -&gt; Config {
    let recherche = args[1].clone();
    let nom_fichier = args[2].clone();

    Config { recherche, nom_fichier }
}
</code></pre>
<!--
<span class="caption">Listing 12-6: Refactoring `parse_config` to return an
instance of a `Config` struct</span>
-->
<p><span class="caption">Encart 12-6 : Remaniement de <code>interpreter_config</code> pour
retourner une instance de la structure <code>Config</code></span></p>
<!--
We’ve added a struct named `Config` defined to have fields named `query` and
`filename`. The signature of `parse_config` now indicates that it returns a
`Config` value. In the body of `parse_config`, where we used to return string
slices that reference `String` values in `args`, we now define `Config` to
contain owned `String` values. The `args` variable in `main` is the owner of
the argument values and is only letting the `parse_config` function borrow
them, which means we’d violate Rust’s borrowing rules if `Config` tried to take
ownership of the values in `args`.
-->
<p>Nous avons ajouté une structure <code>Config</code> qui a deux champs <code>recherche</code> et
<code>nom_fichier</code>. La signature de <code>interpreter_config</code> indique maintenant qu'elle
retourne une valeur <code>Config</code>. Dans le corps de <code>interpreter_config</code>, où nous
retournions une slice de chaînes de caractères qui pointaient sur des valeurs
<code>String</code> présentes dans <code>args</code>, nous définissons maintenant la structure
<code>Config</code> pour contenir des valeurs <code>String</code> qu'elle possède. La variable <code>args</code>
du <code>main</code> est la propriétaire des valeurs des arguments et permet uniquement à
la fonction <code>interpreter_config</code> de les emprunter, ce qui signifie que nous
violons les règles d'emprunt de Rust si <code>Config</code> essaye de prendre possession
des valeurs provenant de <code>args</code>.</p>
<!--
We could manage the `String` data in a number of different ways, but the
easiest, though somewhat inefficient, route is to call the `clone` method on
the values. This will make a full copy of the data for the `Config` instance to
own, which takes more time and memory than storing a reference to the string
data. However, cloning the data also makes our code very straightforward
because we don’t have to manage the lifetimes of the references; in this
circumstance, giving up a little performance to gain simplicity is a worthwhile
trade-off.
-->
<p>Nous pourrions gérer les données <code>String</code> de plusieurs manières, mais la façon
la plus facile, bien que non optimisée, est d'appeler la méthode <code>clone</code> sur
les valeurs. Cela va produire une copie complète des données pour que
l'instance de <code>Config</code> puisse se les approprier, ce qui va prendre plus de
temps et de mémoire que de stocker une référence vers les données de la chaîne
de caractères. Cependant le clonage des données rend votre code très simple
car nous n'avons pas à gérer les durées de vie des références ; dans ces
circonstances, sacrifier un peu de performances pour gagner en simplicité est
un compromis qui en vaut la peine.</p>
<!--
> ### The Trade-Offs of Using `clone`
>
> There’s a tendency among many Rustaceans to avoid using `clone` to fix
> ownership problems because of its runtime cost. In
> [Chapter 13][ch13]<!-- ignore -- >, you’ll learn how to use more efficient
> methods in this type of situation. But for now, it’s okay to copy a few
> strings to continue making progress because you’ll make these copies only
> once and your filename and query string are very small. It’s better to have
> a working program that’s a bit inefficient than to try to hyperoptimize code
> on your first pass. As you become more experienced with Rust, it’ll be
> easier to start with the most efficient solution, but for now, it’s
> perfectly acceptable to call `clone`.
-->
<blockquote>
<h3 id="les-contre-parties-de-lutilisation-de-clone"><a class="header" href="#les-contre-parties-de-lutilisation-de-clone">Les contre-parties de l'utilisation de <code>clone</code></a></h3>
<p>Il y a une tendance chez les Rustacés de s'interdire l'utilisation de <code>clone</code>
pour régler les problèmes d'appartenance à cause du coût à l'exécution. Dans
le <a href="ch13-00-functional-features.html">chapitre 13</a><!-- ignore -->, vous allez apprendre à utiliser des
méthodes plus efficaces dans ce genre de situation. Mais pour le moment, ce
n'est pas un problème de copier quelques chaînes de caractères pour continuer
à progresser car vous allez le faire une seule fois et votre <code>nom_fichier</code> et
<code>recherche</code> sont très courts. Il est plus important d'avoir un programme
fonctionnel qui n'est pas très optimisé plutôt que d'essayer d'optimiser à
outrance le code dès sa première écriture. Plus vous deviendrez expérimenté
en Rust, plus il sera facile de commencer par la solution la plus
performante, mais pour le moment, il est parfaitement acceptable de faire
appel à <code>clone</code>.</p>
</blockquote>
<!--
We’ve updated `main` so it places the instance of `Config` returned by
`parse_config` into a variable named `config`, and we updated the code that
previously used the separate `query` and `filename` variables so it now uses
the fields on the `Config` struct instead.
-->
<p>Nous avons actualisé <code>main</code> pour qu'il utilise l'instance de <code>Config</code> retournée
par <code>interpreter_config</code> dans une variable <code>config</code>, et nous avons rafraîchi le
code qui utilisait les variables séparées <code>recherche</code> et <code>nom_fichier</code> pour
qu'il utilise maintenant les champs de la structure <code>Config</code> à la place.</p>
<!--
Now our code more clearly conveys that `query` and `filename` are related and
that their purpose is to configure how the program will work. Any code that
uses these values knows to find them in the `config` instance in the fields
named for their purpose.
-->
<p>Maintenant, notre code indique clairement que <code>recherche</code> et <code>nom_fichier</code> sont
reliés et que leur but est de configurer le fonctionnement du programme.
N'importe quel code qui utilise ces valeurs sait comment les retrouver dans les
champs de l'instance <code>config</code> grâce à leurs noms donnés à cet effet.</p>
<!--
#### Creating a Constructor for `Config`
-->
<h4 id="créer-un-constructeur-pour-config"><a class="header" href="#créer-un-constructeur-pour-config">Créer un constructeur pour <code>Config</code></a></h4>
<!--
So far, we’ve extracted the logic responsible for parsing the command line
arguments from `main` and placed it in the `parse_config` function. Doing so
helped us to see that the `query` and `filename` values were related and that
relationship should be conveyed in our code. We then added a `Config` struct to
name the related purpose of `query` and `filename` and to be able to return the
values’ names as struct field names from the `parse_config` function.
-->
<p>Pour l'instant, nous avons extrait la logique en charge d'interpréter les
arguments de la ligne de commande à partir du <code>main</code> et nous l'avons placé dans
la fonction <code>interpreter_config</code>. Cela nous a aidé à découvrir que les valeurs
<code>recherche</code> et <code>nom_fichier</code> étaient liées et que ce lien devait être
retranscrit dans notre code. Nous avons ensuite créé une structure <code>Config</code>
afin de donner un nom au rôle apparenté à <code>recherche</code> et à <code>nom_fichier</code>, et
pour pouvoir retourner les noms des valeurs sous la forme de noms de champs à
partir de la fonction <code>interpreter_config</code>.</p>
<!--
So now that the purpose of the `parse_config` function is to create a `Config`
instance, we can change `parse_config` from a plain function to a function
named `new` that is associated with the `Config` struct. Making this change
will make the code more idiomatic. We can create instances of types in the
standard library, such as `String`, by calling `String::new`. Similarly, by
changing `parse_config` into a `new` function associated with `Config`, we’ll
be able to create instances of `Config` by calling `Config::new`. Listing 12-7
shows the changes we need to make.
-->
<p>Maintenant que le but de la fonction <code>interpreter_config</code> est de créer une
instance de <code>Config</code>, nous pouvons transformer <code>interpreter_config</code> d'une
simple fonction à une fonction <code>new</code> qui est associée à la structure <code>Config</code>.
Ce changement rendra le code plus familier. Habituellement, nous créons des
instances de types de la bibliothèque standard, comme <code>String</code>, en appelant
<code>String::new</code>. Si on change le <code>interpreter_config</code> en une fonction <code>new</code>
associée à <code>Config</code>, nous pourrons créer de la même façon des instances de
<code>Config</code> en appelant <code>Config::new</code>. L'encart 12-7 nous montre les changements
que nous devons faire pour cela.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,should_panic,noplayground
# use std::env;
# use std::fs;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args);
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);

    // --snip--
}

// --snip--

# struct Config {
#     query: String,
#     filename: String,
# }
# 
impl Config {
    fn new(args: &[String]) -> Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
```
-->
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!(&quot;On recherche : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal passé lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span>
    // -- partie masquée ici --
}

// -- partie masquée ici --

<span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        Config { recherche, nom_fichier }
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-7: Changing `parse_config` into
`Config::new`</span>
-->
<p><span class="caption">Encart 12-7 : Transformer <code>interpreter_config</code> en
<code>Config::new</code></span></p>
<!--
We’ve updated `main` where we were calling `parse_config` to instead call
`Config::new`. We’ve changed the name of `parse_config` to `new` and moved it
within an `impl` block, which associates the `new` function with `Config`. Try
compiling this code again to make sure it works.
-->
<p>Nous avons actualisé le <code>main</code> où nous appelions <code>interpreter_config</code> pour
appeler à la place le <code>Config::new</code>. Nous avons changé le nom de
<code>interpreter_config</code> par <code>new</code> et nous l'avons déplacé dans un bloc <code>impl</code>,
ce qui relie la fonction <code>new</code> à <code>Config</code>. Essayez à nouveau de compiler ce
code pour vous assurer qu'il fonctionne.</p>
<!--
### Fixing the Error Handling
-->
<h3 id="corriger-la-gestion-des-erreurs"><a class="header" href="#corriger-la-gestion-des-erreurs">Corriger la gestion des erreurs</a></h3>
<!--
Now we’ll work on fixing our error handling. Recall that attempting to access
the values in the `args` vector at index 1 or index 2 will cause the program to
panic if the vector contains fewer than three items. Try running the program
without any arguments; it will look like this:
-->
<p>Maintenant, nous allons nous pencher sur la correction de la gestion des
erreurs. Rappellez-vous que la tentative d'accéder aux valeurs dans le vecteur
<code>args</code> aux indices 1 ou 2 va faire paniquer le programme si le vecteur contient
moins de trois éléments. Essayez de lancer le programme sans aucun argument ;
cela donnera quelque chose comme ceci :</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
The line `index out of bounds: the len is 1 but the index is 1` is an error
message intended for programmers. It won’t help our end users understand what
happened and what they should do instead. Let’s fix that now.
-->
<p>La ligne <code>index out of bounds: the len is 1 but the index is 1</code> est un
message d'erreur destiné aux développeurs. Il n'aidera pas nos utilisateurs
finaux à comprendre ce qu'il s'est passé et ce qu'ils devraient faire à la
place. Corrigeons cela dès maintenant.</p>
<!--
#### Improving the Error Message
-->
<h4 id="améliorer-le-message-derreur"><a class="header" href="#améliorer-le-message-derreur">Améliorer le message d'erreur</a></h4>
<!--
In Listing 12-8, we add a check in the `new` function that will verify that the
slice is long enough before accessing index 1 and 2. If the slice isn’t long
enough, the program panics and displays a better error message than the `index
out of bounds` message.
-->
<p>Dans l'encart 12-8, nous ajoutons une vérification dans la fonction <code>new</code>, qui
va vérifier que le slice est suffisamment grand avant d'accéder aux indices 1
et 2. Si le slice n'est pas suffisamment grand, le programme va paniquer et
afficher un meilleur message d'erreur que le message <code>index out of bounds</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# 
# fn main() {
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args);
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
    // --snip--
    fn new(args: &[String]) -> Config {
        if args.len() < 3 {
            panic!("not enough arguments");
        }
        // --snip--
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Config { query, filename }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;On recherche : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal passé lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // -- partie masquée ici --
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!(&quot;il n'y a pas assez d'arguments&quot;);
        }
        // -- partie masquée ici --
<span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { recherche, nom_fichier }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-8: Adding a check for the number of
arguments</span>
-->
<p><span class="caption">Encart 12-8 : Ajout d'une vérification du nombre
d'arguments</span></p>
<!--
This code is similar to [the `Guess::new` function we wrote in Listing
9-10][ch9-custom-types]<!-- ignore -- >, where we called `panic!` when the
`value` argument was out of the range of valid values. Instead of checking for
a range of values here, we’re checking that the length of `args` is at least 3
and the rest of the function can operate under the assumption that this
condition has been met. If `args` has fewer than three items, this condition
will be true, and we call the `panic!` macro to end the program immediately.
-->
<p>Ce code est similaire à <a href="ch09-03-to-panic-or-not-to-panic.html">la fonction Supposition::new que nous avons écrit
dans l'encart 9-10</a><!-- ignore -->, dans lequel nous
appelions <code>panic!</code> lorsque l'argument <code>valeur</code> était hors de l'intervalle des
valeurs valides. Plutôt que de vérifier un intervalle de valeurs dans le cas
présent, nous vérifions que la taille de <code>args</code> est au moins de 3 et que le
reste de la fonction puisse fonctionner en s'appuyant sur l'affirmation que
cette condition a bien été remplie. Si <code>args</code> avait moins de trois éléments,
cette fonction serait vraie, et nous appellerions alors la macro <code>panic!</code>
pour mettre fin au programme immédiatement.</p>
<!--
With these extra few lines of code in `new`, let’s run the program without any
arguments again to see what the error looks like now:
-->
<p>Avec ces quelques lignes de code en plus dans <code>new</code>, lançons le programme sans
aucun argument à nouveau pour voir à quoi ressemble désormais l'erreur :</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'il n'y a pas assez d'arguments', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
This output is better: we now have a reasonable error message. However, we also
have extraneous information we don’t want to give to our users. Perhaps using
the technique we used in Listing 9-13 isn’t the best to use here: a call to
`panic!` is more appropriate for a programming problem than a usage problem,
[as discussed in Chapter 9][ch9-error-guidelines]<!-- ignore -- >. Instead, we
can use the other technique you learned about in Chapter 9—[returning a
`Result`][ch9-result]<!-- ignore -- > that indicates either success or an error.
-->
<p>Cette sortie est meilleure : nous avons maintenant un message d'erreur
compréhensible. Cependant, nous avons aussi des informations superflues que
nous ne souhaitons pas afficher à nos utilisateurs. Peut-être que la technique
que nous avons utilisé dans l'encart 9-13 n'est pas la plus appropriée dans ce
cas : un appel à <code>panic!</code> est plus approprié pour un problème de développement
qu'un problème d'utilisation, <a href="ch09-03-to-panic-or-not-to-panic.html">comme nous l'avons appris au chapitre
9</a><!-- ignore -->. A la place, nous pourrions utiliser
une autre technique que vous avez appris au chapitre 9 — <a href="ch09-02-recoverable-errors-with-result.html">retourner un
<code>Result</code></a><!-- ignore --> qui indique si c'est un succès ou une
erreur.</p>
<!--
#### Returning a `Result` from `new` Instead of Calling `panic!`
-->
<h4 id="retourner-un-result-à-partir-de-new-plutôt-que-dappeler-panic"><a class="header" href="#retourner-un-result-à-partir-de-new-plutôt-que-dappeler-panic">Retourner un <code>Result</code> à partir de <code>new</code> plutôt que d'appeler <code>panic!</code></a></h4>
<!--
We can instead return a `Result` value that will contain a `Config` instance in
the successful case and will describe the problem in the error case. When
`Config::new` is communicating to `main`, we can use the `Result` type to
signal there was a problem. Then we can change `main` to convert an `Err`
variant into a more practical error for our users without the surrounding text
about `thread 'main'` and `RUST_BACKTRACE` that a call to `panic!` causes.
-->
<p>Nous pouvons à la place retourner une valeur <code>Result</code> qui contiendra une
instance de <code>Config</code> dans le cas d'un succès et va décrire le problème dans le
cas d'une erreur. Lorsque <code>Config::new</code> communiquera avec le <code>main</code>, nous
pourrons utiliser le type de <code>Result</code> pour signaler où il y a un problème.
Ensuite, nous pourrons changer le <code>main</code> pour convertir une variante de <code>Err</code>
dans une erreur plus pratique pour nos utilisateurs sans avoir le texte à
propos de <code>thread 'main'</code> et de <code>RUST_BACKTRACE</code> qui sont provoqués par l'appel
à <code>panic!</code>.</p>
<!--
Listing 12-9 shows the changes we need to make to the return value of
`Config::new` and the body of the function needed to return a `Result`. Note
that this won’t compile until we update `main` as well, which we’ll do in the
next listing.
-->
<p>L'encart 12-9 nous montre les changements que nous devons apporter à la
valeur de retour de <code>Config::new</code> et le corps de la fonction pour pouvoir retourner
un <code>Result</code>. Notez que cela ne va pas se compiler tant que nous ne corrigeons
pas aussi le <code>main</code>, ce que nous allons faire dans le prochain encart.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# 
# fn main() {
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args);
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
impl Config {
    fn new(args: &[String]) -> Result<Config, &str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;On recherche : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal passé lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;il n'y a pas assez d'arguments&quot;);
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        Ok(Config { recherche, nom_fichier })
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-9: Returning a `Result` from
`Config::new`</span>
-->
<p><span class="caption">Encart 12-9 : Retourner un <code>Result</code> à partir de
<code>Config::new</code></span></p>
<!--
Our `new` function now returns a `Result` with a `Config` instance in the
success case and a `&str` in the error case.
-->
<p>Notre fonction <code>new</code> retourne désormais un <code>Result</code> contenant une instance de
<code>Config</code> dans le cas d'un succès et une <code>&amp;str</code> dans le cas d'une
erreur.</p>
<!--
We’ve made two changes in the body of the `new` function: instead of calling
`panic!` when the user doesn’t pass enough arguments, we now return an `Err`
value, and we’ve wrapped the `Config` return value in an `Ok`. These changes
make the function conform to its new type signature.
-->
<p>Nous avons fait deux changements dans le corps de notre fonction <code>new</code> :
plutôt que d'avoir à appeler <code>panic!</code> lorsque l'utilisateur n'envoie pas assez
d'arguments, nous retournons maintenant une valeur <code>Err</code>, et nous avons intégré
la valeur de retour <code>Config</code> dans un <code>Ok</code>. Ces modifications font en sorte que
la fonction soit désormais conformes à son nouveau type de signature.</p>
<!--
Returning an `Err` value from `Config::new` allows the `main` function to
handle the `Result` value returned from the `new` function and exit the process
more cleanly in the error case.
-->
<p>Retourner une valeur <code>Err</code> à partir de <code>Config::new</code> permet à la fonction
<code>main</code> de gérer la valeur <code>Result</code> retournée par la fonction <code>new</code> et de
terminer plus proprement le processus dans le cas d'une erreur.</p>
<!--
#### Calling `Config::new` and Handling Errors
-->
<h4 id="appeler-confignew-et-gérer-les-erreurs"><a class="header" href="#appeler-confignew-et-gérer-les-erreurs">Appeler <code>Config::new</code> et gérer les erreurs</a></h4>
<!--
To handle the error case and print a user-friendly message, we need to update
`main` to handle the `Result` being returned by `Config::new`, as shown in
Listing 12-10. We’ll also take the responsibility of exiting the command line
tool with a nonzero error code from `panic!` and implement it by hand. A
nonzero exit status is a convention to signal to the process that called our
program that the program exited with an error state.
-->
<p>Pour gérer les cas d'erreurs et afficher un message correct pour
l'utilisateur, nous devons mettre à jour <code>main</code> pour gérer le <code>Result</code>
retourné par <code>Config::new</code>, comme dans l'encart 12-10. Nous allons aussi
prendre la décision de quitter l'outil en ligne de commande avec un code
d'erreur différent de zéro avec <code>panic!</code> et nous allons l'implémenter
manuellement. Un statut de sortie différent de zéro est une convention pour
signaler au processus qui a appelé notre programme que le programme s'est
terminé dans un état d'erreur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    // --snip--
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     let contents = fs::read_to_string(config.filename)
#         .expect("Something went wrong reading the file");
# 
#     println!("With text:\n{}", contents);
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problème rencontré lors de l'interprétation des arguments : {}&quot;, err);
        process::exit(1);
    });

    // -- partie masquée ici --
<span class="boring">
</span><span class="boring">    println!(&quot;On recherche : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)
</span><span class="boring">        .expect(&quot;Quelque chose s'est mal passé lors de la lecture du fichier&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-10: Exiting with an error code if creating a
new `Config` fails</span>
-->
<p><span class="caption">Encart 12-10 : Quitter avec un code d'erreur si la
création d'une nouvelle <code>Config</code> échoue.
</span></p>
<!--
In this listing, we’ve used a method we haven’t covered in detail yet:
`unwrap_or_else`, which is defined on `Result<T, E>` by the standard library.
Using `unwrap_or_else` allows us to define some custom, non-`panic!` error
handling. If the `Result` is an `Ok` value, this method’s behavior is similar
to `unwrap`: it returns the inner value `Ok` is wrapping. However, if the value
is an `Err` value, this method calls the code in the *closure*, which is an
anonymous function we define and pass as an argument to `unwrap_or_else`. We’ll
cover closures in more detail in [Chapter 13][ch13]<!-- ignore -- >. For now,
you just need to know that `unwrap_or_else` will pass the inner value of the
`Err`, which in this case is the static string `"not enough arguments"` that we
added in Listing 12-9, to our closure in the argument `err` that appears
between the vertical pipes. The code in the closure can then use the `err`
value when it runs.
-->
<p>Dans cet encart, nous avons utilisé une méthode que nous n'avons pas encore
détaillé pour l'instant : <code>unwrap_or_else</code>, qui est défini sur <code>Result&lt;T, E&gt;</code>
par la bibliothèque standard. L'utilisation de <code>unwrap_or_else</code> nous permet de
définir une gestion des erreurs personnalisée, exempt de <code>panic!</code>. Si le
<code>Result</code> est une valeur <code>Ok</code>, le comportement de cette méthode est similaire à
<code>unwrap</code> : elle retourne la valeur à l'intérieur du <code>Ok</code>. Cependant, si la
valeur est une valeur <code>Err</code>, cette méthode appelle le code dans la <em>fermeture</em>,
qui est une fonction anonyme que nous définissons et passons en argument de
<code>unwrap_or_else</code>. Nous verrons les fermetures plus en détail dans le <a href="ch13-00-functional-features.html">chapitre
13</a><!-- ignore -->. Pour l'instant, vous avez juste à savoir que le
<code>unwrap_or_else</code> va passer la valeur interne du <code>Err</code> (qui dans ce cas est la
chaîne de caractères statique <code>&quot;pas assez d'arguments&quot;</code> que nous avons ajouté
dans l'encart 12-9) à notre fermeture dans l'argument <code>err</code> qui est présent
entre deux barres verticales. Le code dans la fermeture peut ensuite utiliser
la valeur <code>err</code> lorsqu'il est exécuté.</p>
<!--
We’ve added a new `use` line to bring `process` from the standard library into
scope. The code in the closure that will be run in the error case is only two
lines: we print the `err` value and then call `process::exit`. The
`process::exit` function will stop the program immediately and return the
number that was passed as the exit status code. This is similar to the
`panic!`-based handling we used in Listing 12-8, but we no longer get all the
extra output. Let’s try it:
-->
<p>Nous avons ajouté une nouvelle ligne <code>use</code> pour importer <code>process</code> dans la portée
à partir de la bibliothèque standard. Le code dans la fermeture qui sera exécuté
dans le cas d'une erreur fait uniquement deux lignes : nous affichons la valeur
de <code>err</code> et nous appelons ensuite <code>process::exit</code>. La fonction <code>process::exit</code>
va stopper le programme immédiatement et retourner le nombre qui lui a été donné
en paramètre comme code de statut de sortie. C'est semblable à la gestion basée
sur <code>panic!</code> que nous avons utilisé à l'encart 12-8, mais nous n'avons plus tout
le texte en plus. Essayons cela :</p>
<!--
```console
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
```
-->
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problème rencontré lors de l'interprétation des arguments : il n'y a pas assez d'arguments
</code></pre>
<!--
Great! This output is much friendlier for our users.
-->
<p>Très bien ! Cette sortie est bien plus compréhensible pour nos utilisateurs.</p>
<!--
### Extracting Logic from `main`
-->
<h3 id="extraction-de-la-logique-du-main"><a class="header" href="#extraction-de-la-logique-du-main">Extraction de la logique du <code>main</code></a></h3>
<!--
Now that we’ve finished refactoring the configuration parsing, let’s turn to
the program’s logic. As we stated in [“Separation of Concerns for Binary
Projects”](#separation-of-concerns-for-binary-projects)<!-- ignore -- >, we’ll
extract a function named `run` that will hold all the logic currently in the
`main` function that isn’t involved with setting up configuration or handling
errors. When we’re done, `main` will be concise and easy to verify by
inspection, and we’ll be able to write tests for all the other logic.
-->
<p>Maintenant que nous avons fini le remaniement de l'interprétation de la
configuration, occupons-nous de logique du programme. Comme nous l'avons dit
dans <a href="ch12-03-improving-error-handling-and-modularity.html#separation-of-concerns-for-binary-projects">“Séparation des tâches des projets de
binaires”</a><!-- ignore -->, nous
allons extraire une fonction <code>run</code> qui va contenir toute la logique qui est
actuellement dans la fonction <code>main</code> qui n'est pas liée au réglage de la
configuration ou la gestion des erreurs. Lorsque nous aurons terminé, <code>main</code>
sera plus concise et facile à vérifier en l'inspectant, et nous pourrons écrire
des tests pour toutes les autres logiques.</p>
<!--
Listing 12-11 shows the extracted `run` function. For now, we’re just making
the small, incremental improvement of extracting the function. We’re still
defining the function in *src/main.rs*.
-->
<p>L'encart 12-11 montre la fonction <code>run</code> extraite. Pour le moment, nous faisons
des petites améliorations progressives pour extraire les fonctions. Nous
continuons à définir la fonction dans <em>src/main.rs</em>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# use std::process;
# 
fn main() {
    // --snip--

#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents);
}

// --snip--
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // -- partie masquée ici --

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problème rencontré lors de l'interprétation des arguments : {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;On recherche : {}&quot;, config.recherche);
    println!(&quot;Dans le fichier : {}&quot;, config.nom_fichier);

    run(config);
}

fn run(config: Config) {
    let contenu = fs::read_to_string(config.nom_fichier)
        .expect(&quot;Quelque chose s'est mal passé lors de la lecture du fichier&quot;);

    println!(&quot;Dans le texte :\n{}&quot;, contenu);
}

// -- partie masquée ici --
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-11: Extracting a `run` function containing the
rest of the program logic</span>
-->
<p><span class="caption">Encart 12-11 : Extraction d'une fonction <code>run</code> qui
contient le reste de la logique du programme</span></p>
<!--
The `run` function now contains all the remaining logic from `main`, starting
from reading the file. The `run` function takes the `Config` instance as an
argument.
-->
<p>La fonction <code>run</code> contient maintenant toute la logique qui restait dans le
<code>main</code>, en commençant par la lecture du fichier. La fonction <code>run</code> prend
l'instance de <code>Config</code> en argument.</p>
<!--
#### Returning Errors from the `run` Function
-->
<h4 id="retourner-des-erreurs-avec-la-fonction-run"><a class="header" href="#retourner-des-erreurs-avec-la-fonction-run">Retourner des erreurs avec la fonction <code>run</code></a></h4>
<!--
With the remaining program logic separated into the `run` function, we can
improve the error handling, as we did with `Config::new` in Listing 12-9.
Instead of allowing the program to panic by calling `expect`, the `run`
function will return a `Result<T, E>` when something goes wrong. This will let
us further consolidate into `main` the logic around handling errors in a
user-friendly way. Listing 12-12 shows the changes we need to make to the
signature and body of `run`.
-->
<p>Avec le restant de la logique du programme maintenant séparée dans la fonction
<code>run</code>, nous pouvons améliorer la gestion des erreurs, comme nous l'avons fait
avec <code>Config::new</code> dans l'encart 12-9. Plutôt que de permettre au programme à
paniquer en appelant <code>expect</code>, la fonction <code>run</code> va retourner un <code>Result&lt;T, E&gt;</code>
lorsque quelque chose se passe mal. Cela va nous permettre de consolider
davantage la logique de gestion des erreurs dans le <code>main</code> pour qu'elle soit
plus conviviale pour l'utilisateur. L'encart 12-12 montre les changements que
nous devons appliquer à la signature et au corps du <code>run</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::fs;
# use std::process;
use std::error::Error;

// --snip--

# 
# fn main() {
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
#     run(config);
# }
# 
fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    println!("With text:\n{}", contents);

    Ok(())
}
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// -- partie masquée ici --

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problème rencontré lors de l'interprétation des arguments : {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;On recherche : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contenu = fs::read_to_string(config.nom_fichier)?;

    println!(&quot;Dans le texte :\n{}&quot;, contenu);

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-12: Changing the `run` function to return
`Result`</span>
-->
<p><span class="caption">Encart 12-12 : Changer la fonction <code>run</code> pour retourner
un <code>Result</code></span></p>
<!--
We’ve made three significant changes here. First, we changed the return type of
the `run` function to `Result<(), Box<dyn Error>>`. This function previously
returned the unit type, `()`, and we keep that as the value returned in the
`Ok` case.
-->
<p>Nous avons fait trois changements significatifs ici. Premièrement, nous avons
changé le type de retour de la fonction <code>run</code> en <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>.
Cette fonction renvoyait précédemment le type unité, <code>()</code>, que nous gardons
comme valeur de retour dans le cas de <code>Ok</code>.</p>
<!--
For the error type, we used the *trait object* `Box<dyn Error>` (and we’ve
brought `std::error::Error` into scope with a `use` statement at the top).
We’ll cover trait objects in [Chapter 17][ch17]<!-- ignore -- >. For now, just
know that `Box<dyn Error>` means the function will return a type that
implements the `Error` trait, but we don’t have to specify what particular type
the return value will be. This gives us flexibility to return error values that
may be of different types in different error cases. The `dyn` keyword is short
for “dynamic.”
-->
<p>En ce qui concerne le type d'erreur, nous avons utilisé <em>l'objet trait</em>
<code>Box&lt;dyn Error&gt;</code> (et nous avons importé <code>std::error::Error</code> dans la portée avec
une instruction <code>use</code> en haut). Nous allons voir les objets trait dans le
<a href="ch17-00-oop.html">chapitre 17</a><!-- ignore -->. Pour l'instant, retenez juste que
<code>Box&lt;dyn Error&gt;</code> signifie que la fonction va retourner un type qui implémente
le trait <code>Error</code>, mais que nous n'avons pas à spécifier quel sera précisément le
type de la valeur de retour. Cela nous donne la flexibilité de retourner des valeurs
d'erreurs qui peuvent être de différents types dans différents cas d'erreurs.
Le mot-clé <code>dyn</code> est un raccourci pour “dynamique”.</p>
<!--
Second, we’ve removed the call to `expect` in favor of the `?` operator, as we
talked about in [Chapter 9][ch9-question-mark]<!-- ignore -- >. Rather than
`panic!` on an error, `?` will return the error value from the current function
for the caller to handle.
-->
<p>Deuxièmement, nous avons enlevé l'appel à <code>expect</code> pour privilégier l'opérateur
<code>?</code>, que nous avons vu dans le <a href="ch09-02-recoverable-errors-with-result.html">chapitre 9</a><!-- ignore -->.
Au lieu de faire un <code>panic!</code> sur une erreur, <code>?</code> va retourner la valeur d'erreur
de la fonction courante vers le code qui l'a appelé pour qu'il la gère.</p>
<!--
Third, the `run` function now returns an `Ok` value in the success case. We’ve
declared the `run` function’s success type as `()` in the signature, which
means we need to wrap the unit type value in the `Ok` value. This `Ok(())`
syntax might look a bit strange at first, but using `()` like this is the
idiomatic way to indicate that we’re calling `run` for its side effects only;
it doesn’t return a value we need.
-->
<p>Troisièmement, la fonction <code>run</code> retourne maintenant une valeur <code>Ok</code> dans les
cas de succès. Nous avons déclaré dans la signature que le type de succès de la
fonction <code>run</code> était <code>()</code>, ce qui signifie que nous avons envelopper la valeur
de type unité dans la valeur <code>Ok</code>. Cette syntaxe <code>Ok(())</code> peut sembler un peu
étrange au départ, mais utiliser <code>()</code> de cette manière est la façon idéale
d'indiquer que nous appelons <code>run</code> uniquement pour ses effets secondaires ; elle
ne retourne pas de valeur dont nous pourrions avoir besoin.</p>
<!--
When you run this code, it will compile but will display a warning:
-->
<p>Lorsque vous exécutez ce code, il va se compiler mais il va afficher un
avertissement :</p>
<!--
```console
$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  -- > src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `minigrep` (bin "minigrep") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

```
-->
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `minigrep` (bin &quot;minigrep&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
On recherche : the
Dans le fichier : poem.txt
Dans le texte :
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<!--
Rust tells us that our code ignored the `Result` value and the `Result` value
might indicate that an error occurred. But we’re not checking to see whether or
not there was an error, and the compiler reminds us that we probably meant to
have some error-handling code here! Let’s rectify that problem now.
-->
<p>Rust nous informe que notre code ignore la valeur <code>Result</code> et que cette valeur
<code>Result</code> pourrait indiquer qu'une erreur s'est passée. Mais nous ne vérifions
pas pour savoir si oui ou non il y a eu une erreur, et le compilateur nous
rappelle que nous devrions avoir du code de gestion des erreurs ici !
Corrigeons dès à présent ce problème.</p>
<!--
#### Handling Errors Returned from `run` in `main`
-->
<h4 id="gérer-les-erreurs-retournées-par-run-dans-main"><a class="header" href="#gérer-les-erreurs-retournées-par-run-dans-main">Gérer les erreurs retournées par <code>run</code> dans <code>main</code></a></h4>
<!--
We’ll check for errors and handle them using a technique similar to one we used
with `Config::new` in Listing 12-10, but with a slight difference:
-->
<p>Nous allons vérifier les erreurs et les gérer en utilisant une technique
similaire à celle que nous avons utilisé avec <code>Config::new</code> dans l'encart
12-10, mais avec une légère différence :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::error::Error;
# use std::fs;
# use std::process;
# 
fn main() {
    // --snip--

#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    if let Err(e) = run(config) {
        println!("Application error: {}", e);

        process::exit(1);
    }
}
# 
# fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     println!("With text:\n{}", contents);
# 
#     Ok(())
# }
# 
# struct Config {
#     query: String,
#     filename: String,
# }
# 
# impl Config {
#     fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // -- partie masquée ici --

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problème rencontré lors de l'interprétation des arguments : {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;On recherche : {}&quot;, config.recherche);
    println!(&quot;Dans le fichier : {}&quot;, config.nom_fichier);

    if let Err(e) = run(config) {
        println!(&quot;Erreur applicative : {}&quot;, e);

        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    recherche: String,
</span><span class="boring">    nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
We use `if let` rather than `unwrap_or_else` to check whether `run` returns an
`Err` value and call `process::exit(1)` if it does. The `run` function doesn’t
return a value that we want to `unwrap` in the same way that `Config::new`
returns the `Config` instance. Because `run` returns `()` in the success case,
we only care about detecting an error, so we don’t need `unwrap_or_else` to
return the unwrapped value because it would only be `()`.
-->
<p>Nous utilisons <code>if let</code> plutôt que <code>unwrap_or_else</code> pour vérifier si <code>run</code>
retourne un valeur <code>Err</code> et appeler <code>process::exit(1)</code> le cas échéant. La
fonction <code>run</code> ne retourne pas de valeur que nous avons besoin de <code>unwrap</code>
comme nous l'avions fait avec le <code>Config::new</code> qui retournait une instance de
<code>Config</code>. Comme <code>run</code> retourne <code>()</code> dans le cas d'un succès, nous nous
préoccupons uniquement de détecter les erreurs, donc n'avons pas besoin de
<code>unwrap_or_else</code> pour retourner la valeur extraite car elle sera toujours
<code>()</code>.</p>
<!--
The bodies of the `if let` and the `unwrap_or_else` functions are the same in
both cases: we print the error and exit.
-->
<p>Les corps du <code>if let</code> et de la fonction <code>unwrap_or_else</code> sont identiques dans
les deux cas : nous affichons l'erreur et nous quittons.</p>
<!--
### Splitting Code into a Library Crate
-->
<h3 id="déplacer-le-code-dans-une-crate-de-bibliothèque"><a class="header" href="#déplacer-le-code-dans-une-crate-de-bibliothèque">Déplacer le code dans une crate de bibliothèque</a></h3>
<!--
Our `minigrep` project is looking good so far! Now we’ll split the
*src/main.rs* file and put some code into the *src/lib.rs* file so we can test
it and have a *src/main.rs* file with fewer responsibilities.
-->
<p>Notre projet <code>minigrep</code> se présente plutôt bien pour le moment ! Maintenant,
nous allons diviser notre fichier <em>src/main.rs</em> et déplacer du code dans le
fichier <em>src/lib.rs</em> pour que nous puissions le tester et avoir un fichier
<em>src/main.rs</em> qui héberge moins de fonctionnalités.</p>
<!--
Let’s move all the code that isn’t the `main` function from *src/main.rs* to
*src/lib.rs*:
-->
<p>Déplaçons tout le code qui ne fait pas partie de la fonction <code>main</code> dans le
<em>src/main.rs</em> vers le <em>src/lib.rs</em> :</p>
<!--
* The `run` function definition
* The relevant `use` statements
* The definition of `Config`
* The `Config::new` function definition
-->
<ul>
<li>La définition de la fonction <code>run</code></li>
<li>Les instructions <code>use</code> correspondantes</li>
<li>La définition de <code>Config</code></li>
<li>La définition de la fonction <code>Config::new</code></li>
</ul>
<!--
The contents of *src/lib.rs* should have the signatures shown in Listing 12-13
(we’ve omitted the bodies of the functions for brevity). Note that this won’t
compile until we modify *src/main.rs* in Listing 12-14.
-->
<p>Le contenu du <em>src/lib.rs</em> devrait contenir les signatures de l'encart 12-13
(nous avons enlevé les corps des fonctions pour des raisons de brièveté). Notez
que cela ne va pas se compiler jusqu'à ce que nous modifions le <em>src/main.rs</em>
dans l'encart 12-14.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &[String]) -> Result<Config, &str> {
        // --snip--
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
    }
}

pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    // --snip--
#     let contents = fs::read_to_string(config.filename)?;
# 
#     println!("With text:\n{}", contents);
# 
#     Ok(())
}
```
-->
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs;

pub struct Config {
    pub recherche: String,
    pub nom_fichier: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
        // -- partie masquée ici --
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // -- partie masquée ici --
<span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;Dans le texte :\n{}&quot;, contenu);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}
</code></pre>
<!--
<span class="caption">Listing 12-13: Moving `Config` and `run` into
*src/lib.rs*</span>
-->
<p><span class="caption">Encart 12-13 : Déplacement de <code>Config</code> et de <code>run</code> dans
<em>src/lib.rs</em></span></p>
<!--
We’ve made liberal use of the `pub` keyword: on `Config`, on its fields and its
`new` method, and on the `run` function. We now have a library crate that has a
public API that we can test!
-->
<p>Nous avons fait un usage généreux du mot-clé <code>pub</code> : sur <code>Config</code>, sur ses
champs et sur la méthode <code>new</code>, et sur la fonction <code>run</code>. Nous avons maintenant
une crate de bibliothèque qui a une API publique que nous pouvons tester !</p>
<!--
Now we need to bring the code we moved to *src/lib.rs* into the scope of the
binary crate in *src/main.rs*, as shown in Listing 12-14.
-->
<p>Maintenant nous devons importer le code que nous avons déplacé dans
<em>src/lib.rs</em> dans la portée de la crate binaire dans <em>src/main.rs</em>, comme dans
l'encart 12-14.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
#     let args: Vec<String> = env::args().collect();
# 
#     let config = Config::new(&args).unwrap_or_else(|err| {
#         println!("Problem parsing arguments: {}", err);
#         process::exit(1);
#     });
# 
#     println!("Searching for {}", config.query);
#     println!("In file {}", config.filename);
# 
    if let Err(e) = minigrep::run(config) {
        // --snip--
#         println!("Application error: {}", e);
# 
#         process::exit(1);
    }
}
```
-->
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // -- partie masquée ici --
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problème rencontré lors de l'interprétation des arguments : {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;On recherche : {}&quot;, config.recherche);
</span><span class="boring">    println!(&quot;Dans le fichier : {}&quot;, config.nom_fichier);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // -- partie masquée ici --
<span class="boring">        println!(&quot;Erreur applicative : {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span>    }
}
</code></pre>
<!--
<span class="caption">Listing 12-14: Using the `minigrep` library crate in
*src/main.rs*</span>
-->
<p><span class="caption">Encart 12-14 : Utilisation de la crate de bibliothèque
<code>minigrep</code> dans <em>src/main.rs</em></span></p>
<!--
We add a `use minigrep::Config` line to bring the `Config` type from the
library crate into the binary crate’s scope, and we prefix the `run` function
with our crate name. Now all the functionality should be connected and should
work. Run the program with `cargo run` and make sure everything works
correctly.
-->
<p>Nous avons ajouté une ligne <code>use minigrep::Config</code> pour importer le type
<code>Config</code> de la crate de bibliothèque dans la portée de la crate binaire, et
nous avons avons préfixé la fonction <code>run</code> avec le nom de notre crate.
Maintenant, toutes les fonctionnalités devraient être connectées et devraient
fonctionner. Lancez le programme avec <code>cargo run</code> pour vous assurer que tout
fonctionne correctement.</p>
<!--
Whew! That was a lot of work, but we’ve set ourselves up for success in the
future. Now it’s much easier to handle errors, and we’ve made the code more
modular. Almost all of our work will be done in *src/lib.rs* from here on out.
-->
<p>Ouah ! C'était pas mal de travail, mais nous sommes organisés pour nous assurer
le succès à venir. Maintenant il est bien plus facile de gérer les erreurs, et
nous avons rendu le code plus modulaire. A partir de maintenant, l'essentiel de
notre travail sera effectué dans <em>src/lib.rs</em>.</p>
<!--
Let’s take advantage of this newfound modularity by doing something that would
have been difficult with the old code but is easy with the new code: we’ll
write some tests!
-->
<p>Profitons de cette nouvelle modularité en accomplissant quelque chose qui
aurait été difficile à faire avec l'ancien code, mais qui est facile avec ce
nouveau code : nous allons écrire des tests !</p>
<!--
[ch13]: ch13-00-functional-features.html
[ch9-custom-types]: ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation
[ch9-error-guidelines]: ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling
[ch9-result]: ch09-02-recoverable-errors-with-result.html
[ch17]: ch17-00-oop.html
[ch9-question-mark]: ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Developing the Library’s Functionality with Test-Driven Development
-->
<h2 id="développer-les-fonctionnalités-de-la-bibliothèque-avec-le-tdd"><a class="header" href="#développer-les-fonctionnalités-de-la-bibliothèque-avec-le-tdd">Développer les fonctionnalités de la bibliothèque avec le TDD</a></h2>
<!--
Now that we’ve extracted the logic into *src/lib.rs* and left the argument
collecting and error handling in *src/main.rs*, it’s much easier to write tests
for the core functionality of our code. We can call functions directly with
various arguments and check return values without having to call our binary
from the command line. Feel free to write some tests for the functionality in
the `Config::new` and `run` functions on your own.
-->
<p>Maintenant que nous avons extrait la logique dans <em>src/lib.rs</em> et que nous
avons laissé la récupération des arguments et la gestion des erreurs dans
<em>src/main.rs</em>, il est bien plus facile d'écrire les tests pour les
fonctionnalités de base de notre code. Nous pouvons appeler les fonctions
directement avec différents arguments et vérifier les valeurs de retour sans
avoir à appeler notre binaire dans la ligne de commande. N'hésitez pas à écrire
quelques tests par vous-même pour les fonctions <code>Config::new</code> et <code>run</code>.</p>
<!--
In this section, we’ll add the searching logic to the `minigrep` program by
using the Test-driven development (TDD) process. This software development
technique follows these steps:
-->
<p>Dans cette section, nous allons ajouter la logique de recherche au programme
<code>minigrep</code> en utilisant le processus de développement orienté par les tests
(c'est le TDD : <em>Test-Driven Development</em>). Cette technique de développement
de logiciels suit ces trois étapes :</p>
<!--
1. Write a test that fails and run it to make sure it fails for the reason you
   expect.
2. Write or modify just enough code to make the new test pass.
3. Refactor the code you just added or changed and make sure the tests
   continue to pass.
4. Repeat from step 1!
-->
<ol>
<li>Ecrire un test qui échoue et lancez-le pour vous assurer qu'il va échouer
pour la raison que vous attendiez.</li>
<li>Ecrire ou modifier juste assez de code pour faire réussir ce nouveau test.</li>
<li>Remanier le code que vous venez d'ajouter ou de changer pour vous assurer
que les tests continuent à réussir.</li>
<li>Recommencer à l'étape 1 !</li>
</ol>
<!--
This process is just one of many ways to write software, but TDD can help drive
code design as well. Writing the test before you write the code that makes the
test pass helps to maintain high test coverage throughout the process.
-->
<p>Ce processus n'est qu'une des différentes manières d'écrire des programmes,
mais le TDD peut aussi aider à piloter sa conception. Ecrire les tests avant
d'écrire le code qui fait réussir les tests aide à maintenir une haute
couverture de tests tout le long du processus.</p>
<!--
We’ll test drive the implementation of the functionality that will actually do
the searching for the query string in the file contents and produce a list of
lines that match the query. We’ll add this functionality in a function called
`search`.
-->
<p>Nous allons expérimenter cela avec l'implémentation de la fonctionnalité qui va
rechercher la chaîne de caractères demandée dans le contenu du fichier et
générer une liste de lignes qui correspond à cette recherche. Nous ajouterons
cette fonctionnalité dans une fonction <code>rechercher</code>.</p>
<!--
### Writing a Failing Test
-->
<h3 id="ecrire-un-test-qui-échoue"><a class="header" href="#ecrire-un-test-qui-échoue">Ecrire un test qui échoue</a></h3>
<!--
Because we don’t need them anymore, let’s remove the `println!` statements from
*src/lib.rs* and *src/main.rs* that we used to check the program’s behavior.
Then, in *src/lib.rs*, we’ll add a `tests` module with a test function, as we
did in [Chapter 11][ch11-anatomy]<!-- ignore -- >. The test function specifies
the behavior we want the `search` function to have: it will take a query and
the text to search for the query in, and it will return only the lines from the
text that contain the query. Listing 12-15 shows this test, which won’t compile
yet.
-->
<p>Comme nous n'en avons plus besoin, enlevons les instructions <code>println!</code> de
<em>src/lib.rs</em> et <em>src/main.rs</em> que nous avions utilisé pour vérifier le bon
comportement du programme. Ensuite, dans <em>src/lib.rs</em>, nous allons ajouter un
module <code>tests</code> avec une fonction de test, comme nous l'avions fait dans le
<a href="ch11-01-writing-tests.html">chapitre 11</a><!-- ignore -->. La fonction de test définit le
comportement que nous voulons qu'ait la fonction <code>rechercher</code> : elle va prendre
en arguments une recherche et le texte dans lequel rechercher, et elle va
retourner seulement les lignes du texte qui correspondent à la recherche.
L'encart 12-15 montre ce test, qui ne se compile pas encore.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn un_resultat() {
        let recherche = &quot;duct&quot;;
        let contenu = &quot;\
Rust:
sécurité, rapidité, productivité.
Obtenez les trois en même temps.&quot;;

        assert_eq!(
            vec![&quot;sécurité, rapidité, productivité.&quot;],
            rechercher(recherche, contenu)
        );
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-15: Creating a failing test for the `search`
function we wish we had</span>
-->
<p><span class="caption">Encart 12-15 : Création d'un test qui échoue pour la
fonction <code>rechercher</code> que nous souhaitons concevoir</span></p>
<!--
This test searches for the string `"duct"`. The text we’re searching is three
lines, only one of which contains `"duct"` (Note that the backslash after the
opening double quote tells Rust not to put a newline character at the beginning
of the contents of this string literal). We assert that the value returned from
the `search` function contains only the line we expect.
-->
<p>Ce test recherche la chaîne de caractères <code>&quot;duct&quot;</code>. Le texte dans lequel nous
recherchons fait trois lignes, et seulement une d'entre elles contient <code>&quot;duct&quot;</code>
(remarquez que l'antislash après la double-guillet ouvrante indique à Rust de
ne pas insérer un caractère de nouvelle ligne au début du contenu de ce litéral
de chaîne de caractère). Nous vérifions que la valeur retournée par la fonction
<code>rechercher</code> contient seulement la ligne que nous avions prévu.</p>
<!--
We aren’t able to run this test and watch it fail because the test doesn’t even
compile: the `search` function doesn’t exist yet! So now we’ll add just enough
code to get the test to compile and run by adding a definition of the `search`
function that always returns an empty vector, as shown in Listing 12-16. Then
the test should compile and fail because an empty vector doesn’t match a vector
containing the line `"safe, fast, productive."`
-->
<p>Nous ne pouvons pas encore exécuter ce test et vérifier s'il échoue car même le
test ne peut pas se compiler : la fonction <code>rechercher</code> n'existe pas encore !
Donc pour le moment nous allons ajouter juste assez de code pour que le test
puisse compiler et s'exécuter en ajoutant une définition de la fonction
<code>rechercher</code> qui retourne un vecteur vide, comme dans l'encart 12-16. Ensuite
le test va compiler et échouer car un vecteur vide ne correspond pas au vecteur
qui contient la ligne <code>&quot;sécurité, rapidité, productivité.&quot;</code></p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    vec![]
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sécurité, rapidité, productivité.
</span><span class="boring">Obtenez les trois en même temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sécurité, rapidité, productivité.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-16: Defining just enough of the `search`
function so our test will compile</span>
-->
<p><span class="caption">Encart 12-16 : Définition du strict minimum de la fonction
<code>rechercher</code> pour que notre test puisse compiler</span></p>
<!--
Notice that we need an explicit lifetime `'a` defined in the signature of
`search` and used with the `contents` argument and the return value. Recall in
[Chapter 10][ch10-lifetimes]<!-- ignore -- > that the lifetime parameters
specify which argument lifetime is connected to the lifetime of the return
value. In this case, we indicate that the returned vector should contain string
slices that reference slices of the argument `contents` (rather than the
argument `query`).
-->
<p>Remarquez que nous avons besoin de préciser explicitement une durée de vie <code>'a</code>
définie dans la signature de <code>rechercher</code> et l'utiliser sur l'argument <code>contenu</code>
et la valeur de retour. Rappelez-vous que dans le
<a href="ch10-03-lifetime-syntax.html">chapitre 10</a><!-- ignore --> nous avions vu que les paramètres
de durée de vie renseignent à quelle durée de vie des arguments sont connectées
aux durées de vie des valeurs de retour. Dans notre cas, nous indiquons que le
vecteur retourné devrait contenir des slices de chaînes de caractères qui sont
des slices de l'argument <code>contenu</code> (et non pas de l'argument <code>recherche</code>).</p>
<!--
In other words, we tell Rust that the data returned by the `search` function
will live as long as the data passed into the `search` function in the
`contents` argument. This is important! The data referenced *by* a slice needs
to be valid for the reference to be valid; if the compiler assumes we’re making
string slices of `query` rather than `contents`, it will do its safety checking
incorrectly.
-->
<p>Autrement dit, nous disons à Rust que les données retournées par la fonction
<code>rechercher</code> vont vivre aussi longtemps que la donnée dans l'argument <code>contenu</code>
de la fonction <code>rechercher</code>. C'est très important ! Les données sur lesquelles
pointent les slices doivent être en vigueur pour que la référence reste valide ;
si le compilateur croit que nous créons des slices de <code>recherche</code> plutôt que de
<code>contenu</code>, ses vérifications de sécurité seront incorrectes.</p>
<!--
If we forget the lifetime annotations and try to compile this function, we’ll
get this error:
-->
<p>Si nous oublions les annotations de durée de vie et que nous essayons de
compiler cette fonction, nous allons obtenir cette erreur :</p>
<!--
```console
$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  -- > src/lib.rs:28:51
   |
28 | pub fn search(query: &str, contents: &str) -> Vec<&str> {
   |                      ----            ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
   |
28 | pub fn search<'a>(query: &'a str, contents: &'a str) -> Vec<&'a str> {
   |              ^^^^        ^^^^^^^            ^^^^^^^         ^^^

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` due to previous error
```
-->
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn rechercher(recherche: &amp;str, contenu: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                              ----           ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `recherche` or `contenu`
help: consider introducing a named lifetime parameter
   |
28 | pub fn rechercher&lt;'a&gt;(recherche: &amp;'a str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
   |                  ^^^^            ^^^^^^^           ^^^^^^^         ^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` due to previous error
</code></pre>
<!--
Rust can’t possibly know which of the two arguments we need, so we need to tell
it. Because `contents` is the argument that contains all of our text and we
want to return the parts of that text that match, we know `contents` is the
argument that should be connected to the return value using the lifetime syntax.
-->
<p>Rust ne peut pas deviner lequel des deux arguments nous allons utiliser, donc
nous devons lui dire. Comme <code>contenu</code> est l'argument qui contient tout notre
texte et que nous voulons retourner des extraits de ce texte qui correspondent à
la recherche, nous savons que <code>contenu</code> est l'argument qui doit être connecté à
la valeur de retour, en utilisant la syntaxe de durée de vie.</p>
<!--
Other programming languages don’t require you to connect arguments to return
values in the signature. Although this might seem strange, it will get easier
over time. You might want to compare this example with the [“Validating
References with Lifetimes”][validating-references-with-lifetimes]<!-- ignore
-- > section in Chapter 10.
-->
<p>Les autres langages de programmation n'ont pas besoin que vous connectiez les
arguments aux valeurs de retour dans la signature. Bien que cela puisse paraître
étrange, cela devient plus facile au fil du temps. Vous devriez peut-être
comparer cet exemple à la
<a href="ch10-03-lifetime-syntax.html">section 3 du chapitre 10</a><!-- ignore -->.</p>
<!--
Now let’s run the test:
-->
<p>Maintenant, exécutons le test :</p>
<!--
```console
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `["safe, fast, productive."]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::un_resultat ... FAILED

failures:

---- tests::un_resultat stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `[&quot;sécurité, rapidité, productivité.&quot;]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::un_resultat

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Great, the test fails, exactly as we expected. Let’s get the test to pass!
-->
<p>Très bien, le test a échoué, comme nous nous y attendions. Faisons maintenant en
sorte qu'il réussisse !</p>
<!--
### Writing Code to Pass the Test
-->
<h3 id="ecrire-du-code-pour-réussir-au-test"><a class="header" href="#ecrire-du-code-pour-réussir-au-test">Ecrire du code pour réussir au test</a></h3>
<!--
Currently, our test is failing because we always return an empty vector. To fix
that and implement `search`, our program needs to follow these steps:
-->
<p>Pour le moment, notre test échoue car nous retournons toujours un vecteur vide.
Pour corriger cela et implémenter <code>rechercher</code>, notre programme doit suivre les
étapes suivantes :</p>
<!--
* Iterate through each line of the contents.
* Check whether the line contains our query string.
* If it does, add it to the list of values we’re returning.
* If it doesn’t, do nothing.
* Return the list of results that match.
-->
<ul>
<li>Itérer sur chacune des lignes de <code>contenu</code>.</li>
<li>Vérifier si la ligne contient la chaîne de caractères recherchée.</li>
<li>Si c'est le cas, l'ajouter à la liste des valeurs que nous retournerons.</li>
<li>Si ce n'est pas le cas, ne rien faire.</li>
<li>Retourner la liste des résultats qui ont été trouvés.</li>
</ul>
<!--
Let’s work through each step, starting with iterating through lines.
-->
<p>Travaillons sur chacune de ces étapes, en commençant par l'itération sur les
lignes.</p>
<!--
#### Iterating Through Lines with the `lines` Method
-->
<h4 id="itérer-sur-chacune-des-lignes-avec-la-méthode-lines"><a class="header" href="#itérer-sur-chacune-des-lignes-avec-la-méthode-lines">Itérer sur chacune des lignes avec la méthode <code>lines</code></a></h4>
<!--
Rust has a helpful method to handle line-by-line iteration of strings,
conveniently named `lines`, that works as shown in Listing 12-17. Note this
won’t compile yet.
-->
<p>Rust a une méthode très pratique pour gérer l'itération ligne-par-ligne des
chaînes de caractères, judicieusement appelée <code>lines</code>, qui fonctionne comme dans
l'encart 12-17. Notez que cela ne se compile pas encore.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        // do something with line
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for ligne in contenu.lines() {
        // faire quelquechose avec ligne ici
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sécurité, rapidité, productivité.
</span><span class="boring">Obtenez les trois en même temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sécurité, rapidité, productivité.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-17: Iterating through each line in `contents`
</span>
-->
<p><span class="caption">Encart 12-17 : Itération sur chacune des lignes de
<code>contenu</code> </span></p>
<!-- markdownlint-disable -->
<!--
The `lines` method returns an iterator. We’ll talk about iterators in depth in
[Chapter 13][ch13-iterators]<!-- ignore -- >, but recall that you saw this way of using an
iterator in [Listing 3-5][ch3-iter]<!-- ignore -- >, where we used a `for` loop
with an iterator to run some code on each item in a collection.
-->
<!-- markdownlint-restore -->
<p>La méthode <code>lines</code> retourne un itérateur. Nous verrons plus tard les itérateurs
dans le <a href="ch13-02-iterators.html">chapitre 13</a><!-- ignore -->, mais souvenez-vous que
vous avez vu cette façon d'utiliser un itérateur dans
<a href="ch03-05-control-flow.html">l'encart 3-5</a><!-- ignore -->, dans lequel nous avions utilisé une
boucle <code>for</code> sur un itérateur pour exécuter du code sur chaque élément d'une
collection.</p>
<!--
#### Searching Each Line for the Query
-->
<h4 id="trouver-chaque-ligne-correspondante-à-la-recherche"><a class="header" href="#trouver-chaque-ligne-correspondante-à-la-recherche">Trouver chaque ligne correspondante à la recherche</a></h4>
<!--
Next, we’ll check whether the current line contains our query string.
Fortunately, strings have a helpful method named `contains` that does this for
us! Add a call to the `contains` method in the `search` function, as shown in
Listing 12-18. Note this still won’t compile yet.
-->
<p>Ensuite, nous allons vérifier que la ligne courante contient la chaîne de
caractères que nous recherchons. Heureusement, les chaînes de caractères ont une
méthode <code>contains</code> assez pratique qui fait cela pour nous ! Ajoutez l'appel à
la méthode <code>contains</code> dans la fonction <code>rechercher</code>, comme dans l'encart 12-18.
Notez qu'ici non plus nous ne pouvons pas encore compiler.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            // faire quelquechose avec la ligne ici
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sécurité, rapidité, productivité.
</span><span class="boring">Obtenez les trois en même temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sécurité, rapidité, productivité.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-18: Adding functionality to see whether the
line contains the string in `query`</span>
-->
<p><span class="caption">Encart 12-18 : Ajout d'une fonctionnalité pour trouver
quelle ligne contient la chaîne de caractères <code>recherche</code></span></p>
<!--
#### Storing Matching Lines
-->
<h4 id="stocker-les-lignes-trouvées"><a class="header" href="#stocker-les-lignes-trouvées">Stocker les lignes trouvées</a></h4>
<!--
We also need a way to store the lines that contain our query string. For that,
we can make a mutable vector before the `for` loop and call the `push` method
to store a `line` in the vector. After the `for` loop, we return the vector, as
shown in Listing 12-19.
-->
<p>Nous avons aussi besoin d'un moyen de stocker les lignes qui contienent la
chaîne de caractères que nous recherchons. Pour cela, nous pouvons créer un
vecteur mutable avant la boucle <code>for</code> et appeler la méthode <code>push</code> pour
enregistrer la <code>ligne</code> dans le vecteur. Après la boucle <code>for</code>, nous retournons
le vecteur, comme dans l'encart 12-19 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contents = fs::read_to_string(config.filename)?;
# 
#     Ok(())
# }
# 
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sécurité, rapidité, productivité.
</span><span class="boring">Obtenez les trois en même temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sécurité, rapidité, productivité.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-19: Storing the lines that match so we can
return them</span>
-->
<p><span class="caption">Encart 12-19 : Enregistrement des lignes qui sont
trouvées afin que nous puissions les retourner</span></p>
<!--
Now the `search` function should return only the lines that contain `query`,
and our test should pass. Let’s run the test:
-->
<p>Maintenant, notre fonction <code>rechercher</code> retourne uniquement les lignes qui
contiennent <code>recherche</code>, et notre test devrait réussir. Exécutons le test :</p>
<!--
```console
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::un_resultat ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
Our test passed, so we know it works!
-->
<p>Notre test a réussi, donc nous savons que cela fonctionne !</p>
<!--
At this point, we could consider opportunities for refactoring the
implementation of the search function while keeping the tests passing to
maintain the same functionality. The code in the search function isn’t too bad,
but it doesn’t take advantage of some useful features of iterators. We’ll
return to this example in [Chapter 13][ch13-iterators]<!-- ignore -- >, where we’ll
explore iterators in detail, and look at how to improve it.
-->
<p>Arrivé à ce stade, nous pourrions envisager des pistes de remaniement pour
l'implémentation de la fonction de recherche tout en faisant en sorte que les
tests réussissent toujours afin de conserver les mêmes fonctionnalités. Le code
de la fonction de recherche n'est pas mauvais, mais il ne profite pas de
quelques fonctionnalités utiles des itérateurs. Nous retrouverons cet exemple dans
le <a href="ch13-02-iterators.html">chapitre 13</a><!-- ignore -->, dans lequel nous explorerons
les itérateurs en détail, et ainsi découvrir comment nous pourrions l'améliorer.</p>
<!--
#### Using the `search` Function in the `run` Function
-->
<h4 id="utiliser-la-fonction-rechercher-dans-la-fonction-run"><a class="header" href="#utiliser-la-fonction-rechercher-dans-la-fonction-run">Utiliser la fonction <code>rechercher</code> dans la fonction <code>run</code></a></h4>
<!--
Now that the `search` function is working and tested, we need to call `search`
from our `run` function. We need to pass the `config.query` value and the
`contents` that `run` reads from the file to the `search` function. Then `run`
will print each line returned from `search`:
-->
<p>Maintenant que la fonction <code>rechercher</code> fonctionne et est testée, nous devons
appeler <code>rechercher</code> dans notre fonction <code>run</code>. Nous devons passer à
<code>rechercher</code> la valeur de <code>config.recherche</code>  et le <code>contenu</code> que <code>run</code> obtient
en lisant le fichier. Ensuite, <code>run</code> devra afficher chaque ligne retournée par
<code>rechercher</code> :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub query: String,
#     pub filename: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("not enough arguments");
#         }
# 
#         let query = args[1].clone();
#         let filename = args[2].clone();
# 
#         Ok(Config { query, filename })
#     }
# }
# 
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    for line in search(&config.query, &contents) {
        println!("{}", line);
    }

    Ok(())
}
# 
# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
#     let mut results = Vec::new();
# 
#     for line in contents.lines() {
#         if line.contains(query) {
#             results.push(line);
#         }
#     }
# 
#     results
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn one_result() {
#         let query = "duct";
#         let contents = "\
# Rust:
# safe, fast, productive.
# Pick three.";
# 
#         assert_eq!(vec!["safe, fast, productive."], search(query, contents));
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contenu = fs::read_to_string(config.nom_fichier)?;

    for ligne in rechercher(&amp;config.recherche, &amp;contenu) {
        println!(&quot;{}&quot;, ligne);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sécurité, rapidité, productivité.
</span><span class="boring">Obtenez les trois en même temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sécurité, rapidité, productivité.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
We’re still using a `for` loop to return each line from `search` and print it.
-->
<p>Nous utilisons ici aussi une boucle <code>for</code> pour récupérer chaque ligne provenant
de <code>rechercher</code> et l'afficher.</p>
<!--
Now the entire program should work! Let’s try it out, first with a word that
should return exactly one line from the Emily Dickinson poem, “frog”:
-->
<p>Maintenant, l'intégralité du programme devrait fonctionner ! Essayons-le, pour
commencer avec un mot qui devrait retourner exactement une seule ligne du poème
d'Emily Dickinson, “frog” :</p>
<!--
```console
$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
```
-->
<pre><code class="language-console">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<!--
Cool! Now let’s try a word that will match multiple lines, like “body”:
-->
<p>Super ! Maintenant, essayons un mot qui devrait retourner plusieurs lignes,
comme “body” :</p>
<!--
```console
$ cargo run body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
```
-->
<pre><code class="language-console">$ cargo run body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<!--
And finally, let’s make sure that we don’t get any lines when we search for a
word that isn’t anywhere in the poem, such as “monomorphization”:
-->
<p>Et enfin, assurons-nous que nous n'obtenons aucune ligne lorsque nous cherchons
un mot qui n'est nulle part dans le poème, comme “monomorphization” :</p>
<!--
```console
$ cargo run monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
```
-->
<pre><code class="language-console">$ cargo run monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<!--
Excellent! We’ve built our own mini version of a classic tool and learned a lot
about how to structure applications. We’ve also learned a bit about file input
and output, lifetimes, testing, and command line parsing.
-->
<p>Très bien ! Nous avons construit notre propre mini-version d'un outil classique
et nous avons beaucoup appris à structurer nos applications. Nous avons aussi
appris un peu sur les entrées et sorties des fichiers, les durées de vie, les
tests, et l'interprétation de la ligne de commande.</p>
<!--
To round out this project, we’ll briefly demonstrate how to work with
environment variables and how to print to standard error, both of which are
useful when you’re writing command line programs.
-->
<p>Pour clôturer ce projet, nous allons brièvement voir comment travailler avec les
variables d'environnement et comment écrire sur la sortie standard des erreurs,
qui sont tous les deux utiles lorsque vous écrivez des programmes en ligne de
commande.</p>
<!--
[validating-references-with-lifetimes]:
ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
[ch11-anatomy]: ch11-01-writing-tests.html#the-anatomy-of-a-test-function
[ch10-lifetimes]: ch10-03-lifetime-syntax.html
[ch3-iter]: ch03-05-control-flow.html#looping-through-a-collection-with-for
[ch13-iterators]: ch13-02-iterators.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Working with Environment Variables
-->
<h2 id="travailler-avec-des-variables-denvironnement"><a class="header" href="#travailler-avec-des-variables-denvironnement">Travailler avec des variables d'environnement</a></h2>
<!--
We’ll improve `minigrep` by adding an extra feature: an option for
case-insensitive searching that the user can turn on via an environment
variable. We could make this feature a command line option and require that
users enter it each time they want it to apply, but instead we’ll use an
environment variable. Doing so allows our users to set the environment variable
once and have all their searches be case insensitive in that terminal session.
-->
<p>Nous allons améliorer <code>minigrep</code> en lui ajoutant une fonctionnalité
supplémentaire : une option pour rechercher sans être sensible à la casse que
l'utilisateur pourra activer via une variable d'environnement. Nous pourrions
appliquer cette fonctionnalité avec une option en ligne de commande et demander
à l'utilisateur de la renseigner à chaque fois qu'il veut l'activer, mais à la
place nous allons utiliser une variable d'environnement. Ceci permet à nos
utilisateurs de régler la variable d'environnement une seule fois et d'avoir
leurs recherches insensibles à la casse dans cette session du terminal.</p>
<!--
### Writing a Failing Test for the Case-Insensitive `search` Function
-->
<h3 id="ecrire-un-test-qui-échoue-pour-la-fonction-rechercher-insensible-à-la-casse"><a class="header" href="#ecrire-un-test-qui-échoue-pour-la-fonction-rechercher-insensible-à-la-casse">Ecrire un test qui échoue pour la fonction <code>rechercher</code> insensible à la casse</a></h3>
<!--
We want to add a new `search_case_insensitive` function that we’ll call when
the environment variable is on. We’ll continue to follow the TDD process, so
the first step is again to write a failing test. We’ll add a new test for the
new `search_case_insensitive` function and rename our old test from
`one_result` to `case_sensitive` to clarify the differences between the two
tests, as shown in Listing 12-20.
-->
<p>Nous souhaitons ajouter une nouvelle fonction <code>rechercher_insensible_casse</code> que
nous allons appeler lorsque la variable d'environnement est active. Nous allons
continuer à suivre le processus de TDD, donc la première étape est d'écrire à
nouveau un test qui échoue. Nous allons ajouter un nouveau test pour la nouvelle
fonction <code>rechercher_insensible_casse</code> et renommer notre ancien test
<code>one_result</code> en <code>sensible_casse</code> pour clarifier les différences entre les deux
tests, comme dans l'encart 12-20.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         Ok(Config { recherche, nom_fichier })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     for ligne in rechercher(&config.recherche, &contenu) {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn sensible_casse() {
        let recherche = "duct";
        let contenu = "\
Rust:
sécurité, rapidité, productivité.
Obtenez les trois en même temps.
Duck tape.";

        assert_eq!(vec!["sécurité, rapidité, productivité."], rechercher(recherche, contenu));
    }

    #[test]
    fn insensible_casse() {
        let recherche = "rUsT";
        let contenu = "\
Rust:
sécurité, rapidité, productivité.
Obtenez les trois en même temps.
C'est pas rustique.";

        assert_eq!(
            vec!["Rust:", "C'est pas rustique."],
            rechercher_insensible_casse(recherche, contenu)
        );
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    for ligne in rechercher(&amp;config.recherche, &amp;contenu) {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn sensible_casse() {
        let recherche = &quot;duct&quot;;
        let contenu = &quot;\
Rust:
sécurité, rapidité, productivité.
Obtenez les trois en même temps.
Duck tape.&quot;;

        assert_eq!(vec![&quot;sécurité, rapidité, productivité.&quot;], rechercher(recherche, contenu));
    }

    #[test]
    fn insensible_casse() {
        let recherche = &quot;rUsT&quot;;
        let contenu = &quot;\
Rust:
sécurité, rapidité, productivité.
Obtenez les trois en même temps.
C'est pas rustique.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;C'est pas rustique.&quot;],
            rechercher_insensible_casse(recherche, contenu)
        );
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-20: Adding a new failing test for the
case-insensitive function we’re about to add</span>
-->
<p><span class="caption">Encart 12-20 : Ajout d'un nouveau test qui échoue pour la
fonction insensible à la casse que nous sommes en train d'ajouter</span></p>
<!--
Note that we’ve edited the old test’s `contents` too. We’ve added a new line
with the text `"Duct tape."` using a capital D that shouldn’t match the query
`"duct"` when we’re searching in a case-sensitive manner. Changing the old test
in this way helps ensure that we don’t accidentally break the case-sensitive
search functionality that we’ve already implemented. This test should pass now
and should continue to pass as we work on the case-insensitive search.
-->
<p>Remarquez que nous avons aussi modifié le <code>contenu</code> de l'ancien test.
Nous avons ajouté une nouvelle ligne avec le texte <code>&quot;Duct tape.&quot;</code> en utilisant
un D majuscule qui ne devrait pas correspondre à la recherche <code>&quot;duct&quot;</code> lorsque
nous recherchons de manière à être sensible à la casse. Ce changement de
l'ancien test permet de nous assurer que nous ne casserons pas accidentellement
la fonction de recherche sensible à la casse que nous avons déjà implémenté. Ce
test devrait toujours continuer à réussir au fur et à mesure que nous progressons
sur la recherche insensible à la casse.</p>
<!--
The new test for the case-*insensitive* search uses `"rUsT"` as its query. In
the `search_case_insensitive` function we’re about to add, the query `"rUsT"`
should match the line containing `"Rust:"` with a capital R and match the line
`"Trust me."` even though both have different casing from the query. This is
our failing test, and it will fail to compile because we haven’t yet defined
the `search_case_insensitive` function. Feel free to add a skeleton
implementation that always returns an empty vector, similar to the way we did
for the `search` function in Listing 12-16 to see the test compile and fail.
-->
<p>Le nouveau test pour la recherche insensible à la casse utilise <code>&quot;rUsT&quot;</code> comme
recherche. Dans la fonction <code>rechercher_insensible_casse</code> que nous sommes en
train d'ajouter, la recherche <code>&quot;rUsT&quot;</code> devrait correspondre à la ligne qui
contient <code>&quot;Rust:&quot;</code> avec un R majuscule ainsi que la ligne <code>C'est pas rustique.</code>
même si ces deux cas ont des casses différentes de la recherche. C'est notre
test qui doit échouer, et il ne devrait pas se compiler car nous n'avons pas
encore défini la fonction <code>rechercher_insensible_casse</code>. Ajoutez son
implémentation qui retourne toujours un vecteur vide, de la même manière que
nous l'avions fait pour la fonction <code>rechercher</code> dans l'encart 12-16 pour voir
si les tests se compilent et échouent.</p>
<!--
### Implementing the `search_case_insensitive` Function
-->
<h3 id="implémenter-la-fonction-rechercher_insensible_casse"><a class="header" href="#implémenter-la-fonction-rechercher_insensible_casse">Implémenter la fonction <code>rechercher_insensible_casse</code></a></h3>
<!--
The `search_case_insensitive` function, shown in Listing 12-21, will be almost
the same as the `search` function. The only difference is that we’ll lowercase
the `query` and each `line` so whatever the case of the input arguments,
they’ll be the same case when we check whether the line contains the query.
-->
<p>La fonction <code>rechercher_insensible_casse</code>, présente dans l'encart 12-21, sera
presque la même que la fonction <code>rechercher</code>. La seule différence est que nous
allons transformer en minuscule le contenu de <code>recherche</code> et de chaque <code>ligne</code>
pour que quel que soit la casse des arguments d'entrée, nous aurons toujours la
même casse lorsque nous vérifierons si la ligne contient la recherche.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         Ok(Config { recherche, nom_fichier })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     for ligne in rechercher(&config.recherche, &contenu) {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
pub fn rechercher_insensible_casse<'a>(
    recherche: &str,
    contenu: &'a str
) -> Vec<&'a str> {
    let recherche = recherche.to_lowercase();
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.to_lowercase().contains(&recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# sécurité, rapidité, productivité.
# Obtenez les trois en même temps.
# Duck tape.";
# 
#         assert_eq!(vec!["sécurité, rapidité, productivité."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn insensible_casse() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# sécurité, rapidité, productivité.
# Obtenez les trois en même temps.
# C'est pas rustique.";
# 
#         assert_eq!(
#             vec!["Rust:", "C'est pas rustique."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    for ligne in rechercher(&amp;config.recherche, &amp;contenu) {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher_insensible_casse&lt;'a&gt;(
    recherche: &amp;str,
    contenu: &amp;'a str
) -&gt; Vec&lt;&amp;'a str&gt; {
    let recherche = recherche.to_lowercase();
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.to_lowercase().contains(&amp;recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sécurité, rapidité, productivité.
</span><span class="boring">Obtenez les trois en même temps.
</span><span class="boring">Duck tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sécurité, rapidité, productivité.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn insensible_casse() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sécurité, rapidité, productivité.
</span><span class="boring">Obtenez les trois en même temps.
</span><span class="boring">C'est pas rustique.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;C'est pas rustique.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-21: Defining the `search_case_insensitive`
function to lowercase the query and the line before comparing them</span>
-->
<p><span class="caption">Encart 12-21 : Définition de la fonction
<code>rechercher_insensible_casse</code> pour obtenir en minuscule la recherche et la
ligne avant de les comparer</span></p>
<!--
First, we lowercase the `query` string and store it in a shadowed variable with
the same name. Calling `to_lowercase` on the query is necessary so no matter
whether the user’s query is `"rust"`, `"RUST"`, `"Rust"`, or `"rUsT"`, we’ll
treat the query as if it were `"rust"` and be insensitive to the case. While
`to_lowercase` will handle basic Unicode, it won’t be 100% accurate. If we were
writing a real application, we’d want to do a bit more work here, but this section
is about environment variables, not Unicode, so we’ll leave it at that here.
-->
<p>D'abord, nous obtenons la chaîne de caractères <code>recherche</code> en minuscule et nous
l'enregistrons dans une variable masquée avec le même nom. L'appel à
<code>to_lowercase</code> sur la recherche est nécessaire afin que quel que soit la
recherche de l'utilisateur, comme <code>&quot;rust&quot;</code>, <code>&quot;RUST&quot;</code>, <code>&quot;Rust&quot;</code>, ou <code>&quot;rUsT&quot;</code>,
nous traitons la recherche comme si elle était <code>&quot;rust&quot;</code> et par conséquent elle
est insensible à la casse. La méthode <code>to_lowercase</code> devrait gérer de l'Unicode
de base, mais ne sera pas fiable à 100%. Si nous avions écris une application
sérieuse, nous aurions dû faire plus de choses à ce propos, toutefois la section
actuelle traite des variables d'environnement et non pas de la gestion de
l'Unicode, donc nous allons conserver ce code simplifié.</p>
<!--
Note that `query` is now a `String` rather than a string slice, because calling
`to_lowercase` creates new data rather than referencing existing data. Say the
query is `"rUsT"`, as an example: that string slice doesn’t contain a lowercase
`u` or `t` for us to use, so we have to allocate a new `String` containing
`"rust"`. When we pass `query` as an argument to the `contains` method now, we
need to add an ampersand because the signature of `contains` is defined to take
a string slice.
-->
<p>Notez que <code>recherche</code> est désormais une <code>String</code> et non plus une slice de chaîne
de caractères, car l'appel à <code>to_lowercase</code> crée des nouvelles données au lieu
de modifier les données déjà existantes. Par exemple, disons que la recherche
est <code>&quot;rUsT&quot;</code> : cette slice de chaîne de caractères ne contient pas de <code>u</code> ou de
<code>t</code> minuscule que nous pourrions utiliser, donc nous devons allouer une nouvelle
<code>String</code> qui contient <code>&quot;rust&quot;</code>. Maintenant, lorsque nous passons <code>recherche</code> en
argument de la méthode <code>contains</code>, nous devons rajouter une esperluette car la
signature de <code>contains</code> est définie pour prendre une slice de chaîne de
caractères.</p>
<!--
Next, we add a call to `to_lowercase` on each `line` before we check whether it
contains `query` to lowercase all characters. Now that we’ve converted `line`
and `query` to lowercase, we’ll find matches no matter what the case of the
query is.
-->
<p>Ensuite, nous ajoutons un appel à <code>to_lowercase</code> sur chaque <code>ligne</code> avant de
vérifier si elle contient <code>recherche</code> afin d'obtenir tous ses caractères en
minuscule. Maintenant que nous avons <code>ligne</code> et <code>recherche</code> en minuscule, nous
allons rechercher les correspondances peu importe la casse de la recherche.</p>
<!--
Let’s see if this implementation passes the tests:
-->
<p>Voyons si cette implémentation passe les tests :</p>
<!--
```console
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::sensible_casse ... ok
test tests::insensible_casse ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

```
-->
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::sensible_casse ... ok
test tests::insensible_casse ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<!--
Great! They passed. Now, let’s call the new `search_case_insensitive` function
from the `run` function. First, we’ll add a configuration option to the
`Config` struct to switch between case-sensitive and case-insensitive search.
Adding this field will cause compiler errors because we aren’t initializing
this field anywhere yet:
-->
<p>Très bien ! Elles ont réussi. Maintenant, utilisons la nouvelle fonction
<code>rechercher_insensible_casse</code> dans la fonction <code>run</code>. Pour commencer, nous
allons ajouter une option de configuration à la structure <code>Config</code> pour changer
entre la recherche sensible et non-sensible à la casse. L'ajout de ce champ va
causer des erreurs de compilation car nous n'avons jamais initialisé ce champ
pour le moment :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
pub struct Config {
    pub recherche: String,
    pub nom_fichier: String,
    pub sensible_casse: bool,
}
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         Ok(Config { recherche, nom_fichier })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub recherche: String,
    pub nom_fichier: String,
    pub sensible_casse: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Note that we added the `case_sensitive` field that holds a Boolean. Next, we
need the `run` function to check the `case_sensitive` field’s value and use
that to decide whether to call the `search` function or the
`search_case_insensitive` function, as shown in Listing 12-22. Note this still
won’t compile yet.
-->
<p>Remarquez que le champ <code>sensible_casse</code> que nous avons ajouté est un Booléen.
Ensuite, nous devons faire en sorte que la fonction <code>run</code> vérifie la valeur du
champ <code>sensible_casse</code> et l'utilise pour décider si elle doit appeler la
fonction <code>rechercher</code> ou la fonction <code>rechercher_insensible_casse</code>, comme dans
l'encart 12-22. Notez que cela ne se compile pas encore.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         Ok(Config { recherche, nom_fichier })
#     }
# }
# 
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contenu = fs::read_to_string(config.nom_fichier)?;

    let resultats = if config.sensible_casse {
        rechercher(&config.recherche, &contenu)
    } else {
        rechercher_insensible_casse(&config.recherche, &contenu)
    };

    for ligne in resultats {
        println!("{}", ligne);
    }

    Ok(())
}
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contenu = fs::read_to_string(config.nom_fichier)?;

    let resultats = if config.sensible_casse {
        rechercher(&amp;config.recherche, &amp;contenu)
    } else {
        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
    };

    for ligne in resultats {
        println!(&quot;{}&quot;, ligne);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-22: Calling either `search` or
`search_case_insensitive` based on the value in `config.case_sensitive`</span>
-->
<p><span class="caption">Encart 12-22 : Appeler <code>rechercher</code> ou
<code>rechercher_insensible_casse</code> en fonction de la valeur dans <code>config.sensible_casse</code>
</span></p>
<!--
Finally, we need to check for the environment variable. The functions for
working with environment variables are in the `env` module in the standard
library, so we want to bring that module into scope with a `use std::env;` line
at the top of *src/lib.rs*. Then we’ll use the `var` function from the `env`
module to check for an environment variable named `CASE_INSENSITIVE`, as shown
in Listing 12-23.
-->
<p>Enfin, nous devons vérifier la variable d'environnement. Les fonctions pour
travailler avec les variables d'environnement sont dans le module <code>env</code> de la
bibliothèque standard, donc nous allons importer ce module dans la portée avec
une ligne <code>use std::env;</code> en haut de <em>src/lib.rs</em>. Ensuite, nous allons utiliser
la fonction <code>var</code> du module <code>env</code> pour vérifier la présence d'une variable
d'environnement <code>MINIGREP_INSENSIBLE_CASSE</code>, comme dans l'encart 12-23.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
use std::env;
// -- partie masquée ici --

# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
impl Config {
    pub fn new(args: &[String]) -> Result<Config, &str> {
        if args.len() < 3 {
            return Err("il n'y a pas assez d'arguments");
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust noplayground">use std::env;
// -- partie masquée ici --

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;il n'y a pas assez d'arguments&quot;);
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 12-23: Checking for an environment variable named
`CASE_INSENSITIVE`</span>
-->
<p><span class="caption">Encart 12-23 : Vérification de la présence de la variable
d'environnement <code>MINIGREP_INSENSIBLE_CASSE</code></span></p>
<!--
Here, we create a new variable `case_sensitive`. To set its value, we call the
`env::var` function and pass it the name of the `CASE_INSENSITIVE` environment
variable. The `env::var` function returns a `Result` that will be the successful
`Ok` variant that contains the value of the environment variable if the
environment variable is set. It will return the `Err` variant if the
environment variable is not set.
-->
<p>Ici, nous créons une nouvelle variable <code>sensible_casse</code>. Pour lui donner une
valeur, nous appelons la fonction <code>env::var</code> et nous lui passons le nom de la
variable d'environnement <code>MINIGREP_INSENSIBLE_CASSE</code>. La fonction <code>env::var</code>
retourne un <code>Result</code> qui sera en cas de succès la variante <code>Ok</code> qui contiendra
la valeur de la variable d'environnement si cette variable d'environnement est
définie. Elle retournera la variante <code>Err</code> si cette variable d'environnement
n'est pas définie.</p>
<!--
We’re using the `is_err` method on the `Result` to check whether it’s an error
and therefore unset, which means it *should* do a case-sensitive search. If the
`CASE_INSENSITIVE` environment variable is set to anything, `is_err` will
return false and the program will perform a case-insensitive search. We don’t
care about the *value* of the environment variable, just whether it’s set or
unset, so we’re checking `is_err` rather than using `unwrap`, `expect`, or any
of the other methods we’ve seen on `Result`.
-->
<p>Nous utilisons la méthode <code>is_err</code> sur le <code>Result</code> pour vérifier si c'est une
erreur et donc par conséquent non définie, ce qui veut dire que nous <em>devons</em>
effectuer une recherche sensible à la casse. Si la variable d'environnement
<code>MINIGREP_INSENSIBLE_CASSE</code> a une valeur qui lui a été assignée, <code>is_err</code> va
retourner <code>false</code> et le programme va procéder à une recherche non sensible à
la casse. Nous ne préoccupons pas de la <em>valeur</em> de la variable d'environnement,
mais uniquement de savoir si elle est définie ou non, donc nous utilisons
<code>is_err</code> plutôt que <code>unwrap</code>, <code>expect</code>, ou toute autre méthode que nous avons
vu pour <code>Result</code>.</p>
<!--
We pass the value in the `case_sensitive` variable to the `Config` instance so
the `run` function can read that value and decide whether to call `search` or
`search_case_insensitive`, as we implemented in Listing 12-22.
-->
<p>Nous passons la valeur de la variable <code>sensible_casse</code> à l'instance de <code>Config</code>
afin que la fonction <code>run</code> puisse lire cette valeur et décider d'appeler
<code>rechercher</code> ou <code>rechercher_insensible_casse</code>, comme nous l'avons implémenté
dans l'encart 12-22.</p>
<!--
Let’s give it a try! First, we’ll run our program without the environment
variable set and with the query `to`, which should match any line that contains
the word “to” in all lowercase:
-->
<p>Faisons un essai ! D'abord, nous allons lancer notre programme avec la variable
d'environnement non définie et avec la recherche <code>to</code>, qui devrait trouver
toutes les lignes qui contiennent le mot “to” en minuscule :</p>
<!--
```console
$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
```
-->
<pre><code class="language-console">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<!--
Looks like that still works! Now, let’s run the program with `CASE_INSENSITIVE`
set to `1` but with the same query `to`.
-->
<p>On dirait que cela fonctionne ! Maintenant, lançons le programme avec
<code>MINIGREP_INSENSIBLE_CASSE</code> définie à <code>1</code> mais avec la même recherche <code>to</code>.</p>
<!--
If you’re using PowerShell, you will need to set the environment
variable and run the program as separate commands:
-->
<p>Si vous utilisez PowerShell, vous allez avoir besoin d'affecter la variable
d'environnement puis exécuter le programme avec deux commande séparées :</p>
<!--
```console
PS> $Env:CASE_INSENSITIVE=1; cargo run to poem.txt
```
-->
<pre><code class="language-console">PS&gt; $Env:MINIGREP_INSENSIBLE_CASSE=1; cargo run to poem.txt
</code></pre>
<!--
This will make `CASE_INSENSITIVE` persist for the remainder of your shell
session. It can be unset with the `Remove-Item` cmdlet:
-->
<p>Cela va faire persister la variable <code>MINIGREP_INSENSIBLE_CASSE</code> pour la durée de
votre session de terminal. Elle peut être désaffectée avec la cmdlet
<code>Remove-Item</code> :</p>
<!--
```console
PS> Remove-Item Env:CASE_INSENSITIVE
```
-->
<pre><code class="language-console">PS&gt; Remove-Item Env:MINIGREP_INSENSIBLE_CASSE
</code></pre>
<!--
We should get lines that contain “to” that might have uppercase letters:
-->
<p>Nous devrions trouver les lignes qui contiennent “to” qui ont des lettres
majuscules :</p>
<!--
<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
CASE_INSENSITIVE=1 cargo run to poem.txt
can't extract because of the environment variable
-- >
-->
<!--
```console
$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
```
-->
<pre><code class="language-text">$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<!--
Excellent, we also got lines containing “To”! Our `minigrep` program can now do
case-insensitive searching controlled by an environment variable. Now you know
how to manage options set using either command line arguments or environment
variables.
-->
<p>Très bien, nous avons aussi obtenu les lignes qui contiennent “To” ! Notre
programme <code>minigrep</code> peut maintenant faire des recherches insensibles à la
casse, contrôlées par une variable d'environnement. Vous savez maintenant comment
gérer des options définies soit par des arguments en ligne de commande, soit
par des variables d'environnement.</p>
<!--
Some programs allow arguments *and* environment variables for the same
configuration. In those cases, the programs decide that one or the other takes
precedence. For another exercise on your own, try controlling case
insensitivity through either a command line argument or an environment
variable. Decide whether the command line argument or the environment variable
should take precedence if the program is run with one set to case sensitive and
one set to case insensitive.
-->
<p>Certains programmes permettent d'utiliser les arguments <em>et</em> les variables
d'environnement pour un même réglage. Dans ce cas, le programme décide si l'un
ou l'autre a la priorité. Pour vous exercer à nouveau, essayez de contrôler la
sensibilité à la casse via un argument de ligne de commande ou une variable
d'environnement. Vous devrez choisir si l'argument de la ligne de commande ou
la variable d'environnement devrait être prioritaire si le programme est exécuté
avec l'option réglée dans un cas pour être sensible à la casse et être
insensible à la casse dans l'autre cas simultanément.</p>
<!--
The `std::env` module contains many more useful features for dealing with
environment variables: check out its documentation to see what is available.
-->
<p>Le module <code>std::env</code> contient plein d'autres fonctionnalitées utiles pour
utiliser les variables d'environnement : regardez sa documentation pour voir ce
qu'il est possible de faire.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Writing Error Messages to Standard Error Instead of Standard Output
-->
<h2 id="ecrire-les-messages-derreur-sur-la-sortie-derreurs-standard-au-lieu-de-la-sortie-normale"><a class="header" href="#ecrire-les-messages-derreur-sur-la-sortie-derreurs-standard-au-lieu-de-la-sortie-normale">Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></h2>
<!--
At the moment, we’re writing all of our output to the terminal using the
`println!` macro. Most terminals provide two kinds of output: *standard
output* (`stdout`) for general information and *standard error* (`stderr`)
for error messages. This distinction enables users to choose to direct the
successful output of a program to a file but still print error messages to the
screen.
-->
<p>Pour l'instant, nous avons écrit toutes nos sorties du terminal en utilisant
la macro <code>println!</code>. La plupart des terminaux fournissent deux genres de
sorties : la <em>sortie standard</em> (<code>stdout</code>) pour les informations générales
et <em>la sortie d'erreur standard</em> (<code>stderr</code>) pour les messages d'erreur. Cette
distinction permet à l'utilisateur de choisir de rediriger la sortie des
réussites d'un programme vers un fichier mais continuer à afficher les messages
d'erreur à l'écran.</p>
<!--
The `println!` macro is only capable of printing to standard output, so we
have to use something else to print to standard error.
-->
<p>La macro <code>println!</code> ne peut écrire que sur la sortie standard, donc nous
devons utiliser autre chose pour écrire sur la sortie d'erreur standard.</p>
<!--
### Checking Where Errors Are Written
-->
<h3 id="vérifier-où-sont-écris-les-erreurs"><a class="header" href="#vérifier-où-sont-écris-les-erreurs">Vérifier où sont écris les erreurs</a></h3>
<!--
First, let’s observe how the content printed by `minigrep` is currently being
written to standard output, including any error messages we want to write to
standard error instead. We’ll do that by redirecting the standard output stream
to a file while also intentionally causing an error. We won’t redirect the
standard error stream, so any content sent to standard error will continue to
display on the screen.
-->
<p>Commençons par observer comment le contenu écris par <code>minigrep</code> est actuellement
écris sur la sortie standard, y compris les messages d'erreur que nous
souhaitons plutôt écrire sur la sortie d'erreur standard. Nous allons faire cela
en redirigeant le flux de sortie standard vers un fichier pendant que nous
déclencherons intentionnellement une erreur. Nous ne redirigerons pas le flux
de sortie d'erreur standard, donc n'importe quel contenu envoyé à la sortie
d'erreur standard va continuer à s'afficher à l'écran.</p>
<!--
Command line programs are expected to send error messages to the standard error
stream so we can still see error messages on the screen even if we redirect the
standard output stream to a file. Our program is not currently well-behaved:
we’re about to see that it saves the error message output to a file instead!
-->
<p>Les programmes en ligne de commande sont censés envoyer leurs messages d'erreur
dans le flux d'erreurs standard afin que nous puissions continuer à voir les
messages d'erreurs à l'écran même si nous redirigeons le flux de la sortie
standard dans un fichier. Notre programme ne se comporte pas comme il le
devrait : nous allons voir qu'à la place, il envoie les messages d'erreur
dans le fichier !</p>
<!--
The way to demonstrate this behavior is by running the program with `>` and the
filename, *output.txt*, that we want to redirect the standard output stream to.
We won’t pass any arguments, which should cause an error:
-->
<p>Pour démontrer ce comportement, il faut exécuter le programme avec <code>&gt;</code> suivi du
nom du fichier, <em>sortie.txt</em>, dans lequel nous souhaitons rediriger le flux de
sortie standard. Nous ne fournissons aucun argument, ce qui va causer une
erreur :</p>
<!--
```console
$ cargo run > output.txt
```
-->
<pre><code class="language-console">$ cargo run &gt; sortie.txt
</code></pre>
<!--
The `>` syntax tells the shell to write the contents of standard output to
*output.txt* instead of the screen. We didn’t see the error message we were
expecting printed to the screen, so that means it must have ended up in the
file. This is what *output.txt* contains:
-->
<p>La syntaxe indique à l'invite de commande d'écrire le contenu de la sortie
standard dans <em>sortie.txt</em> plutôt qu'à l'écran. Nous n'avons pas vu le
message d'erreur que nous nous attendions de voir à l'écran, ce qui veut
dire qu'il a dû finir dans le fichier. Voici ce que <em>sortie.txt</em> contient :</p>
<!--
```text
Problem parsing arguments: not enough arguments
```
-->
<pre><code class="language-text">Problème rencontré lors de l'interprétation des arguments : il n'y a pas assez d'arguments
</code></pre>
<!--
Yup, our error message is being printed to standard output. It’s much more
useful for error messages like this to be printed to standard error so only
data from a successful run ends up in the file. We’ll change that.
-->
<p>Effectivement, notre message d'erreur est écris sur la sortie standard. Il
est bien plus utile que les messages d'erreur comme celui-ci soient écris
dans la sortie d'erreur standard afin qu'uniquement les données d'une
exécution fructueuse finissent dans le fichier. Nous allons corriger cela.</p>
<!--
### Printing Errors to Standard Error
-->
<h3 id="ecrire-les-erreurs-sur-la-sortie-derreur-standard"><a class="header" href="#ecrire-les-erreurs-sur-la-sortie-derreur-standard">Ecrire les erreurs sur la sortie d'erreur standard</a></h3>
<!--
We’ll use the code in Listing 12-24 to change how error messages are printed.
Because of the refactoring we did earlier in this chapter, all the code that
prints error messages is in one function, `main`. The standard library provides
the `eprintln!` macro that prints to the standard error stream, so let’s change
the two places we were calling `println!` to print errors to use `eprintln!`
instead.
-->
<p>Nous allons utiliser le code de l'encart 12-24 pour changer la manière dont les
messages d'erreur sont écris. Grâce au remaniement que nous avons fait plus tôt
dans ce chapitre, tout le code qui écris les messages d'erreurs se trouve dans
une seule fonction, <code>main</code>. La bibliothèque standard fournit la macro
<code>eprintln!</code> qui écris dans le flux d'erreur standard, donc changeons les deux
endroits où nous appelons <code>println!</code> afin d'utiliser <code>eprintln!</code> à la place.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::process;
# 
# use minigrep::Config;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        eprintln!("Problème rencontré lors de l'interprétation des arguments : {}", err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("Erreur applicative : {}", e);

        process::exit(1);
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problème rencontré lors de l'interprétation des arguments : {}&quot;, err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Erreur applicative : {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-24: Writing error messages to standard error
instead of standard output using `eprintln!`</span>
-->
<p><span class="caption">Encart 12-24 : Ecrire les messages d'erreur sur la sortie
d'erreur standard au lieu de la sortie standard en utilisant <code>eprintln!</code></span></p>
<!--
After changing `println!` to `eprintln!`, let’s run the program again in the
same way, without any arguments and redirecting standard output with `>`:
-->
<p>Après avoir changé <code>println!</code> en <code>eprintln!</code>, exécutons le programme à nouveau
de la même manière, sans aucun argument et en redirigeant la sortie standard
avec <code>&gt;</code> :</p>
<!--
```console
$ cargo run > output.txt
Problem parsing arguments: not enough arguments
```
-->
<pre><code class="language-console">$ cargo run &gt; sortie.txt
Problème rencontré lors de l'interprétation des arguments : il n'y a pas assez d'arguments
</code></pre>
<!--
Now we see the error onscreen and *output.txt* contains nothing, which is the
behavior we expect of command line programs.
-->
<p>Désormais nous pouvons voir l'erreur à l'écran et <em>sortie.txt</em> ne contient rien,
ce qui est le comportement de que nous attendons d'un programme en ligne de
commande.</p>
<!--
Let’s run the program again with arguments that don’t cause an error but still
redirect standard output to a file, like so:
-->
<p>Exécutons le programme à nouveau avec des arguments qui ne causent pas d'erreurs
mais nous continuons à rediriger la sortie standard, comme ceci :</p>
<!--
```console
$ cargo run to poem.txt > output.txt
```
-->
<pre><code class="language-console">$ cargo run to poem.txt &gt; sortie.txt
</code></pre>
<!--
We won’t see any output to the terminal, and *output.txt* will contain our
results:
-->
<p>Nous ne voyons rien sur la sortie du terminal, et <em>sortie.txt</em> devrait contenir
notre résultat :</p>
<!--
<span class="filename">Filename: output.txt</span>
-->
<p><span class="filename">Fichier : sortie.txt</span></p>
<!--
```text
Are you nobody, too?
How dreary to be somebody!
```
-->
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<!--
This demonstrates that we’re now using standard output for successful output
and standard error for error output as appropriate.
-->
<p>Ceci prouve que nous utilisons maintenant la sortie standard pour la sortie
réussie et l'erreur standard pour la sortie d'erreur, en fonction des
circonstances.</p>
<!--
## Summary
-->
<h2 id="résumé-11"><a class="header" href="#résumé-11">Résumé</a></h2>
<!--
This chapter recapped some of the major concepts you’ve learned so far and
covered how to perform common I/O operations in Rust. By using command line
arguments, files, environment variables, and the `eprintln!` macro for printing
errors, you’re now prepared to write command line applications. By using the
concepts in previous chapters, your code will be well organized, store data
effectively in the appropriate data structures, handle errors nicely, and be
well tested.
-->
<p>Ce chapitre a résumé certains des concepts majeurs que vous avez appris
précédemment et expliqué comment procéder à des opérations courantes sur les
entrées/sorties en Rust. En utilisant les arguments en ligne de commande, les
fichiers, les variables d'environnement, et la macro <code>eprintln!</code> pour écrire les
erreurs, vous pouvez désormais écrire des applications en ligne de commande. En
suivant les concepts vus dans les chapitres précédents, votre code restera bien
organisé, stockera les données dans les bonnes structures de données, gérera
correctement les erreurs, et sera correctement testé.</p>
<!--
Next, we’ll explore some Rust features that were influenced by functional
languages: closures and iterators.
-->
<p>Maintenant, nous allons découvrir quelques fonctionnalités de Rust qui ont été
influencées par les langages fonctionnels : les closures et les itérateurs.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Functional Language Features: Iterators and Closures
-->
<h1 id="les-fonctionnalités-des-langages-fonctionnels--les-itérateurs-et-les-fermetures"><a class="header" href="#les-fonctionnalités-des-langages-fonctionnels--les-itérateurs-et-les-fermetures">Les fonctionnalités des langages fonctionnels : les itérateurs et les fermetures</a></h1>
<!--
Rust’s design has taken inspiration from many existing languages and
techniques, and one significant influence is *functional programming*.
Programming in a functional style often includes using functions as values by
passing them in arguments, returning them from other functions, assigning them
to variables for later execution, and so forth.
-->
<p>La conception de Rust s'est inspirée de nombreux langages et technologies
existantes, et une de ses influences la plus marquante est la <em>programmation
fonctionnelle</em>. La programmation fonctionnelle consiste souvent à utiliser une
fonction comme une valeur en la passant en argument d'une autre fonction, la
retourner en résultat d'une autre fonction, l'assigner à une variable pour
l'exécuter plus tard, par exemple.</p>
<!--
In this chapter, we won’t debate the issue of what functional programming is or
isn’t but will instead discuss some features of Rust that are similar to
features in many languages often referred to as functional.
-->
<p>Dans ce chapitre, nous n'allons pas débattre sur ce qu'est ou non la
programmation fonctionnelle, mais nous allons plutôt voir quelques
fonctionnalités de Rust qui sont similaires à celles des autres langages souvent
considérés comme fonctionnels.</p>
<!--
More specifically, we’ll cover:
-->
<p>Plus précisément, nous allons voir :</p>
<!--
* *Closures*, a function-like construct you can store in a variable
* *Iterators*, a way of processing a series of elements
* How to use these two features to improve the I/O project in Chapter 12
* The performance of these two features (Spoiler alert: they’re faster than you
  might think!)
-->
<ul>
<li><em>les fermetures</em>, une construction qui ressemble à une fonction que vous
pouvez stocker dans une variable</li>
<li><em>les itérateurs</em>, une façon de travailler sur une série d'éléments</li>
<li>Comment utiliser ces deux fonctionnalités pour améliorer le projet
d'entrée/sortie du chapitre 12</li>
<li>Etudier la performance de ces deux fonctionnalités (divulgâchage : elles sont
probablement plus rapides que ce que vous pensez !)</li>
</ul>
<!--
Other Rust features, such as pattern matching and enums, which we’ve covered in
other chapters, are influenced by the functional style as well. Mastering
closures and iterators is an important part of writing idiomatic, fast Rust
code, so we’ll devote this entire chapter to them.
-->
<p>Les autres fonctionnalités de Rust, comme le filtrage par motif et les
énumérations que nous avons vu dans les chapitres précédents, sont influencés
par la programmation fonctionnelle. La maîtrise des fermetures et des itérateurs
est une étape importante pour écrire du code Rust performant, c'est pourquoi
nous allons leur dédier ce chapitre entier.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Closures: Anonymous Functions that Can Capture Their Environment
-->
<h2 id="les-fermetures--fonctions-anonymes-qui-peuvent-utiliser-leur-environnement"><a class="header" href="#les-fermetures--fonctions-anonymes-qui-peuvent-utiliser-leur-environnement">Les fermetures : fonctions anonymes qui peuvent utiliser leur environnement</a></h2>
<!--
Rust’s closures are anonymous functions you can save in a variable or pass as
arguments to other functions. You can create the closure in one place and then
call the closure to evaluate it in a different context. Unlike functions,
closures can capture values from the scope in which they’re defined. We’ll
demonstrate how these closure features allow for code reuse and behavior
customization.
-->
<p>Les fermetures en Rust sont des fonctions anonymes qui peuvent être sauvegardés
dans une variable ou qui peuvent être passées en argument à d'autres fonctions.
Il est possible de créer une fermeture à un endroit du code et ensuite de
l'appeler dans un contexte différent pour l'exécuter. Contrairement aux
fonctions, les fermetures ont la possibilité de capturer les valeurs présentes
dans le contexte où elles sont appelées. Nous allons montrer comment les
fonctionnalités des fermetures permettent de réutiliser du code et suivre des
comportements personnalisés.</p>
<!--
### Creating an Abstraction of Behavior with Closures
-->
<h3 id="créer-une-abstraction-de-comportement-avec-une-fermeture"><a class="header" href="#créer-une-abstraction-de-comportement-avec-une-fermeture">Créer une abstraction de comportement avec une fermeture</a></h3>
<!--
Let’s work on an example of a situation in which it’s useful to store a closure
to be executed later. Along the way, we’ll talk about the syntax of closures,
type inference, and traits.
-->
<p>Travaillons sur un exemple d'une situation où il est utile de stocker une
fermeture qui s'exécutera ultérieurement. Nous allons parler de la syntaxe des
fermetures, de l'inférence de type, et des traits au cours de ce chapitre.</p>
<!--
Consider this hypothetical situation: we work at a startup that’s making an app
to generate custom exercise workout plans. The backend is written in Rust, and
the algorithm that generates the workout plan takes into account many factors,
such as the app user’s age, body mass index, exercise preferences, recent
workouts, and an intensity number they specify. The actual algorithm used isn’t
important in this example; what’s important is that this calculation takes a
few seconds. We want to call this algorithm only when we need to and only call
it once so we don’t make the user wait more than necessary.
-->
<p>Imaginons la situation suivante : nous travaillons dans une <em>startup</em> qui créé
une application pour générer des plans d'entraînements physiques personnalisés.
L'application dorsale est écrite en Rust et l'algorithme qui génère les
exercices en fonction de beaucoup de facteurs comme l'âge de l'utilisateur, son
indice de masse corporelle, ses préférences et une intensité paramétrée par
l'utilisateur. L'algorithme réellement utilisé n'est pas important pour cet
exemple : ce qui est important c'est que le calcul prenne plusieurs secondes.
Nous voulons appeler l'algorithme uniquement lorsque nous avons besoin, et
seulement une fois, afin que l'utilisateur n'ai pas à attendre plus longtemps
que nécessaire.</p>
<!--
We’ll simulate calling this hypothetical algorithm with the function
`simulated_expensive_calculation` shown in Listing 13-1, which will print
`calculating slowly...`, wait for two seconds, and then return whatever number
we passed in.
-->
<p>Pour simuler l'appel à cet algorithme hypothétique, nous allons utiliser la
fonction <code>simuler_gros_calcul</code> présent dans l'encart 13-1, qui affichera
<code>calcul très lent ...</code>, attendra deux secondes, et ensuite retournera le nombre
qui lui a été donné :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -> u32 {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    intensity
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn simuler_gros_calcul(intensite: u32) -&gt; u32 {
    println!(&quot;calcul très lent ...&quot;);
    thread::sleep(Duration::from_secs(2));
    intensite
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-1: A function to stand in for a hypothetical
calculation that takes about 2 seconds to run</span>
-->
<p><span class="caption">Encart 13-1 : une fonction pour remplacer un calcul
hypothétique qui prend environ deux secondes à exécuter</span></p>
<!--
Next is the `main` function, which contains the parts of the workout app
important for this example. This function represents the code that the app will
call when a user asks for a workout plan. Because the interaction with the
app’s frontend isn’t relevant to the use of closures, we’ll hardcode values
representing inputs to our program and print the outputs.
-->
<p>Ensuite, nous avons la fonction <code>main</code> qui contient les parties importantes de
cet exemple d'application d'entraînement. Cette fonction représente le code que
l'application appellera lorsqu'un utilisateur demande un plan d'entraînement.
Comme l'interaction avec l'application dorsale n'est pas adapté à l'utilisation
des fermetures, nous allons coder en dur les valeurs représentant les entrées de
notre programme, puis afficher les résultats.</p>
<!--
The required inputs are these:
-->
<p>Les paramètres d'entrées nécessaires sont :</p>
<!--
* An intensity number from the user, which is specified when they request
  a workout to indicate whether they want a low-intensity workout or a
  high-intensity workout
* A random number that will generate some variety in the workout plans
-->
<ul>
<li><code>intensite</code> qui est un nombre saisi par utilisateur lorsqu'il demande un
entraînement, afin qu'ils puissent indiquer s'ils veulent un entraînement de
faible ou de haute intensité.</li>
<li>Un nombre aléatoire qui variera les plans d'entraînement</li>
</ul>
<!--
The output will be the recommended workout plan. Listing 13-2 shows the `main`
function we’ll use.
-->
<p>Le résultat sera le plan d'entraînement recommandé. L'encart 13-2 montre la
fonction <code>main</code> que nous allons utiliser.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# fn simulated_expensive_calculation(intensity: u32) -> u32 {
#     println!("calculating slowly...");
#     thread::sleep(Duration::from_secs(2));
#     intensity
# }
# 
# fn generate_workout(intensity: u32, random_number: u32) {}
# 
fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(simulated_user_specified_value, simulated_random_number);
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simuler_gros_calcul(intensite: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calcul très lent ...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    intensite
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {}
</span><span class="boring">
</span>fn main() {
    let valeur_utilisateur_simule = 10;
    let nombre_aleatoire_simule = 7;

    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
}
</code></pre></pre>
<!--
<span class="caption">Listing 13-2: A `main` function with hardcoded values to
simulate user input and random number generation</span>
-->
<p><span class="caption">Encart 13-2 : une fonction <code>main</code> avec des valeurs codées
en dur pour simuler l'entrée d'un utilisateur et la génération de nombres
aléatoires</span></p>
<!--
We’ve hardcoded the variable `simulated_user_specified_value` as 10 and the
variable `simulated_random_number` as 7 for simplicity’s sake; in an actual
program, we’d get the intensity number from the app frontend, and we’d use the
`rand` crate to generate a random number, as we did in the Guessing Game
example in Chapter 2. The `main` function calls a `generate_workout` function
with the simulated input values.
-->
<p>Nous avons codé en dur la variable <code>valeur_utilisateur_simule</code> à 10 et la
variable <code>nombre_aleatoire_simule</code> à 7 pour des raisons de simplicité ; dans un
vrai programme nous obtiendrions le nombre d'intensité à partir de l'application
frontale et nous utiliserions la crate <code>rand</code> pour générer un nombre aléatoire,
comme nous l'avons fait dans l'exemple du jeu du plus ou du moins dans le
chapitre 2. La fonction <code>main</code> appelle une fonction <code>generer_exercices</code> avec les
valeurs d'entrée simulées.</p>
<!--
Now that we have the context, let’s get to the algorithm. The function
`generate_workout` in Listing 13-3 contains the business logic of the
app that we’re most concerned with in this example. The rest of the code
changes in this example will be made to this function.
-->
<p>Maintenant que nous avons le contexte, passons à l'algorithme. La fonction
<code>generer_exercices</code> dans l'encart 13-3 contient la logique métier de
l'application qui nous préoccupe le plus dans cet exemple. Le reste des
changements de code dans cet exemple sera appliqué à cette fonction :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# fn simulated_expensive_calculation(intensity: u32) -> u32 {
#     println!("calculating slowly...");
#     thread::sleep(Duration::from_secs(2));
#     intensity
# }
# 
fn generate_workout(intensity: u32, random_number: u32) {
    if intensity < 25 {
        println!(
            "Today, do {} pushups!",
            simulated_expensive_calculation(intensity)
        );
        println!(
            "Next, do {} situps!",
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simuler_gros_calcul(intensite: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calcul très lent ...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    intensite
</span><span class="boring">}
</span><span class="boring">
</span>fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
    if intensite &lt; 25 {
        println!(
            &quot;Aujourd'hui, faire {} pompes !&quot;,
            simuler_gros_calcul(intensite)
        );
        println!(
            &quot;Ensuite, faire {} abdominaux !&quot;,
            simuler_gros_calcul(intensite)
        );
    } else {
        if nombre_aleatoire == 3 {
            println!(&quot;Faites une pause aujourd'hui ! Rappelez-vous de bien vous hydrater !&quot;);
        } else {
            println!(
                &quot;Aujourd'hui, courrez pendant {} minutes !&quot;,
                simuler_gros_calcul(intensite)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-3: The business logic that prints the workout
plans based on the inputs and calls to the `simulated_expensive_calculation`
function</span>
-->
<p><span class="caption">Encart 13-3 : la logique métier qui affiche les plans
d'entraînement en fonction des entrées et des appels à la fonction
<code>simuler_gros_calcul</code>.</span></p>
<!--
The code in Listing 13-3 has multiple calls to the slow calculation function.
The first `if` block calls `simulated_expensive_calculation` twice, the `if`
inside the outer `else` doesn’t call it at all, and the code inside the
second `else` case calls it once.
-->
<p>Le code de l'encart 13-3 a plusieurs appels à la fonction de calcul lent : le
premier bloc <code>if</code> appelle <code>simuler_gros_calcul</code> deux fois, le <code>if</code> à l'intérieur
du <code>else</code> ne l'appelle pas du tout, et le code à l'intérieur du second <code>else</code>
l'appelle une seule fois.</p>
<!--
The desired behavior of the `generate_workout` function is to first check
whether the user wants a low-intensity workout (indicated by a number less than
25) or a high-intensity workout (a number of 25 or greater).
-->
<p>Le comportement souhaité de la fonction <code>generer_exercices</code> est de vérifier
d'abord si l'utilisateur veut un entraînement de faible intensité (indiqué par
un nombre inférieur à 25) ou un entraînement de haute intensité (un nombre de 25
ou plus).</p>
<!--
Low-intensity workout plans will recommend a number of push-ups and sit-ups
based on the complex algorithm we’re simulating.
-->
<p>Les plans d'entraînement à faible intensité recommanderont un certain nombre de
pompes et d'abdominaux basés sur l'algorithme complexe que nous simulons.</p>
<!--
If the user wants a high-intensity workout, there’s some additional logic: if
the value of the random number generated by the app happens to be 3, the app
will recommend a break and hydration. If not, the user will get a number of
minutes of running based on the complex algorithm.
-->
<p>Si l'utilisateur souhaite un entraînement de haute intensité, il y a une logique
en plus : si la valeur du nombre aléatoire généré par l'application est 3,
l'application recommandera une pause et une hydratation à la place. Sinon,
l'utilisateur recevra un nombre de minutes de course qui provient de
l'algorithme complexe.</p>
<!--
This code works the way the business wants it to now, but let’s say the data
science team decides that we need to make some changes to the way we call the
`simulated_expensive_calculation` function in the future. To simplify the
update when those changes happen, we want to refactor this code so it calls the
`simulated_expensive_calculation` function only once. We also want to cut the
place where we’re currently unnecessarily calling the function twice without
adding any other calls to that function in the process. That is, we don’t want
to call it if the result isn’t needed, and we still want to call it only once.
-->
<p>Ce code fonctionne comme la logique métier le souhaite, mais imaginons que
l'équipe de science des données nous informe qu'il va y avoir des changements
dans la façon dont nous devrons appeler l'algorithme à l'avenir. Pour simplifier
la mise à jour lorsque ces changements se produisent, nous voulons remanier ce
code pour qu'il n'appelle la fonction <code>simuler_gros_calcul</code> qu'une seule fois.
Nous voulons également nous débarrasser de l'endroit où nous appelons la
fonction deux fois inutilement, sans ajouter d'autres appels à cette fonction au
cours de ce processus. Autrement dit, nous ne voulons pas l'appeler si le
résultat n'en a pas besoin, et nous voulons faire l'appeler qu'une seule fois au
maximum.</p>
<!--
#### Refactoring Using Functions
-->
<h4 id="remaniement-en-utilisant-des-fonctions"><a class="header" href="#remaniement-en-utilisant-des-fonctions">Remaniement en utilisant des fonctions</a></h4>
<!--
We could restructure the workout program in many ways. First, we’ll try
extracting the duplicated call to the `simulated_expensive_calculation`
function into a variable, as shown in Listing 13-4.
-->
<p>Nous pourrions restructurer le programme d'entraînement de plusieurs manières.
Tout d'abord, nous allons essayer d'extraire l'appel en double à la fonction
<code>simuler_gros_calcul</code> dans une variable, comme dans l'encart 13-4 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# fn simulated_expensive_calculation(intensity: u32) -> u32 {
#     println!("calculating slowly...");
#     thread::sleep(Duration::from_secs(2));
#     intensity
# }
# 
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result = simulated_expensive_calculation(intensity);

    if intensity < 25 {
        println!("Today, do {} pushups!", expensive_result);
        println!("Next, do {} situps!", expensive_result);
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!("Today, run for {} minutes!", expensive_result);
        }
    }
}
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simuler_gros_calcul(intensite: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calcul très lent ...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    intensite
</span><span class="boring">}
</span><span class="boring">
</span>fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
    let resultat_lent = simuler_gros_calcul(intensite);

    if intensite &lt; 25 {
        println!(&quot;Aujourd'hui, faire {} pompes !&quot;, resultat_lent);
        println!(&quot;Ensuite, faire {} abdominaux !&quot;, resultat_lent);
    } else {
        if nombre_aleatoire == 3 {
            println!(&quot;Faites une pause aujourd'hui ! Rappelez-vous de bien vous hydrater !&quot;);
        } else {
            println!(&quot;Aujourd'hui, courrez pendant {} minutes !&quot;, resultat_lent);
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-4: Extracting the calls to
`simulated_expensive_calculation` to one place and storing the result in the
`expensive_result` variable</span>
-->
<p><span class="caption">Encart 13-4 : extraction des appels à
<code>simuler_gros_calcul</code> dans un seul endroit et stockage du résultat dans la
variable <code>resultat_lent</code>.</span></p>
<!--
This change unifies all the calls to `simulated_expensive_calculation` and
solves the problem of the first `if` block unnecessarily calling the function
twice. Unfortunately, we’re now calling this function and waiting for the
result in all cases, which includes the inner `if` block that doesn’t use the
result value at all.
-->
<p>Ce changement unifie tous les appels à <code>simuler_gros_calcul</code> et résout le
problème du premier bloc <code>if</code> qui appelle inutilement la fonction à deux
reprises. Malheureusement, nous appelons maintenant cette fonction et attendons
le résultat dans tous les cas, ce qui inclut le bloc <code>if</code> interne qui n'utilise
pas du tout la valeur du résultat.</p>
<!--
We want to refer to `simulated_expensive_calculation` only once in
`generate_workout`, but defer the expensive calculation to only where
we actually need the result. This is a use case for closures!
-->
<p>Nous voulons référer à <code>simuler_gros_calcul</code> une seule fois dans
<code>generer_exercices</code>, mais retarder le gros calcul jusqu'au moment où nous avons
avons besoin du résultat. C'est un cas d'utilisation des fermetures !</p>
<!--
#### Refactoring with Closures to Store Code
-->
<h4 id="remanier-le-code-avec-des-fermetures-pour-stocker-du-code"><a class="header" href="#remanier-le-code-avec-des-fermetures-pour-stocker-du-code">Remanier le code avec des fermetures pour stocker du code</a></h4>
<!--
Instead of always calling the `simulated_expensive_calculation` function before
the `if` blocks, we can define a closure and store the *closure* in a variable
rather than storing the result of the function call, as shown in Listing 13-5.
We can actually move the whole body of `simulated_expensive_calculation` within
the closure we’re introducing here.
-->
<p>Au lieu d'appeler systématiquement la fonction <code>simuler_gros_calcul</code> avant
les blocs <code>if</code>, nous pouvons définir une fermeture et la stocker dans une
variable au lieu de le faire pour le résultat, comme le montre l'encart 13-5.
Nous pouvons en fait déplacer l'ensemble du corps de <code>simuler_gros_calcul</code> dans
la fermeture que nous introduisons ici.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
# 
#     if intensity < 25 {
#         println!("Today, do {} pushups!", expensive_closure(intensity));
#         println!("Next, do {} situps!", expensive_closure(intensity));
#     } else {
#         if random_number == 3 {
#             println!("Take a break today! Remember to stay hydrated!");
#         } else {
#             println!(
#                 "Today, run for {} minutes!",
#                 expensive_closure(intensity)
#             );
#         }
#     }
# }
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
</span>    let fermeture_lente = |nombre| {
        println!(&quot;calcul très lent ...&quot;);
        thread::sleep(Duration::from_secs(2));
        nombre
    };
<span class="boring">
</span><span class="boring">    if intensite &lt; 25 {
</span><span class="boring">        println!(&quot;Aujourd'hui, faire {} pompes !&quot;, fermeture_lente(intensite));
</span><span class="boring">        println!(&quot;Ensuite, faire {} abdominaux !&quot;, fermeture_lente(intensite));
</span><span class="boring">    } else {
</span><span class="boring">        if nombre_aleatoire == 3 {
</span><span class="boring">            println!(&quot;Faites une pause aujourd'hui ! Rappelez-vous de bien vous hydrater !&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;Aujourd'hui, courrez pendant {} minutes !&quot;,
</span><span class="boring">                fermeture_lente(intensite)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-5: Defining a closure and storing it in the
`expensive_closure` variable</span>
-->
<p><span class="caption">Encart 13-5 : définition d'une fermeture et son
enregistrement dans la variable <code>fermeture_lente</code>.</span></p>
<!--
The closure definition comes after the `=` to assign it to the variable
`expensive_closure`. To define a closure, we start with a pair of vertical
pipes (`|`), inside which we specify the parameters to the closure; this syntax
was chosen because of its similarity to closure definitions in Smalltalk and
Ruby. This closure has one parameter named `num`: if we had more than one
parameter, we would separate them with commas, like `|param1, param2|`.
-->
<p>La définition de la fermeture vient après le <code>=</code> pour l'assigner à la variable
<code>fermeture_lente</code>. Pour définir une fermeture, on commence par une paire de
barres verticales (<code>|</code>), à l'intérieur desquelles on renseigne les paramètres de
la fermeture ; cette syntaxe a été choisie en raison de sa similitude avec les
définitions des fermetures en Smalltalk et en Ruby. Cette fermeture a un
paramètre <code>nombre</code> : si nous avions plus d'un paramètre, nous les séparerions
par des virgules, comme <code>|param1, param2|</code>.</p>
<!--
After the parameters, we place curly brackets that hold the body of the
closure—these are optional if the closure body is a single expression. The end
of the closure, after the curly brackets, needs a semicolon to complete the
`let` statement. The value returned from the last line in the closure body
(`num`) will be the value returned from the closure when it’s called, because
that line doesn’t end in a semicolon; just as in function bodies.
-->
<p>Après les paramètres, on ajoute des accolades qui contiennent le corps de la
fermeture, celles-ci sont facultatives si le corps de la fermeture est une seule
expression. Après les accolades, nous avons besoin d'un point-virgule
pour terminer l'instruction <code>let</code>. La valeur à la dernière ligne dans le corps
de la fermeture (<code>nombre</code>) sera la valeur retournée par la fermeture lorsqu'elle
sera exécutée, et cette ligne ne se termine pas par un point-virgule, exactement
comme dans le corps des fonctions.</p>
<!--
Note that this `let` statement means `expensive_closure` contains the
*definition* of an anonymous function, not the *resulting value* of calling the
anonymous function. Recall that we’re using a closure because we want to define
the code to call at one point, store that code, and call it at a later point;
the code we want to call is now stored in `expensive_closure`.
-->
<p>Notez que cette instruction <code>let</code> signifie que la variable <code>fermeture_lente</code>
contient la <em>définition</em> d'une fonction anonyme, pas la <em>valeur résultante</em> à
l'appel de cette fonction anonyme. Rappelons que nous utilisons une fermeture
pour définir le code à appeler dans un seul endroit, stocker ce code, et
l'appeler plus tard ; le code que nous voulons appeler est maintenant stocké
dans <code>fermeture_lente</code>.</p>
<!--
With the closure defined, we can change the code in the `if` blocks to call the
closure to execute the code and get the resulting value. We call a closure like
we do a function: we specify the variable name that holds the closure
definition and follow it with parentheses containing the argument values we
want to use, as shown in Listing 13-6.
-->
<p>Maintenant que nous avons défini la fermeture, nous pouvons changer le code dans
les blocs <code>if</code> pour appeler la fermeture afin d'exécuter le code et obtenir la
valeur résultante. L'appel d'une fermeture fonctionne comme pour l'appel d'une
fonction : nous renseignons le nom de la variable qui stocke la définition de la
fermeture et la complétons avec des parenthèses contenant les valeurs du ou des
arguments que nous voulons utiliser pour cet appel, comme dans l'encart 13-6.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity < 25 {
        println!("Today, do {} pushups!", expensive_closure(intensity));
        println!("Next, do {} situps!", expensive_closure(intensity));
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                expensive_closure(intensity)
            );
        }
    }
}
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
    let fermeture_lente = |nombre| {
        println!(&quot;calcul très lent ...&quot;);
        thread::sleep(Duration::from_secs(2));
        nombre
    };

    if intensite &lt; 25 {
        println!(&quot;Aujourd'hui, faire {} pompes !&quot;, fermeture_lente(intensite));
        println!(&quot;Ensuite, faire {} abdominaux !&quot;, fermeture_lente(intensite));
    } else {
        if nombre_aleatoire == 3 {
            println!(&quot;Faites une pause aujourd'hui ! Rappelez-vous de bien vous hydrater !&quot;);
        } else {
            println!(
                &quot;Aujourd'hui, courrez pendant {} minutes !&quot;,
                fermeture_lente(intensite)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-6: Calling the `expensive_closure` we’ve
defined</span>
-->
<p><span class="caption">Encart 13-6 : appel de la fermeture <code>fermeture_lente</code>
que nous avons défini</span></p>
<!--
Now how to perform the expensive calculation is defined in only one
place, and we’re only executing that code where we need the results.
-->
<p>Désormais, le calcul lent n'est défini qu'à un seul endroit, et nous
n'exécutons ce code uniquement où nous avons besoin des résultats.</p>
<!--
However, we’ve reintroduced one of the problems from Listing 13-3: we’re still
calling the closure twice in the first `if` block, which will call the
expensive code twice and make the user wait twice as long as they need to. We
could fix this problem by creating a variable local to that `if` block to hold
the result of calling the closure, but closures provide us with another
solution. We’ll talk about that solution in a bit. But first let’s talk about
why there aren’t type annotations in the closure definition and the traits
involved with closures.
-->
<p>Cependant, nous avons réintroduit l'un des problèmes de l'encart 13-3 : nous
continuons d'appeler la fermeture deux fois dans le premier bloc <code>if</code>, qui
appellera le code lent à deux reprises et fera attendre l'utilisateur deux fois
plus longtemps que nécessaire. Nous pourrions résoudre ce problème en créant une
variable locale à ce bloc <code>if</code> pour conserver le résultat de l'appel à la
fermeture, mais les fermetures nous ouvrent d'autres solutions. Commençons
d'abord par expliquer pourquoi il n'y a pas d'annotation de type dans la
définition des fermetures et les traits liés aux fermetures.</p>
<!--
### Closure Type Inference and Annotation
-->
<h3 id="linférence-de-type-et-lannotation-des-fermetures"><a class="header" href="#linférence-de-type-et-lannotation-des-fermetures">L'inférence de type et l'annotation des fermetures</a></h3>
<!--
Closures don’t require you to annotate the types of the parameters or the
return value like `fn` functions do. Type annotations are required on functions
because they’re part of an explicit interface exposed to your users. Defining
this interface rigidly is important for ensuring that everyone agrees on what
types of values a function uses and returns. But closures aren’t used in an
exposed interface like this: they’re stored in variables and used without
naming them and exposing them to users of our library.
-->
<p>Les fermetures ne nécessitent pas d'annoter le type des paramètres ou de la
valeur de retour comme le font les fonctions <code>fn</code>. Les annotations de type sont
nécessaires pour les fonctions, car elles font partie d'une interface explicite
exposée à leurs utilisateurs. Définir cette interface de manière rigide est
nécessaire pour s'assurer que tout le monde s'accorde sur les types de valeurs
qu'une fonction utilise et retourne. Mais les fermetures ne sont pas utilisées
dans une interface exposée ainsi : elles sont stockées dans des variables et
utilisées sans les nommer ni les exposer aux utilisateurs de notre bibliothèque.</p>
<!--
Closures are usually short and relevant only within a narrow context rather
than in any arbitrary scenario. Within these limited contexts, the compiler is
reliably able to infer the types of the parameters and the return type, similar
to how it’s able to infer the types of most variables.
-->
<p>En outre, les fermetures sont généralement brèves et ne sont pertinentes que
dans un contexte précis plutôt que pour des cas génériques. Dans ce contexte
précis, le compilateur est capable de déduire le type des paramètres et le type
de retour, comme il est capable d'inférer le type de la plupart des variables.</p>
<!--
Making programmers annotate the types in these small, anonymous functions would
be annoying and largely redundant with the information the compiler already has
available.
-->
<p>Demander aux développeurs d'annoter le type dans ces petites fonctions anonymes
serait ennuyant et largement redondant avec l'information dont dispose déjà le
compilateur.</p>
<!--
As with variables, we can add type annotations if we want to increase
explicitness and clarity at the cost of being more verbose than is strictly
necessary. Annotating the types for the closure we defined in Listing 13-5
would look like the definition shown in Listing 13-7.
-->
<p>Comme pour les variables, nous pouvons ajouter des annotations de type si nous
voulons rendre explicite et clarifier le code au risque d'être plus verbeux que
ce qui est strictement nécessaire. Annoter les types de la fermeture que nous
avons défini dans l'encart 13-5 ressemblerait à l'encart 13-7.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num: u32| -> u32 {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
# 
#     if intensity < 25 {
#         println!("Today, do {} pushups!", expensive_closure(intensity));
#         println!("Next, do {} situps!", expensive_closure(intensity));
#     } else {
#         if random_number == 3 {
#             println!("Take a break today! Remember to stay hydrated!");
#         } else {
#             println!(
#                 "Today, run for {} minutes!",
#                 expensive_closure(intensity)
#             );
#         }
#     }
# }
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
</span>    let fermeture_lente = |nombre: u32| -&gt; u32 {
        println!(&quot;calcul très lent ...&quot;);
        thread::sleep(Duration::from_secs(2));
        nombre
    };
<span class="boring">
</span><span class="boring">    if intensite &lt; 25 {
</span><span class="boring">        println!(&quot;Aujourd'hui, faire {} pompes !&quot;, fermeture_lente(intensite));
</span><span class="boring">        println!(&quot;Ensuite, faire {} abdominaux !&quot;, fermeture_lente(intensite));
</span><span class="boring">    } else {
</span><span class="boring">        if nombre_aleatoire == 3 {
</span><span class="boring">            println!(&quot;Faites une pause aujourd'hui ! Rappelez-vous de bien vous hydrater !&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;Aujourd'hui, courrez pendant {} minutes !&quot;,
</span><span class="boring">                fermeture_lente(intensite)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-7: Adding optional type annotations of the
parameter and return value types in the closure</span>
-->
<p><span class="caption">Encart 13-7 : ajout d'annotations de type optionnelles sur
les paramètres et les valeurs de retour de la fermeture</span></p>
<!--
With type annotations added, the syntax of closures looks more similar to the
syntax of functions. The following is a vertical comparison of the syntax for
the definition of a function that adds 1 to its parameter and a closure that
has the same behavior. We’ve added some spaces to line up the relevant parts.
This illustrates how closure syntax is similar to function syntax except for
the use of pipes and the amount of syntax that is optional:
-->
<p>La syntaxe des fermetures et des fonctions semble plus similaire avec les
annotations de type. Ce qui suit est une comparaison verticale entre la syntaxe
d'une définition d'une fonction qui ajoute 1 à son paramètre, et d'une fermeture
qui a le même comportement. Nous avons ajouté des espaces pour aligner les
parties pertinentes. Ceci met en évidence la similarité entre la syntaxe des
fermetures et celle des fonctions, hormis l'utilisation des barres verticales
et certaines syntaxes facultatives :</p>
<!--
```rust,ignore
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```
-->
<pre><code class="language-rust ignore">fn  ajouter_un_v1   (x: u32) -&gt; u32 { x + 1 }
let ajouter_un_v2 = |x: u32| -&gt; u32 { x + 1 };
let ajouter_un_v3 = |x|             { x + 1 };
let ajouter_un_v4 = |x|               x + 1  ;
</code></pre>
<!--
The first line shows a function definition, and the second line shows a fully
annotated closure definition. The third line removes the type annotations from
the closure definition, and the fourth line removes the brackets, which are
optional because the closure body has only one expression. These are all valid
definitions that will produce the same behavior when they’re called. Calling
the closures is required for `add_one_v3` and `add_one_v4` to be able to
compile because the types will be inferred from their usage.
-->
<p>La première ligne affiche la définition d'une fonction et la deuxième ligne une
définition d'une fermeture entièrement annotée. La troisième ligne supprime les
annotations de type de la définition de la fermeture, et la quatrième ligne
supprime les accolades qui sont facultatives, parce que le corps d'une fermeture
n'a qu'une seule expression. Ce sont toutes des définitions valides qui
suivront le même comportement lorsqu'on les appellera. L'appel aux fermetures
est nécessaire pour que <code>ajouter_un_v3</code> et <code>ajouter_un_v4</code> puisse être compilés
car les types seront déduits en fonction de leur utilisation.</p>
<!--
Closure definitions will have one concrete type inferred for each of their
parameters and for their return value. For instance, Listing 13-8 shows the
definition of a short closure that just returns the value it receives as a
parameter. This closure isn’t very useful except for the purposes of this
example. Note that we haven’t added any type annotations to the definition: if
we then try to call the closure twice, using a `String` as an argument the
first time and a `u32` the second time, we’ll get an error.
-->
<p>Les définitions des fermetures auront un type concret déduit pour chacun de
leurs paramètres et pour leur valeur de retour. Par exemple, l'encart 13-8
montre la définition d'une petite fermeture qui renvoie simplement la valeur
qu'elle reçoit comme paramètre. Cette fermeture n'est pas très utile sauf pour
les besoins de cet exemple. Notez que nous n'avons pas ajouté d'annotations de
type à la définition : si nous essayons alors d'appeler la fermeture deux fois,
en utilisant une <code>String</code> comme argument la première fois et un <code>u32</code> la
deuxième fois, nous obtiendrons une erreur :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let fermeture_exemple = |x| x;

    let s = fermeture_exemple(String::from(&quot;hello&quot;));
    let n = fermeture_exemple(5);
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-8: Attempting to call a closure whose types
are inferred with two different types</span>
-->
<p><span class="caption">Encart 13-8 : tentative d'appeler une fermeture dont les
types sont déduits avec deux types différents</span></p>
<!--
The compiler gives us this error:
-->
<p>Le compilateur nous renvoie l'erreur suivante :</p>
<!--
```console
$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 -- > src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |                             ^
  |                             |
  |                             expected struct `String`, found integer
  |                             help: try using a conversion method: `5.to_string()`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = fermeture_exemple(5);
  |                               ^
  |                               |
  |                               expected struct `String`, found integer
  |                               help: try using a conversion method: `5.to_string()`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` due to previous error
</code></pre>
<!--
The first time we call `example_closure` with the `String` value, the compiler
infers the type of `x` and the return type of the closure to be `String`. Those
types are then locked into the closure in `example_closure`, and we get a type
error if we try to use a different type with the same closure.
-->
<p>La première fois que nous appelons <code>fermeture_exemple</code> avec une <code>String</code>, le
compilateur déduit que le type de <code>x</code> et le type de retour de la fermeture sont
de type <code>String</code>. Ces types sont ensuite verrouillés dans <code>fermeture_exemple</code>,
et nous obtenons une erreur de type si nous essayons d'utiliser un type
différent avec la même fermeture.</p>
<!--
### Storing Closures Using Generic Parameters and the `Fn` Traits
-->
<h3 id="stockage-des-fermetures-avec-des-paramètres-génériques-et-le-trait-fn"><a class="header" href="#stockage-des-fermetures-avec-des-paramètres-génériques-et-le-trait-fn">Stockage des fermetures avec des paramètres génériques et le trait <code>Fn</code></a></h3>
<!--
Let’s return to our workout generation app. In Listing 13-6, our code was still
calling the expensive calculation closure more times than it needed to. One
option to solve this issue is to save the result of the expensive closure in a
variable for reuse and use the variable in each place we need the result,
instead of calling the closure again. However, this method could result in a
lot of repeated code.
-->
<p>Revenons à notre application de génération d'entraînements. Dans l'encart 13-6,
notre code appelait toujours la fermeture lente plus de fois que nécessaire. Une
option pour résoudre ce problème est de sauvegarder le résultat de la fermeture
lente dans une variable pour une future utilisation et d'utiliser la variable à
chaque endroit où nous en avons besoin au lieu de rappeler la fermeture à
nouveau. Cependant, cette méthode pourrait donner lieu à du code très répété.</p>
<!--
Fortunately, another solution is available to us. We can create a struct that
will hold the closure and the resulting value of calling the closure. The
struct will execute the closure only if we need the resulting value, and it
will cache the resulting value so the rest of our code doesn’t have to be
responsible for saving and reusing the result. You may know this pattern as
*memoization* or *lazy evaluation*.
-->
<p>Heureusement, une autre solution s'offre à nous. Nous pouvons créer une
structure qui stockera la fermeture et la valeur qui en résulte. La structure
n'exécutera la fermeture uniquement si nous avons besoin de la valeur
résultante, et elle mettra en cache la valeur résultante pour que le reste de
notre code ne soit pas en charge de sauvegarder et de la réutiliser le résultat.
Vous connaissez peut-être cette technique sous le nom de <em>mémoïsation</em> ou
<em>d'évaluation paresseuse</em>.</p>
<!--
To make a struct that holds a closure, we need to specify the type of the
closure, because a struct definition needs to know the types of each of its
fields. Each closure instance has its own unique anonymous type: that is, even
if two closures have the same signature, their types are still considered
different. To define structs, enums, or function parameters that use closures,
we use generics and trait bounds, as we discussed in Chapter 10.
-->
<p>Pour faire en sorte qu'une structure détienne une fermeture, il faut préciser
le type de fermeture, car une définition de structure a besoin de connaître les
types de chacun de ses champs. Chaque instance de fermeture a son propre type
anonyme unique : cela signifie que même si deux fermetures ont la même
signature, leurs types sont toujours considérés comme différents. Pour définir
des structures, des enumérations ou des paramètres de fonction qui utilisent des
fermetures, nous utilisons des génériques et des traits liés, comme nous
l'avons vu au chapitre 10.</p>
<!--
The `Fn` traits are provided by the standard library. All closures implement at
least one of the traits: `Fn`, `FnMut`, or `FnOnce`. We’ll discuss the
difference between these traits in the [“Capturing the Environment with
Closures”](#capturing-the-environment-with-closures)<!-- ignore -- > section; in
this example, we can use the `Fn` trait.
-->
<p>Les traits <code>Fn</code> sont fournis par la bibliothèque standard. Toutes les fermetures
implémentent au moins un des traits suivants : <code>Fn</code>, <code>FnMut</code>, ou <code>FnOnce</code>. Nous
verrons la différence entre ces traits dans la section
<a href="ch13-01-closures.html#capturer-lenvironnement-avec-les-fermetures">“Capturer l'environnement avec les
fermetures”</a><!-- ignore --> ; dans
cet exemple, nous pouvons utiliser le trait <code>Fn</code>.</p>
<!--
We add types to the `Fn` trait bound to represent the types of the parameters
and return values the closures must have to match this trait bound. In this
case, our closure has a parameter of type `u32` and returns a `u32`, so the
trait bound we specify is `Fn(u32) -> u32`.
-->
<p>Nous ajoutons des types au trait lié <code>Fn</code> pour représenter les types de
paramètres et les valeurs de retour que les fermetures doivent avoir pour
correspondre à ce trait lié. Dans ce cas, notre fermeture a un paramètre de type
<code>u32</code> et renvoie un <code>u32</code>, le trait lié que nous précisons est donc
<code>Fn (u32) -&gt; u32</code>.</p>
<!--
Listing 13-9 shows the definition of the `Cacher` struct that holds a closure
and an optional result value.
-->
<p>L'encart 13-9 montre la définition de la structure <code>Cache</code> qui possède une
fermeture et une valeur de résultat optionnelle :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
struct Cacher<T>
where
    T: Fn(u32) -> u32,
{
    calculation: T,
    value: Option<u32>,
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Cache&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    calcul: T,
    valeur: Option&lt;u32&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-9: Defining a `Cacher` struct that holds a
closure in `calculation` and an optional result in `value`</span>
-->
<p><span class="caption">Encart 13-9 : définition d'une structure <code>Cache</code> qui
possède une fermeture dans <code>calcul</code> et un résultat facultatif dans <code>valeur</code>.
</span></p>
<!--
The `Cacher` struct has a `calculation` field of the generic type `T`. The
trait bounds on `T` specify that it’s a closure by using the `Fn` trait. Any
closure we want to store in the `calculation` field must have one `u32`
parameter (specified within the parentheses after `Fn`) and must return a
`u32` (specified after the `->`).
-->
<p>La structure <code>Cache</code> a un champ <code>calcul</code> du type générique <code>T</code>. Le trait lié <code>T</code>
précise que c'est une fermeture en utilisant le trait <code>Fn</code>. Toute fermeture que
l'on veut stocker dans le champ <code>calcul</code> doit avoir un paramètre <code>u32</code> (ce qui
est précisé entre parenthèse après le <code>Fn</code>) et doit retourner un <code>u32</code> (ce qui
est précisé après le <code>-&gt;</code>).</p>
<!--
> Note: Functions can implement all three of the `Fn` traits too. If what we
> want to do doesn’t require capturing a value from the environment, we can use
> a function rather than a closure where we need something that implements an
> `Fn` trait.
-->
<blockquote>
<p>Remarque : les fonctions implémentent aussi tous les trois traits <code>Fn</code>. Si ce
que nous voulons faire n'a pas besoin de capturer une valeur de
l'environnement, nous pouvons utiliser une fonction plutôt qu'une fermeture où
nous avons besoin de quelque chose qui implémente un trait <code>Fn</code>.</p>
</blockquote>
<!--
The `value` field is of type `Option<u32>`. Before we execute the closure,
`value` will be `None`. When code using a `Cacher` asks for the *result* of the
closure, the `Cacher` will execute the closure at that time and store the
result within a `Some` variant in the `value` field. Then if the code asks for
the result of the closure again, instead of executing the closure again, the
`Cacher` will return the result held in the `Some` variant.
-->
<p>Le champ <code>valeur</code> est de type <code>Option&lt;u32&gt;</code>. Avant d'exécuter la fermeture,
<code>valeur</code> sera initialisée à <code>None</code>. Lorsque du code utilisant un <code>Cache</code> demande
le <em>résultat</em> de la fermeture, le <code>Cache</code> exécutera la fermeture à ce moment-là
et stockera le résultat dans une variante <code>Some</code> dans le champ <code>valeur</code>.
Ensuite, si le code demande à nouveau le résultat de la fermeture, le <code>Cache</code>
renverra le résultat contenu dans la variante <code>Some</code> au lieu d'exécuter à
nouveau la fermeture.</p>
<!--
The logic around the `value` field we’ve just described is defined in Listing
13-10.
-->
<p>La logique autour du champ <code>valeur</code> que nous venons de décrire est définie dans
l'encart 13-10 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# struct Cacher<T>
# where
#     T: Fn(u32) -> u32,
# {
#     calculation: T,
#     value: Option<u32>,
# }
# 
impl<T> Cacher<T>
where
    T: Fn(u32) -> u32,
{
    fn new(calculation: T) -> Cacher<T> {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Cache&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">    calcul: T,
</span><span class="boring">    valeur: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;T&gt; Cache&lt;T&gt;
where
    T: Fn(u32) -&gt; u32
{
    fn new(calcul: T) -&gt; Cache&lt;T&gt; {
        Cache {
            calcul,
            valeur: None,
        }
    }

    fn valeur(&amp;mut self, arg: u32) -&gt; u32 {
        match self.valeur {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calcul)(arg);
                self.valeur = Some(v);
                v
            },
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-10: The caching logic of `Cacher`</span>
-->
<p><span class="caption">Encart 13-10 : la logique de <code>Cache</code></span></p>
<!--
We want `Cacher` to manage the struct fields’ values rather than letting the
calling code potentially change the values in these fields directly, so these
fields are private.
-->
<p>Nous voulons que <code>Cache</code> gère les valeurs des champs de structure plutôt que de
laisser la possibilité au code appelant la possibilité de modifier directement
les valeurs dans ces champs, donc nous faisons en sorte que ces champs soient
privés.</p>
<!--
The `Cacher::new` function takes a generic parameter `T`, which we’ve defined
as having the same trait bound as the `Cacher` struct. Then `Cacher::new`
returns a `Cacher` instance that holds the closure specified in the
`calculation` field and a `None` value in the `value` field, because we haven’t
executed the closure yet.
-->
<p>La fonction <code>Cache::new</code> prend un paramètre générique <code>T</code>, que nous avons
défini comme ayant le même trait lié que la structure <code>Cache</code>. Puis <code>Cache::new</code>
renvoie une instance <code>Cache</code> qui contient la fermeture présente dans le champ
<code>calcul</code> et une valeur <code>None</code> dans le champ <code>valeur</code>, car nous n'avons pas
encore exécuté la fermeture.</p>
<!--
When the calling code needs the result of evaluating the closure, instead of
calling the closure directly, it will call the `value` method. This method
checks whether we already have a resulting value in `self.value` in a `Some`;
if we do, it returns the value within the `Some` without executing the closure
again.
-->
<p>Lorsque le code appelant veut le résultat de l'exécution de la fermeture, au
lieu d'appeler directement la fermeture, il appellera la méthode <code>valeur</code>. Cette
méthode vérifie si nous avons déjà une valeur dans un <code>Some</code> dans
<code>self.valeur</code> ; et si c'est le cas, elle renvoie la valeur contenue dans le
<code>Some</code> sans exécuter de nouveau la fermeture.</p>
<!--
If `self.value` is `None`, the code calls the closure stored in
`self.calculation`, saves the result in `self.value` for future use, and
returns the value as well.
-->
<p>Si <code>self.valeur</code> est <code>None</code>, nous appelons la fermeture stockée dans
<code>self.calcul</code>, et nous sauvegardons le résultat dans <code>self.valeur</code> pour une
utilisation future, puis nous retournons la valeur.</p>
<!--
Listing 13-11 shows how we can use this `Cacher` struct in the function
`generate_workout` from Listing 13-6.
-->
<p>L'encart 13-11 montre comment utiliser cette structure <code>Cache</code> dans la fonction
<code>generer_exercices</code> de l'encart 13-6 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# use std::thread;
# use std::time::Duration;
# 
# struct Cacher<T>
# where
#     T: Fn(u32) -> u32,
# {
#     calculation: T,
#     value: Option<u32>,
# }
# 
# impl<T> Cacher<T>
# where
#     T: Fn(u32) -> u32,
# {
#     fn new(calculation: T) -> Cacher<T> {
#         Cacher {
#             calculation,
#             value: None,
#         }
#     }
# 
#     fn value(&mut self, arg: u32) -> u32 {
#         match self.value {
#             Some(v) => v,
#             None => {
#                 let v = (self.calculation)(arg);
#                 self.value = Some(v);
#                 v
#             }
#         }
#     }
# }
# 
fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity < 25 {
        println!("Today, do {} pushups!", expensive_result.value(intensity));
        println!("Next, do {} situps!", expensive_result.value(intensity));
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                expensive_result.value(intensity)
            );
        }
    }
}
# 
# fn main() {
#     let simulated_user_specified_value = 10;
#     let simulated_random_number = 7;
# 
#     generate_workout(simulated_user_specified_value, simulated_random_number);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">struct Cache&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">    calcul: T,
</span><span class="boring">    valeur: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Cache&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32
</span><span class="boring">{
</span><span class="boring">    fn new(calcul: T) -&gt; Cache&lt;T&gt; {
</span><span class="boring">        Cache {
</span><span class="boring">            calcul,
</span><span class="boring">            valeur: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn valeur(&amp;mut self, arg: u32) -&gt; u32 {
</span><span class="boring">        match self.valeur {
</span><span class="boring">            Some(v) =&gt; v,
</span><span class="boring">            None =&gt; {
</span><span class="boring">                let v = (self.calcul)(arg);
</span><span class="boring">                self.valeur = Some(v);
</span><span class="boring">                v
</span><span class="boring">            },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn generer_exercices(intensite: u32, nombre_aleatoire: u32) {
    let mut resultat_lent = Cache::new(|nombre| {
        println!(&quot;calcul très lent ...&quot;);
        thread::sleep(Duration::from_secs(2));
        nombre
    });

    if intensite &lt; 25 {
        println!(&quot;Aujourd'hui, faire {} pompes !&quot;, resultat_lent.valeur(intensite));
        println!(&quot;Ensuite, faire {} abdominaux !&quot;, resultat_lent.valeur(intensite));
    } else {
        if nombre_aleatoire == 3 {
            println!(&quot;Faites une pause aujourd'hui ! Rappelez-vous de bien vous hydrater !&quot;);
        } else {
            println!(
                &quot;Aujourd'hui, courrez pendant {} minutes !&quot;,
                resultat_lent.valeur(intensite)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let valeur_utilisateur_simule = 10;
</span><span class="boring">    let nombre_aleatoire_simule = 7;
</span><span class="boring">
</span><span class="boring">    generer_exercices(valeur_utilisateur_simule, nombre_aleatoire_simule);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-11: Using `Cacher` in the `generate_workout`
function to abstract away the caching logic</span>
-->
<p><span class="caption">Encart 13-11 : utilisation de <code>Cache</code> dans la fonction
<code>generer_exercices</code> pour masquer la logique du cache.</span></p>
<!--
Instead of saving the closure in a variable directly, we save a new instance of
`Cacher` that holds the closure. Then, in each place we want the result, we
call the `value` method on the `Cacher` instance. We can call the `value`
method as many times as we want, or not call it at all, and the expensive
calculation will be run a maximum of once.
-->
<p>Au lieu de sauvegarder la fermeture dans une variable directement, nous
sauvegardons une nouvelle instance de <code>Cache</code> qui contient la fermeture.
Ensuite, à chaque fois que nous voulons le résultat, nous appelons la méthode
<code>valeur</code> sur cette instance de <code>Cache</code>. Nous pouvons appeler la méthode <code>valeur</code>
autant de fois que nous souhaitons, ou ne pas l'appeler du tout, et le calcul
lent sera exécuté une fois au maximum.</p>
<!--
Try running this program with the `main` function from Listing 13-2. Change the
values in the `simulated_user_specified_value` and `simulated_random_number`
variables to verify that in all the cases in the various `if` and `else`
blocks, `calculating slowly...` appears only once and only when needed. The
`Cacher` takes care of the logic necessary to ensure we aren’t calling the
expensive calculation more than we need to so `generate_workout` can focus on
the business logic.
-->
<p>Essayez d'exécuter ce programme avec la fonction <code>main</code> de l'encart 13-2.
Modifiez les valeurs des variables <code>valeur_utilisateur_simule</code> et
<code>nombre_aleatoire_simule</code> pour vérifier que dans tous les cas des différents
blocs <code>if</code> et <code>else</code>, <code>calcul très lent ...</code> n'apparaît qu'une seule fois et
seulement si nécessaire. Le <code>Cache</code> se charge de la logique nécessaire pour
s'assurer que nous n'appelons pas le calcul lent plus que nous n'en avons
besoin afin que <code>generer_exercices</code> puisse se concentrer sur la logique métier.</p>
<!--
### Limitations of the `Cacher` Implementation
-->
<h3 id="limitations-de-limplémentation-de-cache"><a class="header" href="#limitations-de-limplémentation-de-cache">Limitations de l'implémentation de <code>Cache</code></a></h3>
<!--
Caching values is a generally useful behavior that we might want to use in
other parts of our code with different closures. However, there are two
problems with the current implementation of `Cacher` that would make reusing it
in different contexts difficult.
-->
<p>La mise en cache des valeurs est un comportement généralement utile que nous
pourrions vouloir utiliser dans d'autres parties de notre code avec différentes
fermetures. Cependant, il y a deux problèmes avec l'implémentation actuelle de
<code>Cache</code> qui rendraient difficile sa réutilisation dans des contextes différents.</p>
<!--
The first problem is that a `Cacher` instance assumes it will always get the
same value for the parameter `arg` to the `value` method. That is, this test of
`Cacher` will fail:
-->
<p>Le premier problème est qu'une instance de <code>Cache</code> suppose qu'elle obtienne
toujours la même valeur, indépendamment du paramètre <code>arg</code> de la méthode
<code>valeur</code>. Autrement dit, ce test sur <code>Cache</code> échouera :</p>
<!--
```rust,ignore,panics
# struct Cacher<T>
# where
#     T: Fn(u32) -> u32,
# {
#     calculation: T,
#     value: Option<u32>,
# }
# 
# impl<T> Cacher<T>
# where
#     T: Fn(u32) -> u32,
# {
#     fn new(calculation: T) -> Cacher<T> {
#         Cacher {
#             calculation,
#             value: None,
#         }
#     }
# 
#     fn value(&mut self, arg: u32) -> u32 {
#         match self.value {
#             Some(v) => v,
#             None => {
#                 let v = (self.calculation)(arg);
#                 self.value = Some(v);
#                 v
#             }
#         }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
    #[test]
    fn call_with_different_values() {
        let mut c = Cacher::new(|a| a);

        let v1 = c.value(1);
        let v2 = c.value(2);

        assert_eq!(v2, 2);
    }
# }
```
-->
<pre><code class="language-rust ignore panics"><span class="boring">struct Cache&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">    calcul: T,
</span><span class="boring">    valeur: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Cache&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32
</span><span class="boring">{
</span><span class="boring">    fn new(calcul: T) -&gt; Cache&lt;T&gt; {
</span><span class="boring">        Cache {
</span><span class="boring">            calcul,
</span><span class="boring">            valeur: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn valeur(&amp;mut self, arg: u32) -&gt; u32 {
</span><span class="boring">        match self.valeur {
</span><span class="boring">            Some(v) =&gt; v,
</span><span class="boring">            None =&gt; {
</span><span class="boring">                let v = (self.calcul)(arg);
</span><span class="boring">                self.valeur = Some(v);
</span><span class="boring">                v
</span><span class="boring">            },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn appel_avec_differentes_valeurs() {
        let mut c = Cache::new(|a| a);

        let v1 = c.valeur(1);
        let v2 = c.valeur(2);

        assert_eq!(v2, 2);
    }
<span class="boring">}
</span></code></pre>
<!--
This test creates a new `Cacher` instance with a closure that returns the value
passed into it. We call the `value` method on this `Cacher` instance with an
`arg` value of 1 and then an `arg` value of 2, and we expect the call to
`value` with the `arg` value of 2 to return 2.
-->
<p>Ce test créé une nouvelle instance de <code>Cache</code> avec une fermeture qui retourne
la valeur qui lui est passée. Nous appelons la méthode <code>valeur</code> sur cette
instance de <code>Cache</code> avec une valeur <code>arg</code> de 1 et ensuite une valeur <code>arg</code>
de 2, et nous nous attendons à ce que l'appel à <code>valeur</code> avec la valeur <code>arg</code>
de 2 devrait retourner 2.</p>
<!--
Run this test with the `Cacher` implementation in Listing 13-9 and Listing
13-10, and the test will fail on the `assert_eq!` with this message:
-->
<p>Exécutez ce test avec l'implémentation de <code>Cache</code> de l'encart 13-9 et de
l'encart 13-10, et le test échouera sur le <code>assert_eq!</code> avec ce message :</p>
<!--
```console
$ cargo test
   Compiling cacher v0.1.0 (file:///projects/cacher)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests (target/debug/deps/cacher-074d7c200c000afa)

running 1 test
test tests::call_with_different_values ... FAILED

failures:

---- tests::call_with_different_values stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/lib.rs:43:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::call_with_different_values

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling cacher v0.1.0 (file:///projects/cacher)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests (target/debug/deps/cacher-074d7c200c000afa)

running 1 test
test tests::appel_avec_differentes_valeurs ... FAILED

failures:

---- tests::appel_avec_differentes_valeurs stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/lib.rs:43:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::appel_avec_differentes_valeurs

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
The problem is that the first time we called `c.value` with 1, the `Cacher`
instance saved `Some(1)` in `self.value`. Thereafter, no matter what we pass into
the `value` method, it will always return 1.
-->
<p>Le problème est que la première fois que nous avons appelé <code>c.valeur</code> avec 1,
l'instance <code>Cache</code> a sauvegardé <code>Some(1)</code> dans <code>self.valeur</code>. Par la suite, peu
importe ce que nous passons à la méthode <code>valeur</code>, elle retournera toujours 1.</p>
<!--
Try modifying `Cacher` to hold a hash map rather than a single value. The keys
of the hash map will be the `arg` values that are passed in, and the values of
the hash map will be the result of calling the closure on that key. Instead of
looking at whether `self.value` directly has a `Some` or a `None` value, the
`value` function will look up the `arg` in the hash map and return the value if
it’s present. If it’s not present, the `Cacher` will call the closure and save
the resulting value in the hash map associated with its `arg` value.
-->
<p>Essayez de modifier <code>Cache</code> pour tenir une table de hachage plutôt qu'une seule
valeur. Les clés de la table de hachage seront les valeurs <code>arg</code> qui lui sont
passées, et les valeurs de la table de hachage seront le résultat de l'appel à
la fermeture avec cette clé. Plutôt que de regarder directement si <code>self.valeur</code>
a une valeur <code>Some</code> ou une valeur <code>None</code>, la fonction <code>valeur</code> recherchera <code>arg</code>
dans la table de hachage et retournera la valeur si elle est présente. S'il
n'est pas présent, le <code>Cache</code> appellera la fermeture et sauvegardera la valeur
résultante dans la table de hachage associée à sa clée <code>arg</code>.</p>
<!--
The second problem with the current `Cacher` implementation is that it only
accepts closures that take one parameter of type `u32` and return a `u32`. We
might want to cache the results of closures that take a string slice and return
`usize` values, for example. To fix this issue, try introducing more generic
parameters to increase the flexibility of the `Cacher` functionality.
-->
<p>Le second problème avec l'implémentation actuelle de <code>Cache</code> est qu'il n'accepte
que les fermetures qui prennent un paramètre de type <code>u32</code> et renvoient un
<code>u32</code>. Nous pourrions vouloir mettre en cache les résultats des fermetures qui
prennent une slice d'une chaîne de caractères et renvoient des valeurs <code>usize</code>,
par exemple. Pour corriger ce problème, essayez d'introduire des paramètres plus
génériques pour augmenter la flexibilité de la fonctionnalité offerte par
<code>Cache</code>.</p>
<!--
### Capturing the Environment with Closures
-->
<h3 id="capturer-lenvironnement-avec-les-fermetures"><a class="header" href="#capturer-lenvironnement-avec-les-fermetures">Capturer l'environnement avec les fermetures</a></h3>
<!--
In the workout generator example, we only used closures as inline anonymous
functions. However, closures have an additional capability that functions don’t
have: they can capture their environment and access variables from the scope in
which they’re defined.
-->
<p>Dans l'exemple du générateur d'entraînement, nous n'avons utilisé les fermetures
uniquement comme des fonctions anonymes internes. Cependant, les fermetures ont
une capacité supplémentaire que les fonctions n'ont pas : elles peuvent capturer
leur environnement et accéder aux variables de la portée dans laquelle elles
sont définies.</p>
<!--
Listing 13-12 has an example of a closure stored in the `equal_to_x` variable
that uses the `x` variable from the closure’s surrounding environment.
-->
<p>L'encart 13-12 montre un exemple de fermeture stockée dans la variable
<code>egal_a_x</code> qui utilise la variable <code>x</code> de l'environnement environnant de la
fermeture :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 4;

    let egal_a_x = |z| z == x;

    let y = 4;

    assert!(egal_a_x(y));
}
</code></pre></pre>
<!--
<span class="caption">Listing 13-12: Example of a closure that refers to a
variable in its enclosing scope</span>
-->
<p><span class="caption">Encart 13-12 : exemple d'une fermeture qui réfère à une
variable présente dans la portée qui la contient.</span></p>
<!--
Here, even though `x` is not one of the parameters of `equal_to_x`, the
`equal_to_x` closure is allowed to use the `x` variable that’s defined in the
same scope that `equal_to_x` is defined in.
-->
<p>Ici, même si <code>x</code> n'est pas un des paramètres de <code>egal_a_x</code>, la fermeture
<code>egal_a_x</code> est autorisée à utiliser la variable <code>x</code> définie dans la même
portée où est définie <code>egal_a_x</code>.</p>
<!--
We can’t do the same with functions; if we try with the following example, our
code won’t compile:
-->
<p>Nous ne pouvons pas faire la même chose avec les fonctions ; si nous essayons
avec l'exemple suivant, notre code ne se compilera pas :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -> bool {
        z == x
    }

    let y = 4;

    assert!(equal_to_x(y));
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 4;

    fn egal_a_x(z: i32) -&gt; bool {
        z == x
    }

    let y = 4;

    assert!(egal_a_x(y));
}
</code></pre>
<!--
We get an error:
-->
<p>Nous obtenons l'erreur suivante :</p>
<!--
```console
$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0434]: can't capture dynamic environment in a fn item
 -- > src/main.rs:5:14
  |
5 |         z == x
  |              ^
  |
  = help: use the `|| { ... }` closure form instead

For more information about this error, try `rustc --explain E0434`.
error: could not compile `equal-to-x` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0434]: can't capture dynamic environment in a fn item
 --&gt; src/main.rs:5:14
  |
5 |         z == x
  |              ^
  |
  = help: use the `|| { ... }` closure form instead

For more information about this error, try `rustc --explain E0434`.
error: could not compile `equal-to-x` due to previous error
</code></pre>
<!--
The compiler even reminds us that this only works with closures!
-->
<p>Le compilateur nous rappelle même que cela ne fonctionne qu'avec les
fermetures !</p>
<!--
When a closure captures a value from its environment, it uses memory to store
the values for use in the closure body. This use of memory is overhead that we
don’t want to pay in more common cases where we want to execute code that
doesn’t capture its environment. Because functions are never allowed to capture
their environment, defining and using functions will never incur this overhead.
-->
<p>Lorsqu'une fermeture capture une valeur de son environnement, elle utilise la
mémoire pour stocker les valeurs à utiliser dans son corps. Cette utilisation de
la mémoire a un coût supplémentaire que nous ne voulons pas payer dans les cas
les plus courants où nous voulons exécuter du code qui ne capture pas leur
environnement. Comme les fonctions ne sont jamais autorisées à capturer leur
environnement, la définition et l'utilisation des fonctions n'occasionneront
jamais cette surcharge.</p>
<!--
Closures can capture values from their environment in three ways, which
directly map to the three ways a function can take a parameter: taking
ownership, borrowing mutably, and borrowing immutably. These are encoded in the
three `Fn` traits as follows:
-->
<p>Les fermetures peuvent capturer les valeurs de leur environnement de trois
façons différentes, qui correspondent directement aux trois façons dont une
fonction peut prendre un paramètre : prendre possession, emprunter de manière
immuable et emprunter de manière mutable. Ces moyens sont codés dans les trois
traits <code>Fn</code> comme ceci :</p>
<!--
* `FnOnce` consumes the variables it captures from its enclosing scope, known
  as the closure’s *environment*. To consume the captured variables, the
  closure must take ownership of these variables and move them into the closure
  when it is defined. The `Once` part of the name represents the fact that the
  closure can’t take ownership of the same variables more than once, so it can
  be called only once.
* `FnMut` can change the environment because it mutably borrows values.
* `Fn` borrows values from the environment immutably.
-->
<ul>
<li><code>FnOnce</code> consomme les variables qu'il capture à partir de sa portée, connu
sous le nom de <em>l'environnement</em> de la fermeture. Pour consommer les variables
capturées, la fermeture doit prendre possession de ces variables et les
déplacer dans la fermeture lorsqu'elle est définie. La partie <code>Once</code> du nom
représente le fait que la fermeture ne puisse pas prendre prendre possession
des mêmes variables plus d'une fois, donc elle ne peut être appelée qu'une
seule fois.</li>
<li><code>FnMut</code> peut changer l'environnement car elle emprunte des valeurs de manière
mutable.</li>
<li><code>Fn</code> emprunte des valeurs de l'environnement de manière immuable.</li>
</ul>
<!--
When you create a closure, Rust infers which trait to use based on how the
closure uses the values from the environment. All closures implement `FnOnce`
because they can all be called at least once. Closures that don’t move the
captured variables also implement `FnMut`, and closures that don’t need mutable
access to the captured variables also implement `Fn`. In Listing 13-12, the
`equal_to_x` closure borrows `x` immutably (so `equal_to_x` has the `Fn` trait)
because the body of the closure only needs to read the value in `x`.
-->
<p>Lorsque nous créons une fermeture, Rust déduit quel trait utiliser en se basant
sur la façon dont la fermeture utilise les valeurs de l'environnement. Toutes
les fermetures implémentent <code>FnOne</code> car elles peuvent toute être appelées au
moins une fois. Les fermetures qui ne déplacent pas les variables capturées
implémentent également <code>FnMut</code>, et les fermetures qui n'ont pas besoin d'accès
mutable aux variables capturées implémentent aussi <code>Fn</code>. Dans l'encart 13-12, la
fermeture <code>egal_a_x</code> emprunte <code>x</code> immuablement (donc <code>egal_a_x</code> a le trait <code>Fn</code>)
parce que le corps de la fermeture ne fait que lire la valeur de <code>x</code>.</p>
<!--
If you want to force the closure to take ownership of the values it uses in the
environment, you can use the `move` keyword before the parameter list. This
technique is mostly useful when passing a closure to a new thread to move the
data so it’s owned by the new thread.
-->
<p>Si nous voulons forcer la fermeture à prendre possession des valeurs qu'elle
utilise dans l'environnement, nous pouvons utiliser le mot-clé <code>move</code> avant la
liste des paramètres. Cette technique est très utile lorsque vous passez une
fermeture à une nouvelle tâche pour déplacer les données afin qu'elles
appartiennent à la nouvelle tâche.</p>
<!--
> Note: `move` closures may still implement `Fn` or `FnMut`, even though
> they capture variables by move. This is because the traits implemented by a
> closure type are determined by what the closure does with captured values,
> not how it captures them. The `move` keyword only specifies the latter.
-->
<blockquote>
<p>Remarque : les fermetures <code>move</code> peuvent toujours implémenter <code>Fn</code> ou
<code>FnMut</code>, même si elles capturent les variables en les déplaçant. C'est
possible car les traits implémentés par un type de fermeture sont déterminés
par ce que font ces fermetures avec les valeurs déplacées, et non pas comment
elles les capturent. Le mot-clé <code>move</code> ne définit que cette dernière.</p>
</blockquote>
<!--
We’ll have more examples of `move` closures in Chapter 16 when we talk about
concurrency. For now, here’s the code from Listing 13-12 with the `move`
keyword added to the closure definition and using vectors instead of integers,
because integers can be copied rather than moved; note that this code will not
yet compile.
-->
<p>Nous aurons d'autres exemples de fermetures utilisant <code>move</code> au chapitre 16
lorsque nous parlerons de la concurrence. Pour l'instant, voici le code de
l'encart 13-12 avec le mot-clé <code>move</code> ajouté à la définition de la fermeture et
utilisant des vecteurs au lieu d'entiers, car les entiers peuvent être copiés
plutôt que déplacés ; notez aussi que ce code ne compile pas encore.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!("can't use x here: {:?}", x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = vec![1, 2, 3];

    let egal_a_x = move |z| z == x;

    println!(&quot;On ne peut pas utiliser x ici : {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(egal_a_x(y));
}
</code></pre>
<!--
We receive the following error:
-->
<p>Nous obtenons l'erreur suivante :</p>
<!--
```console
$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0382]: borrow of moved value: `x`
 -- > src/main.rs:6:40
  |
2 |     let x = vec![1, 2, 3];
  |         - move occurs because `x` has type `Vec<i32>`, which does not implement the `Copy` trait
3 | 
4 |     let equal_to_x = move |z| z == x;
  |                      --------      - variable moved due to use in closure
  |                      |
  |                      value moved into closure here
5 | 
6 |     println!("can't use x here: {:?}", x);
  |                                        ^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `equal-to-x` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0382]: borrow of moved value: `x`
 --&gt; src/main.rs:6:40
  |
2 |     let x = vec![1, 2, 3];
  |         - move occurs because `x` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
3 | 
4 |     let egal_a_x = move |z| z == x;
  |                    --------      - variable moved due to use in closure
  |                    |
  |                    value moved into closure here
5 | 
6 |     println!(&quot;On ne peut pas utiliser x ici : {:?}&quot;, x);
  |                                                      ^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `equal-to-x` due to previous error
</code></pre>
<!--
The `x` value is moved into the closure when the closure is defined, because we
added the `move` keyword. The closure then has ownership of `x`, and `main`
isn’t allowed to use `x` anymore in the `println!` statement. Removing
`println!` will fix this example.
-->
<p>La valeur <code>x</code> est déplacée dans la fermeture lorsque la fermeture est définie,
parce que nous avons ajouté le mot-clé <code>move</code>. La fermeture a alors la propriété
de <code>x</code>, et <code>main</code> n'est plus autorisé à utiliser <code>x</code> dans l'instruction
<code>println!</code>. Supprimer <code>println!</code> corrigera cet exemple.</p>
<!--
Most of the time when specifying one of the `Fn` trait bounds, you can start
with `Fn` and the compiler will tell you if you need `FnMut` or `FnOnce` based
on what happens in the closure body.
-->
<p>La plupart du temps, lorsque vous renseignez l'un des traits liés <code>Fn</code>, vous
pouvez commencer par <code>Fn</code> et le compilateur vous dira si vous avez besoin de
<code>FnMut</code> ou <code>FnOnce</code> en fonction de ce qui se passe dans le corps de la
fermeture.</p>
<!--
To illustrate situations where closures that can capture their environment are
useful as function parameters, let’s move on to our next topic: iterators.
-->
<p>Pour illustrer les situations où des fermetures qui capturent leur
environnement sont utiles comme paramètres de fonction, passons à notre
sujet suivant : les itérateurs.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Processing a Series of Items with Iterators
-->
<h2 id="traiter-une-série-déléments-avec-un-itérateur"><a class="header" href="#traiter-une-série-déléments-avec-un-itérateur">Traiter une série d'éléments avec un itérateur</a></h2>
<!--
The iterator pattern allows you to perform some task on a sequence of items in
turn. An iterator is responsible for the logic of iterating over each item and
determining when the sequence has finished. When you use iterators, you don’t
have to reimplement that logic yourself.
-->
<p>Les itérateurs vous permettent d'effectuer une tâche sur une séquence d'éléments
à tour de rôle. Un <em>itérateur</em> est responsable de la logique d'itération sur
chaque élément et de déterminer lorsque la séquence est terminée. Lorsque nous
utilisons des itérateurs, nous n'avons pas besoin de ré-implémenter cette
logique nous-mêmes.</p>
<!--
In Rust, iterators are *lazy*, meaning they have no effect until you call
methods that consume the iterator to use it up. For example, the code in
Listing 13-13 creates an iterator over the items in the vector `v1` by calling
the `iter` method defined on `Vec<T>`. This code by itself doesn’t do anything
useful.
-->
<p>En Rust, un itérateur est <em>une évaluation paresseuse</em>, ce qui signifie qu'il n'a
aucun effet jusqu'à ce que nous appelions des méthodes qui consomment
l'itérateur pour l'utiliser. Par exemple, le code dans l'encart 13-13 crée un
itérateur sur les éléments du vecteur <code>v1</code> en appelant la méthode <code>iter</code> définie
sur <code>Vec&lt;T&gt;</code>. Ce code en lui-même ne fait rien d'utile.</p>
<!--
```rust
# fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-13: Creating an iterator</span>
-->
<p><span class="caption">Encart 13-13 : création d'un itérateur</span></p>
<!--
Once we’ve created an iterator, we can use it in a variety of ways. In Listing
3-5 in Chapter 3, we used iterators with `for` loops to execute some code on
each item, although we glossed over what the call to `iter` did until now.
-->
<p>Une fois que nous avons créé un itérateur, nous pouvons l'utiliser de diverses
manières. Dans l'encart 3-4 du chapitre 3, nous avions utilisé des itérateurs
avec des boucles <code>for</code> pour exécuter du code sur chaque élément, bien que nous
ayons laissé de côté ce que l'appel à <code>iter</code> faisait jusqu'à présent.</p>
<!--
The example in Listing 13-14 separates the creation of the iterator from the
use of the iterator in the `for` loop. The iterator is stored in the `v1_iter`
variable, and no iteration takes place at that time. When the `for` loop is
called using the iterator in `v1_iter`, each element in the iterator is used in
one iteration of the loop, which prints out each value.
-->
<p>L'exemple dans l'encart 13-14 sépare la création de l'itérateur de son
utilisation dans la boucle <code>for</code>. L'itérateur est stocké dans la variable
<code>v1_iter</code>, et aucune itération n'a lieu à ce moment-là. Lorsque la boucle <code>for</code>
est appelée en utilisant l'itérateur <code>v1_iter</code>, chaque élément de l'itérateur
est utilisé à chaque itération de la boucle, qui affiche chaque valeur.</p>
<!--
```rust
# fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("Got: {}", val);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!(&quot;On a : {}&quot;, val);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-14: Using an iterator in a `for` loop</span>
-->
<p><span class="caption">Encart 13-14 : utilisation d'un itérateur dans une boucle
<code>for</code></span></p>
<!--
In languages that don’t have iterators provided by their standard libraries,
you would likely write this same functionality by starting a variable at index
0, using that variable to index into the vector to get a value, and
incrementing the variable value in a loop until it reached the total number of
items in the vector.
-->
<p>Dans les langages qui n'ont pas d'itérateurs fournis par leur bibliothèque
standard, nous écririons probablement cette même fonctionnalité en démarrant une
variable à l'indice 0, utiliser cette variable comme indice sur le vecteur afin
d'obtenir une valeur, et incrémenter la valeur de cette variable dans une boucle
jusqu'à ce qu'elle atteigne le nombre total d'éléments dans le vecteur.</p>
<!--
Iterators handle all that logic for you, cutting down on repetitive code you
could potentially mess up. Iterators give you more flexibility to use the same
logic with many different kinds of sequences, not just data structures you can
index into, like vectors. Let’s examine how iterators do that.
-->
<p>Les itérateurs s'occupent de toute cette logique pour nous, réduisant le code
redondant dans lequel nous pourrions potentiellement faire des erreurs. Les
itérateurs nous donnent plus de flexibilité pour utiliser la même logique avec
de nombreux types de séquences différentes, et non pas uniquement avec des
structures de données avec lesquelles nous pouvons utiliser des indices, comme
les vecteurs. Voyons comment les itérateurs font cela.</p>
<!--
### The `Iterator` Trait and the `next` Method
-->
<h3 id="le-trait-iterator-et-la-méthode-next"><a class="header" href="#le-trait-iterator-et-la-méthode-next">Le trait <code>Iterator</code> et la méthode <code>next</code></a></h3>
<!--
All iterators implement a trait named `Iterator` that is defined in the
standard library. The definition of the trait looks like this:
-->
<p>Tous les itérateurs implémentent un trait appelé <code>Iterator</code> qui est défini dans
la bibliothèque standard. La définition du trait ressemble à ceci :</p>
<!--
```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // les méthodes avec des implémentations par défaut ont été exclues
}
<span class="boring">}
</span></code></pre></pre>
<!--
Notice this definition uses some new syntax: `type Item` and `Self::Item`,
which are defining an *associated type* with this trait. We’ll talk about
associated types in depth in Chapter 19. For now, all you need to know is that
this code says implementing the `Iterator` trait requires that you also define
an `Item` type, and this `Item` type is used in the return type of the `next`
method. In other words, the `Item` type will be the type returned from the
iterator.
-->
<p>Remarquez que cette définition utilise une nouvelle syntaxe : <code>type Item</code> et
<code>Self::Item</code>, qui définissent un <em>type associé</em> à ce trait. Nous verrons ce que
sont les types associés au chapitre 19. Pour l'instant, tout ce que vous devez
savoir est que ce code dit que l'implémentation du trait <code>Iterator</code> nécessite
que vous définissiez aussi un type <code>Item</code>, et ce type <code>Item</code> est utilisé dans le
type de retour de la méthode <code>next</code>. En d'autres termes, le type <code>Item</code> sera le
type retourné par l'itérateur.</p>
<!--
The `Iterator` trait only requires implementors to define one method: the
`next` method, which returns one item of the iterator at a time wrapped in
`Some` and, when iteration is over, returns `None`.
-->
<p>Le trait <code>Iterator</code> exige la définition d'une seule méthode par les
développeurs : la méthode <code>next</code>, qui retourne un élément de l'itérateur à la
fois intégré dans un <code>Some</code>, et lorsque l'itération est terminée, il retourne
<code>None</code>.</p>
<!--
We can call the `next` method on iterators directly; Listing 13-15 demonstrates
what values are returned from repeated calls to `next` on the iterator created
from the vector.
-->
<p>On peut appeler la méthode <code>next</code> directement sur les itérateurs ; l'encart
13-15 montre quelles valeurs sont retournées par des appels répétés à <code>next</code> sur
l'itérateur créé à partir du vecteur.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# #[cfg(test)]
# mod tests {
    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&1));
        assert_eq!(v1_iter.next(), Some(&2));
        assert_eq!(v1_iter.next(), Some(&3));
        assert_eq!(v1_iter.next(), None);
    }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn demo_iterateur() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-15: Calling the `next` method on an
iterator</span>
-->
<p><span class="caption">Encart 13-15 : appel de la méthode <code>next</code> sur un itérateur
</span></p>
<!--
Note that we needed to make `v1_iter` mutable: calling the `next` method on an
iterator changes internal state that the iterator uses to keep track of where
it is in the sequence. In other words, this code *consumes*, or uses up, the
iterator. Each call to `next` eats up an item from the iterator. We didn’t need
to make `v1_iter` mutable when we used a `for` loop because the loop took
ownership of `v1_iter` and made it mutable behind the scenes.
-->
<p>Remarquez que nous avons eu besoin de rendre mutable <code>v1_iter</code> : appeler la
méthode <code>next</code> sur un iterator change son état interne qui garde en mémoire où
il est dans la séquence. En d'autres termes, ce code <em>consomme</em>, ou utilise,
l'itérateur. Chaque appel à <code>next</code> consomme un élément de l'itérateur. Nous
n'avions pas eu besoin de rendre mutable <code>v1_iter</code> lorsque nous avions utilisé
une boucle <code>for</code> parce que la boucle avait pris possession de <code>v1_iter</code> et l'a
rendu mutable en coulisses.</p>
<!--
Also note that the values we get from the calls to `next` are immutable
references to the values in the vector. The `iter` method produces an iterator
over immutable references. If we want to create an iterator that takes
ownership of `v1` and returns owned values, we can call `into_iter` instead of
`iter`. Similarly, if we want to iterate over mutable references, we can call
`iter_mut` instead of `iter`.
-->
<p>Notez également que les valeurs que nous obtenons des appels à <code>next</code> sont des
références immuables aux valeurs dans le vecteur. La méthode <code>iter</code> produit un
itérateur pour des références immuables. Si nous voulons créer un itérateur qui
prend possession de <code>v1</code> et retourne les valeurs possédées, nous pouvons appeler
<code>into_iter</code> au lieu de <code>iter</code>. De même, si nous voulons itérer sur des
références mutables, nous pouvons appeler <code>iter_mut</code> au lieu de <code>iter</code>.</p>
<!--
### Methods that Consume the Iterator
-->
<h3 id="les-méthodes-qui-consomment-un-itérateur"><a class="header" href="#les-méthodes-qui-consomment-un-itérateur">Les méthodes qui consomment un itérateur</a></h3>
<!--
The `Iterator` trait has a number of different methods with default
implementations provided by the standard library; you can find out about these
methods by looking in the standard library API documentation for the `Iterator`
trait. Some of these methods call the `next` method in their definition, which
is why you’re required to implement the `next` method when implementing the
`Iterator` trait.
-->
<p>Le trait <code>Iterator</code> a un certain nombre de méthodes différentes avec des
implémentations par défaut que nous fournit la bibliothèque standard ; vous
pouvez découvrir ces méthodes en regardant dans la documentation de l'API de la
bibliothèque standard pour le trait <code>Iterator</code>. Certaines de ces méthodes
appellent la méthode <code>next</code> dans leur définition, c'est pourquoi nous devons
toujours implémenter la méthode <code>next</code> lors de l'implémentation du trait
<code>Iterator</code>.</p>
<!--
Methods that call `next` are called *consuming adaptors*, because calling them
uses up the iterator. One example is the `sum` method, which takes ownership of
the iterator and iterates through the items by repeatedly calling `next`, thus
consuming the iterator. As it iterates through, it adds each item to a running
total and returns the total when iteration is complete. Listing 13-16 has a
test illustrating a use of the `sum` method:
-->
<p>Les méthodes qui appellent <code>next</code> sont appelées des
<em>adaptateurs de consommation</em>, parce que les appeler consomme l'itérateur. Un
exemple est la méthode <code>sum</code>, qui prend possession de l'itérateur et itére sur
ses éléments en appelant plusieurs fois <code>next</code>, consommant ainsi l'itérateur. A
chaque étape de l'itération, il ajoute chaque élément à un total en cours et
retourne le total une fois l'itération terminée. L'encart 13-16 a un test
illustrant une utilisation de la méthode <code>sum</code> :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# #[cfg(test)]
# mod tests {
    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-16: Calling the `sum` method to get the total
of all items in the iterator</span>
-->
<p><span class="caption">Encart 13-16 : appel de la méthode <code>sum</code> pour obtenir la
somme de tous les éléments présents dans l'itérateur</span></p>
<!--
We aren’t allowed to use `v1_iter` after the call to `sum` because `sum` takes
ownership of the iterator we call it on.
-->
<p>Nous ne sommes pas autorisés à utiliser <code>v1_iter</code> après l'appel à <code>sum</code> car
<code>sum</code> a pris possession de l'itérateur sur lequel nous l'appelons.</p>
<!--
### Methods that Produce Other Iterators
-->
<h3 id="méthodes-qui-produisent-dautres-itérateurs"><a class="header" href="#méthodes-qui-produisent-dautres-itérateurs">Méthodes qui produisent d'autres itérateurs</a></h3>
<!--
Other methods defined on the `Iterator` trait, known as *iterator adaptors*,
allow you to change iterators into different kinds of iterators. You can chain
multiple calls to iterator adaptors to perform complex actions in a readable
way. But because all iterators are lazy, you have to call one of the consuming
adaptor methods to get results from calls to iterator adaptors.
-->
<p>D'autres méthodes définies sur le trait <code>Iterator</code>, connues sous le nom
<em>d'adaptateurs d'itération</em>, nous permettent de transformer un itérateur en un
type d'itérateur différent. Nous pouvons enchaîner plusieurs appels à des
adaptateurs d'itération pour effectuer des actions complexes de manière
compréhensible. Mais comme les itérateurs sont <em>des évaluations paresseuses</em>,
nous devons faire appel à l'une des méthodes d'adaptation de consommation pour
obtenir les résultats des appels aux adaptateurs d'itération.</p>
<!--
Listing 13-17 shows an example of calling the iterator adaptor method `map`,
which takes a closure to call on each item to produce a new iterator. The
closure here creates a new iterator in which each item from the vector has been
incremented by 1. However, this code produces a warning:
-->
<p>L'encart 13-17 montre un exemple d'appel à la méthode d'adaptation d'itération
<code>map</code>, qui prend en paramètre une fermeture qui va s'exécuter sur chaque élément
pour produire un nouvel itérateur. La fermeture crée ici un nouvel itérateur
dans lequel chaque élément du vecteur a été incrémenté de 1. Cependant, ce code
déclenche un avertissement :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,not_desired_behavior
# fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
# }
```
-->
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-17: Calling the iterator adaptor `map` to
create a new iterator</span>
-->
<p><span class="caption">Encart 13-17 : appel de l'adaptateur d'itération <code>map</code>
pour créer un nouvel itérateur</span></p>
<!--
The warning we get is this:
-->
<p>Voici l'avertissement que nous obtenons :</p>
<!--
```console
$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `std::iter::Map` that must be used
 -- > src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
```
-->
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `std::iter::Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<!--
The code in Listing 13-17 doesn’t do anything; the closure we’ve specified
never gets called. The warning reminds us why: iterator adaptors are lazy, and
we need to consume the iterator here.
-->
<p>Le code dans l'encart 13-17 ne fait rien ; la fermeture que nous avons renseigné
n'est jamais exécuté. L'avertissement nous rappelle pourquoi : les adaptateurs
d'itération sont des <em>évaluations paresseuses</em>, c'est pourquoi nous devons
consommer l'itérateur ici.</p>
<!--
To fix this and consume the iterator, we’ll use the `collect` method, which we
used in Chapter 12 with `env::args` in Listing 12-1. This method consumes the
iterator and collects the resulting values into a collection data type.
-->
<p>Pour corriger ceci et consommer l'itérateur, nous utiliserons la méthode
<code>collect</code>, que vous avez utilisé avec <code>env::args</code> dans l'encart 12-1 du
chapitre 12. Cette méthode consomme l'itérateur et collecte les valeurs
résultantes dans un type de collection de données.</p>
<!--
In Listing 13-18, we collect the results of iterating over the iterator that’s
returned from the call to `map` into a vector. This vector will end up
containing each item from the original vector incremented by 1.
-->
<p>Dans l'encart 13-18, nous recueillons les résultats de l'itération sur
l'itérateur qui sont retournés par l'appel à <code>map</code> sur un vecteur. Ce vecteur
finira par contenir chaque élément du vecteur original incrémenté de 1.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-18: Calling the `map` method to create a new
iterator and then calling the `collect` method to consume the new iterator and
create a vector</span>
-->
<p><span class="caption">Encart 13-18 : appel de la méthode <code>map</code> pour créer un
nouvel itérateur, puis appel de la méthode <code>collect</code> pour consommer le nouvel
itérateur afin de créer un vecteur</span></p>
<!--
Because `map` takes a closure, we can specify any operation we want to perform
on each item. This is a great example of how closures let you customize some
behavior while reusing the iteration behavior that the `Iterator` trait
provides.
-->
<p>Comme <code>map</code> prend en paramètre une fermeture, nous pouvons renseigner n'importe
quelle opération que nous souhaitons exécuter sur chaque élément. C'est un bon
exemple de la façon dont les fermetures nous permettent de personnaliser
certains comportements tout en réutilisant le comportement d'itération fourni
par le trait <code>Iterator</code>.</p>
<!--
### Using Closures that Capture Their Environment
-->
<h3 id="utilisation-de-fermetures-capturant-leur-environnement"><a class="header" href="#utilisation-de-fermetures-capturant-leur-environnement">Utilisation de fermetures capturant leur environnement</a></h3>
<!--
Now that we’ve introduced iterators, we can demonstrate a common use of
closures that capture their environment by using the `filter` iterator adaptor.
The `filter` method on an iterator takes a closure that takes each item from
the iterator and returns a Boolean. If the closure returns `true`, the value
will be included in the iterator produced by `filter`. If the closure returns
`false`, the value won’t be included in the resulting iterator.
-->
<p>Maintenant que nous avons présenté les itérateurs, nous pouvons illustrer une
utilisation commune des fermetures qui capturent leur environnement en utilisant
l'adaptateur d'itération <code>filter</code>. La méthode <code>filter</code> appelée sur un itérateur
prend en paramètre une fermeture qui s'exécute sur chaque élément de l'itérateur
et retourne un booléen pour chacun. Si la fermeture retourne <code>true</code>, la valeur
sera incluse dans l'itérateur produit par <code>filter</code>. Si la fermeture retourne
<code>false</code>, la valeur ne sera pas incluse dans l'itérateur résultant.</p>
<!--
In Listing 13-19, we use `filter` with a closure that captures the `shoe_size`
variable from its environment to iterate over a collection of `Shoe` struct
instances. It will return only shoes that are the specified size.
-->
<p>Dans l'encart 13-19, nous utilisons <code>filter</code> avec une fermeture qui capture la
variable <code>pointure_chaussure</code> de son environnement pour itérer sur une
collection d'instances de la structure <code>Chaussure</code>. Il ne retournera que les
chaussures avec la pointure demandée.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_my_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}

fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(PartialEq, Debug)]
struct Chaussure {
    pointure: u32,
    style: String,
}

fn chaussures_a_la_pointure(chaussures: Vec&lt;Chaussure&gt;, pointure_chaussure: u32) -&gt; Vec&lt;Chaussure&gt; {
    chaussures.into_iter()
              .filter(|s| s.pointure == pointure_chaussure)
              .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filtres_par_pointure() {
        let chaussures = vec![
            Chaussure {
                pointure: 10,
                style: String::from(&quot;baskets&quot;),
            },
            Chaussure {
                pointure: 13,
                style: String::from(&quot;sandale&quot;),
            },
            Chaussure {
                pointure: 10,
                style: String::from(&quot;bottes&quot;),
            },
        ];

        let a_ma_pointure = chaussures_a_la_pointure(chaussures, 10);

        assert_eq!(
            a_ma_pointure,
            vec![
                Chaussure {
                    pointure: 10,
                    style: String::from(&quot;baskets&quot;)
                },
                Chaussure {
                    pointure: 10,
                    style: String::from(&quot;bottes&quot;)
                },
            ]
        );
    }
}

fn main() {}
</code></pre></pre>
<!--
<span class="caption">Listing 13-19: Using the `filter` method with a closure
that captures `shoe_size`</span>
-->
<p><span class="caption">Encart 13-19 : utilisation de la méthode <code>filter</code> avec une
fermeture capturant <code>pointure_chaussure</code></span></p>
<!--
The `shoes_in_my_size` function takes ownership of a vector of shoes and a shoe
size as parameters. It returns a vector containing only shoes of the specified
size.
-->
<p>La fonction <code>chaussures_a_la_pointure</code> prend possession d'un vecteur de
chaussures et d'une pointure comme paramètres. Il retourne un vecteur contenant
uniquement des chaussures de la pointure demandée.</p>
<!--
In the body of `shoes_in_my_size`, we call `into_iter` to create an iterator
that takes ownership of the vector. Then we call `filter` to adapt that
iterator into a new iterator that only contains elements for which the closure
returns `true`.
-->
<p>Dans le corps de <code>chaussures_a_la_pointure</code>, nous appelons <code>into_iter</code> pour
créer un itérateur qui prend possession du vecteur. Ensuite, nous appelons
<code>filter</code> pour adapter cet itérateur dans un nouvel itérateur qui ne contient que
les éléments pour lesquels la fermeture retourne <code>true</code>.</p>
<!--
The closure captures the `shoe_size` parameter from the environment and
compares the value with each shoe’s size, keeping only shoes of the size
specified. Finally, calling `collect` gathers the values returned by the
adapted iterator into a vector that’s returned by the function.
-->
<p>La fermeture capture le paramètre <code>pointure_chaussure</code> de l'environnement et
compare la valeur avec la pointure de chaque chaussure, en ne gardant que les
chaussures de la pointure spécifiée. Enfin, l'appel à <code>collect</code> retourne un
vecteur qui regroupe les valeurs renvoyées par l'itérateur.</p>
<!--
The test shows that when we call `shoes_in_my_size`, we get back only shoes
that have the same size as the value we specified.
-->
<p>Le test confirme que lorsque nous appelons <code>chaussures_a_la_pointure</code>, nous
n'obtenons que des chaussures qui ont la même pointure que la valeur que nous
avons demandé.</p>
<!--
### Creating Our Own Iterators with the `Iterator` Trait
-->
<h3 id="créer-nos-propres-itérateurs-avec-le-trait-iterator"><a class="header" href="#créer-nos-propres-itérateurs-avec-le-trait-iterator">Créer nos propres itérateurs avec le trait <code>Iterator</code></a></h3>
<!--
We’ve shown that you can create an iterator by calling `iter`, `into_iter`, or
`iter_mut` on a vector. You can create iterators from the other collection
types in the standard library, such as hash map. You can also create iterators
that do anything you want by implementing the `Iterator` trait on your own
types. As previously mentioned, the only method you’re required to provide a
definition for is the `next` method. Once you’ve done that, you can use all
other methods that have default implementations provided by the `Iterator`
trait!
-->
<p>Nous avons vu que nous pouvons créer un itérateur en appelant <code>iter</code>,
<code>into_iter</code>, ou <code>iter_mut</code> sur un vecteur. Nous pouvons créer des itérateurs à
partir d'autres types de collections de la bibliothèque standard, comme les
tables de hachage. Nous pouvons aussi créer des itérateurs qui font tout ce que
nous voulons en implémentant le trait <code>Iterator</code> sur nos propres types. Comme
nous l'avons mentionné précédemment, la seule méthode pour laquelle nous devons
fournir une définition est la méthode <code>next</code>. Une fois que nous avons fait cela,
nous pouvons utiliser toutes les autres méthodes qui ont des implémentations par
défaut fournies par le trait <code>Iterator</code> !</p>
<!--
To demonstrate, let’s create an iterator that will only ever count from 1 to 5.
First, we’ll create a struct to hold some values. Then we’ll make this struct
into an iterator by implementing the `Iterator` trait and using the values in
that implementation.
-->
<p>Pour preuve, créons un itérateur qui ne comptera que de 1 à 5. D'abord, nous
allons créer une structure contenant quelques valeurs. Ensuite nous
transformerons cette structure en itérateur en implémentant le trait <code>Iterator</code>
et nous utiliserons les valeurs de cette implémentation.</p>
<!--
Listing 13-20 has the definition of the `Counter` struct and an associated
`new` function to create instances of `Counter`:
-->
<p>L'encart 13-20 montre la définition de la structure <code>Compteur</code> et une fonction
associée <code>new</code> pour créer des instances de <code>Compteur</code> :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}

fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Compteur {
    compteur: u32,
}

impl Compteur {
    fn new() -&gt; Compteur {
        Compteur { compteur: 0 }
    }
}

fn main() {}
</code></pre></pre>
<!--
<span class="caption">Listing 13-20: Defining the `Counter` struct and a `new`
function that creates instances of `Counter` with an initial value of 0 for
`count`</span>
-->
<p><span class="caption">Encart 13-20 : définition de la structure <code>Compteur</code> et
d'une fonction <code>new</code> qui crée des instances de <code>Compteur</code> avec une valeur
initiale de 0 pour le champ <code>compteur</code>.</span></p>
<!--
The `Counter` struct has one field named `count`. This field holds a `u32`
value that will keep track of where we are in the process of iterating from 1
to 5. The `count` field is private because we want the implementation of
`Counter` to manage its value. The `new` function enforces the behavior of
always starting new instances with a value of 0 in the `count` field.
-->
<p>La structure <code>Compteur</code> a un champ <code>compteur</code>. Ce champ contient une valeur
<code>u32</code> qui gardera la trace de l'endroit où nous sommes dans le processus
d'itération de 1 à 5. Le champ <code>compteur</code> est privé car nous voulons que ce soit
l'implémentation de <code>Compteur</code> qui gère sa valeur. La fonction <code>new</code> impose le
de toujours démarrer de nouvelles instances avec une valeur de 0 pour le champ
<code>compteur</code>.</p>
<!--
Next, we’ll implement the `Iterator` trait for our `Counter` type by defining
the body of the `next` method to specify what we want to happen when this
iterator is used, as shown in Listing 13-21:
-->
<p>Ensuite, nous allons implémenter le trait <code>Iterator</code> sur notre type <code>Compteur</code>
en définissant le corps de la méthode <code>next</code> pour préciser ce que nous voulons
qu'il se passe quand cet itérateur est utilisé, comme dans l'encart 13-21 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Compteur {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.compteur &lt; 5 {
            self.compteur += 1;
            Some(self.compteur)
        } else {
            None
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-21: Implementing the `Iterator` trait on our
`Counter` struct</span>
-->
<p><span class="caption">Encart 13-21 : implémentation du trait <code>Iterator</code> sur
notre structure <code>Compteur</code></span></p>
<!--
We set the associated `Item` type for our iterator to `u32`, meaning the
iterator will return `u32` values. Again, don’t worry about associated types
yet, we’ll cover them in Chapter 19.
-->
<p>Nous avons défini le type associé <code>Item</code> pour notre itérateur à <code>u32</code>, ce qui
signifie que l'itérateur renverra des valeurs <code>u32</code>. Encore une fois, ne vous
préoccupez pas des types associés, nous les aborderons au chapitre 19.</p>
<!--
We want our iterator to add 1 to the current state, so we initialized `count`
to 0 so it would return 1 first. If the value of `count` is less than 5, `next`
will increment `count` and return the current value wrapped in `Some`. Once
`count` is 5, our iterator will stop incrementing `count` and always return
`None`.
-->
<p>Nous voulons que notre itérateur ajoute 1 à l'état courant, donc nous avons
initialisé <code>compteur</code> à 0 pour qu'il retourne 1 lors du premier appel à <code>next</code>.
Si la valeur de <code>compteur</code> est strictement inférieure à 5, <code>next</code> va incrémenter
<code>compteur</code> puis va retourner valeur courante intégrée dans un <code>Some</code>. Une fois
que <code>compteur</code> vaudra 5, notre itérateur va arrêter d'incrémenter <code>compteur</code> et
retournera toujours <code>None</code>.</p>
<!--
#### Using Our `Counter` Iterator’s `next` Method
-->
<h3 id="utiliser-la-méthode-next-de-notre-itérateur-compteur"><a class="header" href="#utiliser-la-méthode-next-de-notre-itérateur-compteur">Utiliser la méthode <code>next</code> de notre Itérateur <code>Compteur</code></a></h3>
<!--
Once we’ve implemented the `Iterator` trait, we have an iterator! Listing 13-22
shows a test demonstrating that we can use the iterator functionality of our
`Counter` struct by calling the `next` method on it directly, just as we did
with the iterator created from a vector in Listing 13-15.
-->
<p>Une fois que nous avons implémenté le trait <code>Iterator</code>, nous avons un
itérateur ! L'encart 13-22 montre un test démontrant que nous pouvons utiliser
la fonctionnalité d'itération de notre structure <code>Compteur</code> en appelant
directement la méthode <code>next</code>, comme nous l'avons fait avec l'itérateur créé à
partir d'un vecteur dans l'encart 13-15.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
# impl Iterator for Counter {
#     type Item = u32;
# 
#     fn next(&mut self) -> Option<Self::Item> {
#         if self.count < 5 {
#             self.count += 1;
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
    #[test]
    fn calling_next_directly() {
        let mut counter = Counter::new();

        assert_eq!(counter.next(), Some(1));
        assert_eq!(counter.next(), Some(2));
        assert_eq!(counter.next(), Some(3));
        assert_eq!(counter.next(), Some(4));
        assert_eq!(counter.next(), Some(5));
        assert_eq!(counter.next(), None);
    }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Compteur {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.compteur &lt; 5 {
</span><span class="boring">            self.compteur += 1;
</span><span class="boring">            Some(self.compteur)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn appel_direct_a_next() {
        let mut compteur = Compteur::new();

        assert_eq!(compteur.next(), Some(1));
        assert_eq!(compteur.next(), Some(2));
        assert_eq!(compteur.next(), Some(3));
        assert_eq!(compteur.next(), Some(4));
        assert_eq!(compteur.next(), Some(5));
        assert_eq!(compteur.next(), None);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-22: Testing the functionality of the `next`
method implementation</span>
-->
<p><span class="caption">Encart 13-22 : test de l'implémentation de la méthode
<code>next</code></span></p>
<!--
This test creates a new `Counter` instance in the `counter` variable and then
calls `next` repeatedly, verifying that we have implemented the behavior we
want this iterator to have: returning the values from 1 to 5.
-->
<p>Ce test créé une nouvelle instance de <code>Compteur</code> dans la variable <code>compteur</code> et
appelle ensuite <code>next</code> à plusieurs reprises, en vérifiant que nous avons
implémenté le comportement que nous voulions que cet itérateur suive : renvoyer
les valeurs de 1 à 5.</p>
<!--
#### Using Other `Iterator` Trait Methods
-->
<h4 id="utiliser-dautres-méthodes-du-trait-iterator"><a class="header" href="#utiliser-dautres-méthodes-du-trait-iterator">Utiliser d'autres méthodes du trait <code>Iterator</code></a></h4>
<!--
We implemented the `Iterator` trait by defining the `next` method, so we
can now use any `Iterator` trait method’s default implementations as defined in
the standard library, because they all use the `next` method’s functionality.
-->
<p>Maintenant que nous avons implémenté le trait <code>Iterator</code> en définissant la
méthode <code>next</code>, nous pouvons maintenant utiliser les implémentations par défaut
de n'importe quelle méthode du trait <code>Iterator</code> telles que définies dans la
bibliothèque standard, car elles utilisent toutes la méthode <code>next</code>.</p>
<!--
For example, if for some reason we wanted to take the values produced by an
instance of `Counter`, pair them with values produced by another `Counter`
instance after skipping the first value, multiply each pair together, keep only
those results that are divisible by 3, and add all the resulting values
together, we could do so, as shown in the test in Listing 13-23:
-->
<p>Par exemple, si pour une raison quelconque nous voulions prendre les valeurs
produites par une instance de <code>Compteur</code>, les coupler avec des valeurs produites
par une autre instance de <code>Compteur</code> après avoir sauté la première valeur,
multiplier chaque paire ensemble, ne garder que les résultats qui sont
divisibles par 3 et additionner toutes les valeurs résultantes ensemble, nous
pourrions le faire, comme le montre le test dans l'encart 13-23 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
# impl Iterator for Counter {
#     type Item = u32;
# 
#     fn next(&mut self) -> Option<Self::Item> {
#         if self.count < 5 {
#             self.count += 1;
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn calling_next_directly() {
#         let mut counter = Counter::new();
# 
#         assert_eq!(counter.next(), Some(1));
#         assert_eq!(counter.next(), Some(2));
#         assert_eq!(counter.next(), Some(3));
#         assert_eq!(counter.next(), Some(4));
#         assert_eq!(counter.next(), Some(5));
#         assert_eq!(counter.next(), None);
#     }
# 
    #[test]
    fn using_other_iterator_trait_methods() {
        let sum: u32 = Counter::new()
            .zip(Counter::new().skip(1))
            .map(|(a, b)| a * b)
            .filter(|x| x % 3 == 0)
            .sum();
        assert_eq!(18, sum);
    }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Compteur {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.compteur &lt; 5 {
</span><span class="boring">            self.compteur += 1;
</span><span class="boring">            Some(self.compteur)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn appel_direct_a_next() {
</span><span class="boring">        let mut compteur = Compteur::new();
</span><span class="boring">
</span><span class="boring">        assert_eq!(compteur.next(), Some(1));
</span><span class="boring">        assert_eq!(compteur.next(), Some(2));
</span><span class="boring">        assert_eq!(compteur.next(), Some(3));
</span><span class="boring">        assert_eq!(compteur.next(), Some(4));
</span><span class="boring">        assert_eq!(compteur.next(), Some(5));
</span><span class="boring">        assert_eq!(compteur.next(), None);
</span><span class="boring">    }
</span><span class="boring">
</span>    #[test]
    fn utilisation_des_autres_methodes_du_trait_iterator() {
        let somme: u32 = Compteur::new()
            .zip(Compteur::new().skip(1))
            .map(|(a, b)| a * b)
            .filter(|x| x % 3 == 0)
            .sum();
        assert_eq!(18, somme);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-23: Using a variety of `Iterator` trait
methods on our `Counter` iterator</span>
-->
<p><span class="caption">Encart 13-23 : utilisation d'une gamme de méthodes de
traits <code>Iterator</code> sur notre itérateur <code>Counter</code> </span></p>
<!--
Note that `zip` produces only four pairs; the theoretical fifth pair `(5,
None)` is never produced because `zip` returns `None` when either of its input
iterators return `None`.
-->
<p>Notez que <code>zip</code> ne produit que quatre paires ; la cinquième paire théorique
<code>(5, None)</code> n'est jamais produite car <code>zip</code> retourne <code>None</code> lorsque l'un de
ses itérateurs d'entrée retourne <code>None</code>.</p>
<!--
All of these method calls are possible because we specified how the `next`
method works, and the standard library provides default implementations for
other methods that call `next`.
-->
<p>Tous ces appels de méthode sont possibles car nous avons renseigné comment
la méthode <code>next</code> fonctionne et la bibliothèque standard fournit des
implémentations par défaut pour les autres méthodes qui appellent <code>next</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Improving Our I/O Project
-->
<h2 id="amélioration-de-notre-projet-dentréesortie"><a class="header" href="#amélioration-de-notre-projet-dentréesortie">Amélioration de notre projet d'entrée/sortie</a></h2>
<!--
With this new knowledge about iterators, we can improve the I/O project in
Chapter 12 by using iterators to make places in the code clearer and more
concise. Let’s look at how iterators can improve our implementation of the
`Config::new` function and the `search` function.
-->
<p>Grâce à ces nouvelles connaissances sur les itérateurs, nous pouvons améliorer
le projet d'entrée/sortie du chapitre 12 en utilisant des itérateurs pour
rendre certains endroits du code plus clairs et plus concis. Voyons comment les
itérateurs peuvent améliorer notre implémentation de la fonction <code>Config::new</code>
et de la fonction <code>rechercher</code>.</p>
<!--
### Removing a `clone` Using an Iterator
-->
<h3 id="supprimer-lappel-à-clone-à-laide-dun-itérateur"><a class="header" href="#supprimer-lappel-à-clone-à-laide-dun-itérateur">Supprimer l'appel à <code>clone</code> à l'aide d'un itérateur</a></h3>
<!--
In Listing 12-6, we added code that took a slice of `String` values and created
an instance of the `Config` struct by indexing into the slice and cloning the
values, allowing the `Config` struct to own those values. In Listing 13-24,
we’ve reproduced the implementation of the `Config::new` function as it was in
Listing 12-23:
-->
<p>Dans l'encart 12-6, nous avions ajouté du code qui prenait une <em>slice</em> de
<code>String</code> et qui créait une instance de la structure <code>Config</code> en utilisant les
indices de la <em>slice</em> et en clonant les valeurs, permettant ainsi à la
structure <code>Config</code> de posséder ces valeurs. Dans l'encart 13-24, nous avions
reproduit l'implémentation de la fonction <code>Config::new</code> comme était dans
l'encart 12-23 à la fin du chapitre 12 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("il n'y a pas assez d'arguments");
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;il n'y a pas assez d'arguments&quot;);
        }

        let recherche = args[1].clone();
        let nom_fichier = args[2].clone();

        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
<span class="caption">Listing 13-24: Reproduction of the `Config::new` function
from Listing 12-23</span>
-->
<p><span class="caption">Encart 13-24 : reproduction de la fonction <code>Config::new</code>
de la fin du chapitre 12</span></p>
<!--
At the time, we said not to worry about the inefficient `clone` calls because
we would remove them in the future. Well, that time is now!
-->
<p>À ce moment-là, nous avions dit de ne pas s'inquiéter des appels inefficaces à
<code>clone</code> parce que nous les supprimerions à l'avenir. Et bien, ce moment est
venu !</p>
<!--
We needed `clone` here because we have a slice with `String` elements in the
parameter `args`, but the `new` function doesn’t own `args`. To return
ownership of a `Config` instance, we had to clone the values from the `query`
and `filename` fields of `Config` so the `Config` instance can own its values.
-->
<p>Nous avions besoin de <code>clone</code> ici parce que nous avons une slice d'éléments
<code>String</code> dans le paramètre <code>args</code>, mais la fonction <code>new</code> ne possède pas <code>args</code>.
Pour rendre la propriété d'une instance de <code>Config</code>, nous avons dû cloner les
valeurs des champs <code>recherche</code> et <code>nom_fichier</code> de <code>Config</code> pour qu'elle puisse
prendre possession de ses valeurs.</p>
<!--
With our new knowledge about iterators, we can change the `new` function to
take ownership of an iterator as its argument instead of borrowing a slice.
We’ll use the iterator functionality instead of the code that checks the length
of the slice and indexes into specific locations. This will clarify what the
`Config::new` function is doing because the iterator will access the values.
-->
<p>Avec nos nouvelles connaissances sur les itérateurs, nous pouvons changer la
fonction <code>new</code> pour prendre possession d'un itérateur passé en argument au lieu
d'emprunter une <em>slice</em>. Nous utiliserons les fonctionnalités des itérateurs à
la place du code qui vérifie la taille de la slice et qui utilise les indices
des éléments précis. Cela clarifiera ce que la fonction <code>Config::new</code> fait car
l'itérateur accédera aux valeurs.</p>
<!--
Once `Config::new` takes ownership of the iterator and stops using indexing
operations that borrow, we can move the `String` values from the iterator into
`Config` rather than calling `clone` and making a new allocation.
-->
<p>Une fois que <code>Config::new</code> prend possession de l'itérateur et cesse d'utiliser
les opérations avec les indices et d'emprunter les données, nous pouvons
déplacer les valeurs <code>String</code> de l'iterator dans <code>Config</code> plutôt que de faire
appel à <code>clone</code> et de créer par conséquent de nouvelles allocations.</p>
<!--
#### Using the Returned Iterator Directly
-->
<h4 id="utiliser-directement-litérateur-retourné"><a class="header" href="#utiliser-directement-litérateur-retourné">Utiliser directement l'itérateur retourné</a></h4>
<!--
Open your I/O project’s *src/main.rs* file, which should look like this:
-->
<p>Ouvrez le fichier <em>src/main.rs</em> de votre projet d'entrée/sortie, qui devrait
ressembler à ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::process;
# 
# use minigrep::Config;
# 
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        eprintln!("Problème rencontré lors de l'interprétation des arguments : {}", err);
        process::exit(1);
    });

    // -- partie masquée ici --
# 
#     if let Err(e) = minigrep::run(config) {
#         eprintln!("Erreur applicative : {}", e);
# 
#         process::exit(1);
#     }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problème rencontré lors de l'interprétation des arguments : {}&quot;, err);
        process::exit(1);
    });

    // -- partie masquée ici --
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Erreur applicative : {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<!--
We’ll change the start of the `main` function that we had in Listing 12-24 to
the code in Listing 13-25. This won’t compile until we update `Config::new` as
well.
-->
<p>Nous allons changer le début de la fonction <code>main</code> que nous avions dans l'encart
12-24 pour le code dans l'encart 13-25. Ceci ne compilera pas encore jusqu'à ce
que nous mettions également à jour <code>Config::new</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::process;
# 
# use minigrep::Config;
# 
fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!("Problème rencontré lors de l'interprétation des arguments : {}", err);
        process::exit(1);
    });

    // -- partie masquée ici --
# 
#     if let Err(e) = minigrep::run(config) {
#         eprintln!("Erreur applicative : {}", e);
# 
#         process::exit(1);
#     }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Problème rencontré lors de l'interprétation des arguments : {}&quot;, err);
        process::exit(1);
    });

    // -- partie masquée ici --
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Erreur applicative : {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<!--
<span class="caption">Listing 13-25: Passing the return value of `env::args` to
`Config::new`</span>
-->
<p><span class="caption">Encart 13-25 : on passe directement la valeur de retour de
<code>env::args</code> à <code>Config::new</code>.</span></p>
<!--
The `env::args` function returns an iterator! Rather than collecting the
iterator values into a vector and then passing a slice to `Config::new`, now
we’re passing ownership of the iterator returned from `env::args` to
`Config::new` directly.
-->
<p>La fonction <code>env::args</code> retourne un itérateur ! Plutôt que de collecter les
valeurs de l'itérateur dans un vecteur et de passer ensuite une <em>slice</em> à
<code>Config::new</code>, nous passons maintenant la possession de l'itérateur de
<code>env::args</code> directement à <code>Config::new</code>.</p>
<!--
Next, we need to update the definition of `Config::new`. In your I/O project’s
*src/lib.rs* file, let’s change the signature of `Config::new` to look like
Listing 13-26. This still won’t compile because we need to update the function
body.
-->
<p>Ensuite, nous devons mettre à jour la définition de <code>Config::new</code>. Dans le
fichier <em>src/lib.rs</em> de votre projet d'entrée/sortie, modifions la signature de
<code>Config::new</code> pour qu'elle ressemble à l'encart 13-26. Ceci ne compilera pas
encore car nous devons mettre à jour le corps de la fonction.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
impl Config {
    pub fn new(mut args: env::Args) -> Result<Config, &'static str> {
        // -- partie masquée ici --
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();
# 
#         Ok(Config {
#             recherche,
#             nom_fichier,
#             sensible_casse,
#         })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(mut args: env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // -- partie masquée ici --
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            recherche,
</span><span class="boring">            nom_fichier,
</span><span class="boring">            sensible_casse,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-26: Updating the signature of `Config::new` to
expect an iterator</span>
-->
<p><span class="caption">Encart 13-26 : mise à jour de la signature de
<code>Config::new</code> pour recevoir un itérateur</span></p>
<!--
The standard library documentation for the `env::args` function shows that the
type of the iterator it returns is `std::env::Args`. We’ve updated the
signature of the `Config::new` function so the parameter `args` has the type
`std::env::Args` instead of `&[String]`. Because we’re taking ownership of
`args` and we’ll be mutating `args` by iterating over it, we can add the `mut`
keyword into the specification of the `args` parameter to make it mutable.
-->
<p>La documentation de la bibliothèque standard de la fonction <code>env::args</code>
indique que le type de l'itérateur qu'elle renvoie est <code>std::env::Args</code>. Nous
avons mis à jour la signature de la fonction <code>Config::new</code> pour que le
paramètre <code>args</code> ait le type <code>std::env::Args</code> au lieu de <code>&amp;[String]</code>. Etant
donné que nous prenons possession de <code>args</code> et que nous allons muter <code>args</code>
en itérant dessus, nous pouvons ajouter le mot-clé <code>mut</code> dans la spécification
du paramètre <code>args</code> pour le rendre mutable.</p>
<!--
#### Using `Iterator` Trait Methods Instead of Indexing
-->
<h4 id="utilisation-des-méthodes-du-trait-iterator-au-lieu-des-indices"><a class="header" href="#utilisation-des-méthodes-du-trait-iterator-au-lieu-des-indices">Utilisation des méthodes du trait <code>Iterator</code> au lieu des indices</a></h4>
<!--
Next, we’ll fix the body of `Config::new`. The standard library documentation
also mentions that `std::env::Args` implements the `Iterator` trait, so we know
we can call the `next` method on it! Listing 13-27 updates the code from
Listing 12-23 to use the `next` method:
-->
<p>Ensuite corrigeons le corps de <code>Config::new</code>. La documentation de la bibliothèque
standard explique aussi que <code>std::env::Args</code> implémente le trait <code>Iterator</code>, donc
nous savons que nous pouvons appeler la méthode <code>next</code> dessus ! L'encart 13-27
met à jour le code de l'encart 12-23 afin d'utiliser la méthode <code>next</code> :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# use std::env;
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
impl Config {
    pub fn new(mut args: env::Args) -> Result<Config, &'static str> {
        args.next();

        let recherche = match args.next() {
            Some(arg) => arg,
            None => return Err("nous n'avons pas de chaîne de caractères"),
        };

        let nom_fichier = match args.next() {
            Some(arg) => arg,
            None => return Err("nous n'avons pas de nom de fichier"),
        };

        let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
# pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.contains(recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(mut args: env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let recherche = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;nous n'avons pas de chaîne de caractères&quot;),
        };

        let nom_fichier = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;nous n'avons pas de nom de fichier&quot;),
        };

        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();

        Ok(Config {
            recherche,
            nom_fichier,
            sensible_casse,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.contains(recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-27: Changing the body of `Config::new` to use
iterator methods</span>
-->
<p><span class="caption">Encart 13-27 : changement du corps de <code>Config::new</code> afin
d'utiliser les méthodes d'itération</span></p>
<!--
Remember that the first value in the return value of `env::args` is the name of
the program. We want to ignore that and get to the next value, so first we call
`next` and do nothing with the return value. Second, we call `next` to get the
value we want to put in the `query` field of `Config`. If `next` returns a
`Some`, we use a `match` to extract the value. If it returns `None`, it means
not enough arguments were given and we return early with an `Err` value. We do
the same thing for the `filename` value.
-->
<p>Rappelez-vous que la première valeur de ce qui est retourné par <code>env::args</code> est
le nom du programme. Nous voulons ignorer cette valeur et passer à la suivante,
donc d'abord nous appelons une fois <code>next</code> et nous ne faisons rien avec sa
valeur de retour. Ensuite, nous appelons <code>next</code> pour obtenir la valeur que nous
voulons mettre dans le champ <code>recherche</code> de <code>Config</code>. Si <code>next</code> renvoie un
<code>Some</code>, nous utilisons un <code>match</code> pour extraire sa valeur. S'il retourne <code>None</code>,
cela signifie qu'il n'y a pas assez d'arguments donnés et nous revenons plus tôt
avec une valeur <code>Err</code>. De même pour la valeur <code>nom_fichier</code>.</p>
<!--
### Making Code Clearer with Iterator Adaptors
-->
<h3 id="rendre-le-code-plus-clair-avec-des-adaptateurs-ditération"><a class="header" href="#rendre-le-code-plus-clair-avec-des-adaptateurs-ditération">Rendre le code plus clair avec des adaptateurs d'itération</a></h3>
<!--
We can also take advantage of iterators in the `search` function in our I/O
project, which is reproduced here in Listing 13-28 as it was in Listing 12-19:
-->
<p>Nous pouvons également tirer parti des itérateurs dans la fonction
<code>rechercher</code> de notre projet d'entrée/sortie, qui est reproduite ici dans
l'encart 13-28, comme elle l'était dans l'encart 12-19 à la fin du chapitre 12 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
# }
# 
# impl Config {
#     pub fn new(args: &[String]) -> Result<Config, &str> {
#         if args.len() < 3 {
#             return Err("il n'y a pas assez d'arguments");
#         }
# 
#         let recherche = args[1].clone();
#         let nom_fichier = args[2].clone();
# 
#         Ok(Config { recherche, nom_fichier })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     Ok(())
# }
# 
pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn un_resultat() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# sécurité, rapidité, productivité.
# Obtenez les trois en même temps.";
# 
#         assert_eq!(vec!["sécurité, rapidité, productivité."], rechercher(recherche, contenu));
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;il n'y a pas assez d'arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let recherche = args[1].clone();
</span><span class="boring">        let nom_fichier = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { recherche, nom_fichier })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut resultats = Vec::new();

    for ligne in contenu.lines() {
        if ligne.contains(recherche) {
            resultats.push(ligne);
        }
    }

    resultats
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn un_resultat() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">sécurité, rapidité, productivité.
</span><span class="boring">Obtenez les trois en même temps.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;sécurité, rapidité, productivité.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-28: The implementation of the `search`
function from Listing 12-19</span>
-->
<p><span class="caption">Encart 13-28 : La mise en oeuvre de la fonction
<code>rechercher</code> de l'encart 12-19</span></p>
<!--
We can write this code in a more concise way using iterator adaptor methods.
Doing so also lets us avoid having a mutable intermediate `results` vector. The
functional programming style prefers to minimize the amount of mutable state to
make code clearer. Removing the mutable state might enable a future enhancement
to make searching happen in parallel, because we wouldn’t have to manage
concurrent access to the `results` vector. Listing 13-29 shows this change:
-->
<p>Nous pouvons écrire ce code de façon plus concise en utilisant des méthodes
des adaptateurs d'itération. Ce faisant, nous évitons ainsi d'avoir le vecteur
mutable <code>resultats</code>. Le style de programmation fonctionnelle préfère minimiser
la quantité d'états modifiables pour rendre le code plus clair. Supprimer l'état
mutable pourrait nous aider à faire une amélioration future afin que la recherche
se fasse en parallèle, car nous n'aurions pas à gérer l'accès concurrent au
vecteur <code>resultats</code>. L'encart 13-29 montre ce changement :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::env;
# use std::error::Error;
# use std::fs;
# 
# pub struct Config {
#     pub recherche: String,
#     pub nom_fichier: String,
#     pub sensible_casse: bool,
# }
# 
# impl Config {
#     pub fn new(mut args: std::env::Args) -> Result<Config, &'static str> {
#         args.next();
# 
#         let recherche = match args.next() {
#             Some(arg) => arg,
#             None => return Err("nous n'avons pas de chaîne de caractères"),
#         };
# 
#         let nom_fichier = match args.next() {
#             Some(arg) => arg,
#             None => return Err("nous n'avons pas de nom de fichier"),
#         };
# 
#         let sensible_casse = env::var("MINIGREP_INSENSIBLE_CASSE").is_err();
# 
#         Ok(Config {
#             recherche,
#             nom_fichier,
#             sensible_casse,
#         })
#     }
# }
# 
# pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
#     let contenu = fs::read_to_string(config.nom_fichier)?;
# 
#     let resultats = if config.sensible_casse {
#         rechercher(&config.recherche, &contenu)
#     } else {
#         rechercher_insensible_casse(&config.recherche, &contenu)
#     };
# 
#     for ligne in resultats {
#         println!("{}", ligne);
#     }
# 
#     Ok(())
# }
# 
pub fn rechercher<'a>(recherche: &str, contenu: &'a str) -> Vec<&'a str> {
    contenu
        .lines()
        .filter(|ligne| ligne.contains(recherche))
        .collect()
}
# 
# pub fn rechercher_insensible_casse<'a>(
#     recherche: &str,
#     contenu: &'a str,
# ) -> Vec<&'a str> {
#     let recherche = recherche.to_lowercase();
#     let mut resultats = Vec::new();
# 
#     for ligne in contenu.lines() {
#         if ligne.to_lowercase().contains(&recherche) {
#             resultats.push(ligne);
#         }
#     }
# 
#     resultats
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
# 
#     #[test]
#     fn sensible_casse() {
#         let recherche = "duct";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Duct tape.";
# 
#         assert_eq!(vec!["safe, fast, productive."], rechercher(recherche, contenu));
#     }
# 
#     #[test]
#     fn case_insensitive() {
#         let recherche = "rUsT";
#         let contenu = "\
# Rust:
# safe, fast, productive.
# Pick three.
# Trust me.";
# 
#         assert_eq!(
#             vec!["Rust:", "Trust me."],
#             rechercher_insensible_casse(recherche, contenu)
#         );
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub recherche: String,
</span><span class="boring">    pub nom_fichier: String,
</span><span class="boring">    pub sensible_casse: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        args.next();
</span><span class="boring">
</span><span class="boring">        let recherche = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;nous n'avons pas de chaîne de caractères&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let nom_fichier = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;nous n'avons pas de nom de fichier&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let sensible_casse = env::var(&quot;MINIGREP_INSENSIBLE_CASSE&quot;).is_err();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            recherche,
</span><span class="boring">            nom_fichier,
</span><span class="boring">            sensible_casse,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contenu = fs::read_to_string(config.nom_fichier)?;
</span><span class="boring">
</span><span class="boring">    let resultats = if config.sensible_casse {
</span><span class="boring">        rechercher(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    } else {
</span><span class="boring">        rechercher_insensible_casse(&amp;config.recherche, &amp;contenu)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for ligne in resultats {
</span><span class="boring">        println!(&quot;{}&quot;, ligne);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn rechercher&lt;'a&gt;(recherche: &amp;str, contenu: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contenu
        .lines()
        .filter(|ligne| ligne.contains(recherche))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn rechercher_insensible_casse&lt;'a&gt;(
</span><span class="boring">    recherche: &amp;str,
</span><span class="boring">    contenu: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let recherche = recherche.to_lowercase();
</span><span class="boring">    let mut resultats = Vec::new();
</span><span class="boring">
</span><span class="boring">    for ligne in contenu.lines() {
</span><span class="boring">        if ligne.to_lowercase().contains(&amp;recherche) {
</span><span class="boring">            resultats.push(ligne);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    resultats
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn sensible_casse() {
</span><span class="boring">        let recherche = &quot;duct&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], rechercher(recherche, contenu));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let recherche = &quot;rUsT&quot;;
</span><span class="boring">        let contenu = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            rechercher_insensible_casse(recherche, contenu)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 13-29: Using iterator adaptor methods in the
implementation of the `search` function</span>
-->
<p><span class="caption">Encart 13-29 : utilisation des méthodes des adaptateurs
d'itération dans l'implémentation de la fonction <code>rechercher</code></span></p>
<!--
Recall that the purpose of the `search` function is to return all lines in
`contents` that contain the `query`. Similar to the `filter` example in Listing
13-19, this code uses the `filter` adaptor to keep only the lines that
`line.contains(query)` returns `true` for. We then collect the matching lines
into another vector with `collect`. Much simpler! Feel free to make the same
change to use iterator methods in the `search_case_insensitive` function as
well.
-->
<p>Souvenez-vous que le but de la fonction <code>rechercher</code> est de renvoyer toutes
les lignes dans <code>contenu</code> qui contiennent <code>recherche</code>. Comme dans l'exemple de
<code>filter</code> dans l'encart 13-19, nous pouvons utiliser l'adaptateur <code>filter</code>
pour garder uniquement les lignes pour lesquelles <code>ligne.contains(recherche)</code>
renvoie <code>true</code>. Nous collectons ensuite les lignes correspondantes dans un
autre vecteur avec <code>collect</code>. C'est bien plus simple ! N'hésitez pas à faire
le même changement pour utiliser les méthodes d'itération dans la fonction
<code>rechercher_insensible_casse</code>.</p>
<!--
The next logical question is which style you should choose in your own code and
why: the original implementation in Listing 13-28 or the version using
iterators in Listing 13-29. Most Rust programmers prefer to use the iterator
style. It’s a bit tougher to get the hang of at first, but once you get a feel
for the various iterator adaptors and what they do, iterators can be easier to
understand. Instead of fiddling with the various bits of looping and building
new vectors, the code focuses on the high-level objective of the loop. This
abstracts away some of the commonplace code so it’s easier to see the concepts
that are unique to this code, such as the filtering condition each element in
the iterator must pass.
-->
<p>Logiquement la question suivante est de savoir quel style utiliser dans votre
propre code et pourquoi : l'implémentation originale de l'encart 13-28 ou la
version utilisant l'itérateur dans l'encart 13-29. La plupart des développeurs
Rust préfèrent utiliser le style avec l'itérateur. C'est un peu plus difficile
à comprendre au début, mais une fois que vous avez compris les différents
adaptateurs d'itération et de ce qu'ils font, les itérateurs peuvent devenir
plus faciles à comprendre. Au lieu de jongler avec différentes boucles et de
construire de nouveaux vecteurs, ce code se concentre sur l'objectif de haut
niveau de la boucle. Cette abstraction permet d'éliminer une partie du code
trivial, de sorte qu'il soit plus facile de dégager les concepts propres à ce
code, comme le filtrage de chaque élément de l'itérateur qui est appliqué.</p>
<!--
But are the two implementations truly equivalent? The intuitive assumption
might be that the more low-level loop will be faster. Let’s talk about
performance.
-->
<p>Mais ces deux implémentations sont-elles réellement équivalentes ? L'hypothèse
intuitive pourrait être que la boucle de plus bas niveau sera plus rapide.
Intéressons nous maintenant à leurs performances.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Comparing Performance: Loops vs. Iterators
-->
<h2 id="comparaison-des-performances--les-boucles-et-les-itérateurs"><a class="header" href="#comparaison-des-performances--les-boucles-et-les-itérateurs">Comparaison des performances : les boucles et les itérateurs</a></h2>
<!--
To determine whether to use loops or iterators, you need to know which version
of our `search` functions is faster: the version with an explicit `for` loop or
the version with iterators.
-->
<p>Pour déterminer s'il faut utiliser des boucles ou des itérateurs, nous devons
savoir quelle version de notre fonction <code>rechercher</code> est la plus rapide : la
version avec une boucle <code>for</code> explicite ou la version avec des itérateurs ?</p>
<!--
We ran a benchmark by loading the entire contents of *The Adventures of
Sherlock Holmes* by Sir Arthur Conan Doyle into a `String` and looking for the
word *the* in the contents. Here are the results of the benchmark on the
version of `search` using the `for` loop and the version using iterators:
-->
<p>Nous avons lancé un benchmark en chargeant tout le contenu de <em>The Adventures
of Sherlock Holmes</em> de Sir Arthur Conan Doyle dans une <code>String</code> et en cherchant
le mot &quot;the&quot; dans le contenu. Voici les résultats du benchmark sur la version
de <code>rechercher</code> avec une boucle <code>for</code> et avec un itérateur :</p>
<!--
```text
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```
-->
<pre><code class="language-text">test benchmark_rechercher_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test benchmark_rechercher_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<!--
The iterator version was slightly faster! We won’t explain the benchmark code
here, because the point is not to prove that the two versions are equivalent
but to get a general sense of how these two implementations compare
performance-wise.
-->
<p>La version avec l'itérateur était un peu plus rapide ! Nous n'expliquerons pas
le code du benchmark ici, car il ne s'agit pas de prouver que les deux versions
sont équivalentes, mais d'avoir une idée générale de la différence de
performances entre les deux.</p>
<!--
For a more comprehensive benchmark, you should check using various texts of
various sizes as the `contents`, different words and words of different lengths
as the `query`, and all kinds of other variations. The point is this:
iterators, although a high-level abstraction, get compiled down to roughly the
same code as if you’d written the lower-level code yourself. Iterators are one
of Rust’s *zero-cost abstractions*, by which we mean using the abstraction
imposes no additional runtime overhead. This is analogous to how Bjarne
Stroustrup, the original designer and implementor of C++, defines
*zero-overhead* in “Foundations of C++” (2012):
-->
<p>Pour un benchmark plus complet, nous vous conseillons d'utiliser des textes de
différentes tailles pour <code>contenu</code>, des mots différents et de différentes
longueurs pour <code>recherche</code>, ainsi que tout autre type de variation que vous
pourriez trouver. Le point important est le suivant : les itérateurs, bien qu'il
s'agisse d'une abstraction de haut niveau, sont compilés à peu près comme si
vous aviez écrit vous-même le code un niveau plus bas. Les itérateurs sont l'une
des abstractions à <em>coût zéro</em> de Rust, c'est-à-dire que l'utilisation de
l'abstraction n'impose aucun surcoût lors de l'exécution. C'est la même notion
que Bjarne Stroustrup, le concepteur et développeur original de C++, définit le
<em>coût zéro</em> dans “Foundations of C++” (2012) :</p>
<!--
> In general, C++ implementations obey the zero-overhead principle: What you
> don’t use, you don’t pay for. And further: What you do use, you couldn’t hand
> code any better.
-->
<blockquote>
<p>En général, les implémentations de C++ obéissent au principe du coût zéro :
ce que vous n'utilisez pas, vous ne payez pas. Et encore plus loin : ce que
vous utilisez, vous ne pouvez pas mieux le coder.</p>
</blockquote>
<!--
As another example, the following code is taken from an audio decoder. The
decoding algorithm uses the linear prediction mathematical operation to
estimate future values based on a linear function of the previous samples. This
code uses an iterator chain to do some math on three variables in scope: a
`buffer` slice of data, an array of 12 `coefficients`, and an amount by which
to shift data in `qlp_shift`. We’ve declared the variables within this example
but not given them any values; although this code doesn’t have much meaning
outside of its context, it’s still a concise, real-world example of how Rust
translates high-level ideas to low-level code.
-->
<p>Comme autre exemple, le code suivant est tiré d'un décodeur audio. L'algorithme
de décodage utilise l'opération mathématique de prédiction linéaire pour
estimer les valeurs futures à partir d'une fonction linéaire des échantillons
précédents. Ce code utilise une chaîne d'itérateurs pour faire quelques calculs
sur trois variables dans la portée : une slice de données <code>tampon</code>, un tableau
de 12 <code>coefficients</code>, et une quantité de décalage des données dans <code>decalage</code>.
Nous avons déclaré les variables dans cet exemple, mais nous ne leur avons pas
donné de valeurs ; bien que ce code n'ait pas beaucoup de signification en
dehors de son contexte, c'est toutefois un exemple concis et concret de la façon
dont Rust traduit des idées de haut niveau en code de plus bas niveau.</p>
<!--
```rust,ignore
let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&buffer[i - 12..i])
                                 .map(|(&c, &s)| c * s as i64)
                                 .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
```
-->
<pre><code class="language-rust ignore">let tampon: &amp;mut [i32];
let coefficients: [i64; 12];
let decalage: i16;

for i in 12..tampon.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;tampon[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; decalage;
    let delta = tampon[i];
    tampon[i] = prediction as i32 + delta;
}
</code></pre>
<!--
To calculate the value of `prediction`, this code iterates through each of the
12 values in `coefficients` and uses the `zip` method to pair the coefficient
values with the previous 12 values in `buffer`. Then, for each pair, we
multiply the values together, sum all the results, and shift the bits in the
sum `qlp_shift` bits to the right.
-->
<p>Pour calculer la valeur de <code>prediction</code>, ce code itère sur chacune des 12
valeurs dans <code>coefficients</code> et utilise la méthode <code>zip</code> pour appairer la
valeur de coefficient avec les 12 valeurs précédentes, présentes dans <code>tampon</code>.
Ensuite, pour chaque paire, nous multiplions les valeurs ensemble, nous
additionnons tous les résultats et nous décalons les bits de l'addition de la
valeur de <code>decalage</code> vers la droite.</p>
<!--
Calculations in applications like audio decoders often prioritize performance
most highly. Here, we’re creating an iterator, using two adaptors, and then
consuming the value. What assembly code would this Rust code compile to? Well,
as of this writing, it compiles down to the same assembly you’d write by hand.
There’s no loop at all corresponding to the iteration over the values in
`coefficients`: Rust knows that there are 12 iterations, so it “unrolls” the
loop. *Unrolling* is an optimization that removes the overhead of the loop
controlling code and instead generates repetitive code for each iteration of
the loop.
-->
<p>Les calculs dans des applications comme les décodeurs audio donnent souvent la
priorité aux performances. Ici, nous créons un itérateur à l'aide de deux
adaptateurs, puis nous en consommons la valeur. A quel code d'assemblage
ressemblera ce code Rust ressemblera-t-il une fois compilé ? Et bien, à l'heure
où nous écrivons ces lignes, il est équivalent même code assembleur que vous
écririez à la main. Il n'y a pas du tout de boucle correspondant à l'itération
sur les valeurs dans <code>coefficients</code> : Rust sait qu'il y a 12 itérations, donc il
“déroule” la boucle. Le <em>déroulage</em> est une optimisation qui supprime la
surcharge du code de contrôle de boucle et génère à la place du code répété pour
chaque itération de la boucle.</p>
<!--
All of the coefficients get stored in registers, which means accessing the
values is very fast. There are no bounds checks on the array access at runtime.
All these optimizations that Rust is able to apply make the resulting code
extremely efficient. Now that you know this, you can use iterators and closures
without fear! They make code seem like it’s higher level but don’t impose a
runtime performance penalty for doing so.
-->
<p>Tous les coefficients sont stockés dans des registres, ce qui signifie qu'il
est très rapide d'accéder à ces valeurs. Il n'y a pas de vérification des bornes
sur les accès au tableau à l'exécution. Toutes ces optimisations que Rust est
capable d'appliquer rendent le code produit extrêmement efficace. Maintenant
que vous savez cela, vous pouvez utiliser des itérateurs et des closures
sans crainte ! Ils font en sorte que le code est de haut niveau, mais ils n'ont
pas de pénalité de performance à l'exécution.</p>
<!--
## Summary
-->
<h2 id="résumé-12"><a class="header" href="#résumé-12">Résumé</a></h2>
<!--
Closures and iterators are Rust features inspired by functional programming
language ideas. They contribute to Rust’s capability to clearly express
high-level ideas at low-level performance. The implementations of closures and
iterators are such that runtime performance is not affected. This is part of
Rust’s goal to strive to provide zero-cost abstractions.
-->
<p>Les closures et les itérateurs sont des fonctionnalités de Rust inspirées par
des idées des langages de programmation fonctionnels. Ils contribuent à la
capacité de Rust d'exprimer clairement des idées de haut niveau avec des
performances dignes d'un langage de bas niveau. Les implémentations des
closures et des itérateurs sont telles que les performances à l'exécution ne
sont pas affectées. Cela fait partie de l'objectif de Rust de s'efforcer à
fournir des abstractions à coût zéro.</p>
<!--
Now that we’ve improved the expressiveness of our I/O project, let’s look at
some more features of `cargo` that will help us share the project with the
world.
-->
<p>Maintenant que nous avons amélioré l'expressivité de notre projet
d'entrée/sortie, regardons d'autres fonctionnalités fournies par <code>cargo</code> qui
nous aideront à partager notre projet avec le monde entier.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche-"><a class="header" href="#-attention-peinture-fraîche-">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/179">Pull Request</a>.</p>
</blockquote>
<!--
# More About Cargo and Crates.io
-->
<h1 id="en-savoir-plus-sur-cargo-et-cratesio"><a class="header" href="#en-savoir-plus-sur-cargo-et-cratesio">En savoir plus sur cargo et crates.io</a></h1>
<!--
So far we’ve used only the most basic features of Cargo to build, run, and test
our code, but it can do a lot more. In this chapter, we’ll discuss some of its
other, more advanced features to show you how to do the following:
-->
<p>Précédemment, nous avons utilisé les fonctionnalités les plus basiques de cargo
pour compiler, exécuter, et tester notre code, mais il peut faire bien plus.
Dans ce chapitre, nous allons voir d'autres fonctionnalités avancées pour vous
apprendre à faire ceci :</p>
<!--
* Customize your build through release profiles
* Publish libraries on [crates.io](https://crates.io/)<!-- ignore -- >
* Organize large projects with workspaces
* Install binaries from [crates.io](https://crates.io/)<!-- ignore -- >
* Extend Cargo using custom commands
-->
<ul>
<li>Personnaliser votre compilation grâce aux profils de publication</li>
<li>Publier des bibliothèques sur <a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>Organiser des gros projets avec les espaces de travail</li>
<li>Installer des binaires à partir de
<a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>Améliorer cargo en utilisant des commandes personnalisées</li>
</ul>
<!--
Cargo can do even more than what we cover in this chapter, so for a full
explanation of all its features, see [its
documentation](https://doc.rust-lang.org/cargo/).
-->
<p>Cargo peut faire encore plus de choses que ce que nous allons voir dans ce
chapitre, donc pour une explication plus complète vous avez à votre disposition
<a href="https://doc.rust-lang.org/cargo/">sa documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--1"><a class="header" href="#-attention-peinture-fraîche--1">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/180">Pull Request</a>.</p>
</blockquote>
<!--
## Customizing Builds with Release Profiles
-->
<h2 id="personnaliser-les-compilations-avec-les-profils-de-publication"><a class="header" href="#personnaliser-les-compilations-avec-les-profils-de-publication">Personnaliser les compilations avec les profils de publication</a></h2>
<!--
In Rust, *release profiles* are predefined and customizable profiles with
different configurations that allow a programmer to have more control over
various options for compiling code. Each profile is configured independently of
the others.
-->
<p>Dans Rust, les <em>profils de publication</em> sont profils prédéfinis et
personnalisables avec différentes configurations qui permettent au développeur
d'avoir plus de contrôle sur différentes options de compilation du code. Chaque
profil est configuré indépendamment des autres.</p>
<!--
Cargo has two main profiles: the `dev` profile Cargo uses when you run `cargo
build` and the `release` profile Cargo uses when you run `cargo build
--release`. The `dev` profile is defined with good defaults for development,
and the `release` profile has good defaults for release builds.
-->
<p>Cargo a deux profils principaux : le profil <code>dev</code> que cargo utilise lorsque vous
lancez <code>cargo build</code> et le profil <code>release</code> (NdT : publication) que cargo
utilise lorsque vous lancez <code>cargo build --release</code>. Le profil <code>dev</code> est défini
avec de bons réglages par défaut pour le développement, et le profil <code>release</code> a
de bons réglages par défaut de compilations pour publication.</p>
<!--
These profile names might be familiar from the output of your builds:
-->
<p>Ces noms de profils vous rappellent peut-être quelque chose sur la sortie
standard de vos compilations :</p>
<!--
<!-- manual-regeneration
anywhere, run:
cargo build
cargo build --release
and ensure output below is accurate
-- >
-->
<!--
```console
$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
```
-->
<pre><code class="language-console">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
</code></pre>
<!--
The `dev` and `release` shown in this build output indicate that the compiler
is using different profiles.
-->
<p>Les profils <code>dev</code> et <code>release</code> sont mentionnés dans cette sortie de compilation,
pour indiquer les différents profils qu'utilise le compilateur.</p>
<!--
Cargo has default settings for each of the profiles that apply when there
aren’t any `[profile.*]` sections in the project’s *Cargo.toml* file. By adding
`[profile.*]` sections for any profile you want to customize, you can override
any subset of the default settings. For example, here are the default values
for the `opt-level` setting for the `dev` and `release` profiles:
-->
<p>Cargo a des réglages par défaut pour chacun des profils qui s'appliquent
lorsqu'il n'y a pas de section <code>[profile.*]</code> dans le fichier <em>Cargo.toml</em> du
projet. En ajoutant les sections <code>[profile.*]</code> pour chaque profil que vous
souhaitez personnaliser, vous pouvez remplacer n'importe quel paramètre par
défaut. Par exemple, voici les valeurs par défaut pour le paramètre <code>opt-level</code>
des profils <code>dev</code> et <code>release</code> :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<!--
```toml
[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
```
-->
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<!--
The `opt-level` setting controls the number of optimizations Rust will apply to
your code, with a range of 0 to 3. Applying more optimizations extends
compiling time, so if you’re in development and compiling your code often,
you’ll want faster compiling even if the resulting code runs slower. That is
the reason the default `opt-level` for `dev` is `0`. When you’re ready to
release your code, it’s best to spend more time compiling. You’ll only compile
in release mode once, but you’ll run the compiled program many times, so
release mode trades longer compile time for code that runs faster. That is why
the default `opt-level` for the `release` profile is `3`.
-->
<p>Le paramètre <code>opt-level</code> contrôle le nombre d'optimisations que Rust va
appliquer à votre code, sur une échelle allant de 0 à 3. L'application d'un
niveau plus haut d'optimisation signifie un allongement de la durée de
compilation, donc si vous êtes en train de développer et que vous compilez
souvent votre code, vous préférerez certainement avoir une compilation rapide
même si le code qui en résulte s'exécute plus lentement. C'est la raison pour
laquelle la valeur par défaut de <code>opt-level</code> pour <code>dev</code> est à <code>0</code>. Lorsque vous
serez prêt à publier votre code, il sera préférable de passer un peu plus de
temps à le compiler. Vous ne compilerez en mode publication (NdT : release)
qu'une seule fois, mais vous exécuterez le programme compilé plusieurs fois,
donc le mode publication opte pour un temps de compilation plus long afin que le
code s'exécute plus rapidement. C'est pourquoi le paramètre <code>opt-level</code> par
défaut pour le profil <code>release</code> est à <code>3</code>.</p>
<!--
You can override any default setting by adding a different value for it in
*Cargo.toml*. For example, if we want to use optimization level 1 in the
development profile, we can add these two lines to our project’s *Cargo.toml*
file:
-->
<p>Vous pouvez remplacer n'importe quel paramètre par défaut en ajoutant une valeur
différente dans <em>Cargo.toml</em>. Par exemple, si nous voulons utiliser le niveau 1
d'optimisation dans le profil de développement, nous pouvons ajouter ces deux
lignes à notre fichier <em>Cargo.toml</em> :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<!--
```toml
[profile.dev]
opt-level = 1
```
-->
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<!--
This code overrides the default setting of `0`. Now when we run `cargo build`,
Cargo will use the defaults for the `dev` profile plus our customization to
`opt-level`. Because we set `opt-level` to `1`, Cargo will apply more
optimizations than the default, but not as many as in a release build.
-->
<p>Ce code remplace le paramètre par défaut à <code>0</code>. Maintenant, lorsque nous lançons
<code>cargo build</code>, cargo va utiliser les réglages par défaut du profil <code>dev</code> ainsi
que notre valeur personnalisée de <code>opt-level</code>. Comme nous avons réglé
<code>opt-level</code> à <code>1</code>, Cargo va appliquer plus d'optimisation que par défaut, mais
pas autant que dans une compilation de publication.</p>
<!--
For the full list of configuration options and defaults for each profile, see
[Cargo’s documentation](https://doc.rust-lang.org/cargo/reference/profiles.html).
-->
<p>Pour la liste complète des options de configuration et leurs valeurs par défaut
pour chaque profil, rendez-vous à la
<a href="https://doc.rust-lang.org/cargo/reference/profiles.html">documentation de cargo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--2"><a class="header" href="#-attention-peinture-fraîche--2">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/181">Pull Request</a>.</p>
</blockquote>
<!--
## Publishing a Crate to Crates.io
-->
<h2 id="publier-une-crate-sur-cratesio"><a class="header" href="#publier-une-crate-sur-cratesio">Publier une crate sur crates.io</a></h2>
<!--
We’ve used packages from [crates.io](https://crates.io/)<!-- ignore -- > as
dependencies of our project, but you can also share your code with other people
by publishing your own packages. The crate registry at
[crates.io](https://crates.io/)<!-- ignore -- > distributes the source code of
your packages, so it primarily hosts code that is open source.
-->
<p>Nous avons déjà utilisé des paquets provenant de
<a href="https://crates.io/">crates.io</a><!-- ignore --> comme dépendance de notre projet,
mais vous pouvez aussi partager votre code avec d'autres personnes en publiant
vos propres paquets. Le registre des crates disponible sur
<a href="https://crates.io/">crates.io</a><!-- ignore --> distribue le code source de vos
paquets, donc il héberge principalement du code qui est open source.</p>
<!--
Rust and Cargo have features that help make your published package easier for
people to use and to find in the first place. We’ll talk about some of these
features next and then explain how to publish a package.
-->
<p>Rust et cargo ont des fonctionnalités qui aident les développeurs à trouver et
utiliser les paquets que vous publiez. Nous allons voir certaines de ces
fonctionnalités puis nous allons expliquer comment publier un paquet.</p>
<!--
### Making Useful Documentation Comments
-->
<h3 id="créer-des-commentaires-de-documentation-utiles"><a class="header" href="#créer-des-commentaires-de-documentation-utiles">Créer des commentaires de documentation utiles</a></h3>
<!--
Accurately documenting your packages will help other users know how and when to
use them, so it’s worth investing the time to write documentation. In Chapter
3, we discussed how to comment Rust code using two slashes, `//`. Rust also has
a particular kind of comment for documentation, known conveniently as a
*documentation comment*, that will generate HTML documentation. The HTML
displays the contents of documentation comments for public API items intended
for programmers interested in knowing how to *use* your crate as opposed to how
your crate is *implemented*.
-->
<p>Documenter correctement vos paquets aidera les autres utilisateurs à savoir
comment et quand les utiliser, donc ça vaut la peine de consacrer du temps à la
rédaction de la documentation. Dans le chapitre 3, nous avons vu comment
commenter du code Rust en utilisant deux barres obliques <code>//</code>. Rust a aussi un
type particulier de commentaire pour la documentation, aussi connu sous le nom
de <em>commentaire de documentation</em>, qui va générer de la documentation en HTML.
Le HTML affiche le contenu des commentaires de documentation pour les éléments
public de votre API à destination des développeurs qui s'intéressent à la
manière <em>d'utiliser</em> votre crate et non pas à la manière dont elle est
<em>implémentée</em>.</p>
<!--
Documentation comments use three slashes, `///`, instead of two and support
Markdown notation for formatting the text. Place documentation comments just
before the item they’re documenting. Listing 14-1 shows documentation comments
for an `add_one` function in a crate named `my_crate`:
-->
<p>Les commentaires de documentation utilisent trois barres obliques <code>///</code> au lieu
de deux et prend en charge la notation Markdown pour mettre en forme le texte.
Placez les commentaires de documentation juste avant l'élément qu'ils
documentent. L'encart 14-1 montre des commentaires de documentation pour une
fonction <code>ajouter_un</code> dans une crate nommée <code>ma_crate</code> :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```
-->
<pre><code class="language-rust ignore">/// Ajoute 1 au nombre donné.
///
/// # Exemples
///
/// ```
/// let argument = 5;
/// let reponse = ma_crate::ajouter_un(argument);
///
/// assert_eq!(6, reponse);
/// ```
pub fn ajouter_un(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<!--
<span class="caption">Listing 14-1: A documentation comment for a
function</span>
-->
<p><span class="caption">Encart 14-1 : un commentaire de documentation pour une
fonction</span></p>
<!--
Here, we give a description of what the `add_one` function does, start a
section with the heading `Examples`, and then provide code that demonstrates
how to use the `add_one` function. We can generate the HTML documentation from
this documentation comment by running `cargo doc`. This command runs the
`rustdoc` tool distributed with Rust and puts the generated HTML documentation
in the *target/doc* directory.
-->
<p>Ici nous avons écrit une description de ce que fait la fonction <code>ajouter_un</code>,
débuté une section avec le titre <code>Exemples</code>, et ensuite on a fourni du code qui
montre comment utiliser la fonction <code>ajouter_un</code>. Nous pouvons générer la
documentation HTML de ces commentaires de documentation en lançant <code>cargo doc</code>.
Cette commande lance l'outil <code>rustdoc</code> qui est distribué avec Rust et place la
documentation HTML générée dans le dossier <em>target/doc</em>.</p>
<!--
For convenience, running `cargo doc --open` will build the HTML for your
current crate’s documentation (as well as the documentation for all of your
crate’s dependencies) and open the result in a web browser. Navigate to the
`add_one` function and you’ll see how the text in the documentation comments is
rendered, as shown in Figure 14-1:
-->
<p>Pour plus de facilité, lancer <code>cargo doc --open</code> va générer le HTML pour la
documentation de votre crate courante (ainsi que la documentation pour toutes
les dépendances de la crate) et ouvrir le résultat dans un navigateur web.
Rendez-vous à la fonction <code>ajouter_one</code> et vous découvrirez comment le texte
dans les commentaires de la documentation a été interprété, qui devrait
ressembler à l'illustration 14-1 :</p>
<!-- markdownlint-disable -->
<!--
<img alt="Rendered HTML documentation for the `add_one` function of `my_crate`" src="img/trpl14-01.png" class="center" />
-->
<!-- markdownlint-restore -->
<p><img
    alt="Documentation HTML générée pour la fonction `ajouter_un` de `ma_crate`"
    src="img/trpl14-01.png"
    class="center" /></p>
<!--
<span class="caption">Figure 14-1: HTML documentation for the `add_one`
function</span>
-->
<p><span class="caption">Illustration 14-1 : documentation HTML pour la fonction
<code>ajouter_un</code></span></p>
<!--
#### Commonly Used Sections
-->
<h4 id="les-sections-utilisées-fréquemment"><a class="header" href="#les-sections-utilisées-fréquemment">Les sections utilisées fréquemment</a></h4>
<!--
We used the `# Examples` Markdown heading in Listing 14-1 to create a section
in the HTML with the title “Examples.” Here are some other sections that crate
authors commonly use in their documentation:
-->
<p>Nous avons utilisé le titre en Markdown <code># Exemples</code> dans l'encart 14-1 afin de
créer une section dans le HTML avec le titre “Exemples”. Voici d'autres sections
que les auteurs de crate utilisent fréquemment dans leur documentation :</p>
<!--
* **Panics**: The scenarios in which the function being documented could
  panic. Callers of the function who don’t want their programs to panic should
  make sure they don’t call the function in these situations.
* **Errors**: If the function returns a `Result`, describing the kinds of
  errors that might occur and what conditions might cause those errors to be
  returned can be helpful to callers so they can write code to handle the
  different kinds of errors in different ways.
* **Safety**: If the function is `unsafe` to call (we discuss unsafety in
  Chapter 19), there should be a section explaining why the function is unsafe
  and covering the invariants that the function expects callers to uphold.
-->
<ul>
<li><strong>Panics</strong> : le scénario dans lequel la fonction est documentée peut paniquer.
Ceux qui utilisent la fonction et qui ne veulent pas que leur programme
panique doivent s'assurer qu'ils n'appellent pas la fonction dans ce genre de
situation.</li>
<li><strong>Errors</strong> : si la fonction retourne un <code>Result</code>, documenter les types
d'erreurs qui peuvent survenir ainsi que les conditions qui mènent à ces
erreurs sera très bénéfique pour ceux qui utilisent votre API afin qu'ils
puissent écrire du code pour gérer ces différents types d'erreurs de manière à
ce que cela leur convienne.</li>
<li><strong>Safety</strong> : si la fonction fait un appel à <code>unsafe</code> (que nous verrons au
chapitre 19), il devrait exister une section qui explique pourquoi la fonction
fait appel à <em>unsafe</em> et quels sont les paramètres que la fonction s'attend à
recevoir des utilisateurs de l'API.</li>
</ul>
<!--
Most documentation comments don’t need all of these sections, but this is a
good checklist to remind you of the aspects of your code that people calling
your code will be interested in knowing about.
-->
<p>La plupart des commentaires sur la documentation n'ont pas besoin de ces
sections, mais c'est une bonne liste de vérifications à avoir pour vous rappeler
les éléments importants à signaler aux utilisateurs.</p>
<!--
#### Documentation Comments as Tests
-->
<h4 id="les-commentaires-de-documentation-pour-faire-des-tests"><a class="header" href="#les-commentaires-de-documentation-pour-faire-des-tests">Les commentaires de documentation pour faire des tests</a></h4>
<!--
Adding example code blocks in your documentation comments can help demonstrate
how to use your library, and doing so has an additional bonus: running `cargo
test` will run the code examples in your documentation as tests! Nothing is
better than documentation with examples. But nothing is worse than examples
that don’t work because the code has changed since the documentation was
written. If we run `cargo test` with the documentation for the `add_one`
function from Listing 14-1, we will see a section in the test results like this:
-->
<p>L'ajout des blocs de code d'exemple dans vos commentaires de documentation
peuvent vous aider à montrer comment utiliser votre bibliothèque, et faire ceci
apporte un bonus supplémentaire : l'exécution de <code>cargo test</code> va lancer les
codes d'exemples présents dans votre documentation comme étant des tests ! Il
n'y a rien de mieux que de la documentation avec des exemples. Mais il n'y a
rien de pire que des exemples qui ne fonctionnent plus car le code a changé
depuis que la documentation a été écrite. Si nous lançons <code>cargo test</code> avec la
documentation de la fonction <code>ajouter_un</code> de l'encart 14-1, nous verrons une
section dans les résultats de tests comme celle-ci :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-- >
-->
<!--
```text
   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```
-->
<pre><code class="language-text">   Doc-tests ma_crate

running 1 test
test src/lib.rs - ajouter_un (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
Now if we change either the function or the example so the `assert_eq!` in the
example panics and run `cargo test` again, we’ll see that the doc tests catch
that the example and the code are out of sync with each other!
-->
<p>Maintenant, si nous changeons la fonction ou l'exemple de sorte que le
<code>assert_eq!</code> fasse paniquer l'exemple et que nous lançons <code>cargo test</code> à
nouveau, nous verrons que les tests de documentation vont découvrir que
l'exemple et le code sont désynchronisés l'un de l'autre !</p>
<!--
#### Commenting Contained Items
-->
<h4 id="commenter-lélément-qui-contient-lélément-courant"><a class="header" href="#commenter-lélément-qui-contient-lélément-courant">Commenter l'élément qui contient l'élément courant</a></h4>
<!--
Another style of doc comment, `//!`, adds documentation to the item that
contains the comments rather than adding documentation to the items following
the comments. We typically use these doc comments inside the crate root file
(*src/lib.rs* by convention) or inside a module to document the crate or the
module as a whole.
-->
<p>Un autre style de commentaire de documentation, <code>//!</code>, ajoute de la
documentation à l'élément qui contient ce commentaire plutôt que d'ajouter la
documentation à l'élément qui suit ce commentaire. Nous utilisons
habituellement ces commentaires de documentation dans le fichier de la crate
racine (qui est <em>src/lib.rs</em> par convention) ou à l'intérieur d'un module afin
de documenter la crate ou le module dans son ensemble.</p>
<!--
For example, if we want to add documentation that describes the purpose of the
`my_crate` crate that contains the `add_one` function, we can add documentation
comments that start with `//!` to the beginning of the *src/lib.rs* file, as
shown in Listing 14-2:
-->
<p>Par exemple, si nous souhaitons ajouter de la documentation qui décrit le rôle
de la crate <code>ma_crate</code> qui contient la fonction <code>ajouter_un</code>, nous pouvons
ajouter des commentaires de documentation qui commencent par <code>//!</code> au début du
fichier <em>src/lib.rs</em>, comme dans l'encart 14-2 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
# ///
# /// # Examples
# ///
# /// ```
# /// let arg = 5;
# /// let answer = my_crate::add_one(arg);
# ///
# /// assert_eq!(6, answer);
# /// ```
# pub fn add_one(x: i32) -> i32 {
#     x + 1
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">//! # Ma crate
</span><span class="boring">//!
</span><span class="boring">//! `ma_crate` est un regroupement d'utilitaires pour rendre plus pratique
</span><span class="boring">//! certains calculs.
</span><span class="boring">
</span><span class="boring">/// Ajoute 1 au nombre donné.
</span><span class="boring">// -- partie masquée ici --
</span><span class="boring">///
</span><span class="boring">/// # Exemples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let argument = 5;
</span><span class="boring">/// let reponse = ma_crate::ajouter_un(argument);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, reponse);
</span><span class="boring">/// ```
</span><span class="boring">pub fn ajouter_un(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 14-2: Documentation for the `my_crate` crate as a
whole</span>
-->
<p><span class="caption">Encart 14-2 : documentation portant sur la crate
<code>ma_crate</code></span></p>
<!--
Notice there isn’t any code after the last line that begins with `//!`. Because
we started the comments with `//!` instead of `///`, we’re documenting the item
that contains this comment rather than an item that follows this comment. In
this case, the item that contains this comment is the *src/lib.rs* file, which
is the crate root. These comments describe the entire crate.
-->
<p>Remarquez qu'il n'y a pas de code après la dernière ligne qui commence par
<code>//!</code>. Comme nous commençons les commentaires par <code>//!</code> au lieu de <code>///</code>, nous
documentons l'élément qui contient ce commentaire plutôt que l'élément qui suit
ce commentaire. Dans notre cas, l'élément qui contient ce commentaire est le
fichier <em>src/lib.rs</em>, qui est la racine de la crate. Ces commentaires vont
décrire l'intégralité de la crate.</p>
<!--
When we run `cargo doc --open`, these comments will display on the front
page of the documentation for `my_crate` above the list of public items in the
crate, as shown in Figure 14-2:
-->
<p>Lorsque nous lançons <code>cargo doc --open</code>, ces commentaires vont s'afficher sur la
page d'accueil de la documentation de <code>ma_crate</code>, au-dessus de la liste des
éléments publics de la crate, comme montré dans l'illustration 14-2 :</p>
<!-- markdownlint-disable -->
<!--
<img alt="Rendered HTML documentation with a comment for the crate as a whole" src="img/trpl14-02.png" class="center" />
-->
<!-- markdownlint-restore -->
<p><img
    alt="Documentation HTML générée avec un commentaire pour toute la crate"
    src="img/trpl14-02.png"
    class="center" /></p>
<!--
<span class="caption">Figure 14-2: Rendered documentation for `my_crate`,
including the comment describing the crate as a whole</span>
-->
<p><span class="caption">Illustration 14-2 : Documentation générée pour <code>ma_crate</code>,
qui contient le commentaire qui décrit l'intégralité de la crate</span></p>
<!--
Documentation comments within items are useful for describing crates and
modules especially. Use them to explain the overall purpose of the container to
help your users understand the crate’s organization.
-->
<p>Les commentaires de la documentation placés à l'intérieur des éléments sont
particulièrement utiles pour décrire les crates et les modules. Utilisez-les
pour expliquer globalement le rôle du conteneur pour aider vos utilisateurs à
comprendre l'organisation de votre crate.</p>
<!--
### Exporting a Convenient Public API with `pub use`
-->
<h3 id="exporter-une-api-publique-conviviale-avec-pub-use"><a class="header" href="#exporter-une-api-publique-conviviale-avec-pub-use">Exporter une API publique conviviale avec <code>pub use</code></a></h3>
<!--
In Chapter 7, we covered how to organize our code into modules using the `mod`
keyword, how to make items public using the `pub` keyword, and how to bring
items into a scope with the `use` keyword. However, the structure that makes
sense to you while you’re developing a crate might not be very convenient for
your users. You might want to organize your structs in a hierarchy containing
multiple levels, but then people who want to use a type you’ve defined deep in
the hierarchy might have trouble finding out that type exists. They might also
be annoyed at having to enter `use`
`my_crate::some_module::another_module::UsefulType;` rather than `use`
`my_crate::UsefulType;`.
-->
<p>Dans le chapitre 7, nous avons vu comment organiser notre code en modules en
utilisant le mot-clé <code>mod</code>, comment faire pour rendre des éléments publics en
utilisant le mot-clé <code>pub</code>, et comment importer des éléments dans la portée en
utilisant le mot-clé <code>use</code>. Cependant, la structure qui a un sens pour vous
pendant que vous développez une crate peut ne pas être pratique pour vos
utilisateurs. Vous pourriez vouloir organiser vos structures dans une hiérarchie
qui a plusieurs niveaux, mais les personnes qui veulent utiliser un type que
vous avez défini dans un niveau profond de la hiérarchie pourraient rencontrer
des difficultés pour savoir que ce type existe. Ils peuvent aussi être agacés
d'avoir à écrire <code>use ma_crate::un_module::un_autre_module::TypeUtile;</code> plutôt
que <code>use ma_crate::TypeUtile;</code>.</p>
<!--
The structure of your public API is a major consideration when publishing a
crate. People who use your crate are less familiar with the structure than you
are and might have difficulty finding the pieces they want to use if your crate
has a large module hierarchy.
-->
<p>La structure de votre API publique est une question importante lorsque vous
publiez une crate. Les personnes qui utilisent votre crate sont moins familiers
avec la structure que vous l'êtes et pourraient avoir des difficultés à trouver
les éléments qu'ils souhaitent utiliser si votre crate a une hiérarchie de
module imposante.</p>
<!--
The good news is that if the structure *isn’t* convenient for others to use
from another library, you don’t have to rearrange your internal organization:
instead, you can re-export items to make a public structure that’s different
from your private structure by using `pub use`. Re-exporting takes a public
item in one location and makes it public in another location, as if it were
defined in the other location instead.
-->
<p>La bonne nouvelle est que si la structure <em>n'est pas</em> pratique pour ceux qui
l'utilisent dans une autre bibliothèque, vous n'avez pas à réorganiser votre
organisation interne : à la place, vous pouvez ré-exporter les éléments pour
créer une structure publique qui est différente de votre structure privée en
utilisant <code>pub use</code>. Ré-exporter prend un élément public d'un endroit et le
rend public dans un autre endroit, comme s'il était défini dans l'autre endroit.</p>
<!--
For example, say we made a library named `art` for modeling artistic concepts.
Within this library are two modules: a `kinds` module containing two enums
named `PrimaryColor` and `SecondaryColor` and a `utils` module containing a
function named `mix`, as shown in Listing 14-3:
-->
<p>Par exemple, disons que nous avons créé une bibliothèque <code>art</code> pour modéliser
des concepts artistiques. A l'intérieur de cette bibliothèque nous avons deux
modules : un module <code>types</code> qui contient deux énumérations <code>CouleurPrimaire</code> et
<code>CouleurSecondaire</code>, et un module <code>utilitaires</code> qui contient une fonction
<code>mixer</code>, comme dans l'encart 14-3 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
        // --snip--
#         SecondaryColor::Orange
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">//! # Art
//!
//! Une bibliothèque pour modéliser des concepts artistiques.

pub mod types {
    /// Les couleurs primaires du modèle RJB.
    pub enum CouleurPrimaire {
        Rouge,
        Jaune,
        Bleu,
    }

    /// Les couleurs secondaires du modèle RJB.
    pub enum CouleurSecondaire {
        Orange,
        Vert,
        Violet,
    }
}

pub mod utilitaires {
    use crate::types::*;

    /// Combine deux couleurs primaires dans les mêmes quantités pour
    /// créer une couleur secondaire.
    pub fn mixer(c1: CouleurPrimaire, c2: CouleurPrimaire) -&gt; CouleurSecondaire {
        // -- partie masquée ici --
<span class="boring">        CouleurSecondaire::Orange
</span>    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 14-3: An `art` library with items organized into
`kinds` and `utils` modules</span>
-->
<p><span class="caption">Encart 14-3 : une bibliothèque <code>art</code> avec des éléments
organisés selon les modules <code>types</code> and <code>utilitaires</code></span></p>
<!--
Figure 14-3 shows what the front page of the documentation for this crate
generated by `cargo doc` would look like:
-->
<p>L'illustration 14-3 montre la page d'accueil de la documentation de cette crate
générée par <code>cargo doc</code> qui devrait ressembler à cela :</p>
<!-- markdownlint-disable -->
<!--
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" />
-->
<p><img
    alt="Documentation générée pour la crate `art` qui liste les modules `types` et `utilitaires`"
    src="img/trpl14-03.png"
    class="center" /></p>
<!-- markdownlint-restore -->
<!--
<span class="caption">Figure 14-3: Front page of the documentation for `art`
that lists the `kinds` and `utils` modules</span>
-->
<p><span class="caption">Illustration 14-3 : Page d'accueil de la documentation de
<code>art</code> qui liste les modules <code>types</code> et <code>utilitaires</code></span></p>
<!--
Note that the `PrimaryColor` and `SecondaryColor` types aren’t listed on the
front page, nor is the `mix` function. We have to click `kinds` and `utils` to
see them.
-->
<p>Notez que les types <code>CouleurPrimaire</code> et <code>CouleurSecondaire</code> ne sont pas listés
sur la page d'accueil, ni la fonction <code>mixer</code>. Nous devons cliquer sur <code>types</code>
et <code>utilitaires</code> pour les voir.</p>
<!--
Another crate that depends on this library would need `use` statements that
bring the items from `art` into scope, specifying the module structure that’s
currently defined. Listing 14-4 shows an example of a crate that uses the
`PrimaryColor` and `mix` items from the `art` crate:
-->
<p>Une autre crate qui dépend de cette bibliothèque va avoir besoin d'utiliser
l'instruction <code>use</code> pour importer les éléments de <code>art</code> dans sa portée, en
suivant la structure du module qui est actuellement définie. L'encart 14-4
montre un exemple d'une crate qui utilise les éléments <code>CouleurPrimaire</code> et
<code>mixer</code> de la crate <code>art</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
```
-->
<pre><code class="language-rust ignore">use art::types::CouleurPrimaire;
use art::utilitaires::mixer;

fn main() {
    let rouge = CouleurPrimaire::Rouge;
    let jaune = CouleurPrimaire::Jaune;
    mixer(rouge, jaune);
}
</code></pre>
<!--
<span class="caption">Listing 14-4: A crate using the `art` crate’s items with
its internal structure exported</span>
-->
<p><span class="caption">Encart 14-4 : une crate qui utilise les éléments de la
crate <code>art</code> avec sa structure interne exportée</span></p>
<!--
The author of the code in Listing 14-4, which uses the `art` crate, had to
figure out that `PrimaryColor` is in the `kinds` module and `mix` is in the
`utils` module. The module structure of the `art` crate is more relevant to
developers working on the `art` crate than to developers using the `art` crate.
The internal structure that organizes parts of the crate into the `kinds`
module and the `utils` module doesn’t contain any useful information for
someone trying to understand how to use the `art` crate. Instead, the `art`
crate’s module structure causes confusion because developers have to figure out
where to look, and the structure is inconvenient because developers must
specify the module names in the `use` statements.
-->
<p>L'auteur du code de l'encart 14-4, qui utilise la crate <code>art</code>, doit comprendre
que <code>CouleurPrimaire</code> est dans le module <code>types</code> et que <code>mixer</code> est dans le
module <code>utilitaires</code>. La structure du module de la crate <code>art</code> est bien plus
pratique pour les développeurs qui travaillent sur la crate <code>art</code> que pour les
développeurs qui utilisent la crate <code>art</code>. La structure interne qui divise les
éléments de la crate dans le module <code>types</code> et le module <code>utilitaires</code> ne
contient aucune information utile à quelqu'un qui essaye de comprendre comment
utiliser la crate <code>art</code>. Au lieu de cela, la structure du module de la crate
<code>art</code> génère de la confusion car les développeurs doivent découvrir où trouver
les éléments, et la structure n'est pas pratique car les développeurs doivent
renseigner les noms des modules dans les instructions <code>use</code>.</p>
<!--
To remove the internal organization from the public API, we can modify the
`art` crate code in Listing 14-3 to add `pub use` statements to re-export the
items at the top level, as shown in Listing 14-5:
-->
<p>Pour masquer l'organisation interne de l'API publique, nous pouvons modifier le
code de la crate <code>art</code> de l'encart 14-3 pour ajouter l'instruction <code>pub use</code>
pour ré-exporter les éléments au niveau supérieur, comme montré dans l'encart
14-5 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
#     /// The primary colors according to the RYB color model.
#     pub enum PrimaryColor {
#         Red,
#         Yellow,
#         Blue,
#     }
# 
#     /// The secondary colors according to the RYB color model.
#     pub enum SecondaryColor {
#         Orange,
#         Green,
#         Purple,
#     }
}

pub mod utils {
    // --snip--
#     use crate::kinds::*;
# 
#     /// Combines two primary colors in equal amounts to create
#     /// a secondary color.
#     pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
#         SecondaryColor::Orange
#     }
}
```
-->
<pre><code class="language-rust ignore">//! # Art
//!
//! Une bibliothèque pour modéliser des concepts artistiques.

pub use self::types::CouleurPrimaire;
pub use self::types::CouleurSecondaire;
pub use self::utilitaires::mixer;

pub mod types {
    // -- partie masquée ici --
<span class="boring">    /// Les couleurs primaires du modèle RJB.
</span><span class="boring">    pub enum CouleurPrimaire {
</span><span class="boring">        Rouge,
</span><span class="boring">        Jaune,
</span><span class="boring">        Bleu,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Les couleurs secondaires du modèle RJB.
</span><span class="boring">    pub enum CouleurSecondaire {
</span><span class="boring">        Orange,
</span><span class="boring">        Vert,
</span><span class="boring">        Violet,
</span><span class="boring">    }
</span>}

pub mod utilitaires {
    // -- partie masquée ici --
<span class="boring">    use crate::types::*;
</span><span class="boring">
</span><span class="boring">    /// Combine deux couleurs primaires dans les mêmes quantités pour
</span><span class="boring">    /// créer une couleur secondaire.
</span><span class="boring">    pub fn mixer(c1: CouleurPrimaire, c2: CouleurPrimaire) -&gt; CouleurSecondaire {
</span><span class="boring">        CouleurSecondaire::Orange
</span><span class="boring">    }
</span>}
</code></pre>
<!--
<span class="caption">Listing 14-5: Adding `pub use` statements to re-export
items</span>
-->
<p><span class="caption">Encart 14-5 : ajout de l'instruction <code>pub use</code> pour
ré-exporter les éléments</span></p>
<!--
The API documentation that `cargo doc` generates for this crate will now list
and link re-exports on the front page, as shown in Figure 14-4, making the
`PrimaryColor` and `SecondaryColor` types and the `mix` function easier to find.
-->
<p>La documentation de l'API qui <code>cargo doc</code> a généré pour cette crate va
maintenant lister et lier les ré-exportations sur la page d'accueil, comme dans
l'illustration 14-4, ce qui rend les types <code>CouleurPrimaire</code> et
<code>CouleurSecondaire</code> plus faciles à trouver.</p>
<!-- markdownlint-disable -->
<!--
<img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-04.png" class="center" />
-->
<p><img
    alt="Documentation générée pour la crate `art` avec les ré-exports sur la page d'accueil"
    src="img/trpl14-04.png"
    class="center" /></p>
<!-- markdownlint-restore -->
<!--
<span class="caption">Figure 14-4: The front page of the documentation for `art`
that lists the re-exports</span>
-->
<p><span class="caption">Illustration 14-4 : la page d'accueil de la documentation
pour <code>art</code> qui liste les ré-exports</span></p>
<!--
The `art` crate users can still see and use the internal structure from Listing
14-3 as demonstrated in Listing 14-4, or they can use the more convenient
structure in Listing 14-5, as shown in Listing 14-6:
-->
<p>Les utilisateurs de la crate <code>art</code> peuvent toujours voir et utiliser la
structure interne de l'encart 14-3 comme ils l'utilisaient dans l'encart 14-4,
mais ils peuvent maintenant utiliser la structure plus pratique de l'encart
14-5, comme montré dans l'encart 14-6 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
use art::mix;
use art::PrimaryColor;

fn main() {
    // --snip--
#     let red = PrimaryColor::Red;
#     let yellow = PrimaryColor::Yellow;
#     mix(red, yellow);
}
```
-->
<pre><code class="language-rust ignore">use art::mixer;
use art::CouleurPrimaire;

fn main() {
    // -- partie masquée ici --
<span class="boring">    let rouge = CouleurPrimaire::Rouge;
</span><span class="boring">    let jaune = CouleurPrimaire::Jaune;
</span><span class="boring">    mixer(rouge, jaune);
</span>}
</code></pre>
<!--
<span class="caption">Listing 14-6: A program using the re-exported items from
the `art` crate</span>
-->
<p><span class="caption">Encart 14-6 : un programme qui utilise les éléments
ré-exportés de la crate <code>art</code></span></p>
<!--
In cases where there are many nested modules, re-exporting the types at the top
level with `pub use` can make a significant difference in the experience of
people who use the crate.
-->
<p>Dans les cas où il y a de nombreux modules imbriqués, ré-exporter les types au
niveau le plus haut avec <code>pub use</code> peut faire une différence significative dans
l'expérience utilisateur de ceux qui utilisent cette crate.</p>
<!--
Creating a useful public API structure is more of an art than a science, and
you can iterate to find the API that works best for your users. Choosing `pub
use` gives you flexibility in how you structure your crate internally and
decouples that internal structure from what you present to your users. Look at
some of the code of crates you’ve installed to see if their internal structure
differs from their public API.
-->
<p>Créer une structure d'API publique utile est plus un art qu'une science, et vous
pouvez itérer plusieurs fois pour trouver une API qui fonctionne mieux pour vos
utilisateurs. Choisir <code>pub use</code> vous donne de la flexibilité pour l'organisation
interne de votre crate et découple la structure interne de ce que vous présentez
aux utilisateurs. N'hésitez pas à regarder le code source des crates que vous
avez installé pour voir si leur structure interne est différente de leur API
publique.</p>
<!--
### Setting Up a Crates.io Account
-->
<h3 id="mise-en-place-dun-compte-cratesio"><a class="header" href="#mise-en-place-dun-compte-cratesio">Mise en place d'un compte crates.io</a></h3>
<!--
Before you can publish any crates, you need to create an account on
[crates.io](https://crates.io/)<!-- ignore -- > and get an API token. To do so,
visit the home page at [crates.io](https://crates.io/)<!-- ignore -- > and log in
via a GitHub account. (The GitHub account is currently a requirement, but the
site might support other ways of creating an account in the future.) Once
you’re logged in, visit your account settings at
[https://crates.io/me/](https://crates.io/me/)<!-- ignore -- > and retrieve your
API key. Then run the `cargo login` command with your API key, like this:
-->
<p>Avant de pouvoir publier une crate, vous devez créer un compte sur
<a href="https://crates.io/">crates.io</a><!-- ignore --> et obtenir un jeton d'API. Pour
pouvoir faire cela, visitez la page d'accueil de
<a href="https://crates.io/">crates.io</a><!-- ignore --> et connectez-vous avec votre
compte GitHub (le compte GitHub est actuellement une obligation, mais crates.io
pourra permettre de créer un compte d'une autre manière un jour). Une fois
identifié, visitez les réglages de votre compte à l'adresse
<a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> et récupérez votre
jeton d'API (NdT : <em>API key</em>). Ensuite, lancez la commande <code>cargo login</code> avec
votre clé d'API, comme ceci :</p>
<!--
```console
$ cargo login abcdefghijklmnopqrstuvwxyz012345
```
-->
<pre><code class="language-console">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<!--
This command will inform Cargo of your API token and store it locally in
*~/.cargo/credentials*. Note that this token is a *secret*: do not share it
with anyone else. If you do share it with anyone for any reason, you should
revoke it and generate a new token on [crates.io](https://crates.io/)<!-- ignore
-- >.
-->
<p>Cette commande informera cargo de votre jeton d'API et l'enregistrera localement
dans <em>~/.cargo/credentials</em>. Notez que ce jeton est un <em>secret</em> : ne le partagez
avec personne d'autre. Si vous le donnez à quelqu'un pour une quelconque raison,
vous devriez la révoquer et générer un nouveau jeton sur
<a href="https://crates.io/">crates.io</a><!-- ignore -->.</p>
<!--
### Adding Metadata to a New Crate
-->
<h3 id="ajouter-des-métadonnées-à-une-nouvelle-crate"><a class="header" href="#ajouter-des-métadonnées-à-une-nouvelle-crate">Ajouter des métadonnées à une nouvelle crate</a></h3>
<!--
Now that you have an account, let’s say you have a crate you want to publish.
Before publishing, you’ll need to add some metadata to your crate by adding it
to the `[package]` section of the crate’s *Cargo.toml* file.
-->
<p>Maintenant que vous avez un compte, imaginons que vous avez une crate que vous
souhaitez publier. Avant de la publier, vous aurez besoin d'ajouter quelques
métadonnées à votre crate en les ajoutant à la section <code>[package]</code> de votre
fichier <em>Cargo.toml</em> de la crate.</p>
<!--
Your crate will need a unique name. While you’re working on a crate locally,
you can name a crate whatever you’d like. However, crate names on
[crates.io](https://crates.io/)<!-- ignore -- > are allocated on a first-come,
first-served basis. Once a crate name is taken, no one else can publish a crate
with that name. Before attempting to publish a crate, search for the name you
want to use on the site. If the name has been used by another crate, you will
need to find another name and edit the `name` field in the *Cargo.toml* file
under the `[package]` section to use the new name for publishing, like so:
-->
<p>Votre crate va avoir besoin d'un nom unique. Tant que vous travaillez en local,
vous pouvez nommer un crate comme vous le souhaitez. Cependant, les noms des
crates sur <a href="https://crates.io/">crates.io</a><!-- ignore --> sont accordés selon le
principe du <em>premier arrivé, premier servi</em>. Une fois qu'un nom de crate est
accordé, personne d'autre ne peut publier une crate avec ce nom. Avant d'essayer
de publier une crate, recherchez sur le site le nom que vous souhaitez utiliser.
Si le nom a été utilisé par une autre crate, vous allez devoir trouver un autre
nom et modifier le champ <code>name</code> dans le fichier <em>Cargo.toml</em> sous la section
<code>[package]</code> pour utiliser le nouveau nom pour la publication, comme ceci :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<!--
```toml
[package]
name = "guessing_game"
```
-->
<pre><code class="language-toml">[package]
name = &quot;jeu_du_plus_ou_du_moins&quot;
</code></pre>
<!--
Even if you’ve chosen a unique name, when you run `cargo publish` to publish
the crate at this point, you’ll get a warning and then an error:
-->
<p>Même si vous avez choisi un nom unique, lorsque vous lancez <code>cargo publish</code> pour
publier la crate à ce stade, vous allez avoir un avertissement suivi par une
erreur :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo publish
copy just the relevant lines below
-- >
-->
<!--
```console
$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: api errors (status 200 OK): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
```
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
-- partie masquée ici --
error: api errors (status 200 OK): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
</code></pre>
<!--
The reason is that you’re missing some crucial information: a description and
license are required so people will know what your crate does and under what
terms they can use it. To rectify this error, you need to include this
information in the *Cargo.toml* file.
-->
<p>La raison est qu'il manque quelques informations essentielles : une description
et une licence sont nécessaires pour que les gens puissent savoir ce que fait
votre crate et sous quelles conditions ils peuvent l'utiliser. Pour corriger
cette erreur, vous devez rajouter ces informations dans le fichier <em>Cargo.toml</em>.</p>
<!--
Add a description that is just a sentence or two, because it will appear with
your crate in search results. For the `license` field, you need to give a
*license identifier value*. The [Linux Foundation’s Software Package Data
Exchange (SPDX)][spdx] lists the identifiers you can use for this value. For
example, to specify that you’ve licensed your crate using the MIT License, add
the `MIT` identifier:
-->
<p>Ajoutez une description qui ne fait qu'une phrase ou deux, car elle va
s'afficher à proximité de votre crate dans les résultats de recherche. Pour le
champ <code>license</code>, vous devez donner une <em>valeur d'identification de la licence</em>.
La <a href="http://spdx.org/licenses/">Linux Foundation’s Software Package Data Exchange (SPDX)</a> liste les
identifications que vous pouvez utiliser pour cette valeur. Par exemple, pour
renseigner que votre crate est sous la licence MIT, ajoutez l'identifiant
<code>MIT</code> :</p>
<!--
[spdx]: http://spdx.org/licenses/
-->
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<!--
```toml
[package]
name = "guessing_game"
license = "MIT"
```
-->
<pre><code class="language-toml">[package]
name = &quot;jeu_du_plus_ou_du_moins&quot;
license = &quot;MIT&quot;
</code></pre>
<!--
If you want to use a license that doesn’t appear in the SPDX, you need to place
the text of that license in a file, include the file in your project, and then
use `license-file` to specify the name of that file instead of using the
`license` key.
-->
<p>Si vous voulez utiliser une licence qui n'apparaît pas dans le SPDX, vous devez
placer le texte de cette licence dans un fichier, inclure ce fichier dans votre
projet, et ensuite utiliser <code>licence-file</code> pour renseigner le nom de ce fichier
plutôt que d'utiliser la clé <code>licence</code>.</p>
<!--
Guidance on which license is appropriate for your project is beyond the scope
of this book. Many people in the Rust community license their projects in the
same way as Rust by using a dual license of `MIT OR Apache-2.0`. This practice
demonstrates that you can also specify multiple license identifiers separated
by `OR` to have multiple licenses for your project.
-->
<p>Les conseils sur le choix de la licence appropriée pour votre projet sortent du
cadre de ce livre. De nombreuses personnes dans la communauté Rust appliquent à
leurs projets la même licence que Rust qui utilise la licence double
<code>MIT OR Apache-2.0</code>. Cette pratique montre que vous pouvez également indiquer
plusieurs identificateurs de licence séparés par <code>OR</code> pour avoir plusieurs
licences pour votre projet.</p>
<!--
With a unique name, the version, the author details that `cargo new` added
when you created the crate, your description, and a license added, the
*Cargo.toml* file for a project that is ready to publish might look like this:
-->
<p>Avec le nom unique, la version, les informations du développeur que <code>cargo new</code>
a ajouté lorsque vous avez créé la crate, ainsi que la description et la licence
que vous avez ajouté, le fichier <em>Cargo.toml</em> de ce projet qui est prêt à être
publié devrait ressembler à ceci :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<!--
```toml
[package]
name = "guessing_game"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
edition = "2018"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
```
-->
<pre><code class="language-toml">[package]
name = &quot;jeu_du_plus_ou_du_moins&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Votre nom &lt;adresse@exemple.com&gt;&quot;]
edition = &quot;2018&quot;
description = &quot;Un jeu où vous devez deviner quel nombre l'ordinateur a choisi.&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<!--
[Cargo’s documentation](https://doc.rust-lang.org/cargo/) describes other
metadata you can specify to ensure others can discover and use your crate more
easily.
-->
<p>La <a href="https://doc.rust-lang.org/cargo/">documentation de cargo</a> décris d'autres
métadonnées que vous pouvez renseigner pour vous assurer que les autres
développeurs puissent découvrir encore plus facilement votre crate.</p>
<!--
### Publishing to Crates.io
-->
<h3 id="publier-sur-cratesio"><a class="header" href="#publier-sur-cratesio">Publier sur crates.io</a></h3>
<!--
Now that you’ve created an account, saved your API token, chosen a name for
your crate, and specified the required metadata, you’re ready to publish!
Publishing a crate uploads a specific version to
[crates.io](https://crates.io/)<!-- ignore -- > for others to use.
-->
<p>Maintenant que vous avez créé un compte, sauvegardé votre jeton de clé, choisi
un nom pour votre crate, et précisé les métadonnées requises, vous êtes prêt à
publier ! Publier une crate téléverse une version précise sur
<a href="https://crates.io/">crates.io</a><!-- ignore --> pour que les autres puissent
l'utiliser.</p>
<!--
Be careful when publishing a crate because a publish is *permanent*. The
version can never be overwritten, and the code cannot be deleted. One major
goal of [crates.io](https://crates.io/)<!-- ignore -- > is to act as a permanent
archive of code so that builds of all projects that depend on crates from
[crates.io](https://crates.io/)<!-- ignore -- > will continue to work. Allowing
version deletions would make fulfilling that goal impossible. However, there is
no limit to the number of crate versions you can publish.
-->
<p>Faites attention lorsque vous publiez une crate car une publication est
<em>permanente</em>. La version ne pourra jamais être remplacée, et le code ne pourra
jamais être effacé. Le but majeur de
<a href="https://crates.io/">crates.io</a><!-- ignore --> est de fournir une archive
durable de code afin que les compilations de tous les projets qui dépendent des
crates de <a href="https://crates.io/">crates.io</a><!-- ignore --> puissent toujours
continuer à fonctionner. Si la suppression de version était autorisée, cela
rendrait ce but impossible. Cependant, il n'y a pas de limites au nombre de
versions de votre crate que vous pouvez publier.</p>
<!--
Run the `cargo publish` command again. It should succeed now:
-->
<p>Lancez la commande <code>cargo publish</code> à nouveau. Elle devrait fonctionner à
présent :</p>
<!--
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-- >
-->
<!--
```console
$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
```
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
   Verifying jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
   Compiling jeu_du_plus_ou_du_moins v0.1.0
(file:///projects/jeu_du_plus_ou_du_moins/target/package/jeu_du_plus_ou_du_moins-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading jeu_du_plus_ou_du_moins v0.1.0 (file:///projects/jeu_du_plus_ou_du_moins)
</code></pre>
<!--
Congratulations! You’ve now shared your code with the Rust community, and
anyone can easily add your crate as a dependency of their project.
-->
<p>Félicitations ! Vous venez de partager votre code avec la communauté Rust, et
désormais tout le monde peut facilement ajouter votre crate comme une dépendance
de leur projet.</p>
<!--
### Publishing a New Version of an Existing Crate
-->
<h3 id="publier-une-nouvelle-version-dune-crate-existante"><a class="header" href="#publier-une-nouvelle-version-dune-crate-existante">Publier une nouvelle version d'une crate existante</a></h3>
<!--
When you’ve made changes to your crate and are ready to release a new version,
you change the `version` value specified in your *Cargo.toml* file and
republish. Use the [Semantic Versioning rules][semver] to decide what an
appropriate next version number is based on the kinds of changes you’ve made.
Then run `cargo publish` to upload the new version.
-->
<p>Lorsque vous avez fait des changements sur votre crate et que vous êtes prêt à
publier une nouvelle version, vous devez changer la valeur de <code>version</code>
renseignée dans votre fichier <em>Cargo.toml</em> et le publier à nouveau. Utilisez les
<a href="https://semver.org/lang/fr/">règles versionnage sémantique</a> pour choisir quelle sera la prochaine
version la plus appropriée en fonction des changements que vous avez fait.
Lancez ensuite <code>cargo publish</code> pour téléverser la nouvelle version.</p>
<!--
[semver]: http://semver.org/
-->
<!--
### Removing Versions from Crates.io with `cargo yank`
-->
<h3 id="retirer-des-versions-de-cratesio-avec-cargo-yank"><a class="header" href="#retirer-des-versions-de-cratesio-avec-cargo-yank">Retirer des versions de crates.io avec <code>cargo yank</code></a></h3>
<!--
Although you can’t remove previous versions of a crate, you can prevent any
future projects from adding them as a new dependency. This is useful when a
crate version is broken for one reason or another. In such situations, Cargo
supports *yanking* a crate version.
-->
<p>Bien que vous ne puissiez pas enlever des versions précédentes d'une crate, vous
pouvez prévenir les futurs projets de ne pas l'ajouter comme une nouvelle
dépendance. Cela s'avère pratique lorsqu'une version de crate est défectueuse
pour une raison ou une autre. Dans de telles circonstances, cargo permet de
<em>déprécier</em> une version de crate.</p>
<!--
Yanking a version prevents new projects from starting to depend on that version
while allowing all existing projects that depend on it to continue to download
and depend on that version. Essentially, a yank means that all projects with a
*Cargo.lock* will not break, and any future *Cargo.lock* files generated will
not use the yanked version.
-->
<p>Déprécier une version évite que les nouveaux projets ajoutent une dépendance à
cette version tout en permettant à tous les projets existants de continuer à en
dépendre en leur permettant toujours de télécharger et dépendre de cette
version. En gros, une version dépréciée permet à tous les projets avec un
<em>Cargo.lock</em> de ne pas échouer, mais tous les futurs fichiers <em>Cargo.lock</em>
générés n'utiliseront pas la version dépréciée.</p>
<!--
To yank a version of a crate, run `cargo yank` and specify which version you
want to yank:
-->
<p>Pour déprécier une version d'une crate, lancez <code>cargo yank</code> et renseignez quelle
version vous voulez déprécier :</p>
<!--
```console
$ cargo yank --vers 1.0.1
```
-->
<pre><code class="language-console">$ cargo yank --vers 1.0.1
</code></pre>
<!--
By adding `--undo` to the command, you can also undo a yank and allow projects
to start depending on a version again:
-->
<p>Si vous ajoutez <code>--undo</code> à la commande, vous pouvez aussi annuler une
dépréciation et permettre à nouveaux aux projets de dépendre de cette version :</p>
<!--
```console
$ cargo yank --vers 1.0.1 --undo
```
-->
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
</code></pre>
<!--
A yank *does not* delete any code. For example, the yank feature is not
intended for deleting accidentally uploaded secrets. If that happens, you must
reset those secrets immediately.
-->
<p>Une dépréciation <em>ne supprime pas</em> du code. Par exemple, la fonctionnalité de
dépréciation n'est pas conçue pour supprimer des <em>secrets</em> téléversés par
mégarde. Si cela arrive, vous devriez régénérer immédiatement ces secrets.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--3"><a class="header" href="#-attention-peinture-fraîche--3">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/182">Pull Request</a>.</p>
</blockquote>
<!--
## Cargo Workspaces
-->
<h2 id="les-espaces-de-travail-de-cargo"><a class="header" href="#les-espaces-de-travail-de-cargo">Les espaces de travail de cargo</a></h2>
<!--
In Chapter 12, we built a package that included a binary crate and a library
crate. As your project develops, you might find that the library crate
continues to get bigger and you want to split up your package further into
multiple library crates. In this situation, Cargo offers a feature called
*workspaces* that can help manage multiple related packages that are developed
in tandem.
-->
<p>Dans le chapitre 12, nous avons construit un paquet qui comprenait une crate
binaire et une crate de bibliothèque. Au fur et à mesure que votre projet se
développe, vous pourrez constater que la crate de bibliothèque continue de
s'agrandir et vous voudriez alors peut-être diviser votre paquet en plusieurs
crates de bibliothèque. Pour cette situation, cargo a une fonctionnalité qui
s'appelle <em>les espaces de travail</em> qui peuvent aider à gérer plusieurs paquets
liés qui sont développés en tandem.</p>
<!--
### Creating a Workspace
-->
<h3 id="créer-un-espace-de-travail"><a class="header" href="#créer-un-espace-de-travail">Créer un espace de travail</a></h3>
<!--
A *workspace* is a set of packages that share the same *Cargo.lock* and output
directory. Let’s make a project using a workspace—we’ll use trivial code so we
can concentrate on the structure of the workspace. There are multiple ways to
structure a workspace; we’re going to show one common way. We’ll have a
workspace containing a binary and two libraries. The binary, which will provide
the main functionality, will depend on the two libraries. One library will
provide an `add_one` function, and a second library an `add_two` function.
These three crates will be part of the same workspace. We’ll start by creating
a new directory for the workspace:
-->
<p>Un <em>espace de travail</em> est un jeu de paquets qui partagent tous le même
<em>Cargo.lock</em> et le même dossier de sortie. Créons donc un projet en utilisant un
espace de travail — nous allons utiliser du code trivial afin de nous concentrer
sur la structure de l'espace de travail. Il existe plusieurs façons de
structurer un espace de travail ; nous allons vous montrer une manière commune
d'organisation. Nous allons avoir un espace de travail contenant un binaire et
deux bibliothèques. Le binaire, qui devrait fournir les fonctionnalités
principales, va dépendre des deux bibliothèques. Une bibliothèque va fournir une
fonction <code>ajouter_un</code>, et la seconde bibliothèque, une fonction <code>ajouter_deux</code>.
Ces trois crates feront partie du même espace de travail. Nous allons commencer
par créer un nouveau dossier pour cet espace de travail :</p>
<!--
```console
$ mkdir add
$ cd add
```
-->
<pre><code class="language-console">$ mkdir ajout
$ cd ajout
</code></pre>
<!--
Next, in the *add* directory, we create the *Cargo.toml* file that will
configure the entire workspace. This file won’t have a `[package]` section or
the metadata we’ve seen in other *Cargo.toml* files. Instead, it will start
with a `[workspace]` section that will allow us to add members to the workspace
by specifying the path to the package with our binary crate; in this case,
that path is *adder*:
-->
<p>Ensuite, dans le dossier <em>ajout</em>, nous créons le fichier <em>Cargo.toml</em> qui va
configurer l'intégralité de l'espace de travail. Ce fichier n'aura pas de
section <code>[package]</code> ou les métadonnées que nous avons vues dans les autres
fichiers <em>Cargo.toml</em>. A la place, il commencera par une section <code>[workspace]</code>
qui va nous permettre d'ajouter des membres à l'espace de travail en
renseignant le chemin vers le paquet qui contient notre crate binaire ; dans ce
cas, ce chemin est <em>additioneur</em> :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<!--
```toml
[workspace]

members = [
    "adder",
]
```
-->
<pre><code class="language-toml">[workspace]

members = [
    &quot;additioneur&quot;,
]
</code></pre>
<pre><code class="language-toml">[workspace]

members = [
    &quot;additioneur&quot;,
]
</code></pre>
<!--
Next, we’ll create the `adder` binary crate by running `cargo new` within the
*add* directory:
-->
<p>Ensuite, nous allons créer la crate binaire <code>additioneur</code> en lançant <code>cargo new</code>
dans le dossier <em>ajout</em> :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-01-adder-crate/add
rm -rf adder
cargo new adder
copy output below
-- >
-->
<!--
```console
$ cargo new adder
     Created binary (application) `adder` package
```
-->
<pre><code class="language-console">$ cargo new additioneur
     Created binary (application) `additioneur` package
</code></pre>
<!--
At this point, we can build the workspace by running `cargo build`. The files
in your *add* directory should look like this:
-->
<p>A partir de ce moment, nous pouvons compiler l'espace de travail en lançant
<code>cargo build</code>. Les fichiers dans votre dossier <em>ajout</em> devraient ressembler à
ceci :</p>
<!--
```text
├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
```
-->
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── additioneur
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<!--
The workspace has one *target* directory at the top level for the compiled
artifacts to be placed into; the `adder` package doesn’t have its own *target*
directory. Even if we were to run `cargo build` from inside the *adder*
directory, the compiled artifacts would still end up in *add/target* rather
than *add/adder/target*. Cargo structures the *target* directory in a workspace
like this because the crates in a workspace are meant to depend on each other.
If each crate had its own *target* directory, each crate would have to
recompile each of the other crates in the workspace to have the artifacts in
its own *target* directory. By sharing one *target* directory, the crates can
avoid unnecessary rebuilding.
-->
<p>L'espace de travail a un dossier <em>target</em> au niveau le plus haut pour y placer
les artefacts compilés ; le paquet <code>additioneur</code> n'a pas son propre dossier
<em>target</em>. Même si nous lancions <code>cargo build</code> à l'intérieur du dossier
<em>additioneur</em>, les artefacts compilés finirons toujours dans <em>ajout/target</em>
plutôt que dans <em>ajout/additioneur/target</em>. Cargo organise ainsi le dossier
<em>target</em> car les crates d'un espace de travail sont censés dépendre l'une de
l'autre. Si chaque crate avait son propre dossier <em>target</em>, chaque crate
devrait recompiler chacune des autres crates présentes dans l'espace de
travail pour avoir les artefacts dans son propre dossier <em>target</em>. En
partageant un seul dossier <em>target</em>, les crates peuvent éviter des
re-compilations inutiles.</p>
<!--
### Creating the Second Package in the Workspace
-->
<h3 id="créer-le-second-paquet-dans-lespace-de-travail"><a class="header" href="#créer-le-second-paquet-dans-lespace-de-travail">Créer le second paquet dans l'espace de travail</a></h3>
<!--
Next, let’s create another member package in the workspace and call it `add-one`.
Change the top-level *Cargo.toml* to specify the *add-one* path in the
`members` list:
-->
<p>Ensuite, créons un autre paquet, membre de l'espace de travail et appelons-la
<code>ajouter-un</code>. Changeons le <em>Cargo.toml</em> du niveau le plus haut pour renseigner
le chemin vers <em>ajouter-un</em> dans la liste <code>members</code> :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<!--
```toml
[workspace]

members = [
    "adder",
    "add-one",
]
```
-->
<pre><code class="language-toml">[workspace]

members = [
    &quot;additioneur&quot;,
    &quot;ajouter-un&quot;,
]
</code></pre>
<!--
Then generate a new library crate named `add-one`:
-->
<p>Ensuite, générons une nouvelle crate de bibliothèque <code>ajouter-un</code> :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-02-add-one/add
rm -rf add-one
cargo new add-one --lib
copy output below
-- >
-->
<!--
```console
$ cargo new add-one --lib
     Created library `add-one` package
```
-->
<pre><code class="language-console">$ cargo new ajouter-un --lib
     Created library `ajouter-un` package
</code></pre>
<!--
Your *add* directory should now have these directories and files:
-->
<p>Votre dossier <em>ajout</em> devrait maintenant avoir ces dossiers et fichiers :</p>
<!--
```text
├── Cargo.lock
├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
```
-->
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── ajouter-un
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── additioneur
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<!--
In the *add-one/src/lib.rs* file, let’s add an `add_one` function:
-->
<p>Dans le fichier <em>ajouter-un/src/lib.rs</em>, ajoutons une fonction <code>ajouter_un</code> :</p>
<!--
<span class="filename">Filename: add-one/src/lib.rs</span>
-->
<p><span class="filename">Fichier : ajouter-un/src/lib.rs</span></p>
<!--
```rust
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn ajouter_un(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<!--
Now that we have another package in the workspace, we can have the `adder`
package with our binary depend on the `add-one` package, that has our
library. First, we’ll need to add a path dependency on `add-one` to
*adder/Cargo.toml*.
-->
<p>Maintenant que nous avons un autre paquet dans l'espace de travail, nous pouvons
faire en sorte que le paquet <code>additioneur</code> qui contient notre binaire dépende du
paquet <code>ajouter-un</code>, qui contient notre bibliothèque. D'abord, nous devons
ajouter un chemin de dépendance à <code>ajouter-un</code> dans <em>additioneur/Cargo.toml</em>.</p>
<!--
<span class="filename">Filename: adder/Cargo.toml</span>
-->
<p><span class="filename">Fichier : additioneur/Cargo.toml</span></p>
<!--
```toml
[dependencies]

add-one = { path = "../add-one" }
```
-->
<pre><code class="language-toml">[dependencies]

ajouter-un = { path = &quot;../ajouter-un&quot; }
</code></pre>
<!--
Cargo doesn’t assume that crates in a workspace will depend on each other, so
we need to be explicit about the dependency relationships between the crates.
-->
<p>Cargo ne fait pas la supposition que les crates d'un espace de travail
dépendent l'une de l'autre, donc vous devez être explicites sur les relations
de dépendance entre les crates.</p>
<!--
Next, let’s use the `add_one` function from the `add-one` crate in the `adder`
crate. Open the *adder/src/main.rs* file and add a `use` line at the top to
bring the new `add-one` library crate into scope. Then change the `main`
function to call the `add_one` function, as in Listing 14-7.
-->
<p>Ensuite, utilisons la fonction <code>ajouter_un</code> de la crate <code>ajouter-un</code> dans la
crate <code>additioneur</code>. Ouvrez le fichier <em>additioneur/src/main.rs</em> et ajoutez une
ligne <code>use</code> tout en haut pour importer la bibliothèque <code>ajouter-un</code> dans la
portée. Changez ensuite la fonction <code>main</code> pour appeler la fonction
<code>ajouter_un</code>, comme dans l'encart 14-7.</p>
<!--
<span class="filename">Filename: adder/src/main.rs</span>
-->
<p><span class="filename">Fichier : additioneur/src/main.rs</span></p>
<!--
```rust,ignore
use add_one;

fn main() {
    let num = 10;
    println!(
        "Hello, world! {} plus one is {}!",
        num,
        add_one::add_one(num)
    );
}
```
-->
<pre><code class="language-rust ignore">use ajouter_un;

fn main() {
    let nombre = 10;
    println!(
        &quot;Hello, world ! {} plus un vaut {} !&quot;,
        nombre,
        ajouter_un::ajouter_un(nombre)
    );
}
</code></pre>
<!--
<span class="caption">Listing 14-7: Using the `add-one` library crate from the 
 `adder` crate</span>
-->
<p><span class="caption">Encart 14-7 : utilisation de la bibliothèque <code>ajouter-un</code>
dans la crate <code>additioneur</code></span></p>
<!--
Let’s build the workspace by running `cargo build` in the top-level *add*
directory!
-->
<p>Compilons l'espace de travail en lançant <code>cargo build</code> dans le niveau le plus
haut du dossier <em>ajout</em> !</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo build
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
```
-->
<pre><code class="language-console">$ cargo build
   Compiling ajouter-un v0.1.0 (file:///projects/ajout/ajouter-un)
   Compiling additioneur v0.1.0 (file:///projects/ajout/additioneur)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
</code></pre>
<!--
To run the binary crate from the *add* directory, we can specify which
package in the workspace we want to run by using the `-p` argument and the
package name with `cargo run`:
-->
<p>Pour lancer la crate binaire à partir du dossier <em>ajout</em>, nous pouvons
préciser quel paquet nous souhaitons exécuter dans l'espace de travail en
utilisant l'argument <code>-p</code> suivi du nom du paquet avec <code>cargo run</code> :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo run -p adder
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
```
-->
<pre><code class="language-console">$ cargo run -p additioneur
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/additioneur`
Hello, world ! 10 plus un vaut 11 !
</code></pre>
<!--
This runs the code in *adder/src/main.rs*, which depends on the `add-one` crate.
-->
<p>Cela exécute le code de <em>additioneur/src/main.rs</em>, qui dépend de la crate
<code>ajouter-un</code>.</p>
<!--
#### Depending on an External Package in a Workspace
-->
<h4 id="dépendre-dun-paquet-externe-dans-un-espace-de-travail"><a class="header" href="#dépendre-dun-paquet-externe-dans-un-espace-de-travail">Dépendre d'un paquet externe dans un espace de travail</a></h4>
<!--
Notice that the workspace has only one *Cargo.lock* file at the top level of
the workspace rather than having a *Cargo.lock* in each crate’s directory. This
ensures that all crates are using the same version of all dependencies. If we
add the `rand` package to the *adder/Cargo.toml* and *add-one/Cargo.toml*
files, Cargo will resolve both of those to one version of `rand` and record
that in the one *Cargo.lock*. Making all crates in the workspace use the same
dependencies means the crates in the workspace will always be compatible with
each other. Let’s add the `rand` crate to the `[dependencies]` section in the
*add-one/Cargo.toml* file to be able to use the `rand` crate in the `add-one`
crate:
-->
<p>Notez que l'espace de travail a un seul fichier <em>Cargo.lock</em> dans le niveau le
plus haut de l'espace de travail plutôt que d'avoir un <em>Cargo.lock</em> dans chaque
dossier de chaque crate. Cela garantit que toutes les crates utilisent la même
version de toutes les dépendances. Si nous ajoutons le paquet <code>rand</code> aux
fichiers <em>additioneur/Cargo.toml</em> et <em>ajouter-un/Cargo.toml</em>, cargo va réunir
ces deux en une seule version de <code>rand</code> et enregistrer cela dans un seul
<em>Cargo.lock</em>. Faire en sorte que toutes les crates de l'espace de travail
utilisent la même dépendance signifie que les crates dans l'espace de travail
seront toujours compatibles l'une avec l'autre. Ajoutons la crate <code>rand</code> à la
section <code>[dependencies]</code> du fichier <em>ajouter-un/Cargo.toml</em> pour pouvoir
utiliser la crate <code>rand</code> dans la crate <code>ajouter-un</code> :</p>
<!--
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
-- >
-->
<!--
<span class="filename">Filename: add-one/Cargo.toml</span>
-->
<p><span class="filename">Fichier : ajouter-un/Cargo.toml</span></p>
<!--
```toml
[dependencies]
rand = "0.5.5"
```
-->
<pre><code class="language-toml">[dependencies]
rand = &quot;0.5.5&quot;
</code></pre>
<!--
We can now add `use rand;` to the *add-one/src/lib.rs* file, and building the
whole workspace by running `cargo build` in the *add* directory will bring in
and compile the `rand` crate:
-->
<p>Nous pouvons maintenant ajouter <code>use rand;</code> au fichier <em>ajouter-un/src/lib.rs</em>,
et compiler l'ensemble de l'espace de travail en lançant <code>cargo build</code> dans le
dossier <em>ajout</em>, ce qui va importer et compiler la crate <code>rand</code> :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo build
    Updating crates.io index
  Downloaded rand v0.5.5
   --snip--
   Compiling rand v0.5.6
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18s
```
-->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.5.5
   -- partie masquée ici --
   Compiling rand v0.5.6
   Compiling ajouter-un v0.1.0 (file:///projects/ajout/ajouter-un)
   Compiling additioneur v0.1.0 (file:///projects/ajout/additioneur)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18s
</code></pre>
<!--
The top-level *Cargo.lock* now contains information about the dependency of
`add-one` on `rand`. However, even though `rand` is used somewhere in the
workspace, we can’t use it in other crates in the workspace unless we add
`rand` to their *Cargo.toml* files as well. For example, if we add `use rand;`
to the *adder/src/main.rs* file for the `adder` package, we’ll get an error:
-->
<p>Le <em>Cargo.lock</em> du niveau le plus haut contient maintenant les informations
de dépendance à <code>rand</code> pour <code>ajouter-un</code>. Cependant, même si <code>rand</code> est
utilisé quelque part dans l'espace de travail, nous ne pouvons pas l'utiliser
dans d'autres crates de l'espace de travail tant que nous n'ajoutons pas
<code>rand</code> dans leurs fichiers <em>Cargo.toml</em>. Par exemple, si nous ajoutons
<code>use rand;</code> dans le fichier <em>additioneur/src/main.rs</em> pour le paquet
<code>additioneur</code>, nous allons avoir une erreur :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-03-use-rand/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo build
  --snip--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 -- > adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no `rand` external crate
```
-->
<pre><code class="language-console">$ cargo build
  -- partie masquée ici --
   Compiling additioneur v0.1.0 (file:///projects/ajout/additioneur)
error[E0432]: unresolved import `rand`
 -- &gt; additioneur/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no `rand` external crate
</code></pre>
<!--
To fix this, edit the *Cargo.toml* file for the `adder` package and indicate
that `rand` is a dependency for it as well. Building the `adder` package will
add `rand` to the list of dependencies for `adder` in *Cargo.lock*, but no
additional copies of `rand` will be downloaded. Cargo has ensured that every
crate in every package in the workspace using the `rand` package will be
using the same version. Using the same version of `rand` across the workspace
saves space because we won’t have multiple copies and ensures that the crates
in the workspace will be compatible with each other.
-->
<p>Pour corriger cela, modifiez le fichier <em>Cargo.toml</em> pour le paquet
<code>additioneur</code> et rajouter-lui aussi un dépendance à <code>rand</code>. La compilation du
paquet <code>additioneur</code> va rajouter <code>rand</code> à la liste des dépendances pour
<code>additioneur</code> dans <em>Cargo.lock</em>, mais aucune copie supplémentaire de <code>rand</code> sera
téléchargé. Cargo s'est assuré que toutes les crates de chaque paquet de
l'espace de travail qui utilise le paquet <code>rand</code> serait de la même version.
Utiliser la même version de <code>rand</code> dans les espaces de travail économise de
l'espace car nous n'avons pas à multiplier les copies, ni s'assurer que les
crates dans l'espace de travail seraient compatibles l'une envers l'autre.</p>
<!--
#### Adding a Test to a Workspace
-->
<h4 id="ajouter-un-test-à-lespace-de-travail"><a class="header" href="#ajouter-un-test-à-lespace-de-travail">Ajouter un test à l'espace de travail</a></h4>
<!--
For another enhancement, let’s add a test of the `add_one::add_one` function
within the `add_one` crate:
-->
<p>Afin de procéder à une autre amélioration, ajoutons un test de la fonction
<code>ajouter_un::ajouter_un</code> dans la crate <code>ajouter_un</code> :</p>
<!--
<span class="filename">Filename: add-one/src/lib.rs</span>
-->
<p><span class="filename">Fihcier : add-one/src/lib.rs</span></p>
<!--
```rust
pub fn add_one(x: i32) -> i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn ajouter_un(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn cela_fonctionne() {
        assert_eq!(3, ajouter_un(2));
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
Now run `cargo test` in the top-level *add* directory:
-->
<p>Lancez maintenant <code>cargo test</code> dans le niveau le plus haut du
dossier <em>ajout</em> :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo test
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running target/debug/deps/add_one-f0253159197f7841

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/adder-49979ff40686fa8e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```
-->
<pre><code class="language-console">$ cargo test
   Compiling ajouter-un v0.1.0 (file:///projects/ajout/ajouter-un)
   Compiling additioneur v0.1.0 (file:///projects/ajout/additioneur)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running target/debug/deps/ajouter_un-f0253159197f7841

running 1 test
test tests::cela_fonctionne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/additioneur-49979ff40686fa8e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests ajouter-un

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
The first section of the output shows that the `it_works` test in the `add-one`
crate passed. The next section shows that zero tests were found in the `adder`
crate, and then the last section shows zero documentation tests were found in
the `add-one` crate. Running `cargo test` in a workspace structured like this
one will run the tests for all the crates in the workspace.
-->
<p>La première section de la sortie indique que le test <code>cela_fonctionne</code> de la
crate <code>ajouter-un</code> a réussi. La section suivante indique qu'aucun test n'a été
trouvé dans la crate <code>additioneur</code>, et ensuite la dernière section indique elle
aussi qu'aucun test de documentation a été trouvé dans la crate <code>ajouter-un</code>.
Lancer <code>cargo test</code> dans un espace de travail structuré comme celui-ci va
exécuter les tests pour toutes les crates de cet espace de travail.</p>
<!--
We can also run tests for one particular crate in a workspace from the
top-level directory by using the `-p` flag and specifying the name of the crate
we want to test:
-->
<p>Nous pouvons aussi lancer des tests pour une crate en particulier dans un
espace de travail à partir du dossier du plus haut niveau en utilisant le
drapeau <code>-p</code> et en renseignant le nom de la crate que nous voulons tester :</p>
<!--
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test -p add-one
copy output below; the output updating script doesn't handle subdirectories in paths properly
-- >
-->
<!--
```console
$ cargo test -p add-one
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```
-->
<pre><code class="language-console">$ cargo test -p ajouter-un
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running target/debug/deps/ajouter_un-b3235fea9a156f74

running 1 test
test tests::cela_fonctionne ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests ajouter-un

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
This output shows `cargo test` only ran the tests for the `add-one` crate and
didn’t run the `adder` crate tests.
-->
<p>Cette sortie montre que <code>cargo test</code> a lancé les tests uniquement pour la
crate <code>ajouter-un</code> et n'a pas lancé les tests de la crate <code>additioneur</code>.</p>
<!--
If you publish the crates in the workspace to [crates.io](https://crates.io/),
each crate in the workspace will need to be published separately. The `cargo
publish` command does not have an `--all` flag or a `-p` flag, so you must
change to each crate’s directory and run `cargo publish` on each crate in the
workspace to publish the crates.
-->
<p>Si vous publiez les crates présentes dans l'espace de travail sur
<a href="https://crates.io/">crates.io</a>, chaque crate de l'espace de travail va avoir
besoin d'être publiée de manière séparée. La commande <code>cargo publish</code> n'a pas
de drapeau <code>--all</code> ou <code>-p</code>, donc vous devrez vous rendre dans chaque dossier de
chaque crate et lancer <code>cargo publish</code> sur chaque crate présente dans l'espace
de travail pour publier les crates.</p>
<!--
For additional practice, add an `add-two` crate to this workspace in a similar
way as the `add-one` crate!
-->
<p>En guise d'entrainement supplémentaire, ajoutez une crate <code>ajouter-deux</code> dans
cet espace de travail de la même manière que nous l'avons fait pour la crate
<code>ajouter-un</code> !</p>
<!--
As your project grows, consider using a workspace: it’s easier to understand
smaller, individual components than one big blob of code. Furthermore, keeping
the crates in a workspace can make coordination between them easier if they are
often changed at the same time.
-->
<p>Au fur et à mesure que votre projet se développe, pensez à utiliser un espace
de travail : il est plus facile de comprendre des composants individuels, plus
petits, plutôt qu'un gros tas de code. De plus, garder les crates dans un
espace de travail peut améliorer la collation entre elles si elles sont souvent
modifiées ensemble.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--4"><a class="header" href="#-attention-peinture-fraîche--4">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/183">Pull Request</a>.</p>
</blockquote>
<!--
## Installing Binaries from Crates.io with `cargo install`
-->
<h2 id="installer-des-binaires-à-partir-de-cratesio-avec-cargo-install"><a class="header" href="#installer-des-binaires-à-partir-de-cratesio-avec-cargo-install">Installer des binaires à partir de crates.io avec <code>cargo install</code></a></h2>
<!--
The `cargo install` command allows you to install and use binary crates
locally. This isn’t intended to replace system packages; it’s meant to be a
convenient way for Rust developers to install tools that others have shared on
[crates.io](https://crates.io/)<!-- ignore -- >. Note that you can only install
packages that have binary targets. A *binary target* is the runnable program
that is created if the crate has a *src/main.rs* file or another file specified
as a binary, as opposed to a library target that isn’t runnable on its own but
is suitable for including within other programs. Usually, crates have
information in the *README* file about whether a crate is a library, has a
binary target, or both.
-->
<p>La commande <code>cargo install</code> vous permet d'installer et utiliser des crates de
binaires localement. Cela n'est pas conçu pour remplacer les systèmes de
paquets ; c'est plutôt un moyen pratique pour les développeurs Rust d'installer
des outils que les autres ont partagé sur
<a href="https://crates.io/">crates.io</a><!-- ignore -->. Notez que vous ne pouvez
installer que des paquets qui ont des destinations binaires. Une <em>destination
binaire</em> est le programme exécutable qui est créé si la crate a un fichier
<em>src/main.rs</em> ou un autre fichier renseigné comme un binaire, contrairement
à une destination de bibliothèque qui n'est pas exécutable en tant que tel mais
qu'il est possible d'intégrer à un autre programme. Habituellement, les crates
ont l'information dans le fichier <em>README</em> pour savoir si elle est une
bibliothèque, a une destination binaire, ou les deux.</p>
<!--
All binaries installed with `cargo install` are stored in the installation
root’s *bin* folder. If you installed Rust using *rustup.rs* and don’t have any
custom configurations, this directory will be *$HOME/.cargo/bin*. Ensure that
directory is in your `$PATH` to be able to run programs you’ve installed with
`cargo install`.
-->
<p>Tous les binaires installés avec <code>cargo install</code> sont stockés dans le dossier
<em>bin</em> de la racine. Si vous installez Rust avec <em>rustup.rs</em> et que vous n'avez
pas personnalisé la configuration, ce dossier sera <em>$HOME/.cargo/bin</em>.
Assurez-vous que ce dossier est dans votre <code>$PATH</code> pour pouvoir exécuter des
programmes que vous avez installé avec <code>cargo install</code>.</p>
<!--
For example, in Chapter 12 we mentioned that there’s a Rust implementation of
the `grep` tool called `ripgrep` for searching files. If we want to install
`ripgrep`, we can run the following:
-->
<p>Par exemple, dans le chapitre 12 nous avions mentionné le fait qu'il existait
une implémentation de l'outil <code>grep</code> en Rust qui s'appelait <code>ripgrep</code> et qui
permettait de rechercher dans des fichiers. Si nous voulons installer
<code>ripgrep</code>, nous pouvons faire comme ceci :</p>
<!--
<!-- manual-regeneration
cargo install something you don't have, copy relevant output below
-- >
-->
<!--
```console
$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v11.0.2
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v11.0.2
--snip--
   Compiling ripgrep v11.0.2
    Finished release [optimized] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v11.0.2` (executable `rg`)
```
-->
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v11.0.2
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v11.0.2
-- partie masquée ici --
   Compiling ripgrep v11.0.2
    Finished release [optimized] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v11.0.2` (executable `rg`)
</code></pre>
<!--
The second-to-last line of the output shows the location and the name of the
installed binary, which in the case of `ripgrep` is `rg`. As long as the
installation directory is in your `$PATH`, as mentioned previously, you can
then run `rg --help` and start using a faster, rustier tool for searching files!
-->
<p>L'avant-dernière ligne de la sortie nous montre l'emplacement et le nom du
binaire installé, qui est <code>rg</code> dans le cas de <code>ripgrep</code>. Tel que mentionné
précédemment, du moment que le dossier d'installation est dans votre <code>$PATH</code>,
vous pouvez ensuite lancer <code>rg --help</code> et commencer à utiliser un outil en Rust
qui est rapide pour rechercher dans les fichiers !</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--5"><a class="header" href="#-attention-peinture-fraîche--5">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/184">Pull Request</a>.</p>
</blockquote>
<!--
## Extending Cargo with Custom Commands
-->
<h2 id="etendre-les-fonctionnalités-de-cargo-avec-des-commandes-personnalisées"><a class="header" href="#etendre-les-fonctionnalités-de-cargo-avec-des-commandes-personnalisées">Etendre les fonctionnalités de cargo avec des commandes personnalisées</a></h2>
<!--
Cargo is designed so you can extend it with new subcommands without having to
modify Cargo. If a binary in your `$PATH` is named `cargo-something`, you can
run it as if it was a Cargo subcommand by running `cargo something`. Custom
commands like this are also listed when you run `cargo --list`. Being able to
use `cargo install` to install extensions and then run them just like the
built-in Cargo tools is a super convenient benefit of Cargo’s design!
-->
<p>Cargo est conçu pour que vous puissiez étendre ses fonctionnalités avec des
nouvelles sous-commandes sans avoir à modifier cargo. Si un binaire dans votre
<code>$PATH</code> est nommé selon <code>cargo-quelquechose</code>, vous pouvez le lancer comme s'il
était une sous-commande de cargo en lançant <code>cargo quelquechose</code>. Les commandes
personnalisées comme celle-ci  sont aussi listées lorsque vous lancez
<code>cargo --list</code>. Pouvoir utiliser <code>cargo install</code> pour installer des extensions
et ensuite les lancer comme étant un outil intégré à cargo est un avantage
super pratique de la conception de cargo !</p>
<!--
## Summary
-->
<h2 id="résumé-13"><a class="header" href="#résumé-13">Résumé</a></h2>
<!--
Sharing code with Cargo and [crates.io](https://crates.io/)<!-- ignore -- > is
part of what makes the Rust ecosystem useful for many different tasks. Rust’s
standard library is small and stable, but crates are easy to share, use, and
improve on a timeline different from that of the language. Don’t be shy about
sharing code that’s useful to you on [crates.io](https://crates.io/)<!-- ignore
-- >; it’s likely that it will be useful to someone else as well!
-->
<p>Le partage de code avec cargo et <a href="https://crates.io/">crates.io</a><!-- ignore -->
est la partie qui rend l'écosystème de Rust très utile pour de nombreuses
tâches. La bibliothèque standard de Rust est compacte et stable, et les crates
sont faciles à partager, utiliser, et à améliorer dans un cycle de vie différent
du langage. N'hésitez pas à partager du code qui vous est utile sur
<a href="https://crates.io/">crates.io</a><!-- ignore --> ; il est fort probable qu'il
sera aussi utile à quelqu'un d'autre !</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--6"><a class="header" href="#-attention-peinture-fraîche--6">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/185">Pull Request</a>.</p>
</blockquote>
<!--
# Smart Pointers
-->
<h1 id="les-pointeurs-intelligents"><a class="header" href="#les-pointeurs-intelligents">Les pointeurs intelligents</a></h1>
<!--
A *pointer* is a general concept for a variable that contains an address in
memory. This address refers to, or “points at,” some other data. The most
common kind of pointer in Rust is a reference, which you learned about in
Chapter 4. References are indicated by the `&` symbol and borrow the value they
point to. They don’t have any special capabilities other than referring to
data. Also, they don’t have any overhead and are the kind of pointer we use
most often.
-->
<p>Un <em>pointeur</em> est concept général pour une variable qui contient une adresse
vers la mémoire. Cette adresse pointe vers d'autres données. Le type de pointeur
le plus courant en Rust est la référence, que vous avez appris au chapitre 4.
Les références sont marquées par le symbole <code>&amp;</code> et empruntent la valeur sur
laquelle ils pointent. Elles n'ont pas d'autres fonctionnalités que celle de
pointer sur une donnée. De plus, elles n'ont pas coût sur les performances et
c'est le type de pointeur que nous utilisons le plus souvent.</p>
<!--
*Smart pointers*, on the other hand, are data structures that not only act like
a pointer but also have additional metadata and capabilities. The concept of
smart pointers isn’t unique to Rust: smart pointers originated in C++ and exist
in other languages as well. In Rust, the different smart pointers defined in
the standard library provide functionality beyond that provided by references.
One example that we’ll explore in this chapter is the *reference counting*
smart pointer type. This pointer enables you to have multiple owners of data by
keeping track of the number of owners and, when no owners remain, cleaning up
the data.
-->
<p>Les <em>pointeurs intelligents</em>, d'une autre côté, sont des structures de données
qui, non seulement se comportent comme un pointeur, mais ont aussi des
fonctionnalités et métadonnées supplémentaires. Le concept de pointeur
intelligent n'est pas propre à Rust : les pointeurs intelligents sont
originaires du C++ et existent aussi dans d'autres langages. En Rust, les
différents pointeurs intelligents définis dans bibliothèque standard
fournissent des fonctionnalités supplémentaires à celles des références.
Un exemple que nous allons explorer dans ce chapitre est le type de pointeur
intelligent <em>compteur de références</em>. Ce pointeur vous permet d'avoir
plusieurs propriétaires d'une donnée tout en gardant une trace leur nombre et,
lorsqu'il n'y en a plus, nettoyer cette donnée.</p>
<!--
In Rust, which uses the concept of ownership and borrowing, an additional
difference between references and smart pointers is that references are
pointers that only borrow data; in contrast, in many cases, smart pointers
*own* the data they point to.
-->
<p>En Rust, qui utilise le concept de propriétaire et d'emprunt, une différence
supplémentaire entre les références et les pointeurs intelligents est que les
références sont des pointeurs qui empruntent seulement la donnée ; alors qu'au
contraire, dans de nombreux cas, les pointeurs intelligents sont
<em>propriétaires</em> des données sur lesquels ils pointent.</p>
<!--
We’ve already encountered a few smart pointers in this book, such as `String`
and `Vec<T>` in Chapter 8, although we didn’t call them smart pointers at the
time. Both these types count as smart pointers because they own some memory and
allow you to manipulate it. They also have metadata (such as their capacity)
and extra capabilities or guarantees (such as with `String` ensuring its data
will always be valid UTF-8).
-->
<p>Nous avons déjà rencontré quelques pointeurs intelligents au cours de ce
livre, comme <code>String</code> et <code>Vec&lt;T&gt;</code> au chapitre 8, même si nous ne les avons pas
désignés comme étant des pointeurs intelligents à ce moment-là. Ces deux types
sont considérés comme des pointeurs intelligents car ils sont propriétaires de
ces données et vous permettent de les manipuler. Ils ont aussi des métadonnées
(comme leur capacité) et certaines fonctionnalités ou garanties (comme <code>String</code>
qui s'assure que ses données soient toujours en UTF-8).</p>
<!--
Smart pointers are usually implemented using structs. The characteristic that
distinguishes a smart pointer from an ordinary struct is that smart pointers
implement the `Deref` and `Drop` traits. The `Deref` trait allows an instance
of the smart pointer struct to behave like a reference so you can write code
that works with either references or smart pointers. The `Drop` trait allows
you to customize the code that is run when an instance of the smart pointer
goes out of scope. In this chapter, we’ll discuss both traits and demonstrate
why they’re important to smart pointers.
-->
<p>Les pointeurs intelligents sont souvent implémentés en utilisant des
structures. Les caractéristiques qui distinguent un pointeur intelligent d'une
structure classique est que les pointeurs intelligents implémentent les traits
<code>Deref</code> et <code>Drop</code>. Le trait <code>Deref</code> permet à une instance d'un pointeur
intelligent de se comporter comme une référence afin que vous puissiez écrire
du code qui fonctionne aussi bien avec des références qu'avec des pointeurs
intelligents. Le trait <code>Drop</code> vous permet de personnaliser le code qui est
exécuté lorsqu'une instance d'un pointeur intelligent sort de la portée. Dans
ce chapitre, nous verrons ces deux traits et expliquer pourquoi ils sont
importants pour les pointeurs intelligents.</p>
<!--
Given that the smart pointer pattern is a general design pattern used
frequently in Rust, this chapter won’t cover every existing smart pointer. Many
libraries have their own smart pointers, and you can even write your own. We’ll
cover the most common smart pointers in the standard library:
-->
<p>Vu que le motif des pointeurs intelligents est un motif de conception général
fréquemment utilisé en Rust, ce chapitre ne couvrira pas tous les pointeurs
intelligents existants. De nombreuses bibliothèques ont leurs propres pointeurs
intelligents, et vous pouvez même écrire le vôtre. Nous allons voir les
pointeurs intelligents les plus courants de la bibliothèque standard :</p>
<!--
* `Box<T>` for allocating values on the heap
* `Rc<T>`, a reference counting type that enables multiple ownership
* `Ref<T>` and `RefMut<T>`, accessed through `RefCell<T>`, a type that enforces
  the borrowing rules at runtime instead of compile time
-->
<ul>
<li><code>Box&lt;T&gt;</code> pour l'allocation de valeurs sur le tas</li>
<li><code>Rc&lt;T&gt;</code>, un type comptant les références, qui permet d'avoir plusieurs
propriétaires</li>
<li><code>Ref&lt;T&gt;</code> et <code>RefMut&lt;T&gt;</code>, par lesquels on y accède via <code>RefCell&lt;T&gt;</code>, un type
qui permet d'appliquer les règles d'emprunt au moment de l'exécution au lieu
du moment de la compilation</li>
</ul>
<!--
In addition, we’ll cover the *interior mutability* pattern where an immutable
type exposes an API for mutating an interior value. We’ll also discuss
*reference cycles*: how they can leak memory and how to prevent them.
-->
<p>En outre, nous allons voir le motif de <em>mutabilité interne</em> dans lequel un
type immuable propose une API pour muter une valeur interne. Nous allons aussi
parler des <em>boucles de références</em> : comment elles peuvent provoquer des fuites
de mémoire et comment les éviter.</p>
<!--
Let’s dive in!
-->
<p>Allons-y !</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--7"><a class="header" href="#-attention-peinture-fraîche--7">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/188">Pull Request</a>.</p>
</blockquote>
<!--
## Using `Box<T>` to Point to Data on the Heap
-->
<h2 id="utiliser-boxt-pour-pointer-sur-des-données-présentes-sur-le-tas"><a class="header" href="#utiliser-boxt-pour-pointer-sur-des-données-présentes-sur-le-tas">Utiliser <code>Box&lt;T&gt;</code> pour pointer sur des données présentes sur le tas</a></h2>
<!--
The most straightforward smart pointer is a *box*, whose type is written
`Box<T>`. Boxes allow you to store data on the heap rather than the stack. What
remains on the stack is the pointer to the heap data. Refer to Chapter 4 to
review the difference between the stack and the heap.
-->
<p>Le pointeur intelligent le plus simple est la <em>boite</em>, dont le type s'écrit
<code>Box&lt;T&gt;</code>. Les boites vous permettent de stocker des données sur le tas plutôt
que sur la pile. La seule chose qui reste sur la pile est le pointeur vers les
données sur le tas. Revenez au chapitre 4 pour vous rappeler la différence entre
la pile et le tas.</p>
<!--
Boxes don’t have performance overhead, other than storing their data on the
heap instead of on the stack. But they don’t have many extra capabilities
either. You’ll use them most often in these situations:
-->
<p>Les boites ne provoquent pas de surcharge au niveau des performances, si ce
n'est le stockage de leurs données sur le tas plutôt que sur la pile. Mais elles
n'ont pas non plus beaucoup plus de fonctionnalités. Vous allez les utiliser
principalement dans les situations suivantes :</p>
<!--
* When you have a type whose size can’t be known at compile time and you want
  to use a value of that type in a context that requires an exact size
* When you have a large amount of data and you want to transfer ownership but
  ensure the data won’t be copied when you do so
* When you want to own a value and you care only that it’s a type that
  implements a particular trait rather than being of a specific type
-->
<ul>
<li>Lorsque vous avez un type dont la taille ne peut pas être connu au moment de
la compilation et que vous souhaitez une valeur d'un certain type dans un
contexte qui nécessite de savoir exactement sa taille</li>
<li>Lorsque vous avez une grosse quantité de données et que vous souhaitez
transférer la possession mais vous assurer que les données ne seront pas
copiées lorsque vous le ferez</li>
<li>Lorsque vous voulez prendre possession d'une valeur et que vous souhaitez
seulement qu'elle soit d'un type qui implémente un trait particulier plutôt
que d'attendre qu'elle soit d'un type précis</li>
</ul>
<!--
We’ll demonstrate the first situation in the [“Enabling Recursive Types with
Boxes”](#enabling-recursive-types-with-boxes)<!-- ignore -- > section. In the
second case, transferring ownership of a large amount of data can take a long
time because the data is copied around on the stack. To improve performance in
this situation, we can store the large amount of data on the heap in a box.
Then, only the small amount of pointer data is copied around on the stack,
while the data it references stays in one place on the heap. The third case is
known as a *trait object*, and Chapter 17 devotes an entire section, [“Using
Trait Objects That Allow for Values of Different Types,”][trait-objects]<!--
ignore -- > just to that topic. So what you learn here you’ll apply again in
Chapter 17!
-->
<p>Nous allons expérimenter la première situation dans la section <a href="ch15-01-box.html#pouvoir-utiliser-des-types-r%C3%A9cursifs-gr%C3%A2ce-aux-boites">“Pouvoir
utiliser des types récursifs grâce aux
boites”</a><!-- ignore -->.
Pour la seconde situation, le transfert de possession d'une grosse quantité de
données peut prendre beaucoup de temps car les données sont recopiées sur la
pile. Pour améliorer les performances dans cette situation, nous pouvons stocker
ces données sur le tas grâce à une boite. Ainsi, seul le petit pointeur vers les
données est copié sur la pile, alors que les données qu'il pointe restent à leur
place sur le tas. La troisième situation décris ce qu'on appelle un
<em>objet de trait</em> et le <a href="ch17-02-trait-objects.html">chapitre 17</a><!-- ignore --> dédie une
section entière à ce sujet. Donc ce que vous apprenez ici, vous le retrouverez à
nouveau au chapitre 17 !</p>
<!--
### Using a `Box<T>` to Store Data on the Heap
-->
<h3 id="utiliser-une-boxt-pour-stocker-des-données-sur-le-tas"><a class="header" href="#utiliser-une-boxt-pour-stocker-des-données-sur-le-tas">Utiliser une <code>Box&lt;T&gt;</code> pour stocker des données sur le tas</a></h3>
<!--
Before we discuss this use case for `Box<T>`, we’ll cover the syntax and how to
interact with values stored within a `Box<T>`.
-->
<p>Avant de parler de ce cas d'usage de <code>Box&lt;T&gt;</code>, nous devons voir sa syntaxe et
comment interagir avec les valeurs stockées dans un <code>Box&lt;T&gt;</code>.</p>
<!--
Listing 15-1 shows how to use a box to store an `i32` value on the heap:
-->
<p>L'encart 15-1 nous montre comment utiliser une boite pour stocker une valeur
<code>i32</code> sur le tas :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-1: Storing an `i32` value on the heap using a
box</span>
-->
<p><span class="caption">Encart 15-1 : stocker une valeur <code>i32</code> sur le tas en
utilisant une boîte</span></p>
<!--
We define the variable `b` to have the value of a `Box` that points to the
value `5`, which is allocated on the heap. This program will print `b = 5`; in
this case, we can access the data in the box similar to how we would if this
data were on the stack. Just like any owned value, when a box goes out of
scope, as `b` does at the end of `main`, it will be deallocated. The
deallocation happens for the box (stored on the stack) and the data it points
to (stored on the heap).
-->
<p>Nous avons défini la variable <code>b</code> pour avoir la valeur d'une <code>Box</code> qui pointe
sur la valeur <code>5</code>, qui est donc allouée sur le tas. Ce programme va afficher
<code>b = 5</code> ; dans ce cas, nous pouvons accéder à la donnée présente dans la boite
de la même manière que nous le ferrions si elle était sur la pile. Comme toute
valeur possédée, lorsque une boite sort de la portée, comme lorsque <code>b</code> le fait
à la fin du <code>main</code>, elle sera désallouée. Ce sera la boite qui sera désallouée
en premier (elle est stockée sur la pile), puis ce sera au tour des données sur
lesquelles elle pointait (qui sont stockées sur le tas).</p>
<!--
Putting a single value on the heap isn’t very useful, so you won’t use boxes by
themselves in this way very often. Having values like a single `i32` on the
stack, where they’re stored by default, is more appropriate in the majority of
situations. Let’s look at a case where boxes allow us to define types that we
wouldn’t be allowed to if we didn’t have boxes.
-->
<p>Déposer une seule valeur sur le tas n'est pas très utile, donc vous n'utiliserez
très rarement les boites de cette manière. Laisser les valeurs comme des <code>i32</code>
indépendantes sur la pile, où elles sont stockées par défaut, reste plus
approprié dans la majeure partie des situations. Regardons un cas où les boites
nous permettent de définir des types que nous pourrions par le faire si nous
n'avions pas les boites.</p>
<!--
### Enabling Recursive Types with Boxes
-->
<h3 id="pouvoir-utiliser-des-types-récursifs-grâce-aux-boites"><a class="header" href="#pouvoir-utiliser-des-types-récursifs-grâce-aux-boites">Pouvoir utiliser des types récursifs grâce aux boites</a></h3>
<!--
At compile time, Rust needs to know how much space a type takes up. One type
whose size can’t be known at compile time is a *recursive type*, where a value
can have as part of itself another value of the same type. Because this nesting
of values could theoretically continue infinitely, Rust doesn’t know how much
space a value of a recursive type needs. However, boxes have a known size, so
by inserting a box in a recursive type definition, you can have recursive types.
-->
<p>Au moment de la compilation, Rust a besoin de savoir combien s'espace prend un
type. Un des types dont la taille ne peut pas être connu au moment de la
compilation est le <em>type récursif</em>, dans lequel une valeur peut avoir une partie
de sa définition qui a une valeur du même type qu'elle-même. Comme emboîtement
de valeurs pourrait théoriquement se poursuivre à l'infini, Rust ne sait pas
combien d'espace une valeur d'un type récursif peut avoir besoin. Cependant, les
boites ont une taille connue, donc en utilisant une boite dans la définition
d'un type récursif, vous pouvez créer des types récursifs.</p>
<!--
Let’s explore the *cons list*, which is a data type common in functional
programming languages, as an example of a recursive type. The cons list type
we’ll define is straightforward except for the recursion; therefore, the
concepts in the example we’ll work with will be useful any time you get into
more complex situations involving recursive types.
-->
<p>Découvrons maintenant la <em>liste de construction</em> (NdT : cons list), qui est un
type de donnée courant dans les langages de programmation fonctionnels, comme
étant un exemple de type récursif. Le type liste de construction que nous allons
définir est plutôt simple, sauf pour les cas de récursivité ; par conséquent,
les concepts dans l'exemple avec lequel nous allons travailler vous seront
utiles à chaque fois que vous vous retrouverez dans des situations plus
complexes qui impliquent des types récursifs.</p>
<!--
#### More Information About the Cons List
-->
<h4 id="en-savoir-plus-sur-les-listes-de-construction"><a class="header" href="#en-savoir-plus-sur-les-listes-de-construction">En savoir plus sur les listes de construction</a></h4>
<!--
A *cons list* is a data structure that comes from the Lisp programming language
and its dialects. In Lisp, the `cons` function (short for “construct function”)
constructs a new pair from its two arguments, which usually are a single value
and another pair. These pairs containing pairs form a list.
-->
<p>Une <em>liste de construction</em> est une structure de donnée qui provient du langage
de programmation Lisp et de ses dérivés. En Lisp, la fonction <code>cons</code> (qui est
une forme contractée de “fonction de construction”) construit une nouvelle paire
à partir de ses deux arguments, qui sont souvent une valeur individuelle et une
autre paire. Ces paires qui contiennent des paires forment des listes.</p>
<!--
The cons function concept has made its way into more general functional
programming jargon: “to cons *x* onto *y*” informally means to construct a new
container instance by putting the element *x* at the start of this new
container, followed by the container *y*.
-->
<p>Le concept de la fonction cons a fait son chemin dans le jargon plus général de
la programmation fonctionnelle : &quot;to cons <em>x</em> onto <em>y</em>&quot; signifie de manière
informelle de construire une nouvelle instance de conteneur en mettant l'élément
<em>x</em> au début de ce nouveau conteneur, suivi du conteneur <em>y</em>.</p>
<!--
Each item in a cons list contains two elements: the value of the current item
and the next item. The last item in the list contains only a value called `Nil`
without a next item. A cons list is produced by recursively calling the `cons`
function. The canonical name to denote the base case of the recursion is `Nil`.
Note that this is not the same as the “null” or “nil” concept in Chapter 6,
which is an invalid or absent value.
-->
<p>Chaque élément dans une liste de construction contient deux éléments : la valeur
de l'élément courant et celle de l'élément suivant. Le dernier élément dans la
liste contient seulement une valeur <code>Nil</code> sans aucun élément suivant. Une
liste de construction est produite de manière récursive en appelant la fonction
<code>cons</code>. Le nom canonique pour indiquer le cas de base de la récursion est <code>Nil</code>.
Notez que ce n'est pas la même chose que les concepts “null” ou “nil” du
chapitre 6, qui signale une valeur invalide ou absente.</p>
<!--
Although functional programming languages use cons lists frequently, the cons
list isn’t a commonly used data structure in Rust. Most of the time when you
have a list of items in Rust, `Vec<T>` is a better choice to use. Other, more
complex recursive data types *are* useful in various situations, but by
starting with the cons list, we can explore how boxes let us define a recursive
data type without much distraction.
-->
<p>Bien que les langages de programmation fonctionnels utilisent les listes de
construction fréquemment, la liste de construction n'est pas une structure de
donnée utilisée couramment en Rust. La plupart du temps lorsque vous avez une
liste d'éléments en Rust, <code>Vec&lt;T&gt;</code> s'avère être un meilleur choix à faire.
Autrement, il existe des types de données récursifs plus complexes <em>qui sont</em>
utiles dans d'autres situations, mais en commençant avec les listes de
construction, nous pouvons découvrir comment les boites nous permettent de
définir un type de données récursif sans être trop perturbé par la complexité.</p>
<!--
Listing 15-2 contains an enum definition for a cons list. Note that this code
won’t compile yet because the `List` type doesn’t have a known size, which
we’ll demonstrate.
-->
<p>L'encart 15-2 propose une définition d'une énumération pour une liste de
construction. Notez que ce code ne se compile pas encore car le type <code>List</code> n'a
pas encore de taille connue, ce que nous allons voir ensuite.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
enum List {
    Cons(i32, List),
    Nil,
}
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
<span class="caption">Listing 15-2: The first attempt at defining an enum to
represent a cons list data structure of `i32` values</span>
-->
<p><span class="caption">Encart 15-2 : première tentative de définition d'une
énumération pour représenter une structure de données de liste de construction
de valeurs <code>i32</code></span></p>
<!--
> Note: We’re implementing a cons list that holds only `i32` values for the
> purposes of this example. We could have implemented it using generics, as we
> discussed in Chapter 10, to define a cons list type that could store values of
> any type.
-->
<blockquote>
<p>Remarque : nous implémentons une liste de construction qui stocke uniquement
des valeurs <code>i32</code> pour les besoins de cet exemple. Nous aurions pu
l'implémenter en utilisant des génériques, que nous avons vu chapitre 10, afin
de définir une liste de construction qui pourrait stocker n'importe quel type.</p>
</blockquote>
<!--
Using the `List` type to store the list `1, 2, 3` would look like the code in
Listing 15-3:
-->
<p>L'utilisation du type <code>List</code> pour stocker la liste <code>1, 2, 3</code> ressemblerait au
code dans l'encart 15-3 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# enum List {
#     Cons(i32, List),
#     Nil,
# }
# 
use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<!--
<span class="caption">Listing 15-3: Using the `List` enum to store the list `1,
2, 3`</span>
-->
<p><span class="caption">Encart 15-3 : utilisation de l'énumération <code>List</code> pour
stocker la liste <code>1, 2, 3</code></span></p>
<!--
The first `Cons` value holds `1` and another `List` value. This `List` value is
another `Cons` value that holds `2` and another `List` value. This `List` value
is one more `Cons` value that holds `3` and a `List` value, which is finally
`Nil`, the non-recursive variant that signals the end of the list.
-->
<p>La première valeur <code>Cons</code> stocke <code>1</code> et une autre valeur de <code>List</code>. Cette
valeur <code>List</code> est une autre valeur <code>Cons</code> qui stocke <code>2</code> et une autre valeur de
<code>List</code>. Cette valeur <code>List</code> n'est rien d'autre qu'une valeur <code>Cons</code> qui stocke
<code>3</code> et une valeur <code>List</code>, qui finalement est <code>Nil</code>, la variante non récursive
qui signale la fin de la liste.</p>
<!--
If we try to compile the code in Listing 15-3, we get the error shown in
Listing 15-4:
-->
<p>Si nous essayons de compiler le code de l'encart 15-3, nous avons l'erreur de
l'encart 15-4 :</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 -- > src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `List` representable

error[E0391]: cycle detected when processing `List`
 -- > src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which again requires processing `List`, completing the cycle
  = note: cycle used when computing dropck types for `Canonical { max_universe: U0, variables: [], value: ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: UserFacing, def_id: None }, value: List } }`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to make `List` representable

error[E0391]: cycle detected when processing `List`
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which again requires processing `List`, completing the cycle
  = note: cycle used when computing dropck types for `Canonical { max_universe: U0, variables: [], value: ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: UserFacing, def_id: None }, value: List } }`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
<span class="caption">Listing 15-4: The error we get when attempting to define
a recursive enum</span>
-->
<p><span class="caption">Encart 15-4 : l'erreur que nous obtenons lorsque nous
essayons de définir une énumération récursive</span></p>
<!--
The error shows this type “has infinite size.” The reason is that we’ve defined
`List` with a variant that is recursive: it holds another value of itself
directly. As a result, Rust can’t figure out how much space it needs to store a
`List` value. Let’s break down why we get this error a bit. First, let’s look
at how Rust decides how much space it needs to store a value of a non-recursive
type.
-->
<p>L'erreur explique que ce type “a une taille infinie”. La raison est que nous
avons défini <code>List</code> avec une variante qui est récursive : elle stocke
directement une autre valeur d'elle-même. Au final, Rust ne peut pas savoir
combien de place il a besoin pour stocker une valeur <code>List</code>. Analysons
pourquoi nous obtenons cette erreur. D'abord, regardons comment Rust décide de
l'espace dont il a besoin pour stocker une valeur d'un type non récursif.</p>
<!--
#### Computing the Size of a Non-Recursive Type
-->
<h4 id="calculer-la-taille-dun-type-non-récursif"><a class="header" href="#calculer-la-taille-dun-type-non-récursif">Calculer la taille d'un type non récursif</a></h4>
<!--
Recall the `Message` enum we defined in Listing 6-2 when we discussed enum
definitions in Chapter 6:
-->
<p>Rappelez-vous de l'énumération <code>Message</code> que nous avons défini dans
l'encart 6-2 lorsque nous avons abordé les définitions des énumérations au
chapitre 6 :</p>
<!--
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
To determine how much space to allocate for a `Message` value, Rust goes
through each of the variants to see which variant needs the most space. Rust
sees that `Message::Quit` doesn’t need any space, `Message::Move` needs enough
space to store two `i32` values, and so forth. Because only one variant will be
used, the most space a `Message` value will need is the space it would take to
store the largest of its variants.
-->
<p>Pour déterminer combien d'espace allouer pour une valeur <code>Message</code>, Rust
parcourt chaque variante pour voir quelle variante a besoin le plus d'espace.
Rust voit que <code>Message::Quit</code> n'a pas besoin d'espace, <code>Message::Move</code> a besoin
de suffisamment d'espace pour stocker deux valeurs <code>i32</code>, et ainsi de suite.
Comme une seule variante sera utilisée, le plus grand espace dont une valeur
de <code>Message</code> aura besoin sera l'espace que cela prendra de stocker la plus
grosse de ses variantes.</p>
<!--
Contrast this with what happens when Rust tries to determine how much space a
recursive type like the `List` enum in Listing 15-2 needs. The compiler starts
by looking at the `Cons` variant, which holds a value of type `i32` and a value
of type `List`. Therefore, `Cons` needs an amount of space equal to the size of
an `i32` plus the size of a `List`. To figure out how much memory the `List`
type needs, the compiler looks at the variants, starting with the `Cons`
variant. The `Cons` variant holds a value of type `i32` and a value of type
`List`, and this process continues infinitely, as shown in Figure 15-1.
-->
<p>Comparez cela avec ce qui se passe lorsque Rust essaye de déterminer combien
d'espace un type récursif comme l'énumération <code>List</code> de l'encart 15-2 aurait
besoin. Le compilateur commence par regarder la variante <code>Cons</code>, qui stocke une
valeur de type <code>i32</code> et une valeur de type <code>List</code>. Ainsi, <code>Cons</code> a besoin d'une
quantité d'espace égale à la taille d'un <code>i32</code> plus la taille d'une valeur
<code>List</code>. Pour savoir combien de mémoire le type <code>List</code> a besoin, le compilateur
va regarder ses variantes, en commençant avec la variante <code>Cons</code>. La variante
<code>Cons</code> stocke une valeur de type <code>i32</code> et une valeur de type <code>List</code>, et ce
processus continue à l'infini, comme l'illustration 15-1.</p>
<!-- markdownlint-disable -->
<!--
<img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="Une liste de construction infinie"
    src="img/trpl15-01.svg"
    class="center"
    style="width: 50%;" /></p>
<!--
<span class="caption">Figure 15-1: An infinite `List` consisting of infinite
`Cons` variants</span>
-->
<p><span class="caption">Illustration 15-1 : une <code>List</code> infinie qui contient des
variantes <code>Cons</code> infinies</span></p>
<!--
#### Using `Box<T>` to Get a Recursive Type with a Known Size
-->
<h4 id="utiliser-boxt-pour-créer-un-type-récursif-avec-une-taille-finie"><a class="header" href="#utiliser-boxt-pour-créer-un-type-récursif-avec-une-taille-finie">Utiliser <code>Box&lt;T&gt;</code> pour créer un type récursif avec une taille finie</a></h4>
<!--
Rust can’t figure out how much space to allocate for recursively defined types,
so the compiler gives the error in Listing 15-4. But the error does include
this helpful suggestion:
-->
<p>Rust ne peut pas calculer la quantité d'espace à allouer pour les types
définis récursivement, donc le compilateur déclenche l'erreur de l'encart
15-4. Mais l'erreur renferme cette suggestion très utile :</p>
<!--
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-- >
-->
<!--
```text
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `List` representable
```
-->
<pre><code class="language-text">  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to make `List` representable
</code></pre>
<!--
In this suggestion, “indirection” means that instead of storing a value
directly, we’ll change the data structure to store the value indirectly by
storing a pointer to the value instead.
-->
<p>Dans cette suggestion, “indirection” (NdT : redirection) signifie que plutôt de
stocker une valeur directement, nous devrions changer la structure des données
pour stocker à la place un pointeur vers la valeur.</p>
<!--
Because a `Box<T>` is a pointer, Rust always knows how much space a `Box<T>`
needs: a pointer’s size doesn’t change based on the amount of data it’s
pointing to. This means we can put a `Box<T>` inside the `Cons` variant instead
of another `List` value directly. The `Box<T>` will point to the next `List`
value that will be on the heap rather than inside the `Cons` variant.
Conceptually, we still have a list, created with lists “holding” other lists,
but this implementation is now more like placing the items next to one another
rather than inside one another.
-->
<p>Comme <code>Box&lt;T&gt;</code> est un pointeur, Rust connaît toujours combien d'espace un
<code>Box&lt;T&gt;</code> a besoin : la taille d'un pointeur ne change pas, peu importe la
quantité de données sur lesquelles il pointe. Cela signifie que nous pouvons
insérer un <code>Box&lt;T&gt;</code> à l'intérieur d'une variante <code>Cons</code> au lieu d'y mettre
directement une autre valeur <code>List</code>. Le <code>Box&lt;T&gt;</code> va pointer sur la prochaine
valeur <code>List</code> qui sera sur le tas plutôt que d'être dans la variante <code>Cons</code>.
Théoriquement, nous avons toujours une liste, créée avec des listes qui
“contiennent” d'autres listes, mais cette implémentation est ressemble plus
maintenant à des éléments placés les uns à côté des autres, plutôt que les
uns dans les autres.</p>
<!--
We can change the definition of the `List` enum in Listing 15-2 and the usage
of the `List` in Listing 15-3 to the code in Listing 15-5, which will compile:
-->
<p>Nous pouvons changer la définition de l'énumération <code>List</code> de l'encart 15-2 et
l'utilisation de <code>List</code> dans l'encart 15-3 pour le code de l'encart 15-5, qui
va se compiler :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Filename : src/main.rs</span></p>
<!--
```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-5: Definition of `List` that uses `Box<T>` in
order to have a known size</span>
-->
<p><span class="caption">Encart 15-5 : définition de <code>List</code> qui utilise <code>Box&lt;T&gt;</code>
dans le but d'avoir une taille connue</span></p>
<!--
The `Cons` variant will need the size of an `i32` plus the space to store the
box’s pointer data. The `Nil` variant stores no values, so it needs less space
than the `Cons` variant. We now know that any `List` value will take up the
size of an `i32` plus the size of a box’s pointer data. By using a box, we’ve
broken the infinite, recursive chain, so the compiler can figure out the size
it needs to store a `List` value. Figure 15-2 shows what the `Cons` variant
looks like now.
-->
<p>La variante <code>Cons</code> va avoir besoin de l'espace d'un <code>i32</code> plus l'espace pour
stocker le pointeur vers la donnée de la boite. La variante <code>Nil</code> ne stocke pas
de valeurs, donc elle a besoin de moins d'espace que la variante <code>Cons</code>. Nous
savons maintenant que chaque valeur <code>List</code> va prendre la taille d'un <code>i32</code>
plus la taille d'un pointeur vers la donnée de la boite. En utilisant une boite,
vous avez arrêté la chaine infinie et récursive, donc le compilateur peut
savoir l'espace dont il a besoin pour stocker une valeur <code>List</code>. L'illustration
15-2 montre à quoi ressemble maintenant la variante <code>Cons</code>.</p>
<!--
<img alt="A finite Cons list" src="img/trpl15-02.svg" class="center" />
-->
<p><img
    alt="Une liste de construction finie"
    src="img/trpl15-02.svg"
    class="center" /></p>
<!--
<span class="caption">Figure 15-2: A `List` that is not infinitely sized
because `Cons` holds a `Box`</span>
-->
<p><span class="caption">Illustration 15-2 : une <code>List</code> qui n'a pas de taille
infinie car <code>Cons</code> est une <code>Box</code></span></p>
<!--
Boxes provide only the indirection and heap allocation; they don’t have any
other special capabilities, like those we’ll see with the other smart pointer
types. They also don’t have any performance overhead that these special
capabilities incur, so they can be useful in cases like the cons list where the
indirection is the only feature we need. We’ll look at more use cases for boxes
in Chapter 17, too.
-->
<p>Les boites fournissent uniquement la redirection et l'allocation sur le tas ;
elles n'ont pas d'autres fonctionnalités, comme celles que nous verrons sur
d'autres types de pointeurs intelligents. Elles n'ont pas non plus de surcoût
sur les performances autre que ce qu'offrent ces capacités spéciales, donc
elles sont utiles dans des cas comme les listes de construction où la
redirection est la seule fonctionnalité que nous avons besoin. Nous verrons
aussi plus de cas d'usages pour les boites dans le chapitre 17.</p>
<!--
The `Box<T>` type is a smart pointer because it implements the `Deref` trait,
which allows `Box<T>` values to be treated like references. When a `Box<T>`
value goes out of scope, the heap data that the box is pointing to is cleaned
up as well because of the `Drop` trait implementation. Let’s explore these two
traits in more detail. These two traits will be even more important to the
functionality provided by the other smart pointer types we’ll discuss in the
rest of this chapter.
-->
<p>Le type <code>Box&lt;T&gt;</code> est un pointeur intelligent car il implémente le trait
<code>Deref</code>, qui permet aux valeurs <code>Box&lt;T&gt;</code> d'être traitées comme des
références. Lorsque une valeur <code>Box&lt;T&gt;</code> sort de la portée, les données sur le
tas que la boite pointait est aussi nettoyé grâce au trait <code>Drop</code>. Explorons
plus en détail ces deux traits. Ces deux traits deviendrons encore plus
importants pour les fonctionnalités offertes par les autres pointeurs
intelligents que nous verrons dans le reste de ce chapitre.</p>
<!-- markdownlint-disable -->
<!--
[trait-objects]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
-->
<!-- markdownlint-restore -->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--8"><a class="header" href="#-attention-peinture-fraîche--8">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/189">Pull Request</a>.</p>
</blockquote>
<!--
## Treating Smart Pointers Like Regular References with the `Deref` Trait
-->
<h2 id="considérer-les-pointeurs-intelligents-comme-des-références-grâce-au-trait-deref"><a class="header" href="#considérer-les-pointeurs-intelligents-comme-des-références-grâce-au-trait-deref">Considérer les pointeurs intelligents comme des références grâce au trait <code>Deref</code></a></h2>
<!--
Implementing the `Deref` trait allows you to customize the behavior of the
*dereference operator*, `*` (as opposed to the multiplication or glob
operator). By implementing `Deref` in such a way that a smart pointer can be
treated like a regular reference, you can write code that operates on
references and use that code with smart pointers too.
-->
<p>L'implémentation du trait <code>Deref</code> vous permet de personnaliser le comportement
de <em>l'opérateur de déréférencement</em> <code>*</code> (qui n'est pas l'opérateur de
multiplication ou le joker global). En implémentant <code>Deref</code> de manière à ce
qu'un pointeur intelligent puisse être considéré comme une référence classique,
vous pouvez écrire du code qui fonctionne avec des références mais aussi avec
des pointeurs intelligents.</p>
<!--
Let’s first look at how the dereference operator works with regular references.
Then we’ll try to define a custom type that behaves like `Box<T>`, and see why
the dereference operator doesn’t work like a reference on our newly defined
type. We’ll explore how implementing the `Deref` trait makes it possible for
smart pointers to work in ways similar to references. Then we’ll look at
Rust’s *deref coercion* feature and how it lets us work with either references
or smart pointers.
-->
<p>Regardons d'abord comment l'opérateur de déréférencement fonctionne avec des
références classiques. Ensuite nous essayerons de définir un type personnalisé
qui se comporte comme <code>Box&lt;T&gt;</code>, et voir pourquoi l'opérateur de déréférencement
ne fonctionne pas comme une référence sur notre type fraîchement défini. Nous
allons découvrir comment implémenter le trait <code>Deref</code> de manière à ce qu'il soit
possible que les pointeurs intelligents fonctionnent comme les références.
Ensuite nous verons la fonctionnalité d'<em>extrapolation de déréférencement</em> de
Rust et voir comment elle nous permet de travailler à la fois avec des
références et des pointeurs intelligents.</p>
<!--
> Note: there’s one big difference between the `MyBox<T>` type we’re about to
> build and the real `Box<T>`: our version will not store its data on the heap.
> We are focusing this example on `Deref`, so where the data is actually stored
> is less important than the pointer-like behavior.
-->
<blockquote>
<p>Remarque : il y a une grosse différence entre le type <code>MaBoite&lt;T&gt;</code> que nous
allons construire et la vraie <code>Box&lt;T&gt;</code> : notre version ne va pas stocker ses
données sur le tas. Nous allons concentrer cet exemple sur <code>Deref</code>, donc
l'endroit où est concrètement stocké la donnée est moins important que le
comportement similaire aux pointeurs.</p>
</blockquote>
<!--
### Following the Pointer to the Value with the Dereference Operator
-->
<h3 id="suivre-le-pointeur-vers-la-valeur-grâce-à-lopérateur-de-déréférencement"><a class="header" href="#suivre-le-pointeur-vers-la-valeur-grâce-à-lopérateur-de-déréférencement">Suivre le pointeur vers la valeur grâce à l'opérateur de déréférencement</a></h3>
<!--
A regular reference is a type of pointer, and one way to think of a pointer is
as an arrow to a value stored somewhere else. In Listing 15-6, we create a
reference to an `i32` value and then use the dereference operator to follow the
reference to the data:
-->
<p>Une référence classique est un type de pointeur, et une manière de modéliser un
pointeur est d'imaginer une flèche pointant vers une valeur stockée autre part.
Dans l'encart 15-6, nous créons une référence vers une valeur <code>i32</code> et utilisons
ensuite l'opérateur de déréférencement pour suivre la référence vers la donnée :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-6: Using the dereference operator to follow a
reference to an `i32` value</span>
-->
<p><span class="caption">Encart 15-6 : utiliser l'opérateur de déréférencement pour
suivre une référence vers une valeur <code>i32</code></span></p>
<!--
The variable `x` holds an `i32` value, `5`. We set `y` equal to a reference to
`x`. We can assert that `x` is equal to `5`. However, if we want to make an
assertion about the value in `y`, we have to use `*y` to follow the reference
to the value it’s pointing to (hence *dereference*). Once we dereference `y`,
we have access to the integer value `y` is pointing to that we can compare with
`5`.
-->
<p>La variable <code>x</code> stocke une valeur <code>i32</code> : <code>5</code>. Nous avons assigné à <code>y</code> une
référence vers <code>x</code>. Nous pouvons faire une <code>assert</code> pour vérifier que <code>x</code> est
égal à <code>5</code>. Cependant, si nous souhaitons faire une <code>assert</code> sur la valeur dans
<code>y</code>, nous devons utiliser <code>*y</code> pour suivre la référence vers la valeur sur
laquelle elle pointe (d'où le <em>déréférencement</em>). Une fois que nous avons
déréférencé <code>y</code>, nous avons accès à la valeur de l'entier sur laquelle <code>y</code>
pointe afin que nous puissions la comparer avec <code>5</code>.</p>
<!--
If we tried to write `assert_eq!(5, y);` instead, we would get this compilation
error:
-->
<p>Si nous avions essayé d'écrire <code>assert_eq!(5, y);</code> à la place, nous aurions
obtenu cette erreur de compilation :</p>
<!--
```console
$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&{integer}`
 -- > src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`
  |
  = help: the trait `std::cmp::PartialEq<&{integer}>` is not implemented for `{integer}`
  = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Comparing a number and a reference to a number isn’t allowed because they’re
different types. We must use the dereference operator to follow the reference
to the value it’s pointing to.
-->
<p>Comparer un nombre et une référence vers un nombre n'est pas autorisé car ils
sont de types différents. Nous devons utiliser l'opérateur de déréférencement
pour suivre la référence vers la valeur sur laquelle elle pointe.</p>
<!--
### Using `Box<T>` Like a Reference
-->
<h3 id="utiliser-boxt-comme-étant-une-référence"><a class="header" href="#utiliser-boxt-comme-étant-une-référence">Utiliser <code>Box&lt;T&gt;</code> comme étant une référence</a></h3>
<!--
We can rewrite the code in Listing 15-6 to use a `Box<T>` instead of a
reference; the dereference operator will work as shown in Listing 15-7:
-->
<p>Nous pouvons réécrire le code l'encart 15-6 pour utiliser une <code>Box&lt;T&gt;</code> au lieu
d'une référence ; l'opérateur de déréférencement devrait fonctionner comme
montré dans l'encart 15-7 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-7: Using the dereference operator on a
`Box<i32>`</span>
-->
<p><span class="caption">Encart 15-7 : utilisation de l'opérateur de
déréférencement sur un <code>Box&lt;i32&gt;</code></span></p>
<!--
The only difference between Listing 15-7 and Listing 15-6 is that here we set
`y` to be an instance of a box pointing to a copied value of `x` rather than a
reference pointing to the value of `x`. In the last assertion, we can use the
dereference operator to follow the box’s pointer in the same way that we did
when `y` was a reference. Next, we’ll explore what is special about `Box<T>`
that enables us to use the dereference operator by defining our own box type.
-->
<p>La seule différence entre l'encart 15-7 et l'encart 15-6 est qu'ici nous avons
fait en sorte que <code>y</code> soit une instance de boite qui pointe sur une copie de la
valeur de <code>x</code> plutôt qu'avoir une référence vers la valeur de <code>x</code>. Dans la
dernière assertion, nous pouvons utiliser l'opérateur de déréférencement pour
suivre le pointeur de la boite de la même manière que nous l'avons fait lorsque
<code>y</code> était une référence. Maintenant, nous allons regarder ce qu'il y a de si
spécial dans <code>Box&lt;T&gt;</code> qui nous permet d'utiliser l'opérateur de déréférencement
en définissant notre propre type de boite.</p>
<!--
### Defining Our Own Smart Pointer
-->
<h3 id="définir-notre-propre-pointeur-intelligent"><a class="header" href="#définir-notre-propre-pointeur-intelligent">Définir notre propre pointeur intelligent</a></h3>
<!--
Let’s build a smart pointer similar to the `Box<T>` type provided by the
standard library to experience how smart pointers behave differently from
references by default. Then we’ll look at how to add the ability to use the
dereference operator.
-->
<p>Construisons un pointeur intelligent similaire au type <code>Box&lt;T&gt;</code> fourni par la
bibliothèque standard pour apprendre comment les pointeurs intelligents se
comportent différemment des références classiques. Ensuite nous regarderons
comment lui ajouter la possibilité d'utiliser l'opérateur de déréférencement.</p>
<!--
The `Box<T>` type is ultimately defined as a tuple struct with one element, so
Listing 15-8 defines a `MyBox<T>` type in the same way. We’ll also define a
`new` function to match the `new` function defined on `Box<T>`.
-->
<p>Le type <code>Box&lt;T&gt;</code> est essentiellement défini comme étant une structure de tuple
d'un seul élément, donc l'encart 15-8 définit un type <code>MaBoite&lt;T&gt;</code> de la même
manière. Nous allons aussi définir une fonction <code>new</code> pour correspondre à la
fonction <code>new</code> définie sur <code>Box&lt;T&gt;</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">struct MaBoite&lt;T&gt;(T);

impl&lt;T&gt; MaBoite&lt;T&gt; {
    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
        MaBoite(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-8: Defining a `MyBox<T>` type</span>
-->
<p><span class="caption">Encart 15-8 : définition du type <code>MaBoite&lt;T&gt;</code></span></p>
<!--
We define a struct named `MyBox` and declare a generic parameter `T`, because
we want our type to hold values of any type. The `MyBox` type is a tuple struct
with one element of type `T`. The `MyBox::new` function takes one parameter of
type `T` and returns a `MyBox` instance that holds the value passed in.
-->
<p>Nous définissons une structure <code>MaBoite</code> et on déclare un paramètre générique
<code>T</code>, car nous souhaitons que notre type stocke des valeurs de n'importe quel
type. Le type <code>MaBoite</code> est une structure de tuple avec un seul élément de type
<code>T</code>. La fonction <code>MaBoite::new</code> prend un paramètre de type <code>T</code> et retourne une
instance <code>MaBoite</code> qui stocke la valeur qui lui est passée.</p>
<!--
Let’s try adding the `main` function in Listing 15-7 to Listing 15-8 and
changing it to use the `MyBox<T>` type we’ve defined instead of `Box<T>`. The
code in Listing 15-9 won’t compile because Rust doesn’t know how to dereference
`MyBox`.
-->
<p>Essayons d'ajouter la fonction <code>main</code> de l'encart 15-7 dans l'encart 15-8 et la
modifier pour utiliser le type <code>MaBoite&lt;T&gt;</code> que nous avons défini à la place de
<code>Box&lt;T&gt;</code>. Le code de l'encart 15-9 ne se compile pas car Rust ne sait pas
comment déréférencer <code>MaBoite</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# struct MyBox<T>(T);
# 
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
# 
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MaBoite&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MaBoite&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
</span><span class="boring">        MaBoite(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MaBoite::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
<!--
<span class="caption">Listing 15-9: Attempting to use `MyBox<T>` in the same
way we used references and `Box<T>`</span>
-->
<p><span class="caption">Encart 15-9 : tentative d'utiliser <code>MaBoite&lt;T&gt;</code> de la même
manière que nous avions utilisé les références et <code>Box&lt;T&gt;</code></span></p>
<!--
Here’s the resulting compilation error:
-->
<p>Voici l'erreur de compilation qui en résulte :</p>
<!--
```console
$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox<{integer}>` cannot be dereferenced
  -- > src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MaBoite&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Our `MyBox<T>` type can’t be dereferenced because we haven’t implemented that
ability on our type. To enable dereferencing with the `*` operator, we
implement the `Deref` trait.
-->
<p>Notre type <code>MaBoite&lt;T&gt;</code> ne peut pas être déréférencée car nous n'avons pas
implémenté cette fonctionnalité sur notre type. Pour permettre le
déréférencement avec l'opérateur <code>*</code>, nous devons implémenter le trait <code>Deref</code>.</p>
<!--
### Treating a Type Like a Reference by Implementing the `Deref` Trait
-->
<h3 id="considérer-un-type-comme-une-référence-en-implémentant-le-trait-deref"><a class="header" href="#considérer-un-type-comme-une-référence-en-implémentant-le-trait-deref">Considérer un type comme une référence en implémentant le trait <code>Deref</code></a></h3>
<!--
As discussed in Chapter 10, to implement a trait, we need to provide
implementations for the trait’s required methods. The `Deref` trait, provided
by the standard library, requires us to implement one method named `deref` that
borrows `self` and returns a reference to the inner data. Listing 15-10
contains an implementation of `Deref` to add to the definition of `MyBox`:
-->
<p>Comme nous l'avons vu dans le chapitre 10, pour implémenter un trait, nous
devons fournir les implémentations des méthodes nécessaires pour ce trait. Le
trait <code>Deref</code>, fourni par la bibliothèque standard, nécessite que nous
implémentions une méthode <code>deref</code> qui prend possession de <code>self</code> et retourne une
référence vers la donnée interne. L'encart 15-10 contient une implémentation de
<code>Deref</code> à ajouter à la définition de <code>MaBoite</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }
}
# 
# struct MyBox<T>(T);
# 
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
# 
# fn main() {
#     let x = 5;
#     let y = MyBox::new(x);
# 
#     assert_eq!(5, x);
#     assert_eq!(5, *y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

impl&lt;T&gt; Deref for MaBoite&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MaBoite&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MaBoite&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
</span><span class="boring">        MaBoite(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MaBoite::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-10: Implementing `Deref` on `MyBox<T>`</span>
-->
<p><span class="caption">Encart 15-10 : implémentation de <code>Deref</code> sur <code>MaBoite&lt;T&gt;</code>
</span></p>
<!--
The `type Target = T;` syntax defines an associated type for the `Deref` trait
to use. Associated types are a slightly different way of declaring a generic
parameter, but you don’t need to worry about them for now; we’ll cover them in
more detail in Chapter 19.
-->
<p>La syntaxe <code>type Target = T;</code> définit un type associé pour le trait <code>Deref</code> à
utiliser. Les types associés sont une manière légèrement différente de déclarer
un paramètre générique, mais vous n'avez pas à vous préoccuper d'eux pour le
moment ; nous les verrons plus en détail au chapitre 19.</p>
<!--
We fill in the body of the `deref` method with `&self.0` so `deref` returns a
reference to the value we want to access with the `*` operator. The `main`
function in Listing 15-9 that calls `*` on the `MyBox<T>` value now compiles,
and the assertions pass!
-->
<p>Nous renseignons le corps de la méthode <code>deref</code> avec <code>&amp;self.0</code> afin que <code>deref</code>
retourne une référence vers la valeur que nous souhaitons accéder avec
l'opérateur <code>*</code>. La fonction <code>main</code> de l'encart 15-9 qui appelle <code>*</code> sur la
valeur <code>MaBoite&lt;T&gt;</code> se compile désormais, et le <code>assert</code> réussit aussi !</p>
<!--
Without the `Deref` trait, the compiler can only dereference `&` references.
The `deref` method gives the compiler the ability to take a value of any type
that implements `Deref` and call the `deref` method to get a `&` reference that
it knows how to dereference.
-->
<p>Sans le trait <code>Deref</code>, le compilateur peut seulement déréférencer des références
<code>&amp;</code>. La méthode <code>deref</code> donne la possibilité au compilateur d'obtenir la valeur
de n'importe quel type qui implémente <code>Deref</code> en appelant la méthode <code>deref</code>
pour obtenir une référence <code>&amp;</code> qu'il sait comment déréférencer.</p>
<!--
When we entered `*y` in Listing 15-9, behind the scenes Rust actually ran this
code:
-->
<p>Lorsque nous avons précisé <code>*y</code> dans l'encart 15-9, Rust fait tourner ce code en
coulisses :</p>
<!--
```rust,ignore
*(y.deref())
```
-->
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<!--
Rust substitutes the `*` operator with a call to the `deref` method and then a
plain dereference so we don’t have to think about whether or not we need to
call the `deref` method. This Rust feature lets us write code that functions
identically whether we have a regular reference or a type that implements
`Deref`.
-->
<p>Rust remplace l'opérateur <code>*</code> par un appel à la méthode <code>deref</code> suivi par un
simple déréférencement afin que nous n'ayons pas à nous demander si nous devons
ou non appeler la méthode <code>deref</code>. Cette fonctionnalité de Rust nous permet
d'écrire du code qui fonctionne de manière identique que nous ayons une
référence classique ou un type qui implémente <code>Deref</code>.</p>
<!--
The reason the `deref` method returns a reference to a value, and that the plain
dereference outside the parentheses in `*(y.deref())` is still necessary, is the
ownership system. If the `deref` method returned the value directly instead of
a reference to the value, the value would be moved out of `self`. We don’t want
to take ownership of the inner value inside `MyBox<T>` in this case or in most
cases where we use the dereference operator.
-->
<p>La raison pour laquelle la méthode <code>deref</code> retourne une référence à une valeur,
et que le déréférencement du tout dans les parenthèses externes de
<code>*(y.deref())</code> reste nécessaire, est le système de possession. Si la méthode
<code>deref</code> retournait la valeur directement au lieu d'une référence à cette valeur,
la valeur serait <em>déplacée</em> à l'extérieur de <code>self</code>. Nous ne souhaitons pas
prendre possession de la valeur à l'intérieur de <code>MaBoite&lt;T&gt;</code> dans ce cas ainsi
que la plupart des cas où nous utilisons l'opérateur de déréférencement.</p>
<!--
Note that the `*` operator is replaced with a call to the `deref` method and
then a call to the `*` operator just once, each time we use a `*` in our code.
Because the substitution of the `*` operator does not recurse infinitely, we
end up with data of type `i32`, which matches the `5` in `assert_eq!` in
Listing 15-9.
-->
<p>Notez que l'opérateur <code>*</code> est remplacé par un appel à la méthode <code>deref</code> suivi
par un appel à l'opérateur <code>*</code> une seule fois, à chaque fois que nous utilisons
un <code>*</code> dans notre code. Comme la substitution de l'opérateur <code>*</code> ne s'effectue
pas de manière récursive et infinie, nous récupérerons une donnée de type <code>i32</code>,
qui correspond au <code>5</code> du <code>assert_eq!</code> de l'encart 15-9.</p>
<!--
### Implicit Deref Coercions with Functions and Methods
-->
<h3 id="extrapolation-de-déréférencement-implicite-avec-les-fonctions-et-les-méthodes"><a class="header" href="#extrapolation-de-déréférencement-implicite-avec-les-fonctions-et-les-méthodes">Extrapolation de déréférencement implicite avec les fonctions et les méthodes</a></h3>
<!--
*Deref coercion* is a convenience that Rust performs on arguments to functions
and methods. Deref coercion works only on types that implement the `Deref`
trait. Deref coercion converts such a type into a reference to another type.
For example, deref coercion can convert `&String` to `&str` because `String`
implements the `Deref` trait such that it returns `str`. Deref coercion happens
automatically when we pass a reference to a particular type’s value as an
argument to a function or method that doesn’t match the parameter type in the
function or method definition. A sequence of calls to the `deref` method
converts the type we provided into the type the parameter needs.
-->
<p>L'<em>extrapolation de déréférencement</em> est une commodité que Rust applique sur les
arguments des fonctions et des méthodes. L'extrapolation de déréférencement
fonctionne uniquement avec un type qui implémente le trait <code>Deref</code>.
L'extrapolation de déréférencement convertit ce type en une référence vers un
autre type. Par exemple, l'extrapolation de déréférencement peut convertir
<code>&amp;String</code> en <code>&amp;str</code> car <code>String</code> implémente le trait <code>Deref</code> de sorte qu'il
puisse retourner <code>str</code>. L'extrapolation de déréférencement s'applique
automatiquement lorsque nous passons une référence vers une valeur d'un type
particulier en argument d'une fonction ou d'une méthode qui ne correspond pas à
ce type de paramètre dans la définition de la fonction ou de la méthode. Une
série d'appels à la méthode <code>deref</code> convertit le type que nous donnons dans le
type que le paramètre nécessite.</p>
<!--
Deref coercion was added to Rust so that programmers writing function and
method calls don’t need to add as many explicit references and dereferences
with `&` and `*`. The deref coercion feature also lets us write more code that
can work for either references or smart pointers.
-->
<p>L'extrapolation de déréférencement a été ajouté à Rust afin de permettre aux
développeurs d'écrire des appels de fonctions et de méthodes qui n'ont pas
besoin d'indiquer explicitement les références et les déréférencements avec <code>&amp;</code>
et <code>*</code>. La fonctionnalité d'extrapolation de déréférencement nous permet aussi
d'écrire plus de code qui peut fonctionner à la fois pour les références ou pour
les pointeurs intelligents.</p>
<!--
To see deref coercion in action, let’s use the `MyBox<T>` type we defined in
Listing 15-8 as well as the implementation of `Deref` that we added in Listing
15-10. Listing 15-11 shows the definition of a function that has a string slice
parameter:
-->
<p>Pour voir l'extrapolation de déréférencement en action, utilisons le type
<code>MaBoite&lt;T&gt;</code> que nous avons défini dans l'encart 15-8 ainsi que l'implémentation
de <code>Deref</code> que nous avons ajouté dans l'encart 15-10. L'encart 15-11 montre la
définition d'une fonction qui a un paramètre qui est une slice de chaîne de
caractères :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn hello(name: &str) {
    println!("Hello, {}!", name);
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn saluer(nom: &amp;str) {
    println!(&quot;Salutations, {} !&quot;, nom);
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-11: A `hello` function that has the parameter
`name` of type `&str`</span>
-->
<p><span class="caption">Encart 15-11 : une fonction <code>saluer</code> qui prend en
paramètre <code>nom</code> du type <code>&amp;str</code></span></p>
<!--
We can call the `hello` function with a string slice as an argument, such as
`hello("Rust");` for example. Deref coercion makes it possible to call `hello`
with a reference to a value of type `MyBox<String>`, as shown in Listing 15-12:
-->
<p>Nous pouvons appeler la fonction <code>saluer</code> avec une slice de chaîne de caractères
en argument, comme par exemple <code>saluer(&quot;Rust&quot;);</code>. L'extrapolation de
déréférencement rend possible l'appel de <code>saluer</code> avec une référence à une
valeur du type <code>MaBoite&lt;String&gt;</code>, comme dans l'encart 15-12 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# use std::ops::Deref;
# 
# impl<T> Deref for MyBox<T> {
#     type Target = T;
# 
#     fn deref(&self) -> &T {
#         &self.0
#     }
# }
# 
# struct MyBox<T>(T);
# 
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
# 
# fn hello(name: &str) {
#     println!("Hello, {}!", name);
# }
# 
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MaBoite&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MaBoite&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MaBoite&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
</span><span class="boring">        MaBoite(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn saluer(nom: &amp;str) {
</span><span class="boring">    println!(&quot;Salutations, {} !&quot;, nom);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MaBoite::new(String::from(&quot;Rust&quot;));
    saluer(&amp;m);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-12: Calling `hello` with a reference to a
`MyBox<String>` value, which works because of deref coercion</span>
-->
<p><span class="caption">Encart 15-12 : appel à <code>saluer</code> avec une référence à une
valeur du type <code>MaBoite&lt;String&gt;</code>, qui fonctionne grâce à l'extrapolation de
déréférencement</span></p>
<!--
Here we’re calling the `hello` function with the argument `&m`, which is a
reference to a `MyBox<String>` value. Because we implemented the `Deref` trait
on `MyBox<T>` in Listing 15-10, Rust can turn `&MyBox<String>` into `&String`
by calling `deref`. The standard library provides an implementation of `Deref`
on `String` that returns a string slice, and this is in the API documentation
for `Deref`. Rust calls `deref` again to turn the `&String` into `&str`, which
matches the `hello` function’s definition.
-->
<p>Ici nous appelons la fonction <code>saluer</code> avec l'argument <code>&amp;m</code>, qui est une
référence vers une valeur de type <code>MaBoite&lt;String&gt;</code>. Comme nous avons implémenté
le trait <code>Deref</code> sur <code>MaBoite&lt;T&gt;</code> dans l'encart 15-10, Rust peut transformer le
<code>&amp;MaBoite&lt;String&gt;</code> en <code>&amp;String</code> en appelant <code>deref</code>. La bibliothèque standard
fournit une implémentation de <code>Deref</code> sur <code>String</code> qui retourne une slice de
chaîne de caractères, comme expliqué dans la documentation de l'API de <code>Deref</code>.
Rust appelle à nouveau <code>deref</code> pour transformer le <code>&amp;String</code> en <code>&amp;str</code>, qui
correspond à la définition de la fonction <code>saluer</code>.</p>
<!--
If Rust didn’t implement deref coercion, we would have to write the code in
Listing 15-13 instead of the code in Listing 15-12 to call `hello` with a value
of type `&MyBox<String>`.
-->
<p>Si Rust n'avait pas implémenté l'extrapolation de déréférencement, nous aurions
dû écrire le code de l'encart 15-13 au lieu du code de l'encart 15-12 pour
appeler <code>saluer</code> avec une valeur du type <code>&amp;MaBoite&lt;String&gt;</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# use std::ops::Deref;
# 
# impl<T> Deref for MyBox<T> {
#     type Target = T;
# 
#     fn deref(&self) -> &T {
#         &self.0
#     }
# }
# 
# struct MyBox<T>(T);
# 
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
# 
# fn hello(name: &str) {
#     println!("Hello, {}!", name);
# }
# 
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MaBoite&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MaBoite&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MaBoite&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MaBoite&lt;T&gt; {
</span><span class="boring">        MaBoite(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn saluer(nom: &amp;str) {
</span><span class="boring">    println!(&quot;Salutations, {} !&quot;, nom);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MaBoite::new(String::from(&quot;Rust&quot;));
    saluer(&amp;(*m)[..]);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-13: The code we would have to write if Rust
didn’t have deref coercion</span>
-->
<p><span class="caption">Encart 15-13 : le code que nous aurions dû écrire si Rust
n'avait pas d'extrapolation de déréférencement</span></p>
<!--
The `(*m)` dereferences the `MyBox<String>` into a `String`. Then the `&` and
`[..]` take a string slice of the `String` that is equal to the whole string to
match the signature of `hello`. The code without deref coercions is harder to
read, write, and understand with all of these symbols involved. Deref coercion
allows Rust to handle these conversions for us automatically.
-->
<p>Le <code>(*m)</code> déréférence la <code>MaBoite&lt;String&gt;</code> en une <code>String</code>. Ensuite le <code>&amp;</code> et le
<code>[..]</code> créent une slice de chaîne de caractères à partir de la <code>String</code> qui est
égale à l'intégralité du contenu de la <code>String</code>, ceci afin de correspondre à la
signature de <code>saluer</code>. Le code sans l'extrapolation de déréférencement est bien
plus difficile à lire, écrire et comprendre avec la présence de tous ces
symboles. L'extrapolation de déréférencement permet à Rust d'automatiser ces
convertions pour nous.</p>
<!--
When the `Deref` trait is defined for the types involved, Rust will analyze the
types and use `Deref::deref` as many times as necessary to get a reference to
match the parameter’s type. The number of times that `Deref::deref` needs to be
inserted is resolved at compile time, so there is no runtime penalty for taking
advantage of deref coercion!
-->
<p>Lorsque le trait <code>Deref</code> est défini pour les types concernés, Rust va analyser
les types et utiliser <code>Deref::deref</code> autant de fois que nécessaire pour obtenir
une référence qui correspond au type du paramètre. Le nombre de fois qu'il est
nécessaire d'insérer <code>Deref::deref</code> est résolu au moment de la compilation,
ainsi il n'y a pas de surcoût au moment de l'exécution pour bénéficier de
l'extrapolation de déréférencement !</p>
<!--
### How Deref Coercion Interacts with Mutability
-->
<h3 id="linteraction-de-lextrapolation-de-déréférencement-avec-la-mutabilité"><a class="header" href="#linteraction-de-lextrapolation-de-déréférencement-avec-la-mutabilité">L'interaction de l'extrapolation de déréférencement avec la mutabilité</a></h3>
<!--
Similar to how you use the `Deref` trait to override the `*` operator on
immutable references, you can use the `DerefMut` trait to override the `*`
operator on mutable references.
-->
<p>De la même manière que vous pouvez utiliser le trait <code>Deref</code> pour remplacer le
comportement de l'opérateur <code>*</code> sur les références immuables, vous pouvez
utiliser le trait <code>DerefMut</code> pour remplacer le comportement de l'opérateur <code>*</code>
sur les références mutables.</p>
<!--
Rust does deref coercion when it finds types and trait implementations in three
cases:
-->
<p>Rust procède à l'extrapolation de déréférencement lorsqu'il trouve des types et
des implémentations de traits dans trois cas :</p>
<!--
* From `&T` to `&U` when `T: Deref<Target=U>`
* From `&mut T` to `&mut U` when `T: DerefMut<Target=U>`
* From `&mut T` to `&U` when `T: Deref<Target=U>`
-->
<ul>
<li>Passer de <code>&amp;T</code> à <code>&amp;U</code> lorsque <code>T: Deref&lt;Target=U&gt;</code></li>
<li>Passer de <code>&amp;mut T</code> à <code>&amp;mut U</code> lorsque <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>Passer de <code>&amp;mut T</code> à <code>&amp;U</code> lorsque <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<!--
The first two cases are the same except for mutability. The first case states
that if you have a `&T`, and `T` implements `Deref` to some type `U`, you can
get a `&U` transparently. The second case states that the same deref coercion
happens for mutable references.
-->
<p>Les deux premiers cas sont exactement les mêmes, sauf pour la mutabilité. Le
premier cas signifie que si vous avez un <code>&amp;T</code> et que <code>T</code> implémente <code>Deref</code> pour
le type <code>U</code>, vous pouvez obtenir un <code>&amp;U</code> de manière transparente. Le second cas
signifie que la même extrapolation de déréférencement se déroule pour les
références mutables.</p>
<!--
The third case is trickier: Rust will also coerce a mutable reference to an
immutable one. But the reverse is *not* possible: immutable references will
never coerce to mutable references. Because of the borrowing rules, if you have
a mutable reference, that mutable reference must be the only reference to that
data (otherwise, the program wouldn’t compile). Converting one mutable
reference to one immutable reference will never break the borrowing rules.
Converting an immutable reference to a mutable reference would require that the
initial immutable reference is the only immutable reference to that data, but
the borrowing rules don’t guarantee that. Therefore, Rust can’t make the
assumption that converting an immutable reference to a mutable reference is
possible.
-->
<p>Le troisième cas est plus ardue : Rust va aussi procéder à une extrapolation de
déréférencement d'une référence immuable vers une référence mutable. A cause des
règles d'emprunt, si vous avez une référence mutable, cette référence mutable
doit être la seule référence vers cette donnée (autrement, le programme ne peut
pas être compilé). Convertir une référence mutable vers une référence immuable
ne va jamais casser les règles d'emprunt. Convertir une référence immuable vers
une référence mutable nécessite que la référence immuable initiale soit la seule
référence immuable vers cette donnée, mais les règles d'emprunt n'empêchent pas
cela. Ainsi, Rust ne peut pas déduire que la conversion d'une référence immuable
vers une référence mutable soit possible.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--9"><a class="header" href="#-attention-peinture-fraîche--9">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/191">Pull Request</a>.</p>
</blockquote>
<!--
## Running Code on Cleanup with the `Drop` Trait
-->
<h2 id="exécuter-du-code-au-nettoyage-avec-le-trait-drop"><a class="header" href="#exécuter-du-code-au-nettoyage-avec-le-trait-drop">Exécuter du code au nettoyage avec le trait <code>Drop</code></a></h2>
<!--
The second trait important to the smart pointer pattern is `Drop`, which lets
you customize what happens when a value is about to go out of scope. You can
provide an implementation for the `Drop` trait on any type, and the code you
specify can be used to release resources like files or network connections.
We’re introducing `Drop` in the context of smart pointers because the
functionality of the `Drop` trait is almost always used when implementing a
smart pointer. For example, when a `Box<T>` is dropped it will deallocate the space
on the heap that the box points to.
-->
<p>Le second trait important pour les pointeurs intelligents est <code>Drop</code>, qui vous
permet de personnaliser ce qui se passe lorsqu'une valeur est en train de sortir
d'une portée. Vous pouvez fournir une implémentation du trait <code>Drop</code> sur
n'importe quel type, et le code que vous renseignez peut être utilisé pour
libérer des ressources comme des fichiers ou des connections réseau. Nous
présentons <code>Drop</code> dans le contexte des pointeurs intelligents car la
fonctionnalité du trait <code>Drop</code> est quasiment systématiquement utilisé
lorsque nous implémentons un pointeur intelligent. Par exemple, lorsqu'une
<code>Box&lt;T&gt;</code> est libérée, elle va désallouer l'espace occupé sur le tas sur lequel
la boite pointe.</p>
<!--
In some languages, the programmer must call code to free memory or resources
every time they finish using an instance of a smart pointer. If they forget,
the system might become overloaded and crash. In Rust, you can specify that a
particular bit of code be run whenever a value goes out of scope, and the
compiler will insert this code automatically. As a result, you don’t need to be
careful about placing cleanup code everywhere in a program that an instance of
a particular type is finished with—you still won’t leak resources!
-->
<p>Dans certains langages, le développeur doit appeler du code pour libérer la
mémoire ou des ressources à chaque fois qu'il finit d'utiliser une instance ou
un pointeur intelligent. S'il oublie de le faire, le système peut surcharger et
planter. Avec Rust, vous pouvez renseigner du code qui sera exécuté à chaque
fois qu'une valeur sort de la portée, et le compilateur va insérer
automatiquement ce code. Au final, vous n'avez pas besoin de concentrer votre
attention à placer du code de nettoyage à chaque fois qu'une instance d'un type
particulier n'est plus utilisée — vous ne risquez pas d'avoir des fuites de
ressources !</p>
<!--
Specify the code to run when a value goes out of scope by implementing the
`Drop` trait. The `Drop` trait requires you to implement one method named
`drop` that takes a mutable reference to `self`. To see when Rust calls `drop`,
let’s implement `drop` with `println!` statements for now.
-->
<p>Vous renseignez le code à exécuter lorsqu'une valeur sort de la portée en
implémentant le trait <code>Drop</code>. Le trait <code>Drop</code> nécessite que vous implémentiez
une méthode <code>drop</code> qui prend en paramètre une référence mutable à <code>self</code>. Pour
visualiser lorsque Rust appelle <code>drop</code>, implémentons <code>drop</code> avec une instruction
<code>println!</code> à l'intérieur, pour le moment.</p>
<!--
Listing 15-14 shows a `CustomSmartPointer` struct whose only custom
functionality is that it will print `Dropping CustomSmartPointer!` when the
instance goes out of scope. This example demonstrates when Rust runs the `drop`
function.
-->
<p>L'encart 15-14 montre une structure <code>PointeurPerso</code> dont la seule fonctionnalité
personnalisée est qu'elle va écrire <code>Nettoyage d'un PointeurPerso !</code> lorsque
l'instance sort de la portée. Cet exemple montre lorsque Rust exécute la
fonction <code>drop</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct PointeurPerso {
    donnee: String,
}

impl Drop for PointeurPerso {
    fn drop(&amp;mut self) {
        println!(&quot;Nettoyage d'un PointeurPerso avec la donnée `{}` !&quot;, self.donnee);
    }
}

fn main() {
    let c = PointeurPerso {
        donnee: String::from(&quot;des trucs&quot;),
    };
    let d = PointeurPerso {
        donnee: String::from(&quot;d'autres trucs&quot;),
    };
    println!(&quot;PointeurPersos créés.&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-14: A `CustomSmartPointer` struct that
implements the `Drop` trait where we would put our cleanup code</span>
-->
<p><span class="caption">Encart 15-14 : Une structure <code>PointeurPerso</code> qui
implémente le trait <code>Drop</code> dans lequel nous plaçons notre code de nettoyage
</span></p>
<!--
The `Drop` trait is included in the prelude, so we don’t need to bring it into
scope. We implement the `Drop` trait on `CustomSmartPointer` and provide an
implementation for the `drop` method that calls `println!`. The body of the
`drop` function is where you would place any logic that you wanted to run when
an instance of your type goes out of scope. We’re printing some text here to
demonstrate when Rust will call `drop`.
-->
<p>Le trait <code>Drop</code> est importé dans l'étape préliminaire, donc nous n'avons pas
besoin de l'importer dans la portée. Nous implémentons le trait <code>Drop</code> sur
<code>PointeurPerso</code> et nous fournissons une implémentation de la méthode <code>drop</code> qui
appelle <code>println!</code>. Le corps de la fonction <code>drop</code> est l'endroit où vous placez
la logique que vous souhaitez exécuter lorsqu'une instance du type concerné sort
de la portée. Ici nous affichons un petit texte pour visionner lorsque Rust
appelle <code>drop</code>.</p>
<!--
In `main`, we create two instances of `CustomSmartPointer` and then print
`CustomSmartPointers created`. At the end of `main`, our instances of
`CustomSmartPointer` will go out of scope, and Rust will call the code we put
in the `drop` method, printing our final message. Note that we didn’t need to
call the `drop` method explicitly.
-->
<p>Dans le <code>main</code>, nous créons deux instances de <code>PointeurPerso</code> et ensuite on
affiche <code>PointeurPerso créés</code>. A la fin du <code>main</code>, nos instances de
<code>PointeurPerso</code> vont sortir de la portée, et Rust va appeler le code que nous
avons placé explicitement dans a méthode <code>drop</code>.</p>
<!--
When we run this program, we’ll see the following output:
-->
<p>Lorsque nous exécutons ce programme, nous devrions voir la sortie suivante :</p>
<!--
```console
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
```
-->
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
PointeurPersos créés.
Nettoyage d'un PointeurPerso avec la donnée `d'autres trucs`!
Nettoyage d'un PointeurPerso avec la donnée `des trucs`!
</code></pre>
<!--
Rust automatically called `drop` for us when our instances went out of scope,
calling the code we specified. Variables are dropped in the reverse order of
their creation, so `d` was dropped before `c`. This example gives you a visual
guide to how the `drop` method works; usually you would specify the cleanup
code that your type needs to run rather than a print message.
-->
<p>Rust a appelé automatiquement <code>drop</code> pour nous lorsque nos instances sont
sorties de la portée, et appelé le code que nous avons renseigné. Les variables
sont libérées dans l'ordre inverse à leur création, donc <code>d</code> a été libéré avant
<code>c</code>. Cet exemple vous fournit une illustration de comment la méthode <code>drop</code>
fonctionne ; normalement vous devriez renseigner le code de nettoyage que votre
type a besoin d'exécuter plutôt que d'afficher un message.</p>
<!--
### Dropping a Value Early with `std::mem::drop`
-->
<h3 id="libérer-prématurément-une-valeur-avec-stdmemdrop"><a class="header" href="#libérer-prématurément-une-valeur-avec-stdmemdrop">Libérer prématurément une valeur avec <code>std::mem::drop</code></a></h3>
<!--
Unfortunately, it’s not straightforward to disable the automatic `drop`
functionality. Disabling `drop` isn’t usually necessary; the whole point of the
`Drop` trait is that it’s taken care of automatically. Occasionally, however,
you might want to clean up a value early. One example is when using smart
pointers that manage locks: you might want to force the `drop` method that
releases the lock so that other code in the same scope can acquire the lock.
Rust doesn’t let you call the `Drop` trait’s `drop` method manually; instead
you have to call the `std::mem::drop` function provided by the standard library
if you want to force a value to be dropped before the end of its scope.
-->
<p>Malheureusement, il n'est pas simple de désactiver la fonctionnalité automatique
<code>drop</code>. La désactivation de <code>drop</code> n'est généralement pas nécessaire ; tout
l'intérêt du trait <code>Drop</code> est qu'il est pris en charge automatiquement.
Occasionnellement, cependant, vous pourriez avoir besoin de nettoyer
prématurément une valeur. Un exemple est lorsque vous utilisez des pointeurs
intelligents qui gèrent un système de verrouillage : vous pourriez vouloir
forcer la méthode <code>drop</code> qui libère le verrou afin qu'un autre code dans la même
portée puisse prendre ce verrou. Rust ne vous autorise pas à appeler
manuellement la méthode <code>drop</code> du trait <code>Drop</code> ; à la place vous devez appeler
la fonction <code>std::mem::drop</code>, fournie par la bibliothèque standard, si vous
souhaitez forcer une valeur à être libérée avant la fin de sa portée.</p>
<!--
If we try to call the `Drop` trait’s `drop` method manually by modifying the
`main` function from Listing 15-14, as shown in Listing 15-15, we’ll get a
compiler error:
-->
<p>Si nous essayons d'appeler manuellement la méthode <code>drop</code> du trait <code>Drop</code> en
modifiant la fonction <code>main</code> de l'encart 15-14, comme dans l'encart 15-15, nous
aurons une erreur de compilation :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# struct CustomSmartPointer {
#     data: String,
# }
# 
# impl Drop for CustomSmartPointer {
#     fn drop(&mut self) {
#         println!("Dropping CustomSmartPointer with data `{}`!", self.data);
#     }
# }
# 
fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    c.drop();
    println!("CustomSmartPointer dropped before the end of main.");
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct PointeurPerso {
</span><span class="boring">    donnee: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for PointeurPerso {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Nettoyage d'un PointeurPerso avec la donnée `{}` !&quot;, self.donnee);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = PointeurPerso {
        donnee: String::from(&quot;des trucs&quot;),
    };
    println!(&quot;PointeurPerso créé.&quot;);
    c.drop();
    println!(&quot;PointeurPerso libéré avant la fin du main.&quot;);
}
</code></pre>
<!--
<span class="caption">Listing 15-15: Attempting to call the `drop` method from
the `Drop` trait manually to clean up early</span>
-->
<p><span class="caption">Encart 15-15 : tentative d'appel manuel à la méthode
<code>drop</code> du trait <code>Drop</code> afin de nettoyer prématurément</span></p>
<!--
When we try to compile this code, we’ll get this error:
-->
<p>Lorsque nous essayons de compiler ce code, nous obtenons l'erreur suivante :</p>
<!--
```console
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  -- > src/main.rs:16:7
   |
16 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed

error: aborting due to previous error

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed

error: aborting due to previous error

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
This error message states that we’re not allowed to explicitly call `drop`. The
error message uses the term *destructor*, which is the general programming term
for a function that cleans up an instance. A *destructor* is analogous to a
*constructor*, which creates an instance. The `drop` function in Rust is one
particular destructor.
-->
<p>Ce message d'erreur signifie que nous ne sommes pas autorisés à appeler
explicitement <code>drop</code>. Le message d'erreur utilise le terme de <em>destructeur</em>
(<code>destructor</code>) qui est un terme général de programmation qui désigne une
fonction qui nettoie une instance. Un <em>destructeur</em> est analogue à un
<em>constructeur</em>, qui construit une instance. La fonction <code>drop</code> en Rust est un
destructeur particulier.</p>
<!--
Rust doesn’t let us call `drop` explicitly because Rust would still
automatically call `drop` on the value at the end of `main`. This would be a
*double free* error because Rust would be trying to clean up the same value
twice.
-->
<p>Rust ne nous laisse pas appeler explicitement <code>drop</code> car Rust appellera toujours
automatiquement <code>drop</code> sur la valeur à la fin du <code>main</code>. Cela serait une erreur
de <em>double libération</em> car Rust va essayer de nettoyer la même valeur deux fois.</p>
<!--
We can’t disable the automatic insertion of `drop` when a value goes out of
scope, and we can’t call the `drop` method explicitly. So, if we need to force
a value to be cleaned up early, we can use the `std::mem::drop` function.
-->
<p>Nous ne pouvons pas désactiver l'ajout automatique de <code>drop</code> lorsqu'une valeur
sort de la portée, et nous ne pouvons pas désactiver explicitement la méthode
<code>drop</code>. Donc, si nous avons besoin de forcer une valeur à être nettoyée
prématurément, nous pouvons utiliser la fonction <code>std::mem::drop</code>.</p>
<!--
The `std::mem::drop` function is different from the `drop` method in the `Drop`
trait. We call it by passing the value we want to force to be dropped early as
an argument. The function is in the prelude, so we can modify `main` in Listing
15-15 to call the `drop` function, as shown in Listing 15-16:
-->
<p>La fonction <code>std::mem::drop</code> est différente de la méthode <code>drop</code> du trait
<code>Drop</code>. Nous pouvons l'appeler en lui passant en argument la valeur que nous
souhaitons libérer prématurément. La fonction est présente dans l'étape
préliminaire, donc nous pouvons modifier <code>main</code> de l'encart 15-15 pour appeler
la fonction <code>drop</code>, comme dans l'encart 15-16 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# struct CustomSmartPointer {
#     data: String,
# }
# 
# impl Drop for CustomSmartPointer {
#     fn drop(&mut self) {
#         println!("Dropping CustomSmartPointer with data `{}`!", self.data);
#     }
# }
# 
fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    drop(c);
    println!("CustomSmartPointer dropped before the end of main.");
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct PointeurPerso {
</span><span class="boring">    donnee: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for PointeurPerso {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Nettoyage d'un PointeurPerso avec la donnée `{}` !&quot;, self.donnee);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = PointeurPerso {
        donnee: String::from(&quot;des trucs&quot;),
    };
    println!(&quot;PointeurPerso créé.&quot;);
    drop(c);
    println!(&quot;PointeurPerso libéré avant la fin du main.&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-16: Calling `std::mem::drop` to explicitly
drop a value before it goes out of scope</span>
-->
<p><span class="caption">Encart 15-16 : appel à <code>std::mem::drop</code> pour libérer
explicitement une valeur avant qu'elle sorte de la portée</span></p>
<!--
Running this code will print the following:
-->
<p>L'exécution de code va afficher ceci :</p>
<!--
```console
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
PointeurPerso créé.
Nettoyage d'un PointeurPerso avec la donnée `some data` !
PointeurPerso libéré avant la fin du main.
</code></pre>
<!--
The text ```Dropping CustomSmartPointer with data `some data`!``` is printed
between the `CustomSmartPointer created.` and `CustomSmartPointer dropped
before the end of main.` text, showing that the `drop` method code is called to
drop `c` at that point.
-->
<p>Le texte <code>Nettoyage d'un CustomSmartPointer avec la donnée `des trucs` !</code>
est affiché entre <code>PointeurPerso créé</code> et
<code>PointeurPerso libéré avant la fin du main</code>, ce qui démontre que la méthode
<code>drop</code> a été appelée pour libérer <code>c</code> à cet endroit.</p>
<!--
You can use code specified in a `Drop` trait implementation in many ways to
make cleanup convenient and safe: for instance, you could use it to create your
own memory allocator! With the `Drop` trait and Rust’s ownership system, you
don’t have to remember to clean up because Rust does it automatically.
-->
<p>Vous pouvez utiliser le code renseigné dans une implémentation du trait <code>Drop</code>
de plusieurs manières afin de rendre le nettoyage pratique et sûr : par exemple,
vous pouvez l'utiliser pour créer votre propre alloueur de mémoire ! Grâce au
trait <code>Drop</code> et le système de possession de Rust, vous n'avez pas à vous
souvenir de nettoyer car Rust le fait automatiquement.</p>
<!--
You also don’t have to worry about problems resulting from accidentally
cleaning up values still in use: the ownership system that makes sure
references are always valid also ensures that `drop` gets called only once when
the value is no longer being used.
-->
<p>Vous n'avez pas non plus à vous soucier des problèmes résultants du nettoyage
accidentel de valeurs toujours utilisées : le système de possession assurant que
les références sont toujours en vigueur assure également que <code>drop</code> n'est appelé
qu'une seule fois lorsque la valeur n'est plus utilisée.</p>
<!--
Now that we’ve examined `Box<T>` and some of the characteristics of smart
pointers, let’s look at a few other smart pointers defined in the standard
library.
-->
<p>Maintenant que nous avons examiné <code>Box&lt;T&gt;</code> et certaines des caractéristiques des
pointeurs intelligents, découvrons d'autres pointeurs intelligents définis dans
la bibliothèque standard.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--10"><a class="header" href="#-attention-peinture-fraîche--10">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/192">Pull Request</a>.</p>
</blockquote>
<!--
## `Rc<T>`, the Reference Counted Smart Pointer
-->
<h2 id="rct-le-pointeur-intelligent-qui-compte-les-références"><a class="header" href="#rct-le-pointeur-intelligent-qui-compte-les-références"><code>Rc&lt;T&gt;</code>, le pointeur intelligent qui compte les références</a></h2>
<!--
In the majority of cases, ownership is clear: you know exactly which variable
owns a given value. However, there are cases when a single value might have
multiple owners. For example, in graph data structures, multiple edges might
point to the same node, and that node is conceptually owned by all of the edges
that point to it. A node shouldn’t be cleaned up unless it doesn’t have any
edges pointing to it.
-->
<p>Dans la majorité des cas, la possession est claire : vous savez exactement
quelle variable possède une valeur donnée. Cependant, il existe des cas où une
valeur puisse être possédée par plusieurs propriétaires. Par exemple, dans une
structure de données de courbes, plusieurs extrémités peuvent pointer vers le
même noeud, et ce noeud est théoriquement possédé par toutes les extrémités qui
y pointent. Un noeud ne devrait pas être nettoyé, à moins qu'il n'ait plus
d'extrémités qui pointent sur lui.</p>
<!--
To enable multiple ownership, Rust has a type called `Rc<T>`, which is an
abbreviation for *reference counting*. The `Rc<T>` type keeps track of the
number of references to a value which determines whether or not a value is
still in use. If there are zero references to a value, the value can be cleaned
up without any references becoming invalid.
-->
<p>Pour permettre la possession multiple, Rust a le type <code>Rc&lt;T&gt;</code>, qui est une
abréviation pour <code>Reference Counting</code> <em>(compteur de références)</em>. Le type
<code>Rc&lt;T&gt;</code> assure le suivi du nombre de références vers une valeur, ce qui
détermine si la valeur est toujours utilisée ou non. S'il y a zéro références
vers une valeur, la valeur peut être nettoyée sans qu'aucune référence devienne
invalide.</p>
<!--
Imagine `Rc<T>` as a TV in a family room. When one person enters to watch TV,
they turn it on. Others can come into the room and watch the TV. When the last
person leaves the room, they turn off the TV because it’s no longer being used.
If someone turns off the TV while others are still watching it, there would be
uproar from the remaining TV watchers!
-->
<p>Imaginez que <code>Rc&lt;T&gt;</code> est comme une télévision dans une salle commune. Lorsqu'une
personne entre pour regarder la télévision, elle l'allume. Une autre rentre dans
la salle et regarde la télévision. Lorsque la dernière personne quitte la salle,
elle éteint la télévision car elle n'est plus utilisée. Si quelqu'un éteint la
télévision alors que d'autres continuent à la regarder, il va y avoir du tapage
par les autres téléspectateurs !</p>
<!--
We use the `Rc<T>` type when we want to allocate some data on the heap for
multiple parts of our program to read and we can’t determine at compile time
which part will finish using the data last. If we knew which part would finish
last, we could just make that part the data’s owner, and the normal ownership
rules enforced at compile time would take effect.
-->
<p>Nous utilisons le type <code>Rc&lt;T&gt;</code> lorsque nous souhaitons allouer une donnée sur le
tas pour que plusieurs éléments de notre programme puissent la lire et que nous
ne pouvons pas déterminer au moment de la compilation quel élément va finir de
l'utiliser en dernier. Si nous savons quel élément va finir en dernier, nous
pouvons juste faire en sorte que cet élément prenne possession de la donnée, et
les règles de possession classiques qui s'appliquent au moment de la compilation
prendront effet.</p>
<!--
Note that `Rc<T>` is only for use in single-threaded scenarios. When we discuss
concurrency in Chapter 16, we’ll cover how to do reference counting in
multithreaded programs.
-->
<p>Notez que <code>Rc&lt;T&gt;</code> fonctionne uniquement dans des scénarios à un seul processus.
Lorsque nous verrons la concurrence au chapitre 16, nous verrons comment
procéder au comptage de références dans des programmes multi-processus.</p>
<!--
### Using `Rc<T>` to Share Data
-->
<h3 id="utiliser-rct-pour-partager-une-donnée"><a class="header" href="#utiliser-rct-pour-partager-une-donnée">Utiliser <code>Rc&lt;T&gt;</code> pour partager une donnée</a></h3>
<!--
Let’s return to our cons list example in Listing 15-5. Recall that we defined
it using `Box<T>`. This time, we’ll create two lists that both share ownership
of a third list. Conceptually, this looks similar to Figure 15-3:
-->
<p>Retournons à notre exemple de liste de construction de l'encart 15-5.
Souvenez-vous que nous l'avons défini en utilisant <code>Box&lt;T&gt;</code>. Cette fois-ci, nous
allons créer deux listes qui partagent tous les deux la propriété d'une
troisième liste. Théoriquement, cela ressemblera à l'illustration 15-3 :</p>
<!-- markdownlint-disable -->
<!--
<img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" />
-->
<!-- markdownlint-restore -->
<p><img
    alt="Deux listes qui se partagent la propriété d'une troisième liste"
    src="img/trpl15-03.svg"
    class="center" /></p>
<!--
<span class="caption">Figure 15-3: Two lists, `b` and `c`, sharing ownership of
a third list, `a`</span>
-->
<p><span class="caption">Illustration 15-3 : deux listes, <code>b</code> et <code>c</code>, qui se
partagent la possession d'une troisième liste, <code>a</code></span></p>
<!--
We’ll create list `a` that contains 5 and then 10. Then we’ll make two more
lists: `b` that starts with 3 and `c` that starts with 4. Both `b` and `c`
lists will then continue on to the first `a` list containing 5 and 10. In other
words, both lists will share the first list containing 5 and 10.
-->
<p>Nous allons créer une liste <code>a</code> qui contient <code>5</code> et ensuite <code>10</code>. Ensuite, nous
allons créer deux autres listes : <code>b</code> qui démarre avec <code>3</code> et <code>c</code> qui démarre
avec <code>4</code>. Les deux listes <code>b</code> et <code>c</code> vont ensuite continuer sur la première
liste <code>a</code> qui contient déjà <code>5</code> et <code>10</code>. Autrement dit, les deux listes vont se
partager la première liste contenant <code>5</code> et <code>10</code>.</p>
<!--
Trying to implement this scenario using our definition of `List` with `Box<T>`
won’t work, as shown in Listing 15-17:
-->
<p>Si nous essayons d'implémenter ce scénario en utilisant les définitions de
<code>List</code> avec <code>Box&lt;T&gt;</code>, comme dans l'encart 15-17, cela ne va pas fonctionner :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
```
-->
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<!--
<span class="caption">Listing 15-17: Demonstrating we’re not allowed to have
two lists using `Box<T>` that try to share ownership of a third list</span>
-->
<p><span class="caption">Encart 15-17 : démonstration que nous ne sommes pas
autorisés à avoir deux listes qui utilisent <code>Box&lt;T&gt;</code> pour partager la propriété
d'une troisième liste</span></p>
<!--
When we compile this code, we get this error:
-->
<p>Lorsque nous compilons ce code, nous obtenons cette erreur :</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  -- > src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The `Cons` variants own the data they hold, so when we create the `b` list, `a`
is moved into `b` and `b` owns `a`. Then, when we try to use `a` again when
creating `c`, we’re not allowed to because `a` has been moved.
-->
<p>Les variantes <code>Cons</code> prennent possession des données qu'elles obteniennent, donc
lorsque nous avons créé la liste <code>b</code>, <code>a</code> a été déplacée dans <code>b</code> et <code>b</code> possède
désormais <code>a</code>. Ensuite, lorsque nous essayons d'utiliser <code>a</code> à nouveau lorsque
nous créons <code>c</code>, nous ne sommes pas autorisés à le faire car <code>a</code> a été déplacé.</p>
<!--
We could change the definition of `Cons` to hold references instead, but then
we would have to specify lifetime parameters. By specifying lifetime
parameters, we would be specifying that every element in the list will live at
least as long as the entire list. The borrow checker wouldn’t let us compile
`let a = Cons(10, &Nil);` for example, because the temporary `Nil` value would
be dropped before `a` could take a reference to it.
-->
<p>Nous pourrions changer la définition de <code>Cons</code> pour stocker des références à la
place, mais ensuite nous aurions besoin de renseigner des paramètres de durée de
vie. En renseignant les paramètres de durée de vie, nous devrons dire que chaque
élément dans la liste devrait vivre aussi longtemps que la liste entière. Le
vérificateur d'emprunt ne nous laisserait pas compiler <code>let a = Cons(10, &amp;Nil);</code>
par exemple, car la valeur temporaire <code>Nil</code> serait libérée avant que <code>a</code> puisse
obtenir une référence vers elle.</p>
<!--
Instead, we’ll change our definition of `List` to use `Rc<T>` in place of
`Box<T>`, as shown in Listing 15-18. Each `Cons` variant will now hold a value
and an `Rc<T>` pointing to a `List`. When we create `b`, instead of taking
ownership of `a`, we’ll clone the `Rc<List>` that `a` is holding, thereby
increasing the number of references from one to two and letting `a` and `b`
share ownership of the data in that `Rc<List>`. We’ll also clone `a` when
creating `c`, increasing the number of references from two to three. Every time
we call `Rc::clone`, the reference count to the data within the `Rc<List>` will
increase, and the data won’t be cleaned up unless there are zero references to
it.
-->
<p>A la place, nous allons changer la définition de <code>List</code> pour utiliser <code>Rc&lt;T&gt;</code> à
la place de <code>Box&lt;T&gt;</code>, comme dans l'encart 15-18. Chaque variante <code>Cons</code> va
maintenant posséder une valeur et un <code>Rc&lt;T&gt;</code> pointant sur une <code>List</code>. Lorsque
nous créons <code>b</code>, au lieu de prendre possession de <code>a</code>, nous allons cloner le
<code>Rc&lt;List&gt;</code> que <code>a</code> possède, augmentant ainsi le nombre de références de un à
deux et permettant à <code>a</code> et <code>b</code> de partager la propriété des données dans
<code>Rc&lt;List&gt;</code>. Nous allons aussi cloner <code>a</code> lorsque nous créons <code>c</code>, augmentant le
nombre de références de deux à trois. Chaque fois que nous appelons <code>Rc::clone</code>,
le compteur de références des données présentes dans le <code>Rc&lt;List&gt;</code> va augmenter,
et les données ne seront pas nettoyées tant qu'il n'y aura pas zéro références
vers elles.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Filename : src/main.rs</span></p>
<!--
```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-18: A definition of `List` that uses
`Rc<T>`</span>
-->
<p><span class="caption">Encart 15-18 : une définition de <code>List</code> qui utilise
<code>Rc&lt;T&gt;</code></span></p>
<!--
We need to add a `use` statement to bring `Rc<T>` into scope because it’s not
in the prelude. In `main`, we create the list holding 5 and 10 and store it in
a new `Rc<List>` in `a`. Then when we create `b` and `c`, we call the
`Rc::clone` function and pass a reference to the `Rc<List>` in `a` as an
argument.
-->
<p>Nous devons ajouter une instruction <code>use</code> pour importer <code>Rc&lt;T&gt;</code> dans la portée
car il n'est pas présent dans l'étape préliminaire. Dans le <code>main</code>, nous créons
la liste qui stocke <code>5</code> et <code>10</code> et la stocke dans une nouvelle <code>Rc&lt;List&gt;</code> dans
<code>a</code>. Ensuite lorsque nous créons <code>b</code> et <code>c</code>, nous appelons la fonction
<code>Rc::clone</code> et passer une référence vers le <code>Rc&lt;List&gt;</code> de <code>a</code> en argument.</p>
<!--
We could have called `a.clone()` rather than `Rc::clone(&a)`, but Rust’s
convention is to use `Rc::clone` in this case. The implementation of
`Rc::clone` doesn’t make a deep copy of all the data like most types’
implementations of `clone` do. The call to `Rc::clone` only increments the
reference count, which doesn’t take much time. Deep copies of data can take a
lot of time. By using `Rc::clone` for reference counting, we can visually
distinguish between the deep-copy kinds of clones and the kinds of clones that
increase the reference count. When looking for performance problems in the
code, we only need to consider the deep-copy clones and can disregard calls to
`Rc::clone`.
-->
<p>Nous aurions pu appeler <code>a.clone()</code> plutôt que <code>Rc::clone(&amp;a)</code>, mais la
convention en Rust est d'utiliser <code>Rc::clone</code> dans cette situation.
L'implémentation de <code>Rc::clone</code> ne fait pas une copie profonde de toutes les
données comme le fait la plupart des implémentations de <code>clone</code>. L'appel à
<code>Rc:clone</code> augmente uniquement le compteur de références, ce qui ne prend pas
beaucoup de temps. Les copies profondes des données peut prendre beaucoup de
temps. En utilisant <code>Rc::clone</code> pour les compteurs de références, nous pouvons
distinguer visuellement un clonage qui fait une copie profonde d'un clonage qui
augmente uniquement le compteur de références. Lorsque vous enquêtez sur des
problèmes de performances dans le code, vous pouvez ainsi écarter les appels à
<code>Rc::clone</code> des clonages à copie profonde, que vous recherchez probablement.</p>
<!--
### Cloning an `Rc<T>` Increases the Reference Count
-->
<h3 id="cloner-une-rct-augmente-le-compteur-de-référence"><a class="header" href="#cloner-une-rct-augmente-le-compteur-de-référence">Cloner une <code>Rc&lt;T&gt;</code> augmente le compteur de référence</a></h3>
<!--
Let’s change our working example in Listing 15-18 so we can see the reference
counts changing as we create and drop references to the `Rc<List>` in `a`.
-->
<p>Changeons notre exemple de l'encart 15-18 pour que nous puissions voir le
compteur de références changer au fur et à mesure que nous créons et libérons
des références vers le <code>Rc&lt;List&gt;</code> présent dans <code>a</code>.</p>
<!--
In Listing 15-19, we’ll change `main` so it has an inner scope around list `c`;
then we can see how the reference count changes when `c` goes out of scope.
-->
<p>Dans l'encart 15-19, nous allons changer le <code>main</code> afin qu'il ait une portée
en son sein autour de <code>c</code> ; ainsi nous pourrons voir comment le compteur de
références change lorsque <code>c</code> sort de la portée.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# enum List {
#     Cons(i32, Rc<List>),
#     Nil,
# }
# 
# use crate::List::{Cons, Nil};
# use std::rc::Rc;
# 
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;compteur après la création de a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;compteur après la création de b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;compteur après la création de c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;compteur après que c soit sortie de la portée = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-19: Printing the reference count</span>
-->
<p><span class="caption">Encart 15-19 : affichage du compteur de références</span></p>
<!--
At each point in the program where the reference count changes, we print the
reference count, which we can get by calling the `Rc::strong_count` function.
This function is named `strong_count` rather than `count` because the `Rc<T>`
type also has a `weak_count`; we’ll see what `weak_count` is used for in the
[“Preventing Reference Cycles: Turning an `Rc<T>` into a
`Weak<T>`”][preventing-ref-cycles]<!-- ignore -- > section.
-->
<p>A chaque étape du programme où le compteur de références change, nous affichons
le compteur de références, que nous pouvons obtenir en faisant appel à la
fonction <code>Rc::strong_count</code>. Cette fonction s'appelle <code>strong_count</code> plutôt que
<code>count</code> car le type <code>Rc&lt;T&gt;</code> a aussi un <code>weak_count</code> ; nous verrons à quoi sert
ce <code>weak_count</code> dans
<a href="ch15-06-reference-cycles.html">la dernière section de ce chapitre</a><!-- ignore -->.</p>
<!--
This code prints the following:
-->
<p>Ce code affiche ceci :</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
compteur après la création de a = 1
compteur après la création de b = 2
compteur après la création de c = 3
compteur après que c soit sortie de la portée = 2
</code></pre>
<!--
We can see that the `Rc<List>` in `a` has an initial reference count of 1; then
each time we call `clone`, the count goes up by 1. When `c` goes out of scope,
the count goes down by 1. We don’t have to call a function to decrease the
reference count like we have to call `Rc::clone` to increase the reference
count: the implementation of the `Drop` trait decreases the reference count
automatically when an `Rc<T>` value goes out of scope.
-->
<p>Nous pouvons voir clairement que le <code>Rc&lt;List&gt;</code> dans <code>a</code> a un compteur de
références initial à <code>1</code> ; puis à chaque fois que nous appelons <code>clone</code>, le
compteur augmente de 1. Nous n'avons pas à appeler une fonction pour réduire le
compteur de références, comme nous avons dû le faire avec <code>Rc::clone</code> pour
augmenter compteur : l'implémentation du trait <code>Drop</code> réduit le compteur de
références automatiquement lorsqu'une valeur de <code>Rc&lt;T&gt;</code> sort de la portée.</p>
<!--
What we can’t see in this example is that when `b` and then `a` go out of scope
at the end of `main`, the count is then 0, and the `Rc<List>` is cleaned up
completely at that point. Using `Rc<T>` allows a single value to have
multiple owners, and the count ensures that the value remains valid as long as
any of the owners still exist.
-->
<p>Ce que nous ne voyons pas dans cet exemple est lorsque <code>b</code> et <code>a</code> sortent de la
portée à la fin du <code>main</code>, le compteur vaut alors 0, et le <code>Rc&lt;List&gt;</code> est
nettoyé complètement à ce moment. L'utilisation de <code>Rc&lt;T&gt;</code> permet à une valeur
d'avoir plusieurs propriétaires, et le compteur garantit que la valeur reste
en vigueur tant qu'au moins un propriétaire existe encore.</p>
<!--
Via immutable references, `Rc<T>` allows you to share data between multiple
parts of your program for reading only. If `Rc<T>` allowed you to have multiple
mutable references too, you might violate one of the borrowing rules discussed
in Chapter 4: multiple mutable borrows to the same place can cause data races
and inconsistencies. But being able to mutate data is very useful! In the next
section, we’ll discuss the interior mutability pattern and the `RefCell<T>`
type that you can use in conjunction with an `Rc<T>` to work with this
immutability restriction.
-->
<p>Grâce aux références immuables, <code>Rc&lt;T&gt;</code> vous permet de partager des données
entre plusieurs éléments de votre programme pour uniquement les lire. Si <code>Rc&lt;T&gt;</code>
vous aurait aussi permis d'avoir des références mutables, vous aurez alors
violé une des règles d'emprunt vues au chapitre 4 : les emprunts mutables
multiples à une même donnée peuvent causer des accès concurrents et des
incohérences. Cependant, pouvoir modifier des données reste très utile ! Dans la
section suivante, nous allons voir le motif de mutabilité interne et le type
<code>RefCell&lt;T&gt;</code> que vous pouvez utiliser conjointement avec un <code>Rc&lt;T&gt;</code> pour pouvoir
travailler avec cette contrainte d'immuabilité.</p>
<!-- markdownlint-disable -->
<!--
[preventing-ref-cycles]: ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt
-->
<!-- markdownlint-restore -->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--11"><a class="header" href="#-attention-peinture-fraîche--11">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/194">Pull Request</a>.</p>
</blockquote>
<!--
## `RefCell<T>` and the Interior Mutability Pattern
-->
<h2 id="refcellt-et-le-motif-de-mutabilité-interne"><a class="header" href="#refcellt-et-le-motif-de-mutabilité-interne"><code>RefCell&lt;T&gt;</code> et le motif de mutabilité interne</a></h2>
<!--
*Interior mutability* is a design pattern in Rust that allows you to mutate
data even when there are immutable references to that data; normally, this
action is disallowed by the borrowing rules. To mutate data, the pattern uses
`unsafe` code inside a data structure to bend Rust’s usual rules that govern
mutation and borrowing. We haven’t yet covered unsafe code; we will in Chapter
19. We can use types that use the interior mutability pattern when we can
ensure that the borrowing rules will be followed at runtime, even though the
compiler can’t guarantee that. The `unsafe` code involved is then wrapped in a
safe API, and the outer type is still immutable.
-->
<p>La <em>mutabilité interne</em> est un motif de conception en Rust qui vous permet de
muter une donnée même s'il existe des références immuables ; normalement, cette
action n'est pas autorisée par les règles d'emprunt. Pour muter des données, le
motif utilise du code <code>unsafe</code> dans une structure de données pour contourner les
règles courantes de Rust qui gouvernent la mutation et l'emprunt. Nous n'avons
pas encore parlé du code unsafe ; nous le ferons au chapitre 19. Nous pouvons
utiliser des types qui utilisent le motif de mutabilité interne lorsque nous
pouvons être sûr que les règles d'emprunt seront suivies au moment de
l'exécution, même si le compilateur ne peut pas en être sûr. Le code <code>unsafe</code>
concerné est ensuite incorporé dans une API stable, et le type externe reste
immuable.</p>
<!--
Let’s explore this concept by looking at the `RefCell<T>` type that follows the
interior mutability pattern.
-->
<p>Découvrons ce concept en examinant le type <code>RefCell&lt;T&gt;</code> qui applique le motif
de mutabilité interne.</p>
<!--
### Enforcing Borrowing Rules at Runtime with `RefCell<T>`
-->
<h3 id="appliquer-les-règles-demprunt-au-moment-de-lexécution-avec-refcellt"><a class="header" href="#appliquer-les-règles-demprunt-au-moment-de-lexécution-avec-refcellt">Appliquer les règles d'emprunt au moment de l'exécution avec <code>RefCell&lt;T&gt;</code></a></h3>
<!--
Unlike `Rc<T>`, the `RefCell<T>` type represents single ownership over the data
it holds. So, what makes `RefCell<T>` different from a type like `Box<T>`?
Recall the borrowing rules you learned in Chapter 4:
-->
<p>Contrairement à <code>Rc&lt;T&gt;</code>, le type <code>RefCell&lt;T&gt;</code> représente un seul propriétaire
de la donnée qu'il contient. Donc, qu'est-ce qui rend <code>RefCell&lt;T&gt;</code> différent
d'un type comme <code>Box&lt;T&gt;</code> ? Souvenez-vous des règles d'emprunt que vous avez
appris au chapitre 4 :</p>
<!--
* At any given time, you can have *either* (but not both of) one mutable
  reference or any number of immutable references.
* References must always be valid.
-->
<ul>
<li>A un instant donné, vous pouvez avoir <em>soit</em> (mais pas les deux) une
référence mutable, soit n'importe quelle quantité de références immuables</li>
<li>Les références doivent toujours être en vigueur.</li>
</ul>
<!--
With references and `Box<T>`, the borrowing rules’ invariants are enforced at
compile time. With `RefCell<T>`, these invariants are enforced *at runtime*.
With references, if you break these rules, you’ll get a compiler error. With
`RefCell<T>`, if you break these rules, your program will panic and exit.
-->
<p>Avec les références et <code>Box&lt;T&gt;</code>, les règles d'emprunt obligatoires sont
appliquées au moment de la compilation. Avec <code>RefCell&lt;T&gt;</code>, ces obligations
sont appliquées <em>au moment de l'exécution</em>. Avec les références, si vous ne
respectez pas ces règles, vous allez obtenir une erreur de compilation. Avec
<code>RefCell&lt;T&gt;</code>, si vous ne les respectez pas, votre programme va paniquer et se
fermer.</p>
<!--
The advantages of checking the borrowing rules at compile time are that errors
will be caught sooner in the development process, and there is no impact on
runtime performance because all the analysis is completed beforehand. For those
reasons, checking the borrowing rules at compile time is the best choice in the
majority of cases, which is why this is Rust’s default.
-->
<p>Les avantages de vérifier les règles d'emprunt au moment de la compilation est
que les erreurs vont se produire plus tôt dans le processus de développement,
et il n'y a pas d'impact sur la performance à l'exécution car toute l'analyse
a déjà été faite au préalable. Pour ces raisons, la vérification des règles
d'emprunt au moment de compilation est le meilleur choix à faire dans la
majorité des cas, ce qui explique pourquoi c'est le choix par défaut de Rust.</p>
<!--
The advantage of checking the borrowing rules at runtime instead is that
certain memory-safe scenarios are then allowed, whereas they are disallowed by
the compile-time checks. Static analysis, like the Rust compiler, is inherently
conservative. Some properties of code are impossible to detect by analyzing the
code: the most famous example is the Halting Problem, which is beyond the scope
of this book but is an interesting topic to research.
-->
<p>L'avantage de vérifier les règles d'emprunt plutôt à l'exécution est que cela
permet certains scénarios qui restent sûrs pour la mémoire, bien qu'interdites
à cause des vérifications à la compilation. L'analyse statique, comme le
compilateur Rust, est de nature prudente. Certaines propriétés du code sont
impossibles à détecter en analysant le code : l'exemple le plus connu est le
<em>problème de l'arrêt</em>, qui dépasse le cadre de ce livre mais qui reste un
sujet intéressant à étudier.</p>
<!--
Because some analysis is impossible, if the Rust compiler can’t be sure the
code complies with the ownership rules, it might reject a correct program; in
this way, it’s conservative. If Rust accepted an incorrect program, users
wouldn’t be able to trust in the guarantees Rust makes. However, if Rust
rejects a correct program, the programmer will be inconvenienced, but nothing
catastrophic can occur. The `RefCell<T>` type is useful when you’re sure your
code follows the borrowing rules but the compiler is unable to understand and
guarantee that.
-->
<p>Comme certaines analyses sont impossibles, si le compilateur Rust ne peut pas
s'assurer que le code respecte les règles d'emprunt, il risque de rejeter un
programme valide ; dans ce sens, il est prudent. Si Rust accepte un programme
incorrecte, les utilisateurs ne pourront pas avoir confiance dans les
garanties qu'apporte Rust. Cependant, si Rust rejette un programme valide, le
développeur sera importuné, mais rien de catastrophique ne va se passer. Le
type <code>RefCell&lt;T&gt;</code> est utile lorsque vous êtes sûr que votre code suit bien
les règles d'emprunt mais que le compilateur est incapable de comprendre et
de garantir cela.</p>
<!--
Similar to `Rc<T>`, `RefCell<T>` is only for use in single-threaded scenarios
and will give you a compile-time error if you try using it in a multithreaded
context. We’ll talk about how to get the functionality of `RefCell<T>` in a
multithreaded program in Chapter 16.
-->
<p>De la même manière que <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> sert uniquement pour des
scénarios à une seule tâche et va vous donner une erreur à la compilation si
vous essayez de l'utiliser dans un contexte multitâches. Nous verrons
comment bénéficier les des fonctionnalités de <code>RefCell&lt;T&gt;</code> dans un programme
multi-processus au chapitre 16.</p>
<!--
Here is a recap of the reasons to choose `Box<T>`, `Rc<T>`, or `RefCell<T>`:
-->
<p>Voici un résumé des raisons pour choisir <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, ou <code>RefCell&lt;T&gt;</code> :</p>
<!--
* `Rc<T>` enables multiple owners of the same data; `Box<T>` and `RefCell<T>`
  have single owners.
* `Box<T>` allows immutable or mutable borrows checked at compile time; `Rc<T>`
  allows only immutable borrows checked at compile time; `RefCell<T>` allows
  immutable or mutable borrows checked at runtime.
* Because `RefCell<T>` allows mutable borrows checked at runtime, you can
  mutate the value inside the `RefCell<T>` even when the `RefCell<T>` is
  immutable.
-->
<ul>
<li><code>Rc&lt;T&gt;</code> permet d'avoir plusieurs propriétaires pour une même donnée ;
<code>Rc&lt;T&gt;</code> et <code>RefCell&lt;T&gt;</code> n'ont qu'un seul propriétaire.</li>
<li><code>Box&lt;T&gt;</code> permet des emprunts immuables ou mutables à la compilation ;
<code>Rc&lt;T&gt;</code> permet uniquement des emprunts immuables, vérifiés à la
compilation ; <code>RefCell&lt;T&gt;</code> permet des emprunts immuables ou mutables,
vérifiés à l'exécution.</li>
<li>Comme <code>RefCell&lt;T&gt;</code> permet des emprunts mutables, vérifiés à l'exécution,
vous pouvez muter la valeur à l'intérieur du <code>RefCell&lt;T&gt;</code> même si le
<code>RefCell&lt;T&gt;</code> est immuable.</li>
</ul>
<!--
Mutating the value inside an immutable value is the *interior mutability*
pattern. Let’s look at a situation in which interior mutability is useful and
examine how it’s possible.
-->
<p>Modifer une valeur à l'intérieur d'une valeur immuable est ce qu'on appelle
le motif de <em>mutabilité interne</em>. Découvrons une situation pour laquelle la
mutabilité interne est utile est examinons comment c'est possible.</p>
<!--
### Interior Mutability: A Mutable Borrow to an Immutable Value
-->
<h3 id="mutabilité-interne--un-emprunt-mutable-dune-valeur-immuable"><a class="header" href="#mutabilité-interne--un-emprunt-mutable-dune-valeur-immuable">Mutabilité interne : un emprunt mutable d'une valeur immuable</a></h3>
<!--
A consequence of the borrowing rules is that when you have an immutable value,
you can’t borrow it mutably. For example, this code won’t compile:
-->
<p>Une des conséquences des règles d'emprunt est que lorsque vous avez une valeur
immuable, vous ne pouvez pas emprunter sa mutabilité. Par exemple, ce code ne
va pas se compiler :</p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = 5;
    let y = &mut x;
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<!--
If you tried to compile this code, you’d get the following error:
-->
<p>Si vous essayez de compiler ce code, vous allez obtenir l'erreur suivante :</p>
<!--
```console
$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 -- > src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &mut x;
  |             ^^^^^^ cannot borrow as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
However, there are situations in which it would be useful for a value to mutate
itself in its methods but appear immutable to other code. Code outside the
value’s methods would not be able to mutate the value. Using `RefCell<T>` is
one way to get the ability to have interior mutability. But `RefCell<T>`
doesn’t get around the borrowing rules completely: the borrow checker in the
compiler allows this interior mutability, and the borrowing rules are checked
at runtime instead. If you violate the rules, you’ll get a `panic!` instead of
a compiler error.
-->
<p>Cependant, il existe des situations pour lesquelles il serait utile qu'une
valeur puisse se modifier elle-même dans ses propres méthodes mais qui semble
être immuable pour le reste du code. Le code à l'extérieur des méthodes de la
valeur n'est pas capable de modifier la valeur. L'utilisation de <code>RefCell&lt;T&gt;</code>
est une manière de pouvoir procéder à des mutations internes. Mais
<code>RefCell&lt;T&gt;</code> ne contourne pas complètement les règles d'emprunt : le
vérificateur d'emprunt du compilateur permet cette mutabilité interne, et les
règles d'emprunt sont plutôt vérifiées à l'exécution. Si vous violez les
règles, vous allez provoquer un <code>panic!</code> plutôt que d'avoir une erreur de
compilation.</p>
<!--
Let’s work through a practical example where we can use `RefCell<T>` to mutate
an immutable value and see why that is useful.
-->
<p>Voyons un exemple pratique dans lequel nous pouvons utiliser <code>RefCell&lt;T&gt;</code> pour
modifier une valeur immuable et voir en quoi cela est utile.</p>
<!--
#### A Use Case for Interior Mutability: Mock Objects
-->
<h4 id="un-cas-dutilisation-de-la-mutabilité-interne--le-mock-object"><a class="header" href="#un-cas-dutilisation-de-la-mutabilité-interne--le-mock-object">Un cas d'utilisation de la mutabilité interne : le mock object</a></h4>
<!--
A *test double* is the general programming concept for a type used in place of
another type during testing. *Mock objects* are specific types of test doubles
that record what happens during a test so you can assert that the correct
actions took place.
-->
<p>Un <em>double de test</em> est un concept de programmation général pour un type
utilisé à la place d'un autre type pendant des tests. Un <em>mock object</em> est un
type particulier de double de test qui enregistre ce qui se passe lors d'un
test afin que vous puissiez vérifier que les actions se sont passées
correctement.</p>
<!--
Rust doesn’t have objects in the same sense as other languages have objects,
and Rust doesn’t have mock object functionality built into the standard library
as some other languages do. However, you can definitely create a struct that
will serve the same purposes as a mock object.
-->
<p>Rust n'a pas d'objets dans le sens qu'entendent les autres langages qui ont
des objets, et Rust n'a pas de fonctionnalité de mock object construit dans
la bibliothèque standard comme l'entendent d'autres langages. Cependant, vous
pouvez très bien créer une structure qui va répondre aux mêmes besoins qu'un
mock object.</p>
<!--
Here’s the scenario we’ll test: we’ll create a library that tracks a value
against a maximum value and sends messages based on how close to the maximum
value the current value is. This library could be used to keep track of a
user’s quota for the number of API calls they’re allowed to make, for example.
-->
<p>Voici le scénario que nous allons tester : nous allons créer une bibliothèque
qui traque une valeur par rapport à une valeur maximale et envoie des messages
en fonction de la proximité de la valeur courante. Cette bibliothèque peut
être utilisée pour suivre un quota d'un utilisateur pour le nombre d'appels
aux API qu'il est autorisé à faire, par exemple.</p>
<!--
Our library will only provide the functionality of tracking how close to the
maximum a value is and what the messages should be at what times. Applications
that use our library will be expected to provide the mechanism for sending the
messages: the application could put a message in the application, send an
email, send a text message, or something else. The library doesn’t need to know
that detail. All it needs is something that implements a trait we’ll provide
called `Messenger`. Listing 15-20 shows the library code:
-->
<p>Notre bibliothèque va seulement fournir la fonctionnalité de suivi en fonction
de la valeur maximale et quels seront les messages à chaque moment. Les
applications qui utiliseront notre bibliothèque devront fournir un mécanisme
pour envoyer les messages : l'application peut afficher le message dans
l'application, l'envoyer par email, l'envoyer par SMS, ou autre chose. La
bibliothèque n'a pas à se charger de ce détail. Tout ce que ce mécanisme doit
faire est d'implémenter un trait <code>Messager</code> que nous allons fournir. L'encart
15-20 propose du code pour cette bibliothèque :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
pub trait Messenger {
    fn send(&self, msg: &str);
}

pub struct LimitTracker<'a, T: Messenger> {
    messenger: &'a T,
    value: usize,
    max: usize,
}

impl<'a, T> LimitTracker<'a, T>
where
    T: Messenger,
{
    pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max >= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max >= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max >= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Messager {
    fn envoyer(&amp;self, msg: &amp;str);
}

pub struct TraqueurDeLimite&lt;'a, T: Messager&gt; {
    messager: &amp;'a T,
    valeur: usize,
    max: usize,
}

impl&lt;'a, T&gt; TraqueurDeLimite&lt;'a, T&gt;
where
    T: Messager,
{
    pub fn new(messager: &amp;T, max: usize) -&gt; TraqueurDeLimite&lt;T&gt; {
        TraqueurDeLimite {
            messager,
            valeur: 0,
            max,
        }
    }

    pub fn set_valeur(&amp;mut self, valeur: usize) {
        self.valeur = valeur;

        let pourcentage_du_maximum = self.valeur as f64 / self.max as f64;

        if pourcentage_du_maximum &gt;= 1.0 {
            self.messager.envoyer(&quot;Erreur : vous avez dépassé votre quota !&quot;);
        } else if pourcentage_du_maximum &gt;= 0.9 {
            self.messager
                .envoyer(&quot;Avertissement urgent : vous avez utilisé 90% de votre quota !&quot;);
        } else if pourcentage_du_maximum &gt;= 0.75 {
            self.messager
                .envoyer(&quot;Avertissement : vous avez utilisé 75% de votre quota !&quot;);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-20: A library to keep track of how close a
value is to a maximum value and warn when the value is at certain levels</span>
-->
<p><span class="caption">Encart 15-20 : une bibliothèque qui suit la proximité
d'une valeur avec une valeur maximale et avertit lorsque cette valeur atteint
un certain seuil</span></p>
<!--
One important part of this code is that the `Messenger` trait has one method
called `send` that takes an immutable reference to `self` and the text of the
message. This is the interface our mock object needs to have. The other
important part is that we want to test the behavior of the `set_value` method
on the `LimitTracker`. We can change what we pass in for the `value` parameter,
but `set_value` doesn’t return anything for us to make assertions on. We want
to be able to say that if we create a `LimitTracker` with something that
implements the `Messenger` trait and a particular value for `max`, when we pass
different numbers for `value`, the messenger is told to send the appropriate
messages.
-->
<p>La partie la plus importante de ce code est celle où le trait <code>Messager</code> a une
méthode qui fait appel à <code>envoyer</code> en prenant une référence immuable à <code>self</code>
ainsi que le texte du message. C'est l'interface que notre mock object doit
avoir. L'autre partie importante est lorsque nous souhaitons tester le
comportement de la méthode <code>set_valeur</code> sur le <code>TraqueurDeLimite</code>. Nous pouvons
changer ce que nous envoyons dans le paramètre <code>valeur</code>, mais <code>set_valeur</code> ne
nous retourne rien qui nous permet de le vérifier. Nous voulons pouvoir dire que
si nous créons un <code>TraqueurDeLimite</code> avec quelque chose qui implémente le trait
<code>Messager</code> et une valeur précise pour <code>max</code>, lorsque nous passons différents
nombres pour <code>valeur</code>, que le messager puisse confirmer l'envoi des messages
correspondants.</p>
<!--
We need a mock object that, instead of sending an email or text message when we
call `send`, will only keep track of the messages it’s told to send. We can
create a new instance of the mock object, create a `LimitTracker` that uses the
mock object, call the `set_value` method on `LimitTracker`, and then check that
the mock object has the messages we expect. Listing 15-21 shows an attempt to
implement a mock object to do just that, but the borrow checker won’t allow it:
-->
<p>Nous avons besoin d'un mock object qui, au lieu d'envoyer un email ou un SMS
lorsque nous faisons appel à <code>envoyer</code>, va seulement enregistrer les messages
qu'on lui demande d'envoyer. Nous pouvons créer une nouvelle instance du mock
object, créer un <code>TraqueurDeLimite</code> qui utilise le mock object, faire appel à la
méthode <code>set_value</code> sur le <code>TraqueurDeLimite</code>, et ensuite vérifier que le mock
object a bien les messages que nous attendions. L'encart 15-21 montre une
tentative d'implémentation d'un mock object qui fait ceci, mais le vérificateur
d'emprunt ne nous autorise pas à le faire :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# pub trait Messenger {
#     fn send(&self, msg: &str);
# }
# 
# pub struct LimitTracker<'a, T: Messenger> {
#     messenger: &'a T,
#     value: usize,
#     max: usize,
# }
# 
# impl<'a, T> LimitTracker<'a, T>
# where
#     T: Messenger,
# {
#     pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
#         LimitTracker {
#             messenger,
#             value: 0,
#             max,
#         }
#     }
# 
#     pub fn set_value(&mut self, value: usize) {
#         self.value = value;
# 
#         let percentage_of_max = self.value as f64 / self.max as f64;
# 
#         if percentage_of_max >= 1.0 {
#             self.messenger.send("Error: You are over your quota!");
#         } else if percentage_of_max >= 0.9 {
#             self.messenger
#                 .send("Urgent warning: You've used up over 90% of your quota!");
#         } else if percentage_of_max >= 0.75 {
#             self.messenger
#                 .send("Warning: You've used up over 75% of your quota!");
#         }
#     }
# }
# 
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec<String>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messager {
</span><span class="boring">    fn envoyer(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct TraqueurDeLimite&lt;'a, T: Messager&gt; {
</span><span class="boring">    messager: &amp;'a T,
</span><span class="boring">    valeur: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; TraqueurDeLimite&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messager,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messager: &amp;T, max: usize) -&gt; TraqueurDeLimite&lt;T&gt; {
</span><span class="boring">        TraqueurDeLimite {
</span><span class="boring">            messager,
</span><span class="boring">            valeur: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_valeur(&amp;mut self, valeur: usize) {
</span><span class="boring">        self.valeur = valeur;
</span><span class="boring">
</span><span class="boring">        let pourcentage_du_maximum = self.valeur as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if pourcentage_du_maximum &gt;= 1.0 {
</span><span class="boring">            self.messager.envoyer(&quot;Erreur : vous avez dépassé votre quota !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.9 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement urgent : vous avez utilisé 90% de votre quota !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.75 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement : vous avez utilisé 75% de votre quota !&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MessagerMock {
        messages_envoyes: Vec&lt;String&gt;,
    }

    impl MessagerMock {
        fn new() -&gt; MessagerMock {
            MessagerMock {
                messages_envoyes: vec![],
            }
        }
    }

    impl Messager for MessagerMock {
        fn envoyer(&amp;self, message: &amp;str) {
            self.messages_envoyes.push(String::from(message));
        }
    }

    #[test]
    fn envoi_d_un_message_d_avertissement_superieur_a_75_pourcent() {
        let messager_mock = MessagerMock::new();
        let mut traqueur = TraqueurDeLimite::new(&amp;messager_mock, 100);

        traqueur.set_valeur(80);

        assert_eq!(messager_mock.messages_envoyes.len(), 1);
    }
}
</code></pre>
<!--
<span class="caption">Listing 15-21: An attempt to implement a `MockMessenger`
that isn’t allowed by the borrow checker</span>
-->
<p><span class="caption">Encart 15-21 : une tentative d'implémentation d'un
<code>MessagerMock</code> qui n'est pas autorisé par le vérificateur d'emprunt</span></p>
<!--
This test code defines a `MockMessenger` struct that has a `sent_messages`
field with a `Vec` of `String` values to keep track of the messages it’s told
to send. We also define an associated function `new` to make it convenient to
create new `MockMessenger` values that start with an empty list of messages. We
then implement the `Messenger` trait for `MockMessenger` so we can give a
`MockMessenger` to a `LimitTracker`. In the definition of the `send` method, we
take the message passed in as a parameter and store it in the `MockMessenger`
list of `sent_messages`.
-->
<p>Ce code de test définit une structure <code>MessagerMock</code> qui a un champ
<code>messages_envoyes</code> qui est un <code>Vec</code> de valeurs <code>String</code>, afin d'y enregistrer
les messages qui lui sont envoyés. Nous définissons également une fonction
associée <code>new</code> pour faciliter la création de valeurs <code>MessagerMock</code> qui
commencent avec une liste vide de messages. Nous implémentons ensuite le trait
<code>Messager</code> sur <code>MessagerMock</code> afin de donner un <code>MessagerMock</code> à un
<code>TraqueurDeLimite</code>. Dans la définition de la méthode <code>envoyer</code>, nous prenons
le message envoyé en paramètre et nous le stockons dans la liste
<code>messages_envoyes</code> du <code>MessagerMock</code>.</p>
<!--
In the test, we’re testing what happens when the `LimitTracker` is told to set
`value` to something that is more than 75 percent of the `max` value. First, we
create a new `MockMessenger`, which will start with an empty list of messages.
Then we create a new `LimitTracker` and give it a reference to the new
`MockMessenger` and a `max` value of 100. We call the `set_value` method on the
`LimitTracker` with a value of 80, which is more than 75 percent of 100. Then
we assert that the list of messages that the `MockMessenger` is keeping track
of should now have one message in it.
-->
<p>Dans le test, nous vérifions ce qui se passe lorsque le <code>TraqueurDeLimite</code>
doit atteindre une valeur qui est supérieure à 75 pourcent de la valeur <code>max</code>.
D'abord, nous créons un nouveau <code>MessagerMock</code>, qui va démarrer avec une liste
vide de messages. Ensuite, nous créons un nouveau <code>TraqueurDeLimite</code> et nous
lui donnons une référence vers ce <code>MessagerMock</code> et une valeur <code>max</code> de 100.
Nous appelons la méthode <code>set_valeur</code> sur le <code>TraqueurDeLimite</code> avec une
valeur de 80, qui est plus grande que 75 pourcent de 100. Enfin, nous
vérifions que la liste de messages qu'a enregistré le <code>MessagerMock</code> a bien
un message à l'intérieur.</p>
<!--
However, there’s one problem with this test, as shown here:
-->
<p>Cependant, il reste un problème avec ce test, qui est montré ci-dessous :</p>
<!--
```text
$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&` reference
  -- > src/lib.rs:58:13
   |
57 |         fn send(&self, message: &str) {
   |                 ----- help: consider changing this to be a mutable reference: `&mut self`
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-text">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.messages_envoyes` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
57 |         fn envoyer(&amp;self, message: &amp;str) {
   |                    ----- help: consider changing this to be a mutable reference: `&amp;mut self`
58 |             self.messages_envoyes.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
We can’t modify the `MockMessenger` to keep track of the messages, because the
`send` method takes an immutable reference to `self`. We also can’t take the
suggestion from the error text to use `&mut self` instead, because then the
signature of `send` wouldn’t match the signature in the `Messenger` trait
definition (feel free to try and see what error message you get).
-->
<p>Nous ne pouvons pas modifier le <code>MessagerMock</code> pour enregistrer les messages,
car la méthode <code>envoyer</code> utilise une référence immuable à <code>self</code>. Nous ne
pouvons pas non plus suivre la suggestion du texte d'erreur pour utiliser
<code>&amp;mut self</code> à la place, car ensuite la signature de <code>envoyer</code> ne va pas
correspondre à la signature de la définition du trait <code>Messager</code> (essayez et
vous constaterez le message d'erreur que vous obtiendrez).</p>
<!--
This is a situation in which interior mutability can help! We’ll store the
`sent_messages` within a `RefCell<T>`, and then the `send` message will be
able to modify `sent_messages` to store the messages we’ve seen. Listing 15-22
shows what that looks like:
-->
<p>C'est une situation dans laquelle la mutabilité interne peut nous aider !
Nous allons stocker <code>messages_envoyes</code> dans une <code>RefCell&lt;T&gt;</code>, et ensuite le
message de <code>envoyer</code> pourra modifier <code>messages_envoyes</code> pour stocker les
messages que nous avons avons vu. L'encart 15-22 montre à quoi cela peut
ressembler :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# pub trait Messenger {
#     fn send(&self, msg: &str);
# }
# 
# pub struct LimitTracker<'a, T: Messenger> {
#     messenger: &'a T,
#     value: usize,
#     max: usize,
# }
# 
# impl<'a, T> LimitTracker<'a, T>
# where
#     T: Messenger,
# {
#     pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
#         LimitTracker {
#             messenger,
#             value: 0,
#             max,
#         }
#     }
# 
#     pub fn set_value(&mut self, value: usize) {
#         self.value = value;
# 
#         let percentage_of_max = self.value as f64 / self.max as f64;
# 
#         if percentage_of_max >= 1.0 {
#             self.messenger.send("Error: You are over your quota!");
#         } else if percentage_of_max >= 0.9 {
#             self.messenger
#                 .send("Urgent warning: You've used up over 90% of your quota!");
#         } else if percentage_of_max >= 0.75 {
#             self.messenger
#                 .send("Warning: You've used up over 75% of your quota!");
#         }
#     }
# }
# 
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell<Vec<String>>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
#         let mock_messenger = MockMessenger::new();
#         let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);
# 
#         limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub trait Messager {
</span><span class="boring">    fn envoyer(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct TraqueurDeLimite&lt;'a, T: Messager&gt; {
</span><span class="boring">    messager: &amp;'a T,
</span><span class="boring">    valeur: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; TraqueurDeLimite&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messager,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messager: &amp;T, max: usize) -&gt; TraqueurDeLimite&lt;T&gt; {
</span><span class="boring">        TraqueurDeLimite {
</span><span class="boring">            messager,
</span><span class="boring">            valeur: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_valeur(&amp;mut self, valeur: usize) {
</span><span class="boring">        self.valeur = valeur;
</span><span class="boring">
</span><span class="boring">        let pourcentage_du_maximum = self.valeur as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if pourcentage_du_maximum &gt;= 1.0 {
</span><span class="boring">            self.messager.envoyer(&quot;Erreur : vous avez dépassé votre quota !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.9 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement urgent : vous avez utilisé 90% de votre quota !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.75 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement : vous avez utilisé 75% de votre quota !&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MessagerMock {
        messages_envoyes: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MessagerMock {
        fn new() -&gt; MessagerMock {
            MessagerMock {
                messages_envoyes: RefCell::new(vec![]),
            }
        }
    }

    impl Messager for MessagerMock {
        fn envoyer(&amp;self, message: &amp;str) {
            self.messages_envoyes.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn envoi_d_un_message_d_avertissement_superieur_a_75_pourcent() {
        // -- partie masquée ici --
<span class="boring">        let messager_mock = MessagerMock::new();
</span><span class="boring">        let mut traqueur = TraqueurDeLimite::new(&amp;messager_mock, 100);
</span><span class="boring">
</span><span class="boring">        traqueur.set_valeur(80);
</span>
        assert_eq!(messager_mock.messages_envoyes.borrow().len(), 1);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-22: Using `RefCell<T>` to mutate an inner
value while the outer value is considered immutable</span>
-->
<p><span class="caption">Encart 15-22 : utilisation du <code>RefCell&lt;T&gt;</code> pour muter
une valeur interne que les valeurs externes considèrent comme immuable
</span></p>
<!--
The `sent_messages` field is now of type `RefCell<Vec<String>>` instead of
`Vec<String>`. In the `new` function, we create a new `RefCell<Vec<String>>`
instance around the empty vector.
-->
<p>Le champ <code>messages_envoyes</code> est maintenant du type <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> au
lieu de <code>Vec&lt;String&gt;</code>. Dans la fonction <code>new</code>, nous créons une nouvelle
instance de <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> autour du vecteur vide.</p>
<!--
For the implementation of the `send` method, the first parameter is still an
immutable borrow of `self`, which matches the trait definition. We call
`borrow_mut` on the `RefCell<Vec<String>>` in `self.sent_messages` to get a
mutable reference to the value inside the `RefCell<Vec<String>>`, which is
the vector. Then we can call `push` on the mutable reference to the vector to
keep track of the messages sent during the test.
-->
<p>En ce qui concerne l'implémentation de la méthode <code>envoyer</code>, le premier
paramètre est toujours un emprunt immuable de <code>self</code>, ce qui correspond à la
définition du trait. Nous appelons la méthode <code>borrow_mut</code> sur le
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code> présent dans <code>self.messages_envoyes</code> pour obtenir une
référence mutable vers la valeur présente dans le <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, qui
correspond au vecteur. Ensuite, nous appelons <code>push</code> sur la référence mutable
vers le vecteur pour enregistrer le message envoyé pendant le test.</p>
<!--
The last change we have to make is in the assertion: to see how many items are
in the inner vector, we call `borrow` on the `RefCell<Vec<String>>` to get an
immutable reference to the vector.
-->
<p>Le dernier changement que nous devons appliquer est dans la vérification :
pour savoir combien d'éléments sont présents dans le vecteur, nous faisons
appel à <code>borrow</code> de <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> pour obtenir une référence
immuable vers le vecteur.</p>
<!--
Now that you’ve seen how to use `RefCell<T>`, let’s dig into how it works!
-->
<p>Maintenant que vous avez appris à utiliser <code>RefCell&lt;T&gt;</code>, regardons comment il
fonctionne !</p>
<!--
#### Keeping Track of Borrows at Runtime with `RefCell<T>`
-->
<h4 id="suivre-les-emprunts-à-lexécution-avec-refcellt"><a class="header" href="#suivre-les-emprunts-à-lexécution-avec-refcellt">Suivre les emprunts à l'exécution avec <code>RefCell&lt;T&gt;</code></a></h4>
<!--
When creating immutable and mutable references, we use the `&` and `&mut`
syntax, respectively. With `RefCell<T>`, we use the `borrow` and `borrow_mut`
methods, which are part of the safe API that belongs to `RefCell<T>`. The
`borrow` method returns the smart pointer type `Ref<T>`, and `borrow_mut`
returns the smart pointer type `RefMut<T>`. Both types implement `Deref`, so we
can treat them like regular references.
-->
<p>Lorsque nous créons des références immuables et mutables, nous utilisons
respectivement les syntaxes <code>&amp;</code> et <code>&amp;mut</code>. Avec <code>RefCell&lt;T&gt;</code>, nous utilisons
les méthodes <code>borrow</code> et <code>borrow_mut</code>, qui font partie de l'API stable de
<code>RefCell&lt;T&gt;</code>. La méthode <code>borrow</code> retourne un pointeur intelligent du type
<code>Ref&lt;T&gt;</code> et <code>borrow_mut</code> retourne le pointeur intelligent du type <code>RefMut&lt;T&gt;</code>.
Les deux implémentent <code>Deref</code>, donc nous pouvons les considérer comme des
références classiques.</p>
<!--
The `RefCell<T>` keeps track of how many `Ref<T>` and `RefMut<T>` smart
pointers are currently active. Every time we call `borrow`, the `RefCell<T>`
increases its count of how many immutable borrows are active. When a `Ref<T>`
value goes out of scope, the count of immutable borrows goes down by one. Just
like the compile-time borrowing rules, `RefCell<T>` lets us have many immutable
borrows or one mutable borrow at any point in time.
-->
<p>Le <code>RefCell&lt;T&gt;</code> suit combien de pointeurs intelligents <code>Ref&lt;T&gt;</code> et <code>RefMut&lt;T&gt;</code>
sont actuellement actifs. A chaque fois que nous faisons appel à <code>borrow</code>, le
<code>RefCell&lt;T&gt;</code> augmente son compteur du nombre d'emprunts immuables qui existent.
Lorsqu'une valeur <code>Ref&lt;T&gt;</code> sort de la portée, le compteur d'emprunts immuables
est décrémenté de un. <code>RefCell&lt;T&gt;</code> nous permet d'avoir autant d'emprunts
immuables ou alors un seul emprunt mutable au même moment, exactement comme les
règles d'emprunt à la compilation.</p>
<!--
If we try to violate these rules, rather than getting a compiler error as we
would with references, the implementation of `RefCell<T>` will panic at
runtime. Listing 15-23 shows a modification of the implementation of `send` in
Listing 15-22. We’re deliberately trying to create two mutable borrows active
for the same scope to illustrate that `RefCell<T>` prevents us from doing this
at runtime.
-->
<p>Si nous ne respectons pas ces règles, l'implémentation de <code>RefCell&lt;T&gt;</code> va
paniquer à l'exécution plutôt que d'avoir une erreur de compilation comme nous
l'aurions avec des références classiques. L'encart 15-23 nous montre une
modification apportée à l'implémentation de <code>envoyer</code> de l'encart 15-22. Nous
essayons délibérément de créer deux emprunts mutables actifs dans la même
portée pour montrer que <code>RefCell&lt;T&gt;</code> nous empêche de faire ceci à l'exécution.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,panics
# pub trait Messenger {
#     fn send(&self, msg: &str);
# }
# 
# pub struct LimitTracker<'a, T: Messenger> {
#     messenger: &'a T,
#     value: usize,
#     max: usize,
# }
# 
# impl<'a, T> LimitTracker<'a, T>
# where
#     T: Messenger,
# {
#     pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
#         LimitTracker {
#             messenger,
#             value: 0,
#             max,
#         }
#     }
# 
#     pub fn set_value(&mut self, value: usize) {
#         self.value = value;
# 
#         let percentage_of_max = self.value as f64 / self.max as f64;
# 
#         if percentage_of_max >= 1.0 {
#             self.messenger.send("Error: You are over your quota!");
#         } else if percentage_of_max >= 0.9 {
#             self.messenger
#                 .send("Urgent warning: You've used up over 90% of your quota!");
#         } else if percentage_of_max >= 0.75 {
#             self.messenger
#                 .send("Warning: You've used up over 75% of your quota!");
#         }
#     }
# }
# 
# #[cfg(test)]
# mod tests {
#     use super::*;
#     use std::cell::RefCell;
# 
#     struct MockMessenger {
#         sent_messages: RefCell<Vec<String>>,
#     }
# 
#     impl MockMessenger {
#         fn new() -> MockMessenger {
#             MockMessenger {
#                 sent_messages: RefCell::new(vec![]),
#             }
#         }
#     }
# 
    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
# 
#     #[test]
#     fn it_sends_an_over_75_percent_warning_message() {
#         let mock_messenger = MockMessenger::new();
#         let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);
# 
#         limit_tracker.set_value(80);
# 
#         assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
#     }
# }
```
-->
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messager {
</span><span class="boring">    fn envoyer(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct TraqueurDeLimite&lt;'a, T: Messager&gt; {
</span><span class="boring">    messager: &amp;'a T,
</span><span class="boring">    valeur: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; TraqueurDeLimite&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messager,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messager: &amp;T, max: usize) -&gt; TraqueurDeLimite&lt;T&gt; {
</span><span class="boring">        TraqueurDeLimite {
</span><span class="boring">            messager,
</span><span class="boring">            valeur: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_valeur(&amp;mut self, valeur: usize) {
</span><span class="boring">        self.valeur = valeur;
</span><span class="boring">
</span><span class="boring">        let pourcentage_du_maximum = self.valeur as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if pourcentage_du_maximum &gt;= 1.0 {
</span><span class="boring">            self.messager.envoyer(&quot;Erreur : vous avez dépassé votre quota !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.9 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement urgent : vous avez utilisé 90% de votre quota !&quot;);
</span><span class="boring">        } else if pourcentage_du_maximum &gt;= 0.75 {
</span><span class="boring">            self.messager
</span><span class="boring">                .envoyer(&quot;Avertissement : vous avez utilisé 75% de votre quota !&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MessagerMock {
</span><span class="boring">        messages_envoyes: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MessagerMock {
</span><span class="boring">        fn new() -&gt; MessagerMock {
</span><span class="boring">            MessagerMock {
</span><span class="boring">                messages_envoyes: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messager for MessagerMock {
        fn envoyer(&amp;self, message: &amp;str) {
            let mut premier_emprunt = self.messages_envoyes.borrow_mut();
            let mut second_emprunt = self.messages_envoyes.borrow_mut();

            premier_emprunt.push(String::from(message));
            second_emprunt.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn envoi_d_un_message_d_avertissement_superieur_a_75_pourcent() {
</span><span class="boring">        let messager_mock = MessagerMock::new();
</span><span class="boring">        let mut traqueur = TraqueurDeLimite::new(&amp;messager_mock, 100);
</span><span class="boring">
</span><span class="boring">        traqueur.set_valeur(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(messager_mock.messages_envoyes.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 15-23: Creating two mutable references in the
same scope to see that `RefCell<T>` will panic</span>
-->
<p><span class="caption">Encart 15-23 : création de deux références mutables dans
la même portée pour voir si <code>RefCell&lt;T&gt;</code> va paniquer</span></p>
<!--
We create a variable `one_borrow` for the `RefMut<T>` smart pointer returned
from `borrow_mut`. Then we create another mutable borrow in the same way in the
variable `two_borrow`. This makes two mutable references in the same scope,
which isn’t allowed. When we run the tests for our library, the code in Listing
15-23 will compile without any errors, but the test will fail:
-->
<p>Nous créons une variable <code>premier_emprunt</code> pour le pointeur intelligent
<code>RefMut&lt;T&gt;</code> retourné par <code>borrow_mut</code>. Ensuite nous créons un autre emprunt de
la même manière, qui s'appelle <code>second_emprunt</code>. Cela fait deux références
mutables dans la même portée, ce qui n'est pas autorisé. Lorsque nous lançons
les tests sur notre bibliothèque, le code de l'encart 15-23 va se compiler
sans erreur, mais les tests vont échouer :</p>
<!--
```console
$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running target/debug/deps/limit_tracker-d1b2637139dca6ca

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'main' panicked at 'already borrowed: BorrowMutError', src/libcore/result.rs:1188:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
```
-->
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running target/debug/deps/limit_tracker-d1b2637139dca6ca

running 1 test
test tests::envoi_d_un_message_d_avertissement_superieur_a_75_pourcent ... FAILED

failures:

---- tests::envoi_d_un_message_d_avertissement_superieur_a_75_pourcent stdout ----
thread 'main' panicked at 'already borrowed: BorrowMutError', src/libcore/result.rs:1188:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::envoi_d_un_message_d_avertissement_superieur_a_75_pourcent

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Notice that the code panicked with the message `already borrowed:
BorrowMutError`. This is how `RefCell<T>` handles violations of the borrowing
rules at runtime.
-->
<p>Remarquez que le code a paniqué avec le message
<code>already borrowed: BorrowMutError</code> (NdT : <code>déjà emprunté</code>). C'est ainsi que
<code>RefCell&lt;T&gt;</code> gère les violations des règles d'emprunt à l'exécution.</p>
<!--
Catching borrowing errors at runtime rather than compile time means that you
would find a mistake in your code later in the development process and possibly
not until your code was deployed to production. Also, your code would incur a
small runtime performance penalty as a result of keeping track of the borrows
at runtime rather than compile time. However, using `RefCell<T>` makes it
possible to write a mock object that can modify itself to keep track of the
messages it has seen while you’re using it in a context where only immutable
values are allowed. You can use `RefCell<T>` despite its trade-offs to get more
functionality than regular references provide.
-->
<p>La détection des erreurs d'emprunt à l'exécution plutôt qu'à la compilation
signifie que vous allez trouver une erreur dans votre code plus tard dans le
processus de développement et peut-être même pas avant que votre code soit
déployé en production. De plus, votre code va subir une petite perte de
performances à l'exécution en raison du contrôle des emprunts à l'exécution
plutôt qu'à la compilation. Cependant, l'utilisation de <code>RefCell&lt;T&gt;</code> rend
possible l'écriture d'un mock object qui peut se modifier lui-même afin
d'enregistrer les messages qu'il a vu passer alors que vous l'utilisez dans un
contexte où seules les valeurs immuables sont permises. Vous pouvez utiliser
<code>RefCell&lt;T&gt;</code> malgré ses inconvénients pour obtenir plus de fonctionnalités
que celles qu'offre une référence classique.</p>
<!--
### Having Multiple Owners of Mutable Data by Combining `Rc<T>` and `RefCell<T>`
-->
<h3 id="permettre-plusieurs-propriétaires-de-données-mutables-en-combinant-rct-et-refcellt"><a class="header" href="#permettre-plusieurs-propriétaires-de-données-mutables-en-combinant-rct-et-refcellt">Permettre plusieurs propriétaires de données mutables en combinant <code>Rc&lt;T&gt;</code> et <code>RefCell&lt;T&gt;</code></a></h3>
<!--
A common way to use `RefCell<T>` is in combination with `Rc<T>`. Recall that
`Rc<T>` lets you have multiple owners of some data, but it only gives immutable
access to that data. If you have an `Rc<T>` that holds a `RefCell<T>`, you can
get a value that can have multiple owners *and* that you can mutate!
-->
<p>Il est courant d'utiliser <code>RefCell&lt;T&gt;</code> en tandem avec <code>Rc&lt;T&gt;</code>. Rappelez-vous
que <code>Rc&lt;T&gt;</code> vous permet d'avoir plusieurs propriétaires d'une même donnée, mais
qu'il vous donne seulement un accès immuable à cette donnée. Si vous avez un
<code>Rc&lt;T&gt;</code> qui contient un <code>RefCell&lt;T&gt;</code>, vous pouvez obtenir une valeur qui peut
avoir plusieurs propriétaires <em>et</em> que vous pouvez modifier !</p>
<!--
For example, recall the cons list example in Listing 15-18 where we used
`Rc<T>` to allow multiple lists to share ownership of another list. Because
`Rc<T>` holds only immutable values, we can’t change any of the values in the
list once we’ve created them. Let’s add in `RefCell<T>` to gain the ability to
change the values in the lists. Listing 15-24 shows that by using a
`RefCell<T>` in the `Cons` definition, we can modify the value stored in all
the lists:
-->
<p>Souvenez-vous de l'exemple de la liste de construction de l'encart 15-18 où nous
avions utilisé <code>Rc&lt;T&gt;</code> pour permettre d'avoir plusieurs listes de se partager la
possession d'une autre liste. Comme <code>Rc&lt;T&gt;</code> stocke seulement des valeurs
immuables, nous ne pouvons changer aucune valeur dans la liste une fois que
nous l'avons créé. Ajoutons un <code>RefCell&lt;T&gt;</code> pour pouvoir changer les valeurs
dans les listes. L'encart 15-24 nous montre ceci en ajoutant un <code>RefCell&lt;T&gt;</code>
dans la définition de <code>Cons</code>, nous pouvons ainsi modifier les valeurs stockées
dans n'importe quelle liste :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));

    *value.borrow_mut() += 10;

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}
```
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let valeur = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;valeur), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *valeur.borrow_mut() += 10;

    println!(&quot;a après les opérations = {:?}&quot;, a);
    println!(&quot;b après les opérations = {:?}&quot;, b);
    println!(&quot;c après les opérations = {:?}&quot;, c);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-24: Using `Rc<RefCell<i32>>` to create a
`List` that we can mutate</span>
-->
<p><span class="caption">Encart 15-24 : utilisation de <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> pour
créer une <code>List</code> que nous pouvons modifier</span></p>
<!--
We create a value that is an instance of `Rc<RefCell<i32>>` and store it in a
variable named `value` so we can access it directly later. Then we create a
`List` in `a` with a `Cons` variant that holds `value`. We need to clone
`value` so both `a` and `value` have ownership of the inner `5` value rather
than transferring ownership from `value` to `a` or having `a` borrow from
`value`.
-->
<p>Nous créons une valeur qui est une instance de <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> et nous la
stockons dans une variable <code>valeur</code> afin que nous puissions y avoir accès plus
tard. Ensuite, nous créons une <code>List</code> dans <code>a</code> avec une variante de <code>Cons</code> qui
utilise <code>valeur</code>. Nous devons utiliser clone sur <code>valeur</code> afin que <code>a</code> et
<code>valeur</code> soient toutes les deux propriétaires de la valeur interne <code>5</code> plutôt
que d'avoir à transférer la possession de <code>valeur</code> à <code>a</code> ou avoir <code>a</code> qui
emprunte <code>valeur</code>.</p>
<!--
We wrap the list `a` in an `Rc<T>` so when we create lists `b` and `c`, they
can both refer to `a`, which is what we did in Listing 15-18.
-->
<p>Nous insérons la liste <code>a</code> dans un <code>Rc&lt;T&gt;</code> pour que lorsque nous créons <code>b</code> et
<code>c</code>, elles puissent toutes les deux utiliser <code>a</code>, ce que nous avions déjà fait
dans l'encart 15-18.</p>
<!--
After we’ve created the lists in `a`, `b`, and `c`, we add 10 to the value in
`value`. We do this by calling `borrow_mut` on `value`, which uses the
automatic dereferencing feature we discussed in Chapter 5 (see the section
[“Where’s the `->` Operator?”][wheres-the---operator]<!-- ignore -- >) to
dereference the `Rc<T>` to the inner `RefCell<T>` value. The `borrow_mut`
method returns a `RefMut<T>` smart pointer, and we use the dereference operator
on it and change the inner value.
-->
<p>Après avoir créé les listes dans <code>a</code>, <code>b</code>, et <code>c</code>, nous ajoutons 10 à la valeur
dans <code>valeur</code>. Nous faisons cela en appelant <code>borrow_mut</code> sur <code>valeur</code>, ce qui
utilise la fonctionnalité de déréférencement automatique que nous avons vu au
chapitre 5 (voir la section
<a href="ch05-03-method-syntax.html#o%C3%B9-est-lop%C3%A9rateur---">“Où est l'opérateur -&gt; ?”</a><!-- ignore -->) pour
déréférencer le <code>Rc&lt;T&gt;</code> dans la valeur interne <code>RefCell&lt;T&gt;</code>. La méthode
<code>borrow_mut</code> retourne un pointeur intelligent <code>RefMut&lt;T&gt;</code>, et nous utilisons
l'opérateur de déréférencement sur lui pour changer sa valeur interne.</p>
<!--
When we print `a`, `b`, and `c`, we can see that they all have the modified
value of 15 rather than 5:
-->
<p>Lorsque nous affichons <code>a</code>, <code>b</code> et <code>c</code>, nous pouvons constater qu'elles ont
toutes la valeur modifiée de 15 au lieu de 5 :</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a après les opérations = Cons(RefCell { value: 15 }, Nil)
b après les opérations = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c après les opérations = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<!--
This technique is pretty neat! By using `RefCell<T>`, we have an outwardly
immutable `List` value. But we can use the methods on `RefCell<T>` that provide
access to its interior mutability so we can modify our data when we need to.
The runtime checks of the borrowing rules protect us from data races, and it’s
sometimes worth trading a bit of speed for this flexibility in our data
structures.
-->
<p>Cette technique est plutôt ingénieuse ! En utilisant <code>RefCell&lt;T&gt;</code>, nous avons
une valeur <code>List</code> qui est immuable de l'extérieur. Mais nous pouvons utiliser
les méthodes de <code>RefCell&lt;T&gt;</code> qui nous donne accès à sa mutabilité interne afin
que nous puissions modifier notre donnée lorsque nous en avons besoin. Les
vérifications des règles d'emprunt à l'exécution nous protègent des accès
concurrents, et il est parfois intéressant de sacrifier un peu de vitesse pour
cette flexibilité dans nos structures de données.</p>
<!--
The standard library has other types that provide interior mutability, such as
`Cell<T>`, which is similar except that instead of giving references to the
inner value, the value is copied in and out of the `Cell<T>`. There’s also
`Mutex<T>`, which offers interior mutability that’s safe to use across threads;
we’ll discuss its use in Chapter 16. Check out the standard library docs for
more details on the differences between these types.
-->
<p>La bibliothèque standard a d'autres types qui fournissent de la mutabilité
interne, comme <code>Cell&lt;T&gt;</code>, qui est similaire sauf qu'au lieu de fournir des
références à la valeur interne, la valeur est copiée à l'intérieur et à
l'extérieur du <code>Cell&lt;T&gt;</code>. Il existe aussi <code>Mutex&lt;T&gt;</code> qui offre de la mutabilité
interne qui est sécurisée pour une utilisation partagée entre plusieures
tâches ; nous allons voir son utilisation au chapitre 16. Plongez-vous dans la
documentation de la bibliothèque standard pour plus de détails entre ces
différents types.</p>
<!--
[wheres-the---operator]: ch05-03-method-syntax.html#wheres-the---operator
-->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--12"><a class="header" href="#-attention-peinture-fraîche--12">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/195">Pull Request</a>.</p>
</blockquote>
<!--
## Reference Cycles Can Leak Memory
-->
<h2 id="les-boucles-de-références-qui-peuvent-provoquer-des-fuites-de-mémoire"><a class="header" href="#les-boucles-de-références-qui-peuvent-provoquer-des-fuites-de-mémoire">Les boucles de références qui peuvent provoquer des fuites de mémoire</a></h2>
<!--
Rust’s memory safety guarantees make it difficult, but not impossible, to
accidentally create memory that is never cleaned up (known as a *memory leak*).
Preventing memory leaks entirely is not one of Rust’s guarantees in the same
way that disallowing data races at compile time is, meaning memory leaks are
memory safe in Rust. We can see that Rust allows memory leaks by using `Rc<T>`
and `RefCell<T>`: it’s possible to create references where items refer to each
other in a cycle. This creates memory leaks because the reference count of each
item in the cycle will never reach 0, and the values will never be dropped.
-->
<p>Les garanties de sécurité de la mémoire de Rust rendent difficile, mais pas
impossible, la création accidentelle de mémoire qui n'est jamais nettoyée
(aussi appelée <em>fuite de mémoire</em>). Eviter absolument les fuites de mémoire
n'est pas une des garanties de Rust comme c'est le cas pour l'accès
concurrent à la compilation, ce qui signifie que les fuites de mémoire ne
sont dangereuses, pour Rust. Nous pouvons constater que Rust permet les fuites
de mémoire en utilisant <code>Rc&lt;T&gt;</code> et <code>RefCell&lt;T&gt;</code> : il est possible de créer des
références où les éléments se réfèrent entre eux de manière cyclique. Cela
crée des fuites de mémoire car le compteur de références de chaque élément
dans la boucle de références ne vaudra jamais 0, et les valeurs ne seront
jamais libérées.</p>
<!--
### Creating a Reference Cycle
-->
<h3 id="créer-une-boucle-de-références"><a class="header" href="#créer-une-boucle-de-références">Créer une boucle de références</a></h3>
<!--
Let’s look at how a reference cycle might happen and how to prevent it,
starting with the definition of the `List` enum and a `tail` method in Listing
15-25:
-->
<p>Voyons comment une boucle de références peut exister et comment l'éviter, en
commençant par la définition de l'énumération <code>List</code> et la méthode <code>parcourir</code>
de l'encart 15-25 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}

fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn parcourir(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}
</code></pre></pre>
<!--
<span class="caption">Listing 15-25: A cons list definition that holds a
`RefCell<T>` so we can modify what a `Cons` variant is referring to</span>
-->
<p><span class="caption">Encart 15-25 : une liste de construction qui stocke une
<code>RefCell&lt;T&gt;</code> pour que nous puissions modifier ce sur quoi une variante <code>Cons</code>
pointe</span></p>
<!--
We’re using another variation of the `List` definition from Listing 15-5. The
second element in the `Cons` variant is now `RefCell<Rc<List>>`, meaning that
instead of having the ability to modify the `i32` value as we did in Listing
15-24, we want to modify which `List` value a `Cons` variant is pointing to.
We’re also adding a `tail` method to make it convenient for us to access the
second item if we have a `Cons` variant.
-->
<p>Nous utilisons une autre variation de la définition de <code>List</code> de l'encart 15-5.
Le second élément dans la variante <code>Cons</code> est maintenant un
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, ce qui signifie qu'au lieu de pouvoir modifier la valeur
<code>i32</code> comme nous l'avions fait dans l'encart 15-24, nous modifions ce sur quoi
une variante <code>Cons</code> pointe (qui reste une valeur <code>List</code>). Nous ajoutons
également une méthode <code>parcourir</code> pour nous faciliter l'accès au second élément
si nous avons une variante <code>Cons</code>.</p>
<!--
In Listing 15-26, we’re adding a `main` function that uses the definitions in
Listing 15-25. This code creates a list in `a` and a list in `b` that points to
the list in `a`. Then it modifies the list in `a` to point to `b`, creating a
reference cycle. There are `println!` statements along the way to show what the
reference counts are at various points in this process.
-->
<p>Dans l'encart 15-26, nous ajoutons une fonction <code>main</code> qui utilise les
définitions de l'encart 15-25. Ce code crée une liste dans <code>a</code> et une liste
dans <code>b</code> qui pointe sur la liste de <code>a</code>. Ensuite, on modifie la liste de <code>a</code>
pour pointer sur <code>b</code>, ce qui crée une boucle de références. Il y a aussi des
instructions <code>println!</code> tout du long pour montrer la valeur des compteurs de
références à différents endroits du processus.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# use crate::List::{Cons, Nil};
# use std::cell::RefCell;
# use std::rc::Rc;
# 
# #[derive(Debug)]
# enum List {
#     Cons(i32, RefCell<Rc<List>>),
#     Nil,
# }
# 
# impl List {
#     fn tail(&self) -> Option<&RefCell<Rc<List>>> {
#         match self {
#             Cons(_, item) => Some(item),
#             Nil => None,
#         }
#     }
# }
# 
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&a));
    println!("b initial rc count = {}", Rc::strong_count(&b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&b));
    println!("a rc count after changing a = {}", Rc::strong_count(&a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!("a next item = {:?}", a.tail());
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn parcourir(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;compteur initial de a = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;prochain élément de a = {:?}&quot;, a.parcourir());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;compteur de a après création de b = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;compteur initial de b = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;prochain élément de b = {:?}&quot;, b.parcourir());

    if let Some(lien) = a.parcourir() {
        *lien.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;compteur de b après avoir changé a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;compteur de a après avoir changé a = {}&quot;, Rc::strong_count(&amp;a));

    // Décommentez la ligne suivante pour constater que nous sommes dans
    // une boucle de références, cela fera déborder la pile
    // println!(&quot;prochain élément de a = {:?}&quot;, a.parcourir());
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-26: Creating a reference cycle of two `List`
values pointing to each other</span>
-->
<p><span class="caption">Encart 15-26 : création d'une boucle de références de
deux valeurs <code>List</code> qui se pointent mutuellement dessus</span></p>
<!--
We create an `Rc<List>` instance holding a `List` value in the variable `a`
with an initial list of `5, Nil`. We then create an `Rc<List>` instance
holding another `List` value in the variable `b` that contains the value 10 and
points to the list in `a`.
-->
<p>Nous créons une instance <code>Rc&lt;List&gt;</code> qui stocke une valeur <code>List</code> dans la
variable <code>a</code> avec une valeur initiale de <code>5, Nil</code>. Nous créons ensuite une
instance <code>Rc&lt;List&gt;</code> qui stocke une autre valeur <code>List</code> dans la variable <code>b</code>
qui contient la valeur 10 et pointe vers la liste dans <code>a</code>.</p>
<!--
We modify `a` so it points to `b` instead of `Nil`, creating a cycle. We
do that by using the `tail` method to get a reference to the
`RefCell<Rc<List>>` in `a`, which we put in the variable `link`. Then we use
the `borrow_mut` method on the `RefCell<Rc<List>>` to change the value inside
from an `Rc<List>` that holds a `Nil` value to the `Rc<List>` in `b`.
-->
<p>Nous modifions <code>a</code> afin qu'elle pointe sur <code>b</code> au lieu de <code>Nil</code>, ce qui crée
une boucle. Nous faisons ceci en utilisant la méthode <code>parcourir</code> pour obtenir
une référence au <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> présent dans <code>a</code>, que nous plaçons dans la
variable <code>link</code>. Ensuite nous utilisons la méthode <code>borrow_mut</code> sur le
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code> pour changer la valeur présente en son sein par une
<code>Rc&lt;List&gt;</code> qui stocke une valeur <code>Nil</code> vers le <code>Rc&lt;List&gt;</code> présent dans <code>b</code>.</p>
<!--
When we run this code, keeping the last `println!` commented out for the
moment, we’ll get this output:
-->
<p>Lorsque nous exécutons ce code, en gardant le dernier <code>println!</code> commenté
pour le moment, nous obtenons ceci :</p>
<!--
```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
```
-->
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
compteur initial de a = 1
prochain élément de a = Some(RefCell { value: Nil })
compteur de a après création de b = 2
compteur initial de b = 1
prochain élément de b = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
compteur de b après avoir changé a = 2
compteur de a après avoir changé a = 2
</code></pre>
<!--
The reference count of the `Rc<List>` instances in both `a` and `b` are 2
after we change the list in `a` to point to `b`. At the end of `main`, Rust
will try to drop `b` first, which will decrease the count of the `Rc<List>`
instance in `b` by 1.
-->
<p>Les compteurs de références des instances de <code>Rc&lt;List&gt;</code> valent tous les deux 2
pour <code>a</code> et <code>b</code> après avoir modifié <code>a</code> pour qu'elle pointe sur <code>b</code>. A la fin
du <code>main</code>, Rust va nettoyer d'abord <code>b</code>, ce qui va réduire le compteur de
l'instance <code>Rc&lt;List&gt;</code> de <code>b</code> de 1.</p>
<!--
However, because `a` is still referencing the `Rc<List>` that was in `b`, that
`Rc<List>` has a count of 1 rather than 0, so the memory the `Rc<List>` has on
the heap won’t be dropped. The memory will just sit there with a count of 1,
forever. To visualize this reference cycle, we’ve created a diagram in Figure
15-4.
-->
<p>Cependant, comme <code>a</code> pointe toujours sur le <code>Rc&lt;List&gt;</code> qui était sur <code>b</code>, le
compteur de son <code>Rc&lt;List&gt;</code> vaudra toujours 1 au lieu de 0, donc la mémoire de
sur le tas de ce <code>Rc&lt;List&gt;</code> ne sera pas nettoyé. La mémoire va juste rester ici
avec un compteur à 1, pour toujours. Pour représenter la boucle de références,
nous avons créé un diagramme dans l'illustration 15-4.</p>
<!--
<img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" />
-->
<p><img
    alt="Une boucle de références de listes"
    src="img/trpl15-04.svg"
    class="center" /></p>
<!--
<span class="caption">Figure 15-4: A reference cycle of lists `a` and `b`
pointing to each other</span>
-->
<p><span class="caption">Illustration 15-4 : une boucle de références entre les
listes <code>a</code> et <code>b</code> qui se pointent mutuellement dessus</span></p>
<!--
If you uncomment the last `println!` and run the program, Rust will try to
print this cycle with `a` pointing to `b` pointing to `a` and so forth until it
overflows the stack.
-->
<p>Si vous décommentez le dernier <code>println!</code> et que vous exécutez le programme,
Rust va essayer d'afficher cette boucle avec <code>a</code> qui pointe sur <code>b</code> qui pointe
sur <code>a</code> ... et ainsi de suite jusqu'à ce que cela fasse déborder la pile.</p>
<!--
In this case, right after we create the reference cycle, the program ends. The
consequences of this cycle aren’t very dire. However, if a more complex program
allocated lots of memory in a cycle and held onto it for a long time, the
program would use more memory than it needed and might overwhelm the system,
causing it to run out of available memory.
-->
<p>Dans ce cas, juste après que nous ayons créé la boucle de références, le
programme se termine. Les conséquences de cette boucle ne sont désastreuses.
Cependant, si un programme plus complexe alloue beaucoup de mémoire dans une
boucle de références et la garde pendant longtemps, le programme va utiliser
bien plus de mémoire qu'il a besoin et pourrait surcharger le système, qui
devrait épuiser la mémoire disponible.</p>
<!--
Creating reference cycles is not easily done, but it’s not impossible either.
If you have `RefCell<T>` values that contain `Rc<T>` values or similar nested
combinations of types with interior mutability and reference counting, you must
ensure that you don’t create cycles; you can’t rely on Rust to catch them.
Creating a reference cycle would be a logic bug in your program that you should
use automated tests, code reviews, and other software development practices to
minimize.
-->
<p>La création de boucles de références n'est pas facile à réaliser, mais n'est pas
non plus impossible. Si vous avez des valeurs <code>RefCell&lt;T&gt;</code> qui contiennent des
valeurs <code>Rc&lt;T&gt;</code> ou combinaisons similaires de types emboîtées avec de la
mutabilité interne et du comptage de références, vous devez vous assurer que
vous ne créez pas de boucles ; vous ne pouvez pas compter sur Rust pour les
détecter. La création de boucle de références devrait être un bogue de logique
de votre programme dont vous devriez réduire le risque en pratiquant des tests
automatisés, des revues de code, ainsi que d'autres pratiques de développement.</p>
<!--
Another solution for avoiding reference cycles is reorganizing your data
structures so that some references express ownership and some references don’t.
As a result, you can have cycles made up of some ownership relationships and
some non-ownership relationships, and only the ownership relationships affect
whether or not a value can be dropped. In Listing 15-25, we always want `Cons`
variants to own their list, so reorganizing the data structure isn’t possible.
Let’s look at an example using graphs made up of parent nodes and child nodes
to see when non-ownership relationships are an appropriate way to prevent
reference cycles.
-->
<p>Une autre solution pour éviter les boucles de références est de réorganiser vos
structures de données afin que certaines références prennent possession et
d'autres non. Par conséquent, vous pouvez obtenir des boucles de certaines
références qui prennent possession ou d'autres références qui ne prennent pas
possession, et seules celles qui prennent possession décident si oui ou non une
valeur peut être libérée. Dans l'encart 15-25, nous voulons toujours que les
variantes <code>Cons</code> possèdent leur propre liste, donc il est impossible de
réorganiser la structure des données. Voyons maintenant un exemple qui utilise
des branches constituées de nœuds parents et enfants pour voir lorsque les
liens qui ne prennent pas possession sont appropriés pour éviter les boucles de
références.</p>
<!--
### Preventing Reference Cycles: Turning an `Rc<T>` into a `Weak<T>`
-->
<h3 id="eviter-les-boucles-de-références--transformer-un-rct-en-weakt"><a class="header" href="#eviter-les-boucles-de-références--transformer-un-rct-en-weakt">Eviter les boucles de références : transformer un <code>Rc&lt;T&gt;</code> en <code>Weak&lt;T&gt;</code></a></h3>
<!--
So far, we’ve demonstrated that calling `Rc::clone` increases the
`strong_count` of an `Rc<T>` instance, and an `Rc<T>` instance is only cleaned
up if its `strong_count` is 0. You can also create a *weak reference* to the
value within an `Rc<T>` instance by calling `Rc::downgrade` and passing a
reference to the `Rc<T>`. When you call `Rc::downgrade`, you get a smart
pointer of type `Weak<T>`. Instead of increasing the `strong_count` in the
`Rc<T>` instance by 1, calling `Rc::downgrade` increases the `weak_count` by 1.
The `Rc<T>` type uses `weak_count` to keep track of how many `Weak<T>`
references exist, similar to `strong_count`. The difference is the `weak_count`
doesn’t need to be 0 for the `Rc<T>` instance to be cleaned up.
-->
<p>Précédemment, nous avons démontré que l'appel à <code>Rc::clone</code> augmente le
<code>strong_count</code> d'une instance de <code>Rc&lt;T&gt;</code>, et une instance <code>Rc&lt;T&gt;</code> est nettoyée
seulement si son <code>strong_count</code> est à 0. Vous pouvez aussi créer un <em>pointeur
faible</em> (NdT : d'où le <code>weak</code>) vers la valeur présente dans une instance <code>Rc&lt;T&gt;</code>
en appelant <code>Rc::downgrade</code> et en lui passant une référence vers le <code>Rc&lt;T&gt;</code>.
Lorsque vous faites appel à <code>Rc::downgrade</code>, vous obtenez un pointeur
intelligent du type <code>Weak&lt;T&gt;</code>. Plutôt que d'augmenter le <code>strong_count</code> de
l'instance de 1, l'appel à <code>Rc::downgrade</code> augmente le <code>weak_count</code> de 1. Le
type <code>Rc&lt;T&gt;</code> utilise le <code>weak_count</code> pour compter combien de références
<code>Weak&lt;T&gt;</code> existent, de la même manière que <code>strong_count</code>. La différence réside
dans le fait que <code>weak_count</code> n'a pas besoin d'être 0 pour que l'instance
<code>Rc&lt;T&gt;</code> soit nettoyée.</p>
<!--
Strong references are how you can share ownership of an `Rc<T>` instance. Weak
references don’t express an ownership relationship. They won’t cause a
reference cycle because any cycle involving some weak references will be broken
once the strong reference count of values involved is 0.
-->
<p>Les références fortes désignent la manière de partager la propriété d'une
instance <code>Rc&lt;T&gt;</code>. Les pointeurs faibles ne désignent pas le lien qui prend
possession. Ils ne vont provoquer de boucle de références car n'importe quelle
boucle qui implique des pointeurs faibles se terminera lorsque le compteur de
références fortes lié vaudra 0.</p>
<!--
Because the value that `Weak<T>` references might have been dropped, to do
anything with the value that a `Weak<T>` is pointing to, you must make sure the
value still exists. Do this by calling the `upgrade` method on a `Weak<T>`
instance, which will return an `Option<Rc<T>>`. You’ll get a result of `Some`
if the `Rc<T>` value has not been dropped yet and a result of `None` if the
`Rc<T>` value has been dropped. Because `upgrade` returns an `Option<Rc<T>>`,
Rust will ensure that the `Some` case and the `None` case are handled, and
there won’t be an invalid pointer.
-->
<p>Comme la valeur contenue dans une référence <code>Weak&lt;T&gt;</code> peut être libérée, pour
pouvoir faire quelque chose avec cette valeur, vous devez vous assurer qu'elle
existe toujours. Vous pouvez faire ceci en appelant la méthode <code>upgrade</code> sur
une instance <code>Weak&lt;T&gt;</code>, qui va retourner une <code>Option&lt;Rc&lt;T&gt;&gt;</code>. Ce résultat
retournera <code>Some</code> si la valeur <code>Rc&lt;T&gt;</code> n'a pas encore été libérée, et un <code>None</code>
si la valeur <code>Rc&lt;T&gt;</code> a été libérée. Comme <code>upgrade</code> retourne une
<code>Option&lt;Rc&lt;T&gt;&gt;</code>, Rust va s'assurer que les cas de <code>Some</code> et de <code>None</code> sont bien
gérés, et qu'il n'existe pas de pointeur invalide.</p>
<!--
As an example, rather than using a list whose items know only about the next
item, we’ll create a tree whose items know about their children items *and*
their parent items.
-->
<p>Par exemple, plutôt que d'utiliser une liste dont les éléments ne connaissent
que les éléments suivants, nous allons créer un arbre dont les éléments
connaissent les éléments enfants <em>et</em> leurs éléments parents.</p>
<!--
#### Creating a Tree Data Structure: a `Node` with Child Nodes
-->
<h4 id="créer-une-structure-darbre-de-données--un-noeud-avec-des-nœuds-enfants"><a class="header" href="#créer-une-structure-darbre-de-données--un-noeud-avec-des-nœuds-enfants">Créer une structure d'arbre de données : un <code>Noeud</code> avec des nœuds enfants</a></h4>
<!--
To start, we’ll build a tree with nodes that know about their child nodes.
We’ll create a struct named `Node` that holds its own `i32` value as well as
references to its children `Node` values:
-->
<p>Pour commencer, nous allons créer un arbre avec des nœuds qui connaissent
leurs nœuds enfants. Nous allons créer une structure <code>Noeud</code> qui contient sa
propre valeur ainsi que les références vers ses <code>Noeud</code> enfants :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}
# 
# fn main() {
#     let leaf = Rc::new(Node {
#         value: 3,
#         children: RefCell::new(vec![]),
#     });
# 
#     let branch = Rc::new(Node {
#         value: 5,
#         children: RefCell::new(vec![Rc::clone(&leaf)]),
#     });
# }
```
-->
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Noeud {
    valeur: i32,
    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let feuille = Rc::new(Noeud {
</span><span class="boring">        valeur: 3,
</span><span class="boring">        enfants: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branche = Rc::new(Noeud {
</span><span class="boring">        valeur: 5,
</span><span class="boring">        enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
</span><span class="boring">    });
</span><span class="boring">}
</span></code></pre></pre>
<!--
We want a `Node` to own its children, and we want to share that ownership with
variables so we can access each `Node` in the tree directly. To do this, we
define the `Vec<T>` items to be values of type `Rc<Node>`. We also want to
modify which nodes are children of another node, so we have a `RefCell<T>` in
`children` around the `Vec<Rc<Node>>`.
-->
<p>Nous souhaitons qu'un <code>Noeud</code> prenne possession de ses enfants, et nous
souhaitons partager la possession avec des variables afin d'accéder directement
à chaque <code>Noeud</code> de l'arbre. Pour pouvoir faire ceci, nous définissons les
éléments du <code>Vec&lt;T&gt;</code> pour être des valeurs du type <code>Rc&lt;Noeud&gt;</code>. Nous souhaitons
également modifier tel nœud est enfant de tel autre nœud, donc nous plaçons
un <code>RefCell&lt;T&gt;</code> dans <code>enfants</code> qui contient ce <code>Vec&lt;Rc&lt;Noeud&gt;&gt;</code>.</p>
<!--
Next, we’ll use our struct definition and create one `Node` instance named
`leaf` with the value 3 and no children, and another instance named `branch`
with the value 5 and `leaf` as one of its children, as shown in Listing 15-27:
-->
<p>Ensuite, nous allons utiliser notre définition de structure et créer une
instance de <code>Noeud</code> qui s'appellera <code>feuille</code> avec la valeur <code>3</code> et sans
enfant, comme dans l'encart 15-27 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Filename : src/main.rs</span></p>
<!--
```rust
# use std::cell::RefCell;
# use std::rc::Rc;
# 
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     children: RefCell<Vec<Rc<Node>>>,
# }
# 
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Noeud {
</span><span class="boring">    valeur: i32,
</span><span class="boring">    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let feuille = Rc::new(Noeud {
        valeur: 3,
        enfants: RefCell::new(vec![]),
    });

    let branche = Rc::new(Noeud {
        valeur: 5,
        enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
    });
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-27: Creating a `leaf` node with no children
and a `branch` node with `leaf` as one of its children</span>
-->
<p><span class="caption">Encart 15-27 : création d'un nœud <code>feuille</code> sans aucun
enfant et un nœud <code>branche</code> avec <code>feuille</code> comme enfant</span></p>
<!--
We clone the `Rc<Node>` in `leaf` and store that in `branch`, meaning the
`Node` in `leaf` now has two owners: `leaf` and `branch`. We can get from
`branch` to `leaf` through `branch.children`, but there’s no way to get from
`leaf` to `branch`. The reason is that `leaf` has no reference to `branch` and
doesn’t know they’re related. We want `leaf` to know that `branch` is its
parent. We’ll do that next.
-->
<p>Nous créons un clone du <code>Rc&lt;Noeud&gt;</code> dans <code>feuille</code> et nous le stockons dans
<code>branche</code>, ce qui signifie que le <code>Noeud</code> dans <code>feuille</code> a maintenant deux
propriétaires : <code>feuille</code> et <code>branche</code>. Nous pouvons obtenir <code>feuille</code> à partir
de <code>branche</code> en utilisant <code>branche.feuille</code>, mais il n'y a pas de moyen
d'obtenir <code>branche</code> à partir de <code>feuille</code>. La raison est que <code>feuille</code> n'a pas
de référence vers <code>branche</code> et ne sait pas s'ils sont liés. Nous voulons que
<code>feuille</code> sache quelle <code>branche</code> est son parent. C'est ce que nous allons faire
dès maintenant.</p>
<!--
#### Adding a Reference from a Child to Its Parent
-->
<h4 id="ajouter-une-référence-à-un-enfant-vers-son-parent"><a class="header" href="#ajouter-une-référence-à-un-enfant-vers-son-parent">Ajouter une référence à un enfant vers son parent</a></h4>
<!--
To make the child node aware of its parent, we need to add a `parent` field to
our `Node` struct definition. The trouble is in deciding what the type of
`parent` should be. We know it can’t contain an `Rc<T>`, because that would
create a reference cycle with `leaf.parent` pointing to `branch` and
`branch.children` pointing to `leaf`, which would cause their `strong_count`
values to never be 0.
-->
<p>Pour que le nœud enfant connaisse son parent, nous devons ajouter un champ
<code>parent</code> vers notre définition de structure <code>Noeud</code>. La difficulté ici est de
choisir quel sera le type de <code>parent</code>. Nous savons qu'il ne peut pas contenir
de <code>Rc&lt;T&gt;</code>, car cela créera une boucle de référence avec <code>feuille.parent</code> qui
pointe sur <code>branche</code> et <code>branche.enfant</code> qui pointe sur <code>feuille</code>, ce qui va
faire que leurs valeurs <code>strong_count</code> ne sera jamais à 0.</p>
<!--
Thinking about the relationships another way, a parent node should own its
children: if a parent node is dropped, its child nodes should be dropped as
well. However, a child should not own its parent: if we drop a child node, the
parent should still exist. This is a case for weak references!
-->
<p>En concevant le lien d'une autre manière, un nœud parent devrait prendre
possession de ses enfants : si un nœud parent est libéré, ses nœuds enfants
devraient aussi être libérés. Cependant, un enfant ne devrait pas prendre
possession de son parent : si nous libérons un nœud enfant, le parent doit
toujours exister. C'est donc un cas d'emploi pour les pointeurs faibles !</p>
<!--
So instead of `Rc<T>`, we’ll make the type of `parent` use `Weak<T>`,
specifically a `RefCell<Weak<Node>>`. Now our `Node` struct definition looks
like this:
-->
<p>Donc, plutôt qu'un <code>Rc&lt;T&gt;</code>, nous allons faire en sorte que le type de <code>parent</code>
soit un <code>Weak&lt;T&gt;</code>, plus précisément un <code>RefCell&lt;Weak&lt;Noeud&gt;&gt;</code>. Maintenant,
la définition de notre structure <code>Noeud</code> devrait ressembler à ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}
# 
# fn main() {
#     let leaf = Rc::new(Node {
#         value: 3,
#         parent: RefCell::new(Weak::new()),
#         children: RefCell::new(vec![]),
#     });
# 
#     println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
# 
#     let branch = Rc::new(Node {
#         value: 5,
#         parent: RefCell::new(Weak::new()),
#         children: RefCell::new(vec![Rc::clone(&leaf)]),
#     });
# 
#     *leaf.parent.borrow_mut() = Rc::downgrade(&branch);
# 
#     println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
# }
```
-->
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Noeud {
    valeur: i32,
    parent: RefCell&lt;Weak&lt;Noeud&gt;&gt;,
    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let feuille = Rc::new(Noeud {
</span><span class="boring">        valeur: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        enfants: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branche = Rc::new(Noeud {
</span><span class="boring">        valeur: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *feuille.parent.borrow_mut() = Rc::downgrade(&amp;branche);
</span><span class="boring">
</span><span class="boring">    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());
</span><span class="boring">}
</span></code></pre></pre>
<!--
A node will be able to refer to its parent node but doesn’t own its parent.
In Listing 15-28, we update `main` to use this new definition so the `leaf`
node will have a way to refer to its parent, `branch`:
-->
<p>Un nœud devrait pouvoir avoir une référence vers son nœud parent, mais il ne
devrait pas prendre possession de son parent. Dans l'encart 15-28, nous mettons
à jour cette nouvelle définition pour que le nœud <code>feuille</code> puisse avoir un
moyen de pointer vers son parent, <code>branche</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# use std::cell::RefCell;
# use std::rc::{Rc, Weak};
# 
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     parent: RefCell<Weak<Node>>,
#     children: RefCell<Vec<Rc<Node>>>,
# }
# 
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Noeud {
</span><span class="boring">    valeur: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Noeud&gt;&gt;,
</span><span class="boring">    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let feuille = Rc::new(Noeud {
        valeur: 3,
        parent: RefCell::new(Weak::new()),
        enfants: RefCell::new(vec![]),
    });

    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());

    let branche = Rc::new(Noeud {
        valeur: 5,
        parent: RefCell::new(Weak::new()),
        enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
    });

    *feuille.parent.borrow_mut() = Rc::downgrade(&amp;branche);

    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-28: A `leaf` node with a weak reference to its
parent node `branch`</span>
-->
<p><span class="caption">Encart 15-28 : un nœud <code>feuille</code> avec un pointeur faible
vers son nœud parent, <code>branche</code></span></p>
<!--
Creating the `leaf` node looks similar to how creating the `leaf` node looked
in Listing 15-27 with the exception of the `parent` field: `leaf` starts out
without a parent, so we create a new, empty `Weak<Node>` reference instance.
-->
<p>La création du nœud <code>feuille</code> semble être identique à la création du nœud
<code>feuille</code> de l'encart 15-27, sauf pour le champ <code>parent</code> : <code>feuille</code> commence
sans parent, donc nous créons une nouvelle instance de référence de type
<code>Weak&lt;Noeud&gt;</code>, qui est vide.</p>
<!--
At this point, when we try to get a reference to the parent of `leaf` by using
the `upgrade` method, we get a `None` value. We see this in the output from the
first `println!` statement:
-->
<p>A ce moment-là, lorsque nous essayons d'obtenir une référence vers le parent de
<code>feuille</code> en utilisant la méthode <code>upgrade</code>, nous obtenons une valeur <code>None</code>.
Nous constatons cela dans la première instruction <code>println!</code> sur la sortie :</p>
<!--
```text
leaf parent = None
```
-->
<pre><code class="language-text">parent de la feuille = None
</code></pre>
<!--
When we create the `branch` node, it will also have a new `Weak<Node>`
reference in the `parent` field, because `branch` doesn’t have a parent node.
We still have `leaf` as one of the children of `branch`. Once we have the
`Node` instance in `branch`, we can modify `leaf` to give it a `Weak<Node>`
reference to its parent. We use the `borrow_mut` method on the
`RefCell<Weak<Node>>` in the `parent` field of `leaf`, and then we use the
`Rc::downgrade` function to create a `Weak<Node>` reference to `branch` from
the `Rc<Node>` in `branch.`
-->
<p>Lorsque nous créons le nœud <code>branche</code>, il va aussi avoir une nouvelle
référence <code>Weak&lt;Noeud&gt;</code> dans le champ <code>parent</code>, car <code>branche</code> n'a pas de nœud
parent. Nous avons néanmoins <code>feuille</code> dans <code>enfants</code> de <code>branche</code>. Une fois
que nous avons l'instance de <code>Noeud</code> dans <code>branche</code>, nous pouvons modifier
<code>feuille</code> pour lui donner une référence <code>Weak&lt;Noeud&gt;</code> vers son parent. Nous
utilisons la méthode <code>borrow_mut</code> sur la <code>RefCell&lt;Weak&lt;Noeud&gt;&gt;</code> du champ
<code>parent</code> de <code>feuille</code>, et ensuite nous utilisons la fonction <code>Rc::downgrade</code>
pour créer une référence de type <code>Weak&lt;Node&gt;</code> vers <code>branche</code> à partir du
<code>Rc&lt;Noeud&gt;</code> présent dans <code>branche</code>.</p>
<!--
When we print the parent of `leaf` again, this time we’ll get a `Some` variant
holding `branch`: now `leaf` can access its parent! When we print `leaf`, we
also avoid the cycle that eventually ended in a stack overflow like we had in
Listing 15-26; the `Weak<Node>` references are printed as `(Weak)`:
-->
<p>Lorsque nous affichons à nouveau le parent de <code>feuille</code>, cette fois nous
obtenons la variante <code>Some</code> qui contient <code>branche</code> : désormais, <code>feuille</code> peut
accéder à son parent ! Lorsque nous affichons <code>feuille</code>, nous avons aussi évité
la boucle qui aurait probablement fini en débordement de pile comme nous
l'avions expérimenté dans l'encart 15-26 ; les références <code>Weak&lt;Noeud&gt;</code>
s'écrivent <code>(Weak)</code> :</p>
<!--
```text
leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
```
-->
<pre><code class="language-text">parent de la feuille = Some(Noeud { valeur: 5, parent: RefCell { value: (Weak) },
enfants: RefCell { value: [Noeud { valeur: 3, parent: RefCell { value: (Weak) },
enfants: RefCell { value: [] } }] } })
</code></pre>
<!--
The lack of infinite output indicates that this code didn’t create a reference
cycle. We can also tell this by looking at the values we get from calling
`Rc::strong_count` and `Rc::weak_count`.
-->
<p>L'absence d'une sortie infinie nous confirme que ce code ne crée pas de boucle
de références. Nous pouvons aussi le constater en affichant les valeurs que
nous pouvons obtenir en faisant appel à <code>Rc::strong_count</code> et <code>Rc::weak_count</code>.</p>
<!--
#### Visualizing Changes to `strong_count` and `weak_count`
-->
<h4 id="visualiser-les-modifications-de-strong_count-et-weak_count"><a class="header" href="#visualiser-les-modifications-de-strong_count-et-weak_count">Visualiser les modifications de <code>strong_count</code> et <code>weak_count</code></a></h4>
<!--
Let’s look at how the `strong_count` and `weak_count` values of the `Rc<Node>`
instances change by creating a new inner scope and moving the creation of
`branch` into that scope. By doing so, we can see what happens when `branch` is
created and then dropped when it goes out of scope. The modifications are shown
in Listing 15-29:
-->
<p>Regardons comment changent les valeurs <code>strong_count</code> et <code>weak_count</code> des
instances de <code>Rc&lt;Noeud&gt;</code> en créant une portée interne et en déplaçant la
création de <code>branche</code> dans cette portée. En faisant ceci, nous pourrons
constater ce qui se passe lorsque <code>branche</code> est créée et lorsqu'elle sera
libérée lorsqu'elle sortira de la portée. Ces modifications sont présentées
dans l'encart 15-29 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# use std::cell::RefCell;
# use std::rc::{Rc, Weak};
# 
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     parent: RefCell<Weak<Node>>,
#     children: RefCell<Vec<Rc<Node>>>,
# }
# 
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&branch),
            Rc::weak_count(&branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&leaf),
            Rc::weak_count(&leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Noeud {
</span><span class="boring">    valeur: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Noeud&gt;&gt;,
</span><span class="boring">    enfants: RefCell&lt;Vec&lt;Rc&lt;Noeud&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let feuille = Rc::new(Noeud {
        valeur: 3,
        parent: RefCell::new(Weak::new()),
        enfants: RefCell::new(vec![]),
    });

    println!(
        &quot;feuille strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;feuille),
        Rc::weak_count(&amp;feuille),
    );

    {
        let branche = Rc::new(Noeud {
            valeur: 5,
            parent: RefCell::new(Weak::new()),
            enfants: RefCell::new(vec![Rc::clone(&amp;feuille)]),
        });

        *feuille.parent.borrow_mut() = Rc::downgrade(&amp;branche);

        println!(
            &quot;branche strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branche),
            Rc::weak_count(&amp;branche),
        );

        println!(
            &quot;feuille strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;feuille),
            Rc::weak_count(&amp;feuille),
        );
    }

    println!(&quot;parent de la feuille = {:?}&quot;, feuille.parent.borrow().upgrade());
    println!(
        &quot;feuille strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;feuille),
        Rc::weak_count(&amp;feuille),
    );
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-29: Creating `branch` in an inner scope and
examining strong and weak reference counts</span>
-->
<p><span class="caption">Encart 15-29 : création de <code>branche</code> dans une portée
interne et vérification des compteurs de références strong et weak</span></p>
<!--
After `leaf` is created, its `Rc<Node>` has a strong count of 1 and a weak
count of 0. In the inner scope, we create `branch` and associate it with
`leaf`, at which point when we print the counts, the `Rc<Node>` in `branch`
will have a strong count of 1 and a weak count of 1 (for `leaf.parent` pointing
to `branch` with a `Weak<Node>`). When we print the counts in `leaf`, we’ll see
it will have a strong count of 2, because `branch` now has a clone of the
`Rc<Node>` of `leaf` stored in `branch.children`, but will still have a weak
count of 0.
-->
<p>Après la création de <code>feuille</code>, son <code>Rc&lt;Noeud&gt;</code> a le compteur strong à 1 et le
compteur weak à 0. Dans la portée interne, nous créons <code>branche</code> et l'associons
à <code>feuille</code>, et à partir de là, lorsque nous affichons les compteurs, le
<code>Rc&lt;Noeud&gt;</code> dans <code>branche</code> aura le compteur strong à 1 et le compteur weak à 1
(pour que <code>feuille.parent</code> pointe sur <code>branche</code> avec un <code>Weak&lt;Noeud&gt;</code>). Lorsque
nous affichons les compteurs dans <code>feuille</code> nous constatons qu'il a le compteur
strong à 2, car <code>branche</code> a maintenant un clone du <code>Rc&lt;Noeud&gt;</code> de <code>feuille</code>
stocké dans <code>branche.enfants</code>, mais a toujours le compteur weak à 0.</p>
<!--
When the inner scope ends, `branch` goes out of scope and the strong count of
the `Rc<Node>` decreases to 0, so its `Node` is dropped. The weak count of 1
from `leaf.parent` has no bearing on whether or not `Node` is dropped, so we
don’t get any memory leaks!
-->
<p>Lorsque la portée interne se termine, <code>branche</code> sort de la portée et le
compteur strong de <code>Rc&lt;Noeud&gt;</code> décroît à 0, donc son <code>Noeud</code> est libéré. Le
compteur weak à 1 de <code>feuille.parent</code> n'a aucune répercussion suite à la
libération ou non du <code>Noeud</code>, donc nous ne sommes pas dans une situation de
fuite de mémoire !</p>
<!--
If we try to access the parent of `leaf` after the end of the scope, we’ll get
`None` again. At the end of the program, the `Rc<Node>` in `leaf` has a strong
count of 1 and a weak count of 0, because the variable `leaf` is now the only
reference to the `Rc<Node>` again.
-->
<p>Si nous essayons d'accéder au parent de <code>feuille</code> après la fin de la portée,
nous allons à nouveau obtenir <code>None</code>. A la fin du programme, le <code>Rc&lt;Noeud&gt;</code>
dans <code>feuille</code> a son compteur strong à 1 et son compteur weak à 0, car la
variable <code>feuille</code> est à nouveau la seule référence au <code>Rc&lt;Noeud&gt;</code>.</p>
<!--
All of the logic that manages the counts and value dropping is built into
`Rc<T>` and `Weak<T>` and their implementations of the `Drop` trait. By
specifying that the relationship from a child to its parent should be a
`Weak<T>` reference in the definition of `Node`, you’re able to have parent
nodes point to child nodes and vice versa without creating a reference cycle
and memory leaks.
-->
<p>Toute cette logique qui gère les compteurs et les libérations des valeurs est
intégrée dans <code>Rc&lt;T&gt;</code> et <code>Weak&lt;T&gt;</code> et leurs implémentations du trait <code>Drop</code>. En
précisant dans la définition de <code>Noeud</code> que le lien entre un enfant et son
parent doit être une référence <code>Weak&lt;T&gt;</code>, vous pouvez avoir des nœuds parents
qui pointent sur des nœuds enfants et vice versa sans risquer de créer des
boucles de références et des fuites de mémoire.</p>
<!--
## Summary
-->
<h2 id="résumé-14"><a class="header" href="#résumé-14">Résumé</a></h2>
<!--
This chapter covered how to use smart pointers to make different guarantees and
trade-offs from those Rust makes by default with regular references. The
`Box<T>` type has a known size and points to data allocated on the heap. The
`Rc<T>` type keeps track of the number of references to data on the heap so
that data can have multiple owners. The `RefCell<T>` type with its interior
mutability gives us a type that we can use when we need an immutable type but
need to change an inner value of that type; it also enforces the borrowing
rules at runtime instead of at compile time.
-->
<p>Ce chapitre a expliqué l'utilisation des pointeurs intelligents pour appliquer
différentes garanties et compromis que celles qu'applique Rust par défaut avec
les références classiques. Le type <code>Box&lt;T&gt;</code> a une taille connue et pointe sur
une donnée allouée sur le tas. Le type <code>Rc&lt;T&gt;</code> compte le nombre de références
vers une donnée présente sur le tas afin que cette donnée puisse avoir
plusieurs propriétaires. Le type <code>RefCell&lt;T&gt;</code> nous permet de l'utiliser lorsque
nous avons besoin d'un type immuable mais que nous avons besoin de changer une
valeur interne à ce type, grâce à sa fonctionnalité de mutabilité interne ;
elle nous permet aussi d'appliquer les règles d'emprunt à l'exécution plutôt
qu'à la compilation.</p>
<!--
Also discussed were the `Deref` and `Drop` traits, which enable a lot of the
functionality of smart pointers. We explored reference cycles that can cause
memory leaks and how to prevent them using `Weak<T>`.
-->
<p>Nous avons aussi vu les traits <code>Deref</code> et <code>Drop</code>, qui offrent des
fonctionnalités très importantes aux pointeurs intelligents. Nous avons
expérimenté les boucles de références qui peuvent causer des fuites de mémoire
et nous avons vu comment les éviter en utilisant <code>Weak&lt;T&gt;</code>.</p>
<!--
If this chapter has piqued your interest and you want to implement your own
smart pointers, check out [“The Rustonomicon”][nomicon] for more useful
information.
-->
<p>Si ce chapitre a éveillé votre curiosité et que vous souhaitez mettre en œuvre
vos propres pointeurs intelligents, visitez <a href="https://doc.rust-lang.org/nomicon/index.html">“The Rustonomicon”</a> pour
en savoir plus.</p>
<!--
Next, we’ll talk about concurrency in Rust. You’ll even learn about a few new
smart pointers.
-->
<p>Au chapitre suivant, nous allons parler de concurrence en Rust. Vous
découvrirez peut-être même quelques nouveaux pointeurs intelligents ...</p>
<!--
[nomicon]: ../nomicon/index.html
-->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--13"><a class="header" href="#-attention-peinture-fraîche--13">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/196">Pull Request</a>.</p>
</blockquote>
<!--
# Fearless Concurrency
-->
<h1 id="la-concurrence-sans-craintes"><a class="header" href="#la-concurrence-sans-craintes">La concurrence sans craintes</a></h1>
<!--
Handling concurrent programming safely and efficiently is another of Rust’s
major goals. *Concurrent programming*, where different parts of a program
execute independently, and *parallel programming*, where different parts of a
program execute at the same time, are becoming increasingly important as more
computers take advantage of their multiple processors. Historically,
programming in these contexts has been difficult and error prone: Rust hopes to
change that.
-->
<p>Le développement sécurisé et efficace dans des contextes de concurrence est un
autre objectif majeur de Rust. La <em>programmation concurrente</em>, dans laquelle
différentes parties d'un programme s'exécutent de manière indépendente, et le
<em>parallélisme</em>, dans lequel différentes parties d'un programme s'exécutent en
même temps, sont devenus des pratiques de plus en plus importantes au fur et à
mesure que les ordinateurs tirent parti de leurs processeurs multiples.
Historiquement, le développement dans ces contextes est difficile et favorise
les erreurs : Rust compte bien changer la donne.</p>
<!--
Initially, the Rust team thought that ensuring memory safety and preventing
concurrency problems were two separate challenges to be solved with different
methods. Over time, the team discovered that the ownership and type systems are
a powerful set of tools to help manage memory safety *and* concurrency
problems! By leveraging ownership and type checking, many concurrency errors
are compile-time errors in Rust rather than runtime errors. Therefore, rather
than making you spend lots of time trying to reproduce the exact circumstances
under which a runtime concurrency bug occurs, incorrect code will refuse to
compile and present an error explaining the problem. As a result, you can fix
your code while you’re working on it rather than potentially after it has been
shipped to production. We’ve nicknamed this aspect of Rust *fearless*
*concurrency*. Fearless concurrency allows you to write code that is free of
subtle bugs and is easy to refactor without introducing new bugs.
-->
<p>Au début, l'équipe de Rust pensait que garantir la sécurité de la mémoire et
éviter les problèmes de concurrence étaient deux challenges distincts qui
devaient être résolus de manière différentes. Avec le temps, l'équipe a
découvert que les systèmes de possession et de type sont des jeux d'outils
puissants qui aident à sécuriser la mémoire <em>et</em> à régler des problèmes de
concurrence ! En exploitant la possession et la vérification de type, de
nombreuses erreurs de concurrence deviennent des erreurs à la compilation en
Rust plutôt que des erreurs à l'exécution. Ainsi, plutôt que d'avoir à passer
beaucoup de votre temps à tenter de reproduire les circonstances exactes dans
lesquelles un bogue de concurrence s'est produit à l'exécution, le code
incorrecte va refuser de se compiler et va vous afficher une erreur expliquant
le problème. Au final, vous pouvez corriger votre code pendant que vous
travaillez dessus plutôt que d'avoir à le faire à posteriori après qu'il ai
potentiellement été livré en production. Nous avons surnommé cet aspect de Rust
la <em>concurrence sans craintes</em>. La concurrence sans craintes vous permet
d'écrire du code dépourvu de bogues subtils et il sera facile de le remanier
sans risquer d'introduire de nouveaux bogues.</p>
<!--
> Note: For simplicity’s sake, we’ll refer to many of the problems as
> *concurrent* rather than being more precise by saying *concurrent and/or
> parallel*. If this book were about concurrency and/or parallelism, we’d be
> more specific. For this chapter, please mentally substitute *concurrent
> and/or parallel* whenever we use *concurrent*.
-->
<blockquote>
<p>Remarque : pour des raisons de simplicité, nous allons désigner la plupart
des problèmes par <em>des problèmes de concurrence</em> plutôt que d'être trop
précis en disant <em>des problèmes de concurrence et/ou de parallélisme</em>. Si ce
livre traitait spécifiquement de concurrence et/ou de parallélisme, nous
serions plus précis. Pour ce chapitre, veuillez garder à l'esprit que nous
parlons de <em>concurrence et/ou de parallélisme</em> à chaque fois que nous
parlerons de <em>concurrence</em>.</p>
</blockquote>
<!--
Many languages are dogmatic about the solutions they offer for handling
concurrent problems. For example, Erlang has elegant functionality for
message-passing concurrency but has only obscure ways to share state between
threads. Supporting only a subset of possible solutions is a reasonable
strategy for higher-level languages, because a higher-level language promises
benefits from giving up some control to gain abstractions. However, lower-level
languages are expected to provide the solution with the best performance in any
given situation and have fewer abstractions over the hardware. Therefore, Rust
offers a variety of tools for modeling problems in whatever way is appropriate
for your situation and requirements.
-->
<p>De nombreux langages sont dogmatiques sur les solutions qu'ils offrent pour
gérer les problèmes de concurrence. Par exemple, Erlang a une fonctionnalité
élégante de passage de messages pour la concurrence mais a une façon étrange
de partager un état entre les tâches. Ne proposer qu'un sous-ensemble de
solutions possibles est une stratégie acceptable pour les langages de haut
niveau, car un langage de haut niveau offre des avantages en sacrifiant
certains contrôles pour être plus accessibles. Cependant, les langages de bas
niveau sont censés fournir la solution la plus performante dans n'importe
quelle situation donnée et proposer moins de facilités sur le matériel.
Cependant, Rust offre une gamme d'outils répondre aux problèmes de toutes les
manières possibles pour vos besoins du moment.</p>
<!--
Here are the topics we’ll cover in this chapter:
-->
<p>Voici les sujets que nous allons aborder dans ce chapitre :</p>
<!--
* How to create threads to run multiple pieces of code at the same time
* *Message-passing* concurrency, where channels send messages between threads
* *Shared-state* concurrency, where multiple threads have access to some piece
  of data
* The `Sync` and `Send` traits, which extend Rust’s concurrency guarantees to
  user-defined types as well as types provided by the standard library
-->
<ul>
<li>Comment créer des tâches pour exécuter plusieurs parties de code en même temps</li>
<li>Le <em>passage de message</em> en concurrence, qui permet à plusieurs tâches
d'accéder à la même donnée</li>
<li>Les traits <code>Sync</code> et <code>Send</code>, qui étendent les garanties de Rust sur la
concurrence autant à des types définis par les utilisateurs que par ceux qui
sont fournis par la bibliothèque standard</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--14"><a class="header" href="#-attention-peinture-fraîche--14">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/197">Pull Request</a>.</p>
</blockquote>
<!--
## Using Threads to Run Code Simultaneously
-->
<h2 id="utiliser-les-tâches-pour-exécuter-simultanément-du-code"><a class="header" href="#utiliser-les-tâches-pour-exécuter-simultanément-du-code">Utiliser les tâches pour exécuter simultanément du code</a></h2>
<!--
In most current operating systems, an executed program’s code is run in a
*process*, and the operating system manages multiple processes at once. Within
your program, you can also have independent parts that run simultaneously. The
features that run these independent parts are called *threads*.
-->
<p>Dans la plupart des systèmes d'exploitation actuels, le code d'un programme
exécuté dans un <em>processus</em>, et le système d'exploitation gère plusieurs
processus à la fois. Dans votre programme, vous pouvez vous aussi avoir des
parties indépendantes qui s'exécutent simultanément. Les éléments qui font
fonctionner ces parties indépendantes sont appelés les <em>tâches</em>.</p>
<!--
Splitting the computation in your program into multiple threads can improve
performance because the program does multiple tasks at the same time, but it
also adds complexity. Because threads can run simultaneously, there’s no
inherent guarantee about the order in which parts of your code on different
threads will run. This can lead to problems, such as:
-->
<p>Le découpage des calculs de votre programme dans plusieurs tâches peut
améliorer sa performance car le programme fait plusieurs choses à la fois, mais
cela rajoute aussi de la complexité. Comme les tâches peuvent s'exécuter de
manière simultanée, il n'y a pas de garantie absolue sur l'ordre d'exécution
de vos différentes parties de votre code. Cela peut poser des problèmes,
comme :</p>
<!--
* Race conditions, where threads are accessing data or resources in an
  inconsistent order
* Deadlocks, where two threads are waiting for each other to finish using a
  resource the other thread has, preventing both threads from continuing
* Bugs that happen only in certain situations and are hard to reproduce and fix
  reliably
-->
<ul>
<li>Les situations de concurrence, durant lesquelles les tâches accèdent à une
donnée ou ressource dans un ordre incohérent</li>
<li>Des interblocages, durant lesquels deux tâches attendent mutuellement que
l'autre finit d'utiliser une ressource que l'autre tâche utilise, bloquant
les deux tâches de progresser</li>
<li>Des bogues qui surgissent uniquement dans certaines situations et qui sont
difficiles à reproduire et corriger durablement</li>
</ul>
<!--
Rust attempts to mitigate the negative effects of using threads, but
programming in a multithreaded context still takes careful thought and requires
a code structure that is different from that in programs running in a single
thread.
-->
<p>Rust cherche à atténuer les effets indésirables de l'utilisation des tâches,
mais le développement dans un contexte multitâches exige toujours une attention
particulière et nécessite une structure de code différente de celle pour des
programmes qui s'exécutent dans une seule tâche.</p>
<!--
Programming languages implement threads in a few different ways. Many operating
systems provide an API for creating new threads. This model where a language
calls the operating system APIs to create threads is sometimes called *1:1*,
meaning one operating system thread per one language thread.
-->
<p>Les langages de programmation implémentent les tâches de différentes manières.
De nombreux systèmes d'exploitation offrent des API pour créer des nouvelles
tâches. L'appel à cet API du système d'exploitation pour créer des tâches par
un langage est parfois qualifié de <em>1:1</em>, ce qui signifie une tâche du système
d'exploitation par tâche dans le langage de programmation.</p>
<!--
Many programming languages provide their own special implementation of threads.
Programming language-provided threads are known as *green* threads, and
languages that use these green threads will execute them in the context of a
different number of operating system threads. For this reason, the
green-threaded model is called the *M:N* model: there are `M` green threads per
`N` operating system threads, where `M` and `N` are not necessarily the same
number.
-->
<p>De nombreux langages de programmation fournissent leur propre implémentation
spéciale des tâches. Les tâches fournies par un langage de programmation
s'appelle une tâche <em>virtuelle</em>, et les langages qui utilisent ces tâches
virtuelles vont les exécuter dans différentes tâches du système d'exploitation.
C'est pourquoi le modèle des tâches virtuelles est appelé modèle <em>M:N</em> : il y a
<code>M</code> tâches virtuelles pour <code>N</code> tâches du système d'exploitation, dans lequel
<code>M</code> et <code>N</code> ne sont pas nécessairement le même nombre.</p>
<!--
Each model has its own advantages and trade-offs, and the trade-off most
important to Rust is runtime support. *Runtime* is a confusing term and can
have different meanings in different contexts.
-->
<p>Chaque modèle a ses propres avantages et compromis, et le compromis le plus
important pour Rust est la prise en charge de l'environnement d'exécution.
<em>Environnement d'exécution</em> est un terme qui peut prêter à confusion et avoir
différentes significations dans différents contextes.</p>
<!--
In this context, by *runtime* we mean code that is included by the language in
every binary. This code can be large or small depending on the language, but
every non-assembly language will have some amount of runtime code. For that
reason, colloquially when people say a language has “no runtime,” they often
mean “small runtime.” Smaller runtimes have fewer features but have the
advantage of resulting in smaller binaries, which make it easier to combine the
language with other languages in more contexts. Although many languages are
okay with increasing the runtime size in exchange for more features, Rust needs
to have nearly no runtime and cannot compromise on being able to call into C to
maintain performance.
-->
<p>Dans ce contexte, lorsque nous parlons <em>d'environnement exécution</em>, nous
entendons le code qui est intégré par le langage dans chaque binaire. Ce code
peut être plus ou moins vaste en fonction du langage, mais chaque langage non
assembleur aura une certaine quantité de code d'environnement exécution. Pour
cette raison, lorsque les gens disent couramment d'un langage n'a pas
“d'environnement d'exécution”, ils entendent très souvent “faible environnement
d'exécution”. Les faibles environnements d'exécution ont moins de
fonctionnalités mais ont l'avantage d'avoir des bibliothèques plus petites, ce
qui facilite la combinaison du langage avec un autre et dans plus de contextes.
Contrairement à de nombreux langages de programmation qui acceptent d'augmenter
la taille de l'environnement d'exécution pour plus de fonctionnalités, Rust a
besoin d'avoir un environnement d'exécution presque inexistant et ne doit pas
faire de compromis sur ses capacités à faire appel au C, afin de conserver ses
performances.</p>
<!--
The green-threading M:N model requires a larger language runtime to manage
threads. As such, the Rust standard library only provides an implementation of
1:1 threading. Because Rust is such a low-level language, there are crates that
implement M:N threading if you would rather trade overhead for aspects such as
more control over which threads run when and lower costs of context switching,
for example.
-->
<p>Le modèle de tâches virtuelles M:N nécessite un plus grand environnement
d'exécution pour gérer les tâches. C'est pourquoi la bibliothèque standard de
Rust fournit seulement une implémentation 1:1. Comme Rust est un langage
bas-niveau, il existe des crates qui implémentent des tâches M:N si vous
préférez compenser des pertes de performances pour plus de maîtrise dans
l'exécution des tâches et moins de conséquences pour les changements de
contextes.</p>
<!--
Now that we’ve defined threads in Rust, let’s explore how to use the
thread-related API provided by the standard library.
-->
<p>Maintenant que nous avons défini ce qu'étaient les tâches en Rust, découvrons
comment utiliser les API liées aux tâches fournies par la bibliothèque
standard.</p>
<!--
### Creating a New Thread with `spawn`
-->
<h3 id="créer-une-nouvelle-tâche-avec-spawn"><a class="header" href="#créer-une-nouvelle-tâche-avec-spawn">Créer une nouvelle tâche avec <code>spawn</code></a></h3>
<!--
To create a new thread, we call the `thread::spawn` function and pass it a
closure (we talked about closures in Chapter 13) containing the code we want to
run in the new thread. The example in Listing 16-1 prints some text from a main
thread and other text from a new thread:
-->
<p>Pour créer une nouvelle tâche, nous appelons la fonction <code>thread::spawn</code> et
nous lui passons une fermeture (nous avons vu les fermetures au chapitre 13)
qui contient le code que nous souhaitons exécuter dans la nouvelle tâche.
L'exemple dans l'encart 16-1 affiche du texte à partir de la tâche principale
et un autre texte à partir d'une nouvelle tâche :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Bonjour n°{} à partir de la nouvelle tâche !&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;Bonjour n°{} à partir de la tâche principale !&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-1: Creating a new thread to print one thing
while the main thread prints something else</span>
-->
<p><span class="caption">Encart 16-1 : création d'une nouvelle tâche pour afficher
une chose pendant que la tâche principale affiche autre chose</span></p>
<!--
Note that with this function, the new thread will be stopped when the main
thread ends, whether or not it has finished running. The output from this
program might be a little different every time, but it will look similar to the
following:
-->
<p>Remarquez d'avec cette fonction, la nouvelle tâche s'arrêtera lorsque la tâche
principale s'arrêtera, qu'elle ai fini ou non de s'exécuter. La sortie de ce
programme peut être différente à chaque fois, mais il devrait ressembler à
ceci :</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
```
-->
<pre><code class="language-text">Bonjour n°1 à partir de la tâche principale !
Bonjour n°1 à partir de la nouvelle tâche !
Bonjour n°2 à partir de la tâche principale !
Bonjour n°2 à partir de la nouvelle tâche !
Bonjour n°3 à partir de la tâche principale !
Bonjour n°3 à partir de la nouvelle tâche !
Bonjour n°4 à partir de la tâche principale !
Bonjour n°4 à partir de la nouvelle tâche !
Bonjour n°5 à partir de la nouvelle tâche !
</code></pre>
<!--
The calls to `thread::sleep` force a thread to stop its execution for a short
duration, allowing a different thread to run. The threads will probably take
turns, but that isn’t guaranteed: it depends on how your operating system
schedules the threads. In this run, the main thread printed first, even though
the print statement from the spawned thread appears first in the code. And even
though we told the spawned thread to print until `i` is 9, it only got to 5
before the main thread shut down.
-->
<p>L'appel à <code>thread::sleep</code> force une tâche à mettre en pause son exécution
pendant une petite durée, permettant à une autre tâche de s'exécuter. Les
tâches se relaieront probablement, mais ce n'est pas garanti : cela dépend de
comment votre système d'exploitation agence les tâches. Lors de cette
exécution, la tâche principale a d'abord écris, même si l'instruction
d'écriture de la nouvelle tâche apparaît en premier dans le code. Et même si
nous avons demandé à la nouvelle tâche d'écrire jusqu'à ce que <code>i</code> vaut <code>9</code>,
elle l'a fait seulement jusqu'à <code>5</code>, avant que la tâche principale s'arrête.</p>
<!--
If you run this code and only see output from the main thread, or don’t see any
overlap, try increasing the numbers in the ranges to create more opportunities
for the operating system to switch between the threads.
-->
<p>Si vous exécutez ce code et que vous ne voyez que du texte provenant de la
tâche principale, ou que vous ne voyez aucun chevauchement, essayez d'augmenter
les nombres dans les intervalles pour donner plus d'opportunités au système
d'exploitation pour basculer entre les tâches.</p>
<!--
### Waiting for All Threads to Finish Using `join` Handles
-->
<h3 id="attendre-que-toutes-les-tâches-aient-fini-en-utilisant-join"><a class="header" href="#attendre-que-toutes-les-tâches-aient-fini-en-utilisant-join">Attendre que toutes les tâches aient fini en utilisant <code>join</code></a></h3>
<!--
The code in Listing 16-1 not only stops the spawned thread prematurely most of
the time due to the main thread ending, but also can’t guarantee that the
spawned thread will get to run at all. The reason is that there is no guarantee
on the order in which threads run!
-->
<p>Le code dans l'encart 16-1 non seulement stoppe la nouvelle tâche prématurément
la plupart du temps à cause de la fin de la tâche principale, mais elle ne
garantit pas non plus que la nouvelle tâche va s'exécuter une seule fois. La
raison à cela est qu'il n'y a pas de garantie sur l'ordre dans lequel les
tâches vont s'exécuter !</p>
<!--
We can fix the problem of the spawned thread not getting to run, or not getting
to run completely, by saving the return value of `thread::spawn` in a variable.
The return type of `thread::spawn` is `JoinHandle`. A `JoinHandle` is an owned
value that, when we call the `join` method on it, will wait for its thread to
finish. Listing 16-2 shows how to use the `JoinHandle` of the thread we created
in Listing 16-1 and call `join` to make sure the spawned thread finishes before
`main` exits:
-->
<p>Nous pouvons régler le problème des nouvelles tâches qui ne s'exécutent pas, ou
pas complètement, en sauvegardant la valeur de retour de <code>thread::spawn</code> dans
une variable. Le type de retour de <code>thread::span</code> est <code>JoinHandle</code>. Un
<code>JoinHandle</code> est une valeur possédée qui, lorsque nous appelons la méthode
<code>join</code> sur elle, va attendre que ses tâches finissent. L'encart 16-2 montre
comment utiliser le <code>JoinHandle</code> de la tâche que nous avons créé dans l'encart
16-1 en appelant la méthode <code>join</code> pour s'assurer que la nouvelle tâche finit
bien avant que <code>main</code> se termine :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let manipulateur = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Bonjour n°{} à partir de la nouvelle tâche !&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;Bonjour n°{} à partir de la tâche principale !&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    manipulateur.join().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-2: Saving a `JoinHandle` from `thread::spawn`
to guarantee the thread is run to completion</span>
-->
<p><span class="caption">Encart 16-2 : sauvegarde d'un <code>JoinHandle</code> d'un
<code>thread::spawn</code> pour garantir que la tâche est exécutée jusqu'à la fin</span></p>
<!--
Calling `join` on the handle blocks the thread currently running until the
thread represented by the handle terminates. *Blocking* a thread means that
thread is prevented from performing work or exiting. Because we’ve put the call
to `join` after the main thread’s `for` loop, running Listing 16-2 should
produce output similar to this:
-->
<p>L'appel à <code>join</code> sur le manipulateur bloque la tâche qui s'exécute actuellement
jusqu'à ce que la tâche représentée par le manipulateur se termine. <em>Bloquer</em>
une tâche signifie que cette tâche est privée d'accomplir un quelconque travail
ou de se terminer. Comme nous avons inséré l'appel à <code>join</code> après la boucle
<code>for</code> de la tâche principale, l'exécution de l'encart 16-2 devrait produire un
résultat similaire à celui-ci :</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
```
-->
<pre><code class="language-text">Bonjour n°1 à partir de la tâche principale !
Bonjour n°2 à partir de la tâche principale !
Bonjour n°1 à partir de la nouvelle tâche !
Bonjour n°3 à partir de la tâche principale !
Bonjour n°2 à partir de la nouvelle tâche !
Bonjour n°4 à partir de la tâche principale !
Bonjour n°3 à partir de la nouvelle tâche !
Bonjour n°4 à partir de la nouvelle tâche !
Bonjour n°5 à partir de la nouvelle tâche !
Bonjour n°6 à partir de la nouvelle tâche !
Bonjour n°7 à partir de la nouvelle tâche !
Bonjour n°8 à partir de la nouvelle tâche !
Bonjour n°9 à partir de la nouvelle tâche !
</code></pre>
<!--
The two threads continue alternating, but the main thread waits because of the
call to `handle.join()` and does not end until the spawned thread is finished.
-->
<p>Les deux tâches continuent à alterner, mais la tâche principale attends à cause
de l'appel à <code>manipulateur.join()</code> et ne se termine pas avant que la nouvelle
tâche soit finie.</p>
<!--
But let’s see what happens when we instead move `handle.join()` before the
`for` loop in `main`, like this:
-->
<p>Mais voyons maintenant ce qui se passe lorsque nous déplaçons le
<code>manipulateur.join()</code> avant la boucle <code>for</code> du <code>main</code> comme ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let manipulateur = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Bonjour n°{} à partir de la nouvelle tâche !&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    manipulateur.join().unwrap();

    for i in 1..5 {
        println!(&quot;Bonjour n°{} à partir de la tâche principale !&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<!--
The main thread will wait for the spawned thread to finish and then run its
`for` loop, so the output won’t be interleaved anymore, as shown here:
-->
<p>La tâche principale va attendre que la nouvelle tâche se finisse et ensuite
exécuter sa boucle <code>for</code>, ainsi la sortie ne sera plus chevauchée, comme
ci-dessous :</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
```
-->
<pre><code class="language-text">Bonjour n°1 à partir de la nouvelle tâche !
Bonjour n°2 à partir de la nouvelle tâche !
Bonjour n°3 à partir de la nouvelle tâche !
Bonjour n°4 à partir de la nouvelle tâche !
Bonjour n°5 à partir de la nouvelle tâche !
Bonjour n°6 à partir de la nouvelle tâche !
Bonjour n°7 à partir de la nouvelle tâche !
Bonjour n°8 à partir de la nouvelle tâche !
Bonjour n°9 à partir de la nouvelle tâche !
Bonjour n°1 à partir de la tâche principale !
Bonjour n°2 à partir de la tâche principale !
Bonjour n°3 à partir de la tâche principale !
Bonjour n°4 à partir de la tâche principale !
</code></pre>
<!--
Small details, such as where `join` is called, can affect whether or not your
threads run at the same time.
-->
<p>Des petits détails, comme l'endroit où <code>join</code> est appelé, peuvent déterminer si
vos tâches peuvent être exécutées ou non en même temps.</p>
<!--
### Using `move` Closures with Threads
-->
<h3 id="utiliser-les-fermetures-move-avec-les-tâches"><a class="header" href="#utiliser-les-fermetures-move-avec-les-tâches">Utiliser les fermetures <code>move</code> avec les tâches</a></h3>
<!--
The `move` closure is often used alongside `thread::spawn` because it allows
you to use data from one thread in another thread.
-->
<p>La fermeture <code>move</code> est souvent utilisé avec <code>thread::spawn</code> car elle vous
permet d'utiliser une donnée d'une tâche dans une autre tâche.</p>
<!--
In Chapter 13, we mentioned we can use the `move` keyword before the parameter
list of a closure to force the closure to take ownership of the values it uses
in the environment. This technique is especially useful when creating new
threads in order to transfer ownership of values from one thread to another.
-->
<p>Au chapitre 13, nous avons évoqué que nous pouvions utiliser le mot-clé <code>move</code>
avant la liste des paramètres d'une fermeture pour forcer la fermeture à
prendre possession des valeurs de son environnement qu'elle utilise. Cette
technique est particulièrement utile lorsque nous créons des nouvelles tâches
pour pouvoir transférer la possession des valeurs d'une tâche à une autre.</p>
<!--
Notice in Listing 16-1 that the closure we pass to `thread::spawn` takes no
arguments: we’re not using any data from the main thread in the spawned
thread’s code. To use data from the main thread in the spawned thread, the
spawned thread’s closure must capture the values it needs. Listing 16-3 shows
an attempt to create a vector in the main thread and use it in the spawned
thread. However, this won’t yet work, as you’ll see in a moment.
-->
<p>Remarquez dans l'encart 16-1 que la fermeture que nous donnons à <code>thread::span</code>
ne prends pas d'arguments : nous n'utilisons aucune donnée de la tâche
principale dans le code de la nouvelle tâche. Pour utiliser des données de la
tâche principale dans la nouvelle tâche, la fermeture de la nouvelle tâche doit
capturer les valeurs dont elle a besoin. L'encart 16-3 montre une tentative de
création d'un vecteur dans la tâche principale et l'utilisation dans la
nouvelle tâche. Cependant, cela ne fonctionne pas encore, comme vous allez le
constater bientôt.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let manipulateur = thread::spawn(|| {
        println!(&quot;Voici un vecteur : {:?}&quot;, v);
    });

    manipulateur.join().unwrap();
}
</code></pre>
<!--
<span class="caption">Listing 16-3: Attempting to use a vector created by the
main thread in another thread</span>
-->
<p><span class="caption">Encart 16-3 : tentative d'utilisation d'un vecteur créé
par la tâche principale dans une autre tâche</span></p>
<!--
The closure uses `v`, so it will capture `v` and make it part of the closure’s
environment. Because `thread::spawn` runs this closure in a new thread, we
should be able to access `v` inside that new thread. But when we compile this
example, we get the following error:
-->
<p>La fermeture utilise <code>v</code>, donc elle va capturer <code>v</code> et l'intégrer dans son
environnement. Comme <code>thread::spawn</code> exécute cette fermeture dans une nouvelle
tâche, nous devrions pouvoir accéder à <code>v</code> dans cette nouvelle tâche. Mais
lorsque nous compilons cet exemple, nous obtenons l'erreur suivante :</p>
<!--
```console
$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 -- > src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("Here's a vector: {:?}", v);
  |                                           - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 -- > src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("Here's a vector: {:?}", v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let manipulateur = thread::spawn(|| {
  |                                      ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let manipulateur = thread::spawn(|| {
  |  ________________________^
7 | |         println!(&quot;Here's a vector: {:?}&quot;, v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Rust *infers* how to capture `v`, and because `println!` only needs a reference
to `v`, the closure tries to borrow `v`. However, there’s a problem: Rust can’t
tell how long the spawned thread will run, so it doesn’t know if the reference
to `v` will always be valid.
-->
<p>Rust <em>déduit</em> comment capturer <code>v</code>, et comme <code>println!</code> n'a besoin que d'une
référence à <code>v</code>, la fermeture essaye d'emprunter <code>v</code>. Cependant, il y a un
problème : Rust ne peut pas savoir combien de temps la tâche va s'exécuter,
donc il ne peut pas savoir si la référence à <code>v</code> sera toujours valide.</p>
<!--
Listing 16-4 provides a scenario that’s more likely to have a reference to `v`
that won’t be valid:
-->
<p>L'encart 16-4 propose un scénario qui est plus encleint à avoir une référence à
<code>v</code> qui ne sera plus valide :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let manipulateur = thread::spawn(|| {
        println!(&quot;Voici un vecteur : {:?}&quot;, v);
    });

    drop(v); // oh, non !

    manipulateur.join().unwrap();
}
</code></pre>
<!--
<span class="caption">Listing 16-4: A thread with a closure that attempts to
capture a reference to `v` from a main thread that drops `v`</span>
-->
<p><span class="caption">Encart 16-4 : une tâche dont la fermeture essaye de
capturer une référence à <code>v</code> à partir de la tâche principale, qui va ensuite
libérer <code>v</code></span></p>
<!--
If we were allowed to run this code, there’s a possibility the spawned thread
would be immediately put in the background without running at all. The spawned
thread has a reference to `v` inside, but the main thread immediately drops
`v`, using the `drop` function we discussed in Chapter 15. Then, when the
spawned thread starts to execute, `v` is no longer valid, so a reference to it
is also invalid. Oh no!
-->
<p>Si nous étions autorisés à exécuter ce code, il y aurait une possibilité que
la nouvelle tâche serait immédiatement placée en arrière-plan sans être
exécutée du tout. La nouvelle tâche a une référence à <code>v</code> en son sein, mais la
tâche principale libère immédiatement <code>v</code>, en utilisant la fonction <code>drop</code> que
nous avons vu au chapitre 15. Ensuite, lorsque la nouvelle tâche commence à
s'exécuter, <code>v</code> n'est plus en vigueur, donc une référence à cette dernière est
elle aussi invalide !</p>
<!--
To fix the compiler error in Listing 16-3, we can use the error message’s
advice:
-->
<p>Pour corriger l'erreur de compilation de l'encart 16-3, nous pouvons appliquer
le conseil du message d'erreur :</p>
<!--
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-- >
-->
<!--
```text
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
```
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let manipulateur = thread::spawn(move || {
  |                                      ^^^^^^^
</code></pre>
<!--
By adding the `move` keyword before the closure, we force the closure to take
ownership of the values it’s using rather than allowing Rust to infer that it
should borrow the values. The modification to Listing 16-3 shown in Listing
16-5 will compile and run as we intend:
-->
<p>En ajoutant le mot-clé <code>move</code> avant la fermeture, nous forçons la fermeture à
prendre possession des valeurs qu'elle utilise au lieu de laisser Rust en
déduire qu'il doit emprunter les valeurs. Les modifications à l'encart 16-3
proposées dans l'encart 16-5 devraient se compiler et s'exécuter comme prévu :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let manipulateur = thread::spawn(move || {
        println!(&quot;Voici un vecteur : {:?}&quot;, v);
    });

    manipulateur.join().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-5: Using the `move` keyword to force a closure
to take ownership of the values it uses</span>
-->
<p><span class="caption">Encart 16-5 : utilisation du mot-clé <code>move</code> pour forcer
une fermeture à prendre possession des valeurs qu'elle utilise</span></p>
<!--
What would happen to the code in Listing 16-4 where the main thread called
`drop` if we use a `move` closure? Would `move` fix that case? Unfortunately,
no; we would get a different error because what Listing 16-4 is trying to do
isn’t allowed for a different reason. If we added `move` to the closure, we
would move `v` into the closure’s environment, and we could no longer call
`drop` on it in the main thread. We would get this compiler error instead:
-->
<p>Qu'est-ce qui arriverait au code de l'encart 16-4 dans lequel la tâche
principale fait appel à <code>drop</code> si nous utilisions la fermeture avec <code>move</code> ?
Est-ce que le <code>move</code> va résoudre ce problème ? Malheureusement, non ; nous
obtiendrions une erreur différente parce que ce que l'encart 16-4 essaye de
faire n'est pas autorisé pour différentes raisons. Si nous ajoutions <code>move</code> à la
fermeture, nous déplacerions <code>v</code> dans l'environnement de la fermeture, et nous
ne pourrions plus appeler <code>drop</code> sur <code>v</code> dans la tâche principale. Nous
obtiendrons à la place cette erreur de compilation :</p>
<!--
```console
$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  -- > src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait
5  | 
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!("Here's a vector: {:?}", v);
   |                                           - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  | 
6  |     let manipulateur = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!(&quot;Voici un vecteur : {:?}&quot;, v);
   |                                             - variable moved due to use in closure
...
10 |     drop(v); // oh, non !
   |          ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads`.

To learn more, run the command again with --verbose.
</code></pre>
<pre><code class="language-text">error[E0382]: use of moved value: `v`
  -- &gt; src/main.rs:10:10
   |
6  |     let manipulateur = thread::spawn(move || {
   |                                      ------- value moved (into closure) here
...
10 |     drop(v); // oh non, le vecteur est libéré !
   |          ^ value used here after move
   |
   = note: move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does
   not implement the `Copy` trait
</code></pre>
<!--
Rust’s ownership rules have saved us again! We got an error from the code in
Listing 16-3 because Rust was being conservative and only borrowing `v` for the
thread, which meant the main thread could theoretically invalidate the spawned
thread’s reference. By telling Rust to move ownership of `v` to the spawned
thread, we’re guaranteeing Rust that the main thread won’t use `v` anymore. If
we change Listing 16-4 in the same way, we’re then violating the ownership
rules when we try to use `v` in the main thread. The `move` keyword overrides
Rust’s conservative default of borrowing; it doesn’t let us violate the
ownership rules.
-->
<p>Les règles de possession de Rust nous ont encore sauvé la mise ! Nous obtenons
une erreur du code l'encart 16-3 car Rust a été conservateur et a juste emprunté
<code>v</code> à la tâche, ce qui signifie que la tâche principale peut théoriquement
neutraliser la référence de la tâche crée. En demandant à Rust de déplacer la
possession de <code>v</code> à la nouvelle tâche, nous avons garanti à Rust que la tâche
principale n'utiliserait plus <code>v</code>. Si nous changeons l'encart 16-4 de la même
manière, nous violons les règles de possession lorsque nous essayons d'utiliser
<code>v</code> dans la tâche principale. Le mot-clé <code>move</code> remplace le comportement
d'emprunt conservateur par défaut ; il ne nous laisse pas enfreindre les règles
d'emprunt.</p>
<!--
With a basic understanding of threads and the thread API, let’s look at what we
can *do* with threads.
-->
<p>Avec cette connaissance de base des tâches et de leur API, découvrons ce que
nous pouvons <em>faire</em> avec les tâches.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--15"><a class="header" href="#-attention-peinture-fraîche--15">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/198">Pull Request</a>.</p>
</blockquote>
<!--
## Using Message Passing to Transfer Data Between Threads
-->
<h2 id="utiliser-lenvoi-de-messages-pour-transférer-des-données-entre-les-tâches"><a class="header" href="#utiliser-lenvoi-de-messages-pour-transférer-des-données-entre-les-tâches">Utiliser l'envoi de messages pour transférer des données entre les tâches</a></h2>
<!--
One increasingly popular approach to ensuring safe concurrency is *message
passing*, where threads or actors communicate by sending each other messages
containing data. Here’s the idea in a slogan from [the Go language
documentation](https://golang.org/doc/effective_go.html#concurrency): 
“Do not communicate by sharing memory; instead, share memory by communicating.”
-->
<p>Une approche de plus en plus populaire pour garantir la sécurité de la
concurrence est l'<em>envoi de message</em>, avec lequel les tâches ou les acteurs
communiquent en envoyant aux autres des messages contenant des données. Voici
l'idée résumée, tirée d'un slogan provenant de <a href="https://golang.org/doc/effective_go.html#concurrency">la documentation du langage
Go</a> : “Ne communiquez pas
en partageant la mémoire ; partagez plutôt la mémoire en communiquant”.</p>
<!--
One major tool Rust has for accomplishing message-sending concurrency is the
*channel*, a programming concept that Rust’s standard library provides an
implementation of. You can imagine a channel in programming as being like a
channel of water, such as a stream or a river. If you put something like a
rubber duck or boat into a stream, it will travel downstream to the end of the
waterway.
-->
<p>Un des outils majeurs que Rust a pour accomplir l'envoi de messages pour la
concurrence est le <em>canal</em>, un concept de programmation dont la bibliothèque
standard de Rust fournit une implémentation. Vous pouvez imaginer un canal de
programmation comme étant un canal d'eau, comme un ruisseau ou une rivière. Si
vous posez quelque chose comme un canard en plastique ou un bateau sur un
ruisseau, il se déplacera en descendant le long la voie d'eau.</p>
<!--
A channel in programming has two halves: a transmitter and a receiver. The
transmitter half is the upstream location where you put rubber ducks into the
river, and the receiver half is where the rubber duck ends up downstream. One
part of your code calls methods on the transmitter with the data you want to
send, and another part checks the receiving end for arriving messages. A
channel is said to be *closed* if either the transmitter or receiver half is
dropped.
-->
<p>Un canal de programmation est divisé en deux parties : un transmetteur et un
receveur. La partie du transmetteur est le lieu en amont où vous déposez les
canards en plastique sur la rivière et la partie du receveur est où les
canards en plastique finissent leur voyage. Une partie de votre code fait appel
à des méthodes sur le transmetteur avec les données que vous souhaitez envoyer,
et une autre partie attends les messages à l'arrivée. Un canal est dit <em>fermé</em>
lorsque la partie correspondante au transmetteur ou la partie du récepteur est
libérée.</p>
<!--
Here, we’ll work up to a program that has one thread to generate values and
send them down a channel, and another thread that will receive the values and
print them out. We’ll be sending simple values between threads using a channel
to illustrate the feature. Once you’re familiar with the technique, you could
use channels to implement a chat system or a system where many threads perform
parts of a calculation and send the parts to one thread that aggregates the
results.
-->
<p>Ici, nous allons concevoir un programme qui a une tâche pour générer des
valeurs et les envoyer dans un canal, et une autre tâche qui va recevoir les
valeurs et les afficher. Nous allons envoyer de simples valeurs entre les
tâches en utilisant un canal pour illustrer cette fonctionnalité. Une fois que
vous serez familier avec cette technique, vous pourrez utiliser les canaux
pour créer un système de dialogue en ligne ou un système où de nombreuses
tâches font chacune une partie d'un gros calcul et envoient leur résultat à une
tâche chargée d'agréger ces résultats.</p>
<!--
First, in Listing 16-6, we’ll create a channel but not do anything with it.
Note that this won’t compile yet because Rust can’t tell what type of values we
want to send over the channel.
-->
<p>Pour commencer, dans l'encart 16-6, nous allons créer un canal mais nous
n'allons rien faire avec. Remarquez qu'il ne se compilera pas encore car Rust
ne peut pas savoir le type de valeurs que nous souhaitons envoyer dans le
canal.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
</code></pre>
<!--
<span class="caption">Listing 16-6: Creating a channel and assigning the two
halves to `tx` and `rx`</span>
-->
<p><span class="caption">Encart 16-6 : création d'un canal et assignation de ses
deux parties à <code>tx</code> et <code>rx</code></span></p>
<!--
We create a new channel using the `mpsc::channel` function; `mpsc` stands for
*multiple producer, single consumer*. In short, the way Rust’s standard library
implements channels means a channel can have multiple *sending* ends that
produce values but only one *receiving* end that consumes those values. Imagine
multiple streams flowing together into one big river: everything sent down any
of the streams will end up in one river at the end. We’ll start with a single
producer for now, but we’ll add multiple producers when we get this example
working.
-->
<p>Nous créons un nouveau canal en utilisant la fonction <code>mpsc::channel</code> ; <code>mpsc</code>
signifie <em>multiple producer, single consumer</em>, c'est-à-dire
<em>plusieurs producteurs, un seul consommateur</em>. En bref, la façon dont la
bibliothèque standard de Rust a implémenté ces canaux permet d'avoir plusieurs
extrémités <em>émettrices</em> qui produisent des valeurs, mais seulement une seule
extrémité <em>réceptrice</em> qui consomme ces valeurs. Immaginez plusieurs ruisseaux
qui se rejoignent en une seule grosse rivière : tout ce qui est déposé sur les
ruisseaux va finir dans une seule rivière à la fin. Nous allons commencer avec
un seul producteur pour le moment, mais nous allons ajouter d'autres
producteurs lorsque notre exemple fonctionnera.</p>
<!--
The `mpsc::channel` function returns a tuple, the first element of which is the
sending end and the second element is the receiving end. The abbreviations `tx`
and `rx` are traditionally used in many fields for *transmitter* and *receiver*
respectively, so we name our variables as such to indicate each end. We’re
using a `let` statement with a pattern that destructures the tuples; we’ll
discuss the use of patterns in `let` statements and destructuring in Chapter
18. Using a `let` statement this way is a convenient approach to extract the
pieces of the tuple returned by `mpsc::channel`.
-->
<p>La fonction <code>mpsc::channel</code> retourne un tuple, le premier élément est celui qui
permet d'envoyer et le second est celui qui reçoit. Les abbréviations <code>tx</code> et
<code>rx</code> sont utilisés traditionnellement dans de nombreux domaines pour signifier
respectivement <em>transmetteur</em> et <em>récepteur</em>, nous avons donc nommé nos
variables comme ceci pour marquer chaque élément.  Nous utilisons une
instruction <code>let</code> avec un motif qui déstructure les tuples ; nous allons voir
l'utilisation des motifs dans les instructions <code>let</code> et la déstructuration au
chapitre 18. L'utilisation d'une instruction <code>let</code> de cette manière est une
approche facile pour extraire les éléments du tuple retourné par
<code>mpsc::channel</code>.</p>
<!--
Let’s move the transmitting end into a spawned thread and have it send one
string so the spawned thread is communicating with the main thread, as shown in
Listing 16-7. This is like putting a rubber duck in the river upstream or
sending a chat message from one thread to another.
-->
<p>Déplaçons maintenant l'élément de transmission dans une nouvelle tâche et
faisons-lui envoyer une chaîne de caractères afin que la nouvelle tâche
communique avec la tâche principale, comme dans l'encart 16-7. C'est comme
poser un canard en plastique sur l'amont de la rivière ou envoyer un message
instantané d'une tâche à une autre.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let valeur = String::from(&quot;salut&quot;);
        tx.send(valeur).unwrap();
    });
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-7: Moving `tx` to a spawned thread and sending
“hi”</span>
-->
<p><span class="caption">Encart 16-7 : déplacement de <code>tx</code> dans la nouvelle tâche
et envoi de “salut”</span></p>
<!--
Again, we’re using `thread::spawn` to create a new thread and then using `move`
to move `tx` into the closure so the spawned thread owns `tx`. The spawned
thread needs to own the transmitting end of the channel to be able to send
messages through the channel.
-->
<p>Nous utilisons à nouveau <code>thread::spawn</code> pour créer une nouvelle tâche et
ensuite utiliser <code>move</code> pour déplacer <code>tx</code> dans la fermeture afin que la
nouvelle tâche possède désormais ``tx`. La nouvelle tâche a besoin de posséder
la partie émettrice du canal pour être en capacité d'envoyer des messages
dans ce canal.</p>
<!--
The transmitting end has a `send` method that takes the value we want to send.
The `send` method returns a `Result<T, E>` type, so if the receiving end has
already been dropped and there’s nowhere to send a value, the send operation
will return an error. In this example, we’re calling `unwrap` to panic in case
of an error. But in a real application, we would handle it properly: return to
Chapter 9 to review strategies for proper error handling.
-->
<p>La partie émettrice a une méthode <code>send</code> qui prend en argument la valeur que
nous souhaitons envoyer. La méthode <code>send</code> retourne un type <code>Result&lt;T, E&gt;</code>,
donc si la partie réceptrice a déjà été libérée et qu'il n'y a nulle part où
envoyer la valeur, l'opération d'envoi va retourner une erreur. Dans cet
exemple, nous faisons appel à <code>unwrap</code> pour paniquer en cas d'erreur. Mais dans
un vrai programme, nous devrions gérer ce cas correctement : retournez au
chapitre 9 pour revoir les stratégies pour gérer correctement les erreurs.</p>
<!--
In Listing 16-8, we’ll get the value from the receiving end of the channel in
the main thread. This is like retrieving the rubber duck from the water at the
end of the river or like getting a chat message.
-->
<p>Dans l'encart 16-8, nous allons obtenir la valeur de l'extrémité réceptrice du
canal dans la tâche principale. C'est comme récupérer le canard en plastique
dans l'eau à la fin de la rivière, ou récupérer un message instantané.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let valeur = String::from(&quot;salut&quot;);
        tx.send(valeur).unwrap();
    });

    let recu = rx.recv().unwrap();
    println!(&quot;On a reçu : {}&quot;, recu);
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-8: Receiving the value “hi” in the main thread
and printing it</span>
-->
<p><span class="caption">Encart 16-8 : réception de la valeur “salut” dans la
tâche principale pour l'afficher</span></p>
<!--
The receiving end of a channel has two useful methods: `recv` and `try_recv`.
We’re using `recv`, short for *receive*, which will block the main thread’s
execution and wait until a value is sent down the channel. Once a value is
sent, `recv` will return it in a `Result<T, E>`. When the sending end of the
channel closes, `recv` will return an error to signal that no more values will
be coming.
-->
<p>La partie réception d'un canal a deux modes intéressants : <code>recv</code> et
<code>try_recv</code>. Nous avons utilisé <code>recv</code>, un raccourci pour <em>recevoir</em>, qui va
bloquer l'exécution de la tâche principale et attendre jusqu'à ce qu'une valeur
soit envoyée dans le canal. Une fois qu'une valeur est envoyée, <code>recv</code> va
la retourner dans un <code>Result&lt;T, E&gt;</code>. Lorsque la partie transmission du canal se
ferme, <code>recv</code> va retourner une erreur pour signaler qu'il n'y aura plus de
valeurs qui arriveront.</p>
<!--
The `try_recv` method doesn’t block, but will instead return a `Result<T, E>`
immediately: an `Ok` value holding a message if one is available and an `Err`
value if there aren’t any messages this time. Using `try_recv` is useful if
this thread has other work to do while waiting for messages: we could write a
loop that calls `try_recv` every so often, handles a message if one is
available, and otherwise does other work for a little while until checking
again.
-->
<p>La méthode <code>try_recv</code> ne bloque pas, mais va plutôt retourner immédiatement un
<code>Result&lt;T, E&gt;</code> : une valeur <code>Ok</code> qui contiendra un message s'il y en a un de
disponible, et une valeur <code>Err</code> s'il n'y a pas de message cette fois-ci.
L'utilisation de <code>try_recv</code> est pratique si cette tâche à d'autres choses à
faire pendant qu'elle attend les messages : nous pouvons ainsi écrire une
boucle qui appelle régulièrement <code>try_recv</code>, gère le message s'il y en a un, et
sinon fait d'autres choses jusqu'à ce qu'elle vérifiera à nouveau.</p>
<!--
We’ve used `recv` in this example for simplicity; we don’t have any other work
for the main thread to do other than wait for messages, so blocking the main
thread is appropriate.
-->
<p>Nous avons utilisé <code>recv</code> dans cet exemple pour des raisons de simplicité ;
nous n'avons rien d'autres à faire dans la tâche principale que d'attendre les
messages, donc bloquer la tâche principale est acceptable.</p>
<!--
When we run the code in Listing 16-8, we’ll see the value printed from the main
thread:
-->
<p>Lorsque nous exécutons le code de l'encart 16-8, nous allons voir la valeur
s'afficher grâce à la tâche principale :</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
Got: hi
```
-->
<pre><code class="language-text">On a reçu : salut
</code></pre>
<!--
Perfect!
-->
<p>C'est parfait ainsi !</p>
<!--
### Channels and Ownership Transference
-->
<h3 id="les-canaux-et-le-transfert-de-possession"><a class="header" href="#les-canaux-et-le-transfert-de-possession">Les canaux et le transfert de possession</a></h3>
<!--
The ownership rules play a vital role in message sending because they help you
write safe, concurrent code. Preventing errors in concurrent programming is the
advantage of thinking about ownership throughout your Rust programs. Let’s do
an experiment to show how channels and ownership work together to prevent
problems: we’ll try to use a `val` value in the spawned thread *after* we’ve
sent it down the channel. Try compiling the code in Listing 16-9 to see why
this code isn’t allowed:
-->
<p>Les règles de possession jouent un rôle vital dans l'envoi de messages car
elles vous aident à écrire du code sûr et concurrent. Réfléchir à la possession
avec vos programmes Rust vous offre l'avantage d'éviter des erreurs de
développement avec la concurrence. Faisons une expérience pour montrer comment
la possession et les canaux fonctionnent ensemble pour éviter les problèmes :
nous allons essayer d'utiliser la <code>valeur</code> dans la nouvelle tâche <em>après</em> que
nous l'ayons envoyé dans le canal. Essayez de compiler le code de l'encart 16-9
pour découvrir pourquoi ce code n'est pas autorisé :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        println!("val is {}", val);
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let valeur = String::from(&quot;hi&quot;);
        tx.send(valeur).unwrap();
        println!(&quot;valeur vaut {}&quot;, valeur);
    });

    let recu = rx.recv().unwrap();
    println!(&quot;On a reçu : {}&quot;, recu);
}
</code></pre>
<!--
<span class="caption">Listing 16-9: Attempting to use `val` after we’ve sent it
down the channel</span>
-->
<p><span class="caption">Encart 16-9 : tentative d'utiliser <code>valeur</code> après que
nous l'ayons envoyé dans le canal</span></p>
<!--
Here, we try to print `val` after we’ve sent it down the channel via `tx.send`.
Allowing this would be a bad idea: once the value has been sent to another
thread, that thread could modify or drop it before we try to use the value
again. Potentially, the other thread’s modifications could cause errors or
unexpected results due to inconsistent or nonexistent data. However, Rust gives
us an error if we try to compile the code in Listing 16-9:
-->
<p>Ici, nous essayons d'afficher <code>valeur</code> après que nous l'ayons envoyé dans le
canal avec <code>tx.send</code>. Ce serait une mauvaise idée de permettre cela : une fois
que la valeur a été envoyée à une autre tâche, cette tâche peut la modifier ou
la libérer avant que nous essayons de l'utiliser à nouveau. Il est possible que
des modifications de l'autre tâche puissent causer des erreurs ou des résultats
inattendus à cause de données incohérentes ou manquantes. Toutefois, Rust nous
affiche une erreur si nous essayons de compiler le code de l'encart 16-9 :</p>
<!--
```console
$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  -- > src/main.rs:10:31
   |
8  |         let val = String::from("hi");
   |             --- move occurs because `val` has type `std::string::String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val is {}", val);
   |                               ^^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `valeur`
  --&gt; src/main.rs:10:31
   |
8  |         let valeur = String::from(&quot;salut&quot;);
   |             ------ move occurs because `valeur` has type `std::string::String`, which does not implement the `Copy` trait
9  |         tx.send(valeur).unwrap();
   |                 ------ value moved here
10 |         println!(&quot;valeur vaut {}&quot;, valeur);
   |                                    ^^^^^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Our concurrency mistake has caused a compile time error. The `send` function
takes ownership of its parameter, and when the value is moved, the receiver
takes ownership of it. This stops us from accidentally using the value again
after sending it; the ownership system checks that everything is okay.
-->
<p>Notre erreur de concurrence a provoqué une erreur à la compilation. La fonction
<code>send</code> prend possession de ses paramètres, et lorsque la valeur est déplacée,
le récepteur en prend possession. Cela nous évite d'utiliser à nouveau
accidentellement la valeur après l'avoir envoyée ; le système de possession
vérifie que tout est en ordre.</p>
<!--
### Sending Multiple Values and Seeing the Receiver Waiting
-->
<h3 id="envoyer-plusieurs-valeurs-et-voir-le-récepteur-les-attendre"><a class="header" href="#envoyer-plusieurs-valeurs-et-voir-le-récepteur-les-attendre">Envoyer plusieurs valeurs et voir le récepteur les attendre</a></h3>
<!--
The code in Listing 16-8 compiled and ran, but it didn’t clearly show us that
two separate threads were talking to each other over the channel. In Listing
16-10 we’ve made some modifications that will prove the code in Listing 16-8 is
running concurrently: the spawned thread will now send multiple messages and
pause for a second between each message.
-->
<p>Le code de l'encart 16-8 s'est compilé et exécuté, mais il ne nous a pas
clairement indiqué que deux tâches séparées communiquaient entre elles via le
canal. Dans l'encart 16-10 nous avons fait quelques modifications qui prouvent
que le code de l'encart 16-8 est exécuté avec de la concurrence : la nouvelle
tâche va maintenant envoyer plusieurs messages et faire une pause d'une seconde
entre chaque message.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let valeurs = vec![
            String::from(&quot;salutations&quot;),
            String::from(&quot;à partir&quot;),
            String::from(&quot;de la&quot;),
            String::from(&quot;nouvelle tâche&quot;),
        ];

        for valeur in valeurs {
            tx.send(valeur).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for recu in rx {
        println!(&quot;On a reçu : {}&quot;, recu);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-10: Sending multiple messages and pausing
between each</span>
-->
<p><span class="caption">Encart 16-10 : envoi de plusieurs messages en faisant une
pause entre chacun</span></p>
<!--
This time, the spawned thread has a vector of strings that we want to send to
the main thread. We iterate over them, sending each individually, and pause
between each by calling the `thread::sleep` function with a `Duration` value of
1 second.
-->
<p>Cette fois-ci, la nouvelle tâche a un vecteur de chaînes de caractères que nous
souhaitons envoyer à la tâche principale. Nous itérons sur celui-ci, on les
envoie individuellement, et on fait une pause entre chaque envoi en appelant la
fonction <code>thread::sleep</code> avec une valeur <code>Duration</code> de 1 seconde.</p>
<!--
In the main thread, we’re not calling the `recv` function explicitly anymore:
instead, we’re treating `rx` as an iterator. For each value received, we’re
printing it. When the channel is closed, iteration will end.
-->
<p>Dans la tâche principale, nous n'appelons plus explicitement la fonction
<code>recv</code> : à la place, nous utilisons <code>rx</code> comme un itérateur. Pour chaque valeur
reçue, nous l'affichons. Lorsque le canal se fermera, l'itération se terminera.</p>
<!--
When running the code in Listing 16-10, you should see the following output
with a 1-second pause in between each line:
-->
<p>Lorsque nous exécutons le code de l'encart 16-10, nous devrions voir la sortie
suivante, avec une pause de 1 seconde entre chaque ligne :</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
Got: hi
Got: from
Got: the
Got: thread
```
-->
<pre><code class="language-text">On a reçu : salutations
On a reçu : à partir
On a reçu : de la
On a reçu : nouvelle tâche
</code></pre>
<!--
Because we don’t have any code that pauses or delays in the `for` loop in the
main thread, we can tell that the main thread is waiting to receive values from
the spawned thread.
-->
<p>Comme nous n'avons pas de code qui met en pause ou retarde la boucle <code>for</code> de
la tâche principale, nous pouvons dire que la tâche principale est en attente
de réception des valeurs de la part de la nouvelle tâche.</p>
<!--
### Creating Multiple Producers by Cloning the Transmitter
-->
<h3 id="créer-plusieurs-producteurs-en-clonant-le-transmetteur"><a class="header" href="#créer-plusieurs-producteurs-en-clonant-le-transmetteur">Créer plusieurs producteurs en clonant le transmetteur</a></h3>
<!--
Earlier we mentioned that `mpsc` was an acronym for *multiple producer,
single consumer*. Let’s put `mpsc` to use and expand the code in Listing 16-10
to create multiple threads that all send values to the same receiver. We can do
so by cloning the transmitting half of the channel, as shown in Listing 16-11:
-->
<p>Précédemment, nous avions évoqué que <code>mpsc</code> était un acronyme pour
<em>multiple producer, single consumer</em>. Mettons <code>mpsc</code> en œuvre en élargissant le
code de l'encart 16-10 pour créer plusieurs tâches qui vont toutes envoyer des
valeurs au même récepteur. Nous pouvons faire ceci en clonant la partie
émettrice du canal, comme dans l'encart 16-11 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# use std::sync::mpsc;
# use std::thread;
# use std::time::Duration;
# 
# fn main() {
    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = mpsc::Sender::clone(&tx);
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }

    // --snip--
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // -- partie masquée ici --

    let (tx, rx) = mpsc::channel();

    let tx1 = mpsc::Sender::clone(&amp;tx);
    thread::spawn(move || {
        let valeurs = vec![
            String::from(&quot;salutations&quot;),
            String::from(&quot;à partir&quot;),
            String::from(&quot;de la&quot;),
            String::from(&quot;nouvelle tâche&quot;),
        ];

        for valeur in valeurs {
            tx1.send(valeur).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let valeurs = vec![
            String::from(&quot;encore plus&quot;),
            String::from(&quot;de messages&quot;),
            String::from(&quot;pour&quot;),
            String::from(&quot;vous&quot;),
        ];

        for valeur in valeurs {
            tx.send(valeur).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for recu in rx {
        println!(&quot;On a reçu : {}&quot;, recu);
    }

    // -- partie masquée ici --
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 16-11: Sending multiple messages from multiple
producers</span>
-->
<p><span class="caption">Encart 16-11 : envoi de plusieurs messages à partir de
plusieurs producteurs</span></p>
<!--
This time, before we create the first spawned thread, we call `clone` on the
sending end of the channel. This will give us a new sending handle we can pass
to the first spawned thread. We pass the original sending end of the channel to
a second spawned thread. This gives us two threads, each sending different
messages to the receiving end of the channel.
-->
<p>Cette fois-ci, avant de créer la première nouvelle tâche, nous appelons <code>clone</code>
sur la partie émettrice du canal. Cela va nous donner un nouveau transmetteur
que nous pourrons passer à la seconde nouvelle tâche. Cela va nous donner deux
tâches, chacune envoyant des messages différents à la partie réceptrice du
canal.</p>
<!--
When you run the code, your output should look something like this:
-->
<p>Lorsque vous exécuterez ce code, votre sortie devrait ressembler à ceci :</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
```
-->
<pre><code class="language-text">On a reçu : salutations
On a reçu : encore plus
On a reçu : de messages
On a reçu : pour
On a reçu : à partir
On a reçu : de la
On a reçu : nouvelle tâche
On a reçu : pour vous
</code></pre>
<!--
You might see the values in another order; it depends on your system. This is
what makes concurrency interesting as well as difficult. If you experiment with
`thread::sleep`, giving it various values in the different threads, each run
will be more nondeterministic and create different output each time.
-->
<p>Vous pourrez peut-être constater que les valeurs sont dans un autre ordre chez
vous ; cela dépend de votre système. C'est ce qui rend la concurrence aussi
intéressante que difficile. Si vous jouez avec la valeur de <code>thread::sleep</code> en
lui donnant différentes valeurs dans différentes tâches, chaque exécution sera
encore moins déterminée et créera une sortie différente à chaque fois.</p>
<!--
Now that we’ve looked at how channels work, let’s look at a different method of
concurrency.
-->
<p>Maintenant que nous avons découvert le fonctionnement des canaux, examinons un
autre genre de concurrence.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--16"><a class="header" href="#-attention-peinture-fraîche--16">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/199">Pull Request</a>.</p>
</blockquote>
<!--
## Shared-State Concurrency
-->
<h2 id="le-partage-détat-en-concurrence"><a class="header" href="#le-partage-détat-en-concurrence">Le partage d'état en concurrence</a></h2>
<!--
Message passing is a fine way of handling concurrency, but it’s not the only
one. Consider this part of the slogan from the Go language documentation again:
“do not communicate by sharing memory.”
-->
<p>L'envoi de messages est un assez bon moyen de gestion de la concurrence, mais il
n'y a pas qu'un seul. Repensons à cette partie du slogan de la documentation du
langage Go : “ne communiquez pas en partageant la mémoire”.</p>
<!--
What would communicating by sharing memory look like? In addition, why would
message-passing enthusiasts not use it and do the opposite instead?
-->
<p>A quoi ressemble le partage de mémoire pour communiquer ? De plus, pourquoi les
partisans de l'envoi de messages ne devraient pas l'utiliser et faire plutôt
le contraire ?</p>
<!--
In a way, channels in any programming language are similar to single ownership,
because once you transfer a value down a channel, you should no longer use that
value. Shared memory concurrency is like multiple ownership: multiple threads
can access the same memory location at the same time. As you saw in Chapter 15,
where smart pointers made multiple ownership possible, multiple ownership can
add complexity because these different owners need managing. Rust’s type system
and ownership rules greatly assist in getting this management correct. For an
example, let’s look at mutexes, one of the more common concurrency primitives
for shared memory.
-->
<p>De manière générale, les canaux dans les langages de programmation ressemble à
la possession unique, car une fois que vous avez transféré une valeur dans un
canal, vous ne pouvez plus utiliser cette valeur. Le partage de mémoire en
concurrence est comme de la possession multiple : plusieurs tâches peuvent
accéder au même endroit de la mémoire en même temps. Comme vous l'avez vu au
chapitre 15, dans lequel les pointeurs intelligents rendent possible la
possession multiple, la possession multiple peut rajouter de la complexité car
ces différents propriétaires ont besoin d'être gérés. Le système de type de Rust
et les règles de possession aident beaucoup à les gérer correctement. Par
exemple, découvrons les mutex, une des primitives les plus courantes pour
partager la mémoire.</p>
<!--
### Using Mutexes to Allow Access to Data from One Thread at a Time
-->
<h3 id="utiliser-les-mutex-pour-permettre-laccès-à-la-donnée-à-une-seule-tâche-à-la-fois"><a class="header" href="#utiliser-les-mutex-pour-permettre-laccès-à-la-donnée-à-une-seule-tâche-à-la-fois">Utiliser les mutex pour permettre l'accès à la donnée à une seule tâche à la fois</a></h3>
<!--
*Mutex* is an abbreviation for *mutual exclusion*, as in, a mutex allows only
one thread to access some data at any given time. To access the data in a
mutex, a thread must first signal that it wants access by asking to acquire the
mutex’s *lock*. The lock is a data structure that is part of the mutex that
keeps track of who currently has exclusive access to the data. Therefore, the
mutex is described as *guarding* the data it holds via the locking system.
-->
<p><em>Mutex</em> est une abréviation pour <em>mutual exclusion</em>, ce qui veut dire qu'un
mutex ne permet qu'à une seule tâche d'accéder à une donnée en même temps. Pour
accéder à la donnée dans un mutex, une tâche doit d'abord signaler qu'elle
souhaite y accéder en demandant l'obtention du <em>verrou</em> du mutex. Le verrou est
une structure de donnée qui fait partie du mutex qui assure le suivi de qui a
actuellement accès à la donnée. Par conséquent, le mutex est qualifié de
<em>gardien</em> de la donnée qu'il renferme via le système de verrou.</p>
<!--
Mutexes have a reputation for being difficult to use because you have to
remember two rules:
-->
<p>Les mutex ont la réputation d'être difficiles à utiliser car vous devez veiller
à deux règles :</p>
<!--
* You must attempt to acquire the lock before using the data.
* When you’re done with the data that the mutex guards, you must unlock the
  data so other threads can acquire the lock.
-->
<ul>
<li>Vous devez obtenir le verrou avant d'utiliser la donnée.</li>
<li>Lorsque vous avez fini avec la donnée que le mutex garde, vous devez
déverrouiller la donnée afin que d'autres tâches puissent obtenir le verrou.</li>
</ul>
<!--
For a real-world metaphor for a mutex, imagine a panel discussion at a
conference with only one microphone. Before a panelist can speak, they have to
ask or signal that they want to use the microphone. When they get the
microphone, they can talk for as long as they want to and then hand the
microphone to the next panelist who requests to speak. If a panelist forgets to
hand the microphone off when they’re finished with it, no one else is able to
speak. If management of the shared microphone goes wrong, the panel won’t work
as planned!
-->
<p>Pour faire une métaphore de la vie courante d'un mutex, imaginez une table ronde
lors d'une conférence avec un seul microphone. Avant qu'un participant puisse
parler, il doit demander ou signaler qu'il veut utiliser le micro. Lorsqu'il
obtient le micro, il peut parler aussi longtemps qu'il le souhaite et ensuite
passer le micro au prochain participant qui a demandé à pouvoir parler. Si un
participant oublie de rendre le micro après avoir fini de parler, personne
d'autre ne peut parler. Si la gestion du micro partagé se passe mal, la table
ronde ne fonctionnera pas comme prévu !</p>
<!--
Management of mutexes can be incredibly tricky to get right, which is why so
many people are enthusiastic about channels. However, thanks to Rust’s type
system and ownership rules, you can’t get locking and unlocking wrong.
-->
<p>La gestion des mutex peut devenir incroyable compliquée, c'est pourquoi tant de
personnes sont partisanes des canaux. Cependant, grâce au système de type de
Rust et aux règles de possession, vous ne pouvez pas vous tromper dans le
verrouillage et déverrouillage.</p>
<!--
#### The API of `Mutex<T>`
-->
<h4 id="lapi-des-mutext"><a class="header" href="#lapi-des-mutext">L'API des <code>Mutex&lt;T&gt;</code></a></h4>
<!--
As an example of how to use a mutex, let’s start by using a mutex in a
single-threaded context, as shown in Listing 16-12:
-->
<p>Pour illustrer l'utilisation d'un mutex, commençons par utiliser un mutex dans
le contexte d'une seule tâche, comme dans l'encart 16-12 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {:?}", m);
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut nombre = m.lock().unwrap();
        *nombre = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-12: Exploring the API of `Mutex<T>` in a
single-threaded context for simplicity</span>
-->
<p><span class="caption">Encart 16-12 : découverte de l'API de <code>Mutex&lt;T&gt;</code> dans le
contexte d'une seule tâche pour raison de simplicité</span></p>
<!--
As with many types, we create a `Mutex<T>` using the associated function `new`.
To access the data inside the mutex, we use the `lock` method to acquire the
lock. This call will block the current thread so it can’t do any work until
it’s our turn to have the lock.
-->
<p>Comme avec beaucoup de types, nous créons un <code>Mutex&lt;T&gt;</code> en utilisant la
fonction associée <code>new</code>. Pour accéder à la donnée dans le mutex, nous utilisons
la méthode <code>lock</code> pour obtenir le verrou. Cela va bloquer la tâche courante,
donc elle ne s'exécutera plus tant que ce n'est à notre tour d'avoir le verrou.</p>
<!--
The call to `lock` would fail if another thread holding the lock panicked. In
that case, no one would ever be able to get the lock, so we’ve chosen to
`unwrap` and have this thread panic if we’re in that situation.
-->
<p>L'appel à <code>lock</code> va échouer dans le cas où une autre tâche qui avait le verrou
paniquerait. Dans ce cas, personne ne pourra obtenir le verrou, donc nous avons
choisi d'utiliser <code>unwrap</code> pour faire en sorte que cette tâche panique si elle
est dans cette situation.</p>
<!--
After we’ve acquired the lock, we can treat the return value, named `num` in
this case, as a mutable reference to the data inside. The type system ensures
that we acquire a lock before using the value in `m`: `Mutex<i32>` is not an
`i32`, so we *must* acquire the lock to be able to use the `i32` value. We
can’t forget; the type system won’t let us access the inner `i32` otherwise.
-->
<p>Après avoir obtenu le verrou, nous pouvons utiliser la valeur de retour comme
une référence mutable vers la donnée, qui s'appellera <code>nombre</code> dans ce cas. Le
système de type s'assure que nous obtenons le verrou avant d'utiliser la valeur
présente dans <code>m</code> : le <code>Mutex&lt;i32&gt;</code> n'est pas un <code>i32</code>, donc nous <em>devons</em>
obtenir le verrou pour pouvoir utiliser la valeur <code>i32</code>. Nous ne pouvons pas
l'oublier ; le système de type ne nous laissera pas accéder au <code>i32</code> à
l'intérieur de toute façon.</p>
<!--
As you might suspect, `Mutex<T>` is a smart pointer. More accurately, the call
to `lock` *returns* a smart pointer called `MutexGuard`, wrapped in a
`LockResult` that we handled with the call to `unwrap`. The `MutexGuard` smart
pointer implements `Deref` to point at our inner data; the smart pointer also
has a `Drop` implementation that releases the lock automatically when a
`MutexGuard` goes out of scope, which happens at the end of the inner scope in
Listing 16-12. As a result, we don’t risk forgetting to release the lock and
blocking the mutex from being used by other threads because the lock release
happens automatically.
-->
<p>Comme vous pouvez vous en douter, <code>Mutex&lt;T&gt;</code> est un pointeur intelligent. Plus
précisément, l'appel à <code>lock</code> <em>retourne</em> un pointeur intelligent <code>MutexGuard</code>,
intégré dans un <code>LockResult</code> que nous avons géré en faisant appel à <code>unwrap</code>.
Le pointeur intelligent <code>MutexGuard</code> implémente <code>Deref</code> pour pouvoir pointer
sur la donnée interne ; ce pointeur intelligent implémente aussi <code>Drop</code> qui
libère le verrou automatiquement lorsqu'un <code>MutexGuard</code> sort de la portée, ce
qui arrive à la fin de la portée interne dans l'encart 16-12. Au final, nous ne
risquons d'oublier de rendre le verrou et ainsi bloquer l'utilisation du mutex
par les autres tâches car la libération du verrou se produit automatiquement.</p>
<!--
After dropping the lock, we can print the mutex value and see that we were able
to change the inner `i32` to 6.
-->
<p>Après avoir libéré le verrou, nous pouvons afficher la valeur dans le mutex et
constater que nous avons pu changer la valeur interne du <code>i32</code> à <code>6</code>.</p>
<!--
#### Sharing a `Mutex<T>` Between Multiple Threads
-->
<h4 id="partager-un-mutext-entre-plusieurs-tâches"><a class="header" href="#partager-un-mutext-entre-plusieurs-tâches">Partager un <code>Mutex&lt;T&gt;</code> entre plusieurs tâches</a></h4>
<!--
Now, let’s try to share a value between multiple threads using `Mutex<T>`.
We’ll spin up 10 threads and have them each increment a counter value by 1, so
the counter goes from 0 to 10. The next example in Listing 16-13 will have
a compiler error, and we’ll use that error to learn more about using
`Mutex<T>` and how Rust helps us use it correctly.
-->
<p>Essayons maintenant de partager une valeur entre plusieurs tâches en utilisant
<code>Mutex&lt;T&gt;</code>. Nous allons faire fonctionner 10 tâches et faire en sorte que
chacune augmente la valeur du compteur de 1, donc le compteur va passer de 0
à 10. Le prochain exemple dans l'encart 16-13 débouchera sur une erreur de
compilation, et nous allons utiliser cette erreur pour en apprendre plus sur
l'utilisation de <code>Mutex&lt;T&gt;</code> et sur comment Rust nous aide à l'utiliser
correctement.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let compteur = Mutex::new(0);
    let mut manipulateurs = vec![];

    for _ in 0..10 {
        let manipulateur = thread::spawn(move || {
            let mut nombre = compteur.lock().unwrap();

            *nombre += 1;
        });
        manipulateurs.push(manipulateur);
    }

    for manipulateur in manipulateurs {
        manipulateur.join().unwrap();
    }

    println!(&quot;Resultat : {}&quot;, *compteur.lock().unwrap());
}
</code></pre>
<!--
<span class="caption">Listing 16-13: Ten threads each increment a counter
guarded by a `Mutex<T>`</span>
-->
<p><span class="caption">Encart 16-13 : dix tâches qui augmentent chacune un
compteur gardé par un <code>Mutex&lt;T&gt;</code></span></p>
<!--
We create a `counter` variable to hold an `i32` inside a `Mutex<T>`, as we
did in Listing 16-12. Next, we create 10 threads by iterating over a range
of numbers. We use `thread::spawn` and give all the threads the same closure,
one that moves the counter into the thread, acquires a lock on the `Mutex<T>`
by calling the `lock` method, and then adds 1 to the value in the mutex. When a
thread finishes running its closure, `num` will go out of scope and release the
lock so another thread can acquire it.
-->
<p>Nous avons créé une variable <code>compteur</code> pour stocker un <code>i32</code> dans un
<code>Mutex&lt;T&gt;</code>, comme nous l'avons fait dans l'encart 16-12. Ensuite, nous créons
10 tâches en itérant sur un intervalle de nombres. Nous utilisons
<code>thread::spawn</code> et nous donnons à toutes les tâches la même fermeture, qui
déplace le compteur dans la tâche, obtient le verrou sur le <code>Mutex&lt;T&gt;</code> en
faisant appel à la méthode <code>lock</code>, et on ajoute ensuite 1 à la valeur présente
dans le mutex. Lorsqu'une tâche finit d'exécuter sa fermeture, <code>nombre</code> va
sortir de la portée et va libérer le verrou afin qu'une autre tâche puisse
l'obtenir.</p>
<!--
In the main thread, we collect all the join handles. Then, as we did in Listing
16-2, we call `join` on each handle to make sure all the threads finish. At
that point, the main thread will acquire the lock and print the result of this
program.
-->
<p>Dans la tâche principale, nous collectons tous les manipulateurs. Ensuite,
comme nous l'avions fait dans l'encart 16-2, nous faisons appel à <code>join</code> sur
chaque manipulateur pour s'assurer que toutes les tâches ont fini. Une fois que
c'est le cas, la tâche principale va obtenir le verrou et afficher le résultat
de ce programme.</p>
<!--
We hinted that this example wouldn’t compile. Now let’s find out why!
-->
<p>Nous avions mentionné que cet exemple ne se compilerait pas. Découvrons
maintenant pourquoi !</p>
<!--
```console
$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: use of moved value: `counter`
  -- > src/main.rs:9:36
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `std::sync::Mutex<i32>`, which does not implement the `Copy` trait
...
9  |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^ value moved into closure here, in previous iteration of loop
10 |             let mut num = counter.lock().unwrap();
   |                           ------- use occurs due to use in closure

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: use of moved value: `compteur`
  --&gt; src/main.rs:9:36
   |
5  |     let compteur = Mutex::new(0);
   |         -------- move occurs because `compteur` has type `std::sync::Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
9  |         let manipulateur = thread::spawn(move || {
   |                                          ^^^^^^^ value moved into closure here, in previous iteration of loop
10 |             let mut nombre = compteur.lock().unwrap();
   |                              -------- use occurs due to use in closure

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The error message states that the `counter` value was moved in the previous
iteration of the loop. So Rust is telling us that we can’t move the ownership
of lock `counter` into multiple threads. Let’s fix the compiler error with a
multiple-ownership method we discussed in Chapter 15.
-->
<p>Le message d'erreur signale que la valeur <code>compteur</code> a été déplacée dans
l'itération précédente de la boucle. Donc Rust nous explique qu'il ne peut
pas déplacer la possession du verrou de <code>compteur</code> dans plusieurs tâches.
Corrigeons cette erreur de compilation avec une méthode pour avoir plusieurs
propriétaires que nous avons vu au chapitre 15.</p>
<!--
#### Multiple Ownership with Multiple Threads
-->
<h4 id="plusieurs-propriétaires-avec-plusieurs-tâches"><a class="header" href="#plusieurs-propriétaires-avec-plusieurs-tâches">Plusieurs propriétaires avec plusieurs tâches</a></h4>
<!--
In Chapter 15, we gave a value multiple owners by using the smart pointer
`Rc<T>` to create a reference counted value. Let’s do the same here and see
what happens. We’ll wrap the `Mutex<T>` in `Rc<T>` in Listing 16-14 and clone
the `Rc<T>` before moving ownership to the thread. Now that we’ve seen the
errors, we’ll also switch back to using the `for` loop, and we’ll keep the
`move` keyword with the closure.
-->
<p>Dans le chapitre 15, nous avons assigné plusieurs propriétaires à une valeur
en utilisant le pointeur intelligent <code>Rc&lt;T&gt;</code> pour créer un compteur de
référence. Faisons la même chose ici et voyons ce qui se passe. Nous allons
intégrer le <code>Mutex&lt;T&gt;</code> dans un <code>Rc&lt;T&gt;</code> dans l'encart 16-14 et cloner le <code>Rc&lt;T&gt;</code>
avant de déplacer sa possession à la tâche. Maintenant que nous avons vu les
erreurs, nous allons aussi revenir à l'utilisation de la boucle <code>for</code> et nous
allons garder le mot-clé <code>move</code> dans la fermeture.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let compteur = Rc::new(Mutex::new(0));
    let mut manipulateurs = vec![];

    for _ in 0..10 {
        let compteur = Rc::clone(&amp;compteur);
        let manipulateur = thread::spawn(move || {
            let mut nombre = compteur.lock().unwrap();

            *nombre += 1;
        });
        manipulateurs.push(manipulateur);
    }

    for manipulateur in manipulateurs {
        manipulateur.join().unwrap();
    }

    println!(&quot;Résultat : {}&quot;, *compteur.lock().unwrap());
}
</code></pre>
<!--
<span class="caption">Listing 16-14: Attempting to use `Rc<T>` to allow
multiple threads to own the `Mutex<T>`</span>
-->
<p><span class="caption">Encart 16-14 : tentative d'utilisation d'un <code>Rc&lt;T&gt;</code> pour
nous permettre d'utiliser plusieurs tâches qui posséderont le <code>Mutex&lt;T&gt;</code></span></p>
<!--
Once again, we compile and get... different errors! The compiler is teaching us
a lot.
-->
<p>A nouveau, nous compilons et nous obtenons ... une erreur différente ! Le
compilateur nous en apprend beaucoup.</p>
<!--
```console
$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `std::rc::Rc<std::sync::Mutex<i32>>` cannot be sent between threads safely
   -- > src/main.rs:11:22
    |
11  |         let handle = thread::spawn(move || {
    |                      ^^^^^^^^^^^^^ `std::rc::Rc<std::sync::Mutex<i32>>` cannot be sent between threads safely
    |
    = help: within `[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc<std::sync::Mutex<i32>>]`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::sync::Mutex<i32>>`
    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc<std::sync::Mutex<i32>>]`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:11:22
    |
11  |         let manipulateur = thread::spawn(move || {
    |                            ^^^^^^^^^^^^^ `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
    |
    = help: within `[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`, the trait `std::marker::Send` is not implemented for `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Wow, that error message is very wordy! Here’s the important part to focus
on: `` `Rc<Mutex<i32>>` cannot be sent between threads safely ``. The compiler
is also telling us the reason why: ``the trait `Send` is not implemented for
`Rc<Mutex<i32>>` ``. We’ll talk about `Send` in the next section: it’s one of
the traits that ensures the types we use with threads are meant for use in
concurrent situations.
-->
<p>Ouah, ce message d'erreur est très bavard ! Voici la partie la plus importante
sur laquelle se concentrer :
<code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>. Le compilateur
nous indique aussi pour quelle raison :
<code>the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;` </code>. Nous allons voir
<code>Send</code> dans la prochaine section : c'est l'un des traits qui garantissent que le
type que nous utilisons avec les tâches est prévu pour être utilisé dans des
situations de concurrence.</p>
<!--
Unfortunately, `Rc<T>` is not safe to share across threads. When `Rc<T>`
manages the reference count, it adds to the count for each call to `clone` and
subtracts from the count when each clone is dropped. But it doesn’t use any
concurrency primitives to make sure that changes to the count can’t be
interrupted by another thread. This could lead to wrong counts—subtle bugs that
could in turn lead to memory leaks or a value being dropped before we’re done
with it. What we need is a type exactly like `Rc<T>` but one that makes changes
to the reference count in a thread-safe way.
-->
<p>Malheureusement, <code>Rc&lt;T&gt;</code> n'est pas sûr pour l'utilisation entre des tâches.
Lorsque <code>Rc&lt;T&gt;</code> gère le compteur de références, il incrémente le compteur autant
de fois que nous avons fait appel à <code>clone</code> et décrémente le compteur à chaque
fois qu'un clone est libéré. Mais il n'utilise pas de primitives de concurrence
pour s'assurer que les changements faits au compteur ne peuvent pas être
interrompus par une autre tâche. Cela pourrait provoquer subtilement des bogues
à cause d'une mauvaise gestion du compteur, qui pourraient provoquer des fuites
de mémoire ou faire en sorte qu'une valeur soit libérée avant que nous ayons
fini de l'utiliser. Nous avons besoin d'un type exactement comme <code>Rc&lt;T&gt;</code> mais
qui procède aux changements du compteur de références de manière sûr dans des
situations concurrentes.</p>
<!--
#### Atomic Reference Counting with `Arc<T>`
-->
<h4 id="compteur-de-référence-atomique-avec-arct"><a class="header" href="#compteur-de-référence-atomique-avec-arct">Compteur de référence atomique avec <code>Arc&lt;T&gt;</code></a></h4>
<!--
Fortunately, `Arc<T>` *is* a type like `Rc<T>` that is safe to use in
concurrent situations. The *a* stands for *atomic*, meaning it’s an *atomically
reference counted* type. Atomics are an additional kind of concurrency
primitive that we won’t cover in detail here: see the standard library
documentation for [`std::sync::atomic`] for more details. At this point, you just
need to know that atomics work like primitive types but are safe to share
across threads.
-->
<p>Heureusement, <code>Arc&lt;T&gt;</code> <em>est</em> un type comme <code>Rc&lt;T&gt;</code> qui est sûr lors de
situations concurrentes. Le <em>A</em> signifie <em>atomique</em>, ce qui signifie que c'est
le type <em>compteur de références atomique</em>. L'atome est une sorte de primitive
concurrente que nous n'allons pas aborder en détails ici : rendez-vous dans la
documentation de la bibliothèque standard sur <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code></a> pour en
savoir plus. Pour le moment, vous avez juste besoin de retenir que les atomes
fonctionnent comme les types primitifs mais qui son sûrs pour l'échange entre
les tâches.</p>
<!--
[`std::sync::atomic`]: ../std/sync/atomic/index.html
-->
<!--
You might then wonder why all primitive types aren’t atomic and why standard
library types aren’t implemented to use `Arc<T>` by default. The reason is that
thread safety comes with a performance penalty that you only want to pay when
you really need to. If you’re just performing operations on values within a
single thread, your code can run faster if it doesn’t have to enforce the
guarantees atomics provide.
-->
<p>Vous vous demandez pourquoi tous les types primitifs ne sont pas atomiques et
pourquoi les types de la bibliothèque standard ne sont pas implémentés en
utilisant <code>Arc&lt;T&gt;</code> par défaut. La raison à cela est que la sécurité entre les
tâches a un coût sur les performances que vous n'êtes prêt à payer que lorsque
vous en avez besoin. Si vous procédez à des opérations sur des valeurs
uniquement dans une seule tâche, votre code va s'exécuter plus vite car il n'a
pas besoin de garantir de que les atomes fournissent.</p>
<!--
Let’s return to our example: `Arc<T>` and `Rc<T>` have the same API, so we fix
our program by changing the `use` line, the call to `new`, and the call to
`clone`. The code in Listing 16-15 will finally compile and run:
-->
<p>Retournons à notre exemple : <code>Arc&lt;T&gt;</code> et <code>Rc&lt;T&gt;</code> ont la même API, donc
corrigeons notre programme en changeant la ligne <code>use</code>, l'appel à <code>new</code>, et
l'appel à <code>clone</code>. Le code dans l'encart 16-15 va finalement se compiler et
s'exécuter :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let compteur = Arc::new(Mutex::new(0));
    let mut manipulateurs = vec![];

    for _ in 0..10 {
        let compteur = Arc::clone(&amp;compteur);
        let manipulateur = thread::spawn(move || {
            let mut nombre = compteur.lock().unwrap();

            *nombre += 1;
        });
        manipulateurs.push(manipulateur);
    }

    for manipulateur in manipulateurs {
        manipulateur.join().unwrap();
    }

    println!(&quot;Résultat : {}&quot;, *compteur.lock().unwrap());
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-15: Using an `Arc<T>` to wrap the `Mutex<T>`
to be able to share ownership across multiple threads</span>
-->
<p><span class="caption">Encart 16-15 : utilisation d'un <code>Arc&lt;T&gt;</code> pour englober
le <code>Mutex&lt;T&gt;</code> afin de partager la possession entre plusieurs tâches</span></p>
<!--
This code will print the following:
-->
<p>Ce code va finalement afficher ceci :</p>
<!--
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -- >
-->
<!--
```text
Result: 10
```
-->
<pre><code class="language-text">Resultat : 10
</code></pre>
<!--
We did it! We counted from 0 to 10, which may not seem very impressive, but it
did teach us a lot about `Mutex<T>` and thread safety. You could also use this
program’s structure to do more complicated operations than just incrementing a
counter. Using this strategy, you can divide a calculation into independent
parts, split those parts across threads, and then use a `Mutex<T>` to have each
thread update the final result with its part.
-->
<p>Nous y sommes arrivés ! Nous avons compté de 0 à 10, ce qui ne semble pas très
impressionnant, mais cela nous a appris beaucoup sur <code>Mutex&lt;T&gt;</code> et la sécurité
entre les tâches. Vous pouvez aussi utiliser cette structure de programme pour
procéder à des opérations plus complexes que simplement incrémenter un
compteur. En utilisant cette stratégie, vous pouvez diviser un calcul en
différentes parties, répartir ces parties sur des tâches, et ensuite utiliser
un <code>Mutex&lt;T&gt;</code> pour faire en sorte que chaque tâche mette à jour le résultat
final avec sa propre partie.</p>
<!--
### Similarities Between `RefCell<T>`/`Rc<T>` and `Mutex<T>`/`Arc<T>`
-->
<h3 id="similarités-entre-refcelltrct-et-mutextarct"><a class="header" href="#similarités-entre-refcelltrct-et-mutextarct">Similarités entre <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> et <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></a></h3>
<!--
You might have noticed that `counter` is immutable but we could get a mutable
reference to the value inside it; this means `Mutex<T>` provides interior
mutability, as the `Cell` family does. In the same way we used `RefCell<T>` in
Chapter 15 to allow us to mutate contents inside an `Rc<T>`, we use `Mutex<T>`
to mutate contents inside an `Arc<T>`.
-->
<p>Vous avez peut-être constaté que <code>compteur</code> est immuable mais que nous pouvons
obtenir une référence mutable vers la valeur qu'il renferme ; cela signifie que
<code>Mutex&lt;T&gt;</code> a une mutabilité interne, comme le fait la famille des <code>Cell</code>. De la
même manière que nous avons utilisé <code>RefCell&lt;T&gt;</code> au chapitre 15 pour nous
permettre de changer le contenu dans un <code>Rc&lt;T&gt;</code>, nous utilisons <code>Mutex&lt;T&gt;</code> pour
modifier le contenu d'un <code>Arc&lt;T&gt;</code>.</p>
<!--
Another detail to note is that Rust can’t protect you from all kinds of logic
errors when you use `Mutex<T>`. Recall in Chapter 15 that using `Rc<T>` came
with the risk of creating reference cycles, where two `Rc<T>` values refer to
each other, causing memory leaks. Similarly, `Mutex<T>` comes with the risk of
creating *deadlocks*. These occur when an operation needs to lock two resources
and two threads have each acquired one of the locks, causing them to wait for
each other forever. If you’re interested in deadlocks, try creating a Rust
program that has a deadlock; then research deadlock mitigation strategies for
mutexes in any language and have a go at implementing them in Rust. The
standard library API documentation for `Mutex<T>` and `MutexGuard` offers
useful information.
-->
<p>Un autre détail à souligner est Rust ne peut pas vous protéger de tous les
genres d'erreurs de logique lorsque vous utilisez <code>Mutex&lt;T&gt;</code>. Souvenez-vous
que le chapitre 15 utilisait <code>Rc&lt;T&gt;</code> avec le risque de créer des boucles de
références, dans lesquelles deux valeurs <code>Rc&lt;T&gt;</code> se référeraient l'une à
l'autre, ce qui provoquait des fuites de mémoire. De la même manière,
l'utilisation de <code>Mutex&lt;T&gt;</code> risque de créer des <em>interblocages</em>. Cela se produit
lorsqu'une opération nécessite de verrouiller deux ressources et que deux tâches
ont chacune un des deux verrous, ce qui fait qu'elles s'attendent mutuellement
pour toujours. Si vous êtes intéressés par les interblocages, essayez de créer
un programme Rust qui a un interblocage ; recherchez ensuite des stratégies pour
pallier aux interblocages dans n'importe quel langage et implémentez-les en
Rust. La documentation de l'API de la bibliothèque standard pour <code>Mutex&lt;T&gt;</code> et
<code>MutexGuard</code> offre des informations précieuses à ce sujet.</p>
<!--
We’ll round out this chapter by talking about the `Send` and `Sync` traits and
how we can use them with custom types.
-->
<p>Nous allons terminer ce chapitre en parlant des traits <code>Send</code> et <code>Sync</code> et
voir comment nous pouvons les utiliser sur des types personnalisés.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--17"><a class="header" href="#-attention-peinture-fraîche--17">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/202">Pull Request</a>.</p>
</blockquote>
<!--
## Extensible Concurrency with the `Sync` and `Send` Traits
-->
<h2 id="etendre-la-concurrence-avec-les-traits-sync-et-send"><a class="header" href="#etendre-la-concurrence-avec-les-traits-sync-et-send">Etendre la concurrence avec les traits <code>Sync</code> et <code>Send</code></a></h2>
<!--
Interestingly, the Rust language has *very* few concurrency features. Almost
every concurrency feature we’ve talked about so far in this chapter has been
part of the standard library, not the language. Your options for handling
concurrency are not limited to the language or the standard library; you can
write your own concurrency features or use those written by others.
-->
<p>Curieusement, le langage Rust a <em>très</em> peu de fonctionnalités de concurrence.
La plupart des fonctionnalités de concurrence que nous avons vu précédemment
dans ce chapitre font partie de la bibliothèque standard, pas du langage. Vos
options pour gérer la concurrence ne sont pas limitées à celles du langage ou
de la bibliothèque standard ; vous pouvez aussi écrire vos propres
fonctionnalités de concurrence ou utiliser celles qui ont été écrites par
d'autres.</p>
<!--
However, two concurrency concepts are embedded in the language: the
`std::marker` traits `Sync` and `Send`.
-->
<p>Cependant, deux concepts de concurrence sont intégrés dans le langage : les
traits <code>Sync</code> et <code>Send</code> de <code>std::marker</code>.</p>
<!--
### Allowing Transference of Ownership Between Threads with `Send`
-->
<h3 id="permettre-le-transfert-de-possession-entre-les-tâches-avec-send"><a class="header" href="#permettre-le-transfert-de-possession-entre-les-tâches-avec-send">Permettre le transfert de possession entre les tâches avec <code>Send</code></a></h3>
<!--
The `Send` marker trait indicates that ownership of the type implementing
`Send` can be transferred between threads. Almost every Rust type is `Send`,
but there are some exceptions, including `Rc<T>`: this cannot be `Send` because
if you cloned an `Rc<T>` value and tried to transfer ownership of the clone to
another thread, both threads might update the reference count at the same time.
For this reason, `Rc<T>` is implemented for use in single-threaded situations
where you don’t want to pay the thread-safe performance penalty.
-->
<p>Le trait <code>Send</code> indique que la possession du type qui implémente <code>Send</code> peut
être transféré entre plusieurs tâches. Presque tous les types de Rust
implémentent <code>Send</code>, mais il subsiste quelques exceptions, comme <code>Rc&lt;T&gt;</code> : il
ne peut pas implémenter <code>Send</code> car si vous clonez une valeur <code>Rc&lt;T&gt;</code> et que
vous essayez de transférer la possession de ce clone à une autre tâche, les
deux tâches peuvent modifier le compteur de référence en même temps. Pour cette
raison, <code>Rc&lt;T&gt;</code> est prévu pour une utilisation dans des situations qui
nécessitent qu'une seule tâche dans lesquelles vous n'avez pas besoin de subir
le coût sur la performance imposé par la sécurité entre les tâches.</p>
<!--
Therefore, Rust’s type system and trait bounds ensure that you can never
accidentally send an `Rc<T>` value across threads unsafely. When we tried to do
this in Listing 16-14, we got the error `the trait Send is not implemented for
Rc<Mutex<i32>>`. When we switched to `Arc<T>`, which is `Send`, the code
compiled.
-->
<p>Toutefois, le système de type et de traits liés de Rust garantit que vous ne
pourrez jamais envoyer accidentellement en toute insécurité une valeur <code>Rc&lt;T&gt;</code>
entre des tâches. Lorsque nous avons essayé de faire cela dans l'encart 16-14,
nous avons obtenu l'erreur
<code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>. Lorsque nous l'avons
changé pour un <code>Arc&lt;T&gt;</code>, qui implémente <code>Send</code>, le code s'est compilé.</p>
<!--
Any type composed entirely of `Send` types is automatically marked as `Send` as
well. Almost all primitive types are `Send`, aside from raw pointers, which
we’ll discuss in Chapter 19.
-->
<p>Tous les types composés entièrement d'autres types qui implémentent <code>Send</code> sont
automatiquement marqués comme <code>Send</code> eux-aussi. Presque la plupart des types
primitifs sont <code>Send</code>, à part les pointeurs bruts, ce que nous avons verrons au
chapitre 19.</p>
<!--
### Allowing Access from Multiple Threads with `Sync`
-->
<h3 id="permettre-laccès-à-plusieurs-tâches-avec-sync"><a class="header" href="#permettre-laccès-à-plusieurs-tâches-avec-sync">Permettre l'accès à plusieurs tâches avec <code>Sync</code></a></h3>
<!--
The `Sync` marker trait indicates that it is safe for the type implementing
`Sync` to be referenced from multiple threads. In other words, any type `T` is
`Sync` if `&T` (a reference to `T`) is `Send`, meaning the reference can be
sent safely to another thread. Similar to `Send`, primitive types are `Sync`,
and types composed entirely of types that are `Sync` are also `Sync`.
-->
<p>Le trait <code>Sync</code> indique qu'il est sûr d'avoir une référence dans plusieurs
tâches vers le type qui implémente <code>Sync</code>. Autrement dit, n'importe quel type
<code>T</code> implémente <code>Sync</code> si <code>&amp;T</code> (une référence vers <code>T</code>) implémente <code>Send</code>, ce
qui signifie que la référence peut être envoyée en toute sécurité à une autre
tâche. De la même manière que <code>Send</code>, les types primitifs implémentent <code>Sync</code>,
et les types composés entièrement d'autres types qui implémentent <code>Sync</code> sont
eux-mêmes <code>Sync</code>.</p>
<!--
The smart pointer `Rc<T>` is also not `Sync` for the same reasons that it’s not
`Send`. The `RefCell<T>` type (which we talked about in Chapter 15) and the
family of related `Cell<T>` types are not `Sync`. The implementation of borrow
checking that `RefCell<T>` does at runtime is not thread-safe. The smart
pointer `Mutex<T>` is `Sync` and can be used to share access with multiple
threads as you saw in the [“Sharing a `Mutex<T>` Between Multiple
Threads”][sharing-a-mutext-between-multiple-threads]<!-- ignore -- > section.
-->
<p>Le pointeur intelligent <code>Rc&lt;T&gt;</code> n'implémente pas non plus <code>Sync</code> pour les mêmes
raisons qu'il n'implémente pas <code>Send</code>. Le type <code>RefCell&lt;T&gt;</code> (que nous avons vu
au chapitre 15) la famille liée aux types <code>Cell&lt;T&gt;</code> n'implémentent pas <code>Sync</code>.
L'implémentation du vérificateur d'emprunt que fait <code>RefCell&lt;T&gt;</code> à l'exécution
n'est pas sûre entre plusieurs tâches. Le pointeur intelligent <code>Mutex&lt;T&gt;</code>
implémente <code>Sync</code> et peut être utilisé pour partager l'accès entre plusieurs
tâches, comme vous l'avez vu dans la section précédente.</p>
<!--
### Implementing `Send` and `Sync` Manually Is Unsafe
-->
<h3 id="implémenter-manuellement-send-et-sync-nest-pas-sûr"><a class="header" href="#implémenter-manuellement-send-et-sync-nest-pas-sûr">Implémenter manuellement <code>Send</code> et <code>Sync</code> n'est pas sûr</a></h3>
<!--
Because types that are made up of `Send` and `Sync` traits are automatically
also `Send` and `Sync`, we don’t have to implement those traits manually. As
marker traits, they don’t even have any methods to implement. They’re just
useful for enforcing invariants related to concurrency.
-->
<p>Comme les types qui sont constitués de types implémentant les traits <code>Send</code> et
<code>Sync</code> sont automatiquement des <code>Send</code> et <code>Sync</code>, nous n'avons pas à
implémenter manuellement ces traits. Comme ce sont des traits de marquage, ils
n'ont même pas de méthodes à implémenter. Ils sont uniquement utiles pour
appliquer les règles de concurrence.</p>
<!--
Manually implementing these traits involves implementing unsafe Rust code.
We’ll talk about using unsafe Rust code in Chapter 19; for now, the important
information is that building new concurrent types not made up of `Send` and
`Sync` parts requires careful thought to uphold the safety guarantees. [“The
Rustonomicon”][nomicon] has more information about these guarantees and how to
uphold them.
-->
<p>L'implémentation manuelle de ces traits implique de faire du code Rust non
sécurisé. Nous allons voir le code Rust non sécurisé dans le chapitre 19 ; pour
l'instant l'information à retenir est que construire de nouveaux types
pour la concurrence constitués d'éléments qui n'implémentent pas <code>Send</code> et
<code>Sync</code> nécessite une réflexion approfondie pour respecter les garanties de
sécurité. <a href="https://doc.rust-lang.org/nomicon/index.html">“The Rustonomicon”</a> contient plus d'informations à propos de
ces garanties et comment les faire appliquer.</p>
<!--
## Summary
-->
<h2 id="résumé-15"><a class="header" href="#résumé-15">Résumé</a></h2>
<!--
This isn’t the last you’ll see of concurrency in this book: the project in
Chapter 20 will use the concepts in this chapter in a more realistic situation
than the smaller examples discussed here.
-->
<p>Ce n'est pas la dernière fois que vous allez rencontrer de la concurrence dans
ce livre : le projet du chapitre 20 va utiliser les concepts de ce chapitre dans
une situation plus réaliste que les petits exemples que nous avons utilisés ici.</p>
<!--
As mentioned earlier, because very little of how Rust handles concurrency is
part of the language, many concurrency solutions are implemented as crates.
These evolve more quickly than the standard library, so be sure to search
online for the current, state-of-the-art crates to use in multithreaded
situations.
-->
<p>Nous l'avons dit précédemment, comme les outils pour gérer la concurrence de
Rust ne sont pas directement intégrés dans le langage, de nombreuses solutions
pour de la concurrence sont implémentées dans des crates. Elles évoluent plus
rapidement que la bibliothèque standard, donc assurez-vous de rechercher en
ligne des crates modernes et à la pointe de la technologie à utiliser dans des
situations multitâches.</p>
<!--
The Rust standard library provides channels for message passing and smart
pointer types, such as `Mutex<T>` and `Arc<T>`, that are safe to use in
concurrent contexts. The type system and the borrow checker ensure that the
code using these solutions won’t end up with data races or invalid references.
Once you get your code to compile, you can rest assured that it will happily
run on multiple threads without the kinds of hard-to-track-down bugs common in
other languages. Concurrent programming is no longer a concept to be afraid of:
go forth and make your programs concurrent, fearlessly!
-->
<p>La bibliothèque standard de Rust fournit les canaux pour l'envoi de messages et
les types de pointeurs intelligents, comme <code>Mutex&lt;T&gt;</code> et <code>Arc&lt;T&gt;</code>, qui sont sûr
à utiliser en concurrence. Le système de type et le vérificateur d'emprunt sont
là pour s'assurer que le code utilisé dans ces solutions ne vont pas conduire à
des situations de concurrence ou utiliser des références qui ne sont plus en
vigueur. Une fois que votre code se compile, vous pouvez être assuré qu'il
fonctionnera bien sur plusieurs tâches sans avoir les genres de bogues
<em>difficiles à traquer</em> qui sont monnaie courante dans les autres langages. Le
développement en concurrence n'est un domaine qui ne devrait plus faire peur :
lancez-vous et appliquez la concurrence à vos programmes sans en avoir crainte !</p>
<!--
Next, we’ll talk about idiomatic ways to model problems and structure solutions
as your Rust programs get bigger. In addition, we’ll discuss how Rust’s idioms
relate to those you might be familiar with from object-oriented programming.
-->
<p>Au chapitre suivant, nous allons voir des techniques adaptées pour modéliser des
problèmes et structurer votre solution au fur et à mesure que vos programmes en
Rust grandissent. De plus, nous analyserons les liens qui peuvent exister entre
les idées de Rust et celles avec lesquelles vous êtes peut-être familier en
programmation orientée objet.</p>
<!--
[sharing-a-mutext-between-multiple-threads]:
ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads
[nomicon]: ../nomicon/index.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Object Oriented Programming Features of Rust
-->
<h1 id="les-fonctionnalités-orientées-objet-de-rust"><a class="header" href="#les-fonctionnalités-orientées-objet-de-rust">Les fonctionnalités orientées objet de Rust</a></h1>
<!--
Object-oriented programming (OOP) is a way of modeling programs. Objects came
from Simula in the 1960s. Those objects influenced Alan Kay’s programming
architecture in which objects pass messages to each other. He coined the term
*object-oriented programming* in 1967 to describe this architecture. Many
competing definitions describe what OOP is; some definitions would classify
Rust as object oriented, but other definitions would not. In this chapter,
we’ll explore certain characteristics that are commonly considered object
oriented and how those characteristics translate to idiomatic Rust. We’ll then
show you how to implement an object-oriented design pattern in Rust and discuss
the trade-offs of doing so versus implementing a solution using some of Rust’s
strengths instead.
-->
<p>La programmation orientée objet (POO) est une façon de concevoir des programmes.
Les objets sont apparus dans Simula dans les années 1960. Ces objets ont
influencé l'architecture de programmation d'Alan Kay dans laquelle les objets
s'envoient des messages. Il a inventé le terme <em>programmation orientée objet</em> en
1967 pour décrire cette architecture. Plusieurs définitions de la POO
s'opposent ; Rust est considéré comme orienté objet selon certaines définitions
mais pas par d'autres. Dans ce chapitre, nous examinerons certaines
caractéristiques généralement considérées comme orientées objet et nous verrons
comment ces caractéristiques se traduisent en code Rust traditionnel. Puis nous
vous montrerons comment implémenter un patron de conception orienté objet en
Rust et nous comparerons les avantages et inconvénients de faire cela plutôt que
d'implémenter une solution qui utilise quelques points forts de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--18"><a class="header" href="#-attention-peinture-fraîche--18">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/220">Pull Request</a>.</p>
</blockquote>
<!--
## Characteristics of Object-Oriented Languages
-->
<h2 id="les-caractéristiques-des-langages-orientés-objet"><a class="header" href="#les-caractéristiques-des-langages-orientés-objet">Les caractéristiques des langages orientés objet</a></h2>
<!--
There is no consensus in the programming community about what features a
language must have to be considered object oriented. Rust is influenced by many
programming paradigms, including OOP; for example, we explored the features
that came from functional programming in Chapter 13. Arguably, OOP languages
share certain common characteristics, namely objects, encapsulation, and
inheritance. Let’s look at what each of those characteristics means and whether
Rust supports it.
-->
<p>Les développeurs ne se sont jamais entendus sur les fonctionnalités qu'un
langage doit avoir pour être considéré orienté objet. Rust est influencé par
de nombreux paradigmes de programmation, y compris la POO ; par exemple, nous
avons examiné les fonctionnalités issues de la programmation fonctionnelle au
chapitre 13. On peut vraisemblablement dire que les langages orientés objet ont
plusieurs caractéristiques en commun, comme les objets, l'encapsulation et
l'héritage. Examinons chacune de ces caractéristiques et regardons si Rust
les supporte.</p>
<!--
### Objects Contain Data and Behavior
-->
<h3 id="les-objets-contiennent-des-données-et-suivent-un-comportement"><a class="header" href="#les-objets-contiennent-des-données-et-suivent-un-comportement">Les objets contiennent des données et suivent un comportement</a></h3>
<!--
The book *Design Patterns: Elements of Reusable Object-Oriented Software* by
Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley
Professional, 1994) colloquially referred to as *The Gang of Four* book, is a
catalog of object-oriented design patterns. It defines OOP this way:
-->
<p>Le livre <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>
d'Erich Gamma, Richard Helm, Ralph Johnson, et John Vlissides (Addison-Wesley
Professional, 1994) que l'on surnomme le livre du <em>Gang of Four</em>, est un
catalogue de patrons de conception orientés objet. Il définit la POO ainsi :</p>
<!--
> Object-oriented programs are made up of objects. An *object* packages both
> data and the procedures that operate on that data. The procedures are
> typically called *methods* or *operations*.
-->
<blockquote>
<p>Les programmes orientés objet sont constitués d'objets. Un <em>objet</em> regroupe
des données ainsi que les procédures qui opèrent sur ces données. Ces
procédures sont typiquement appelées <em>méthodes</em> ou <em>opérations</em>.</p>
</blockquote>
<!--
Using this definition, Rust is object oriented: structs and enums have data,
and `impl` blocks provide methods on structs and enums. Even though structs and
enums with methods aren’t *called* objects, they provide the same
functionality, according to the Gang of Four’s definition of objects.
-->
<p>Si l'on se tient à cette définition, Rust est orienté objet : les structures et
les énumérations ont des données, et les blocs <code>impl</code> leur fournissent des
méthodes. Bien que les structures et les énumérations avec des méthodes ne soient pas qualifiées
d'objets, elles en ont les fonctionnalités, d'après la définition des objets par
le <em>Gang of Four</em>.</p>
<!--
### Encapsulation that Hides Implementation Details
-->
<h3 id="lencapsulation-qui-masque-les-détails-dimplémentation"><a class="header" href="#lencapsulation-qui-masque-les-détails-dimplémentation">L'encapsulation qui masque les détails d'implémentation</a></h3>
<!--
Another aspect commonly associated with OOP is the idea of *encapsulation*,
which means that the implementation details of an object aren’t accessible to
code using that object. Therefore, the only way to interact with an object is
through its public API; code using the object shouldn’t be able to reach into
the object’s internals and change data or behavior directly. This enables the
programmer to change and refactor an object’s internals without needing to
change the code that uses the object.
-->
<p>Un autre aspect qu'on associe souvent à la POO est l'idée d'<em>encapsulation</em>, ce
qui signifie que les détails d'implémentation d'un objet ne sont pas accessibles
au code utilisant cet objet. Ainsi, la seule façon d'interagir avec un objet est
via son API publique ; le code qui utilise l'objet ne devrait pas pouvoir
accéder aux éléments internes d'un objet et changer directement ses données ou
son comportement. Cela permet au développeur de changer et remanier les éléments
internes d'un objet sans avoir à changer le code qui utilise cet objet.</p>
<!--
We discussed how to control encapsulation in Chapter 7: we can use the `pub`
keyword to decide which modules, types, functions, and methods in our code
should be public, and by default everything else is private. For example, we
can define a struct `AveragedCollection` that has a field containing a vector
of `i32` values. The struct can also have a field that contains the average of
the values in the vector, meaning the average doesn’t have to be computed
on demand whenever anyone needs it. In other words, `AveragedCollection` will
cache the calculated average for us. Listing 17-1 has the definition of the
`AveragedCollection` struct:
-->
<p>Nous avons abordé la façon de contrôler l'encapsulation au chapitre 7 : on peut
utiliser le mot-clé <code>pub</code> pour décider quels modules, types, fonctions et
méthodes de notre code devraient être publics ; par défaut, tout le reste est
privé. Par exemple, nous pouvons définir une structure <code>CollectionMoyennee</code> qui
a un champ contenant un vecteur de valeurs <code>i32</code>. La structure peut aussi avoir
un champ qui contient la moyenne des valeurs dans le vecteur de sorte qu'il ne
soit pas nécessaire de recalculer la moyenne à chaque fois que quelqu'un en a
besoin. En d'autres termes, <code>CollectionMoyennee</code> va mettre en cache la moyenne
calculée pour nous. L'encart 17-1 contient la définition de la structure
<code>CollectionMoyennee</code> :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
pub struct AveragedCollection {
    list: Vec<i32>,
    average: f64,
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CollectionMoyennee {
    liste: Vec&lt;i32&gt;,
    moyenne: f64,
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-1: An `AveragedCollection` struct that
maintains a list of integers and the average of the items in the
collection</span>
-->
<p><span class="caption">Encart 17-1 : Une structure <code>CollectionMoyennee</code> qui
contient une liste d'entiers et la moyenne des éléments de la collection</span></p>
<!--
The struct is marked `pub` so that other code can use it, but the fields within
the struct remain private. This is important in this case because we want to
ensure that whenever a value is added or removed from the list, the average is
also updated. We do this by implementing `add`, `remove`, and `average` methods
on the struct, as shown in Listing 17-2:
-->
<p>La structure est marquée <code>pub</code> de sorte que d'autres codes puissent l'utiliser,
mais les champs au sein de la structure restent privés. C'est important dans ce
cas puisque nous voulons nous assurer que lorsqu'une valeur est ajoutée ou
retirée dans la liste, la moyenne soit aussi mise à jour. Nous le faisons en
implémentant les méthodes <code>ajouter</code>, <code>retirer</code> et <code>moyenne</code> sur la structure,
comme le montre l'encart 17-2 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# pub struct AveragedCollection {
#     list: Vec<i32>,
#     average: f64,
# }
# 
impl AveragedCollection {
    pub fn add(&mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&mut self) -> Option<i32> {
        let result = self.list.pop();
        match result {
            Some(value) => {
                self.update_average();
                Some(value)
            }
            None => None,
        }
    }

    pub fn average(&self) -> f64 {
        self.average
    }

    fn update_average(&mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct CollectionMoyennee {
</span><span class="boring">    liste: Vec&lt;i32&gt;,
</span><span class="boring">    moyenne: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl CollectionMoyennee {
    pub fn ajouter(&amp;mut self, valeur: i32) {
        self.liste.push(valeur);
        self.mettre_a_jour_moyenne();
    }

    pub fn retirer(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let resultat = self.liste.pop();
        match resultat {
            Some(valeur) =&gt; {
                self.mettre_a_jour_moyenne();
                Some(valeur)
            }
            None =&gt; None,
        }
    }

    pub fn moyenne(&amp;self) -&gt; f64 {
        self.moyenne
    }

    fn mettre_a_jour_moyenne(&amp;mut self) {
        let total: i32 = self.liste.iter().sum();
        self.moyenne = total as f64 / self.liste.len() as f64;
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-2: Implementations of the public methods
`add`, `remove`, and `average` on `AveragedCollection`</span>
-->
<p><span class="caption">Encart 17-2 : Implémentations des méthodes publiques
<code>ajouter</code>, <code>retirer</code> et <code>moyenne</code> sur <code>CollectionMoyennee</code></span></p>
<!--
The public methods `add`, `remove`, and `average` are the only ways to access
or modify data in an instance of `AveragedCollection`. When an item is added
to `list` using the `add` method or removed using the `remove` method, the
implementations of each call the private `update_average` method that handles
updating the `average` field as well.
-->
<p>Les méthodes publiques <code>ajouter</code>, <code>retirer</code> et <code>moyenne</code> sont les seules façons
d'accéder ou de modifier les données d'une instance de <code>CollectionMoyennee</code>.
Lorsqu'un élément est ajouté à <code>liste</code> en utilisant la méthode <code>ajouter</code> ou
retiré en utilisant la méthode <code>retirer</code>, l'implémentation de chacune de ces
méthodes appelle la méthode privée <code>mettre_a_jour_moyenne</code> qui met à jour le
champ <code>moyenne</code> également.</p>
<!--
We leave the `list` and `average` fields private so there is no way for
external code to add or remove items to the `list` field directly; otherwise,
the `average` field might become out of sync when the `list` changes. The
`average` method returns the value in the `average` field, allowing external
code to read the `average` but not modify it.
-->
<p>Nous laissons les champs <code>liste</code> et <code>moyenne</code> privés pour qu'il soit impossible
pour du code externe d'ajouter ou de retirer des éléments dans notre champ
<code>liste</code> directement ; sinon, le champ <code>moyenne</code> pourrait ne plus être
synchronisé lorsque la liste change. La méthode <code>moyenne</code> renvoie la valeur du
champ <code>moyenne</code>, ce qui permet au code externe de lire le champ <code>moyenne</code> mais
pas de le modifier.</p>
<!--
Because we’ve encapsulated the implementation details of the struct
`AveragedCollection`, we can easily change aspects, such as the data structure,
in the future. For instance, we could use a `HashSet<i32>` instead of a
`Vec<i32>` for the `list` field. As long as the signatures of the `add`,
`remove`, and `average` public methods stay the same, code using
`AveragedCollection` wouldn’t need to change. If we made `list` public instead,
this wouldn’t necessarily be the case: `HashSet<i32>` and `Vec<i32>` have
different methods for adding and removing items, so the external code would
likely have to change if it were modifying `list` directly.
-->
<p>Puisque nous avons encapsulé les détails d'implémentation de la structure
<code>CollectionMoyennee</code>, nous pourrons aisément en changer quelques aspects, tels
que la structure de données, à l'avenir. Par exemple, nous pourrions utiliser
un <code>HashSet&lt;i32&gt;</code> plutôt qu'un <code>Vec&lt;i32&gt;</code> pour le champ <code>liste</code>. Du moment que
les signatures des méthodes publiques <code>ajouter</code>, <code>retirer</code> et <code>moyenne</code> restent
les mêmes, du code qui utilise <code>CollectionMoyennee</code> n'aurait pas besoin de
changer. En revanche, si nous avions fait en sorte que <code>liste</code> soit publique, cela n'aurait pas été
forcément le cas : <code>HashSet&lt;i32&gt;</code> et <code>Vec&lt;i32&gt;</code> ont des méthodes différentes
pour ajouter et retirer des éléments, donc il aurait vraisemblablement fallu
changer le code externe s'il modifiait directement <code>liste</code>.</p>
<!--
If encapsulation is a required aspect for a language to be considered object
oriented, then Rust meets that requirement. The option to use `pub` or not for
different parts of code enables encapsulation of implementation details.
-->
<p>Si l'encapsulation est une condition nécessaire pour qu'un langage soit
considéré orienté objet, alors Rust satisfait cette condition. La possibilité
d'utiliser <code>pub</code> ou non pour différentes parties de notre code permet
d'encapsuler les détails d'implémentation.</p>
<!--
### Inheritance as a Type System and as Code Sharing
-->
<h3 id="lhéritage-comme-système-de-type-et-comme-partage-de-code"><a class="header" href="#lhéritage-comme-système-de-type-et-comme-partage-de-code">L'héritage comme système de type et comme partage de code</a></h3>
<!--
*Inheritance* is a mechanism whereby an object can inherit from another
object’s definition, thus gaining the parent object’s data and behavior without
you having to define them again.
-->
<p>L'<em>héritage</em> est un mécanisme selon lequel un objet peut hériter de la
définition d'un autre objet, acquérant ainsi les données et le comportement de
l'objet père sans que l'on ait besoin de les redéfinir.</p>
<!--
If a language must have inheritance to be an object-oriented language, then
Rust is not one. There is no way to define a struct that inherits the parent
struct’s fields and method implementations. However, if you’re used to having
inheritance in your programming toolbox, you can use other solutions in Rust,
depending on your reason for reaching for inheritance in the first place.
-->
<p>Si un langage doit avoir de l'héritage pour être un langage orienté objet, alors
Rust n'en est pas un. Il est impossible de définir une structure qui hérite des
champs et de l'implémentation des méthodes de la structure mère. Cependant, si
vous avez l'habitude d'utiliser l'héritage dans vos programmes, vous pouvez
utiliser d'autres solutions en Rust, selon la raison pour laquelle vous vous
êtes tourné vers l'héritage en premier lieu.</p>
<!--
You choose inheritance for two main reasons. One is for reuse of code: you can
implement particular behavior for one type, and inheritance enables you to
reuse that implementation for a different type. You can share Rust code using
default trait method implementations instead, which you saw in Listing 10-14
when we added a default implementation of the `summarize` method on the
`Summary` trait. Any type implementing the `Summary` trait would have the
`summarize` method available on it without any further code. This is similar to
a parent class having an implementation of a method and an inheriting child
class also having the implementation of the method. We can also override the
default implementation of the `summarize` method when we implement the
`Summary` trait, which is similar to a child class overriding the
implementation of a method inherited from a parent class.
-->
<p>Il y a deux principales raisons de choisir l'héritage. La première raison est la
réutilisation de code : vous pouvez implémenter un comportement particulier pour
un type, et l'héritage vous permet de réutiliser cette implémentation sur un
autre type. À la place, vous pouvez partager du code Rust en utilisant des
implémentations de méthodes de trait par défaut, comme nous l'avons vu dans
l'encart 10-14 lorsque nous avons ajouté une implémentation par défaut de la
méthode <code>resumer</code> sur le trait <code>Resumable</code>. La méthode <code>resumer</code> serait alors
disponible sur tout type implémentant le trait <code>Resumable</code> sans avoir besoin de
rajouter du code. C'est comme si vous aviez une classe mère avec
l'implémentation d'une méthode et une classe fille avec une autre implémentation
de cette méthode. On peut aussi remplacer l'implémentation par défaut de la
méthode <code>resumer</code> quand on implémente le trait <code>Resumable</code>, un peu comme une
classe fille qui remplace l'implémentation d'une méthode héritée d'une classe
mère.</p>
<!--
The other reason to use inheritance relates to the type system: to enable a
child type to be used in the same places as the parent type. This is also
called *polymorphism*, which means that you can substitute multiple objects for
each other at runtime if they share certain characteristics.
-->
<p>L'autre raison d'utiliser l'héritage concerne le système de types : pour
permettre à un type fils d'être utilisé à la place d'un type père. Cela
s'appelle le <em>polymorphisme</em>, ce qui veut dire qu'on peut substituer plusieurs
objets entre eux à l'exécution s'ils partagent certaines caractéristiques.</p>
<!--
> ### Polymorphism
>
> To many people, polymorphism is synonymous with inheritance. But it’s
> actually a more general concept that refers to code that can work with data
> of multiple types. For inheritance, those types are generally subclasses.
>
> Rust instead uses generics to abstract over different possible types and
> trait bounds to impose constraints on what those types must provide. This is
> sometimes called *bounded parametric polymorphism*.
-->
<blockquote>
<h3 id="polymorphisme"><a class="header" href="#polymorphisme">Polymorphisme</a></h3>
<p>Pour beaucoup de gens, le polymorphisme est synonyme d'héritage. Mais il
s'agit en fait d'un principe plus général qui se rapporte au code manipulant
des données de divers types. Pour l'héritage, ces types sont généralement des
classes filles (ou <em>sous-classes</em>).</p>
<p>À la place, Rust utilise la généricité pour construire des abstractions des différents types et
traits liés possibles pour imposer des contraintes sur ce que ces types
doivent fournir. Cela est parfois appelé <em>polymorphisme paramétrique borné</em>.</p>
</blockquote>
<!--
Inheritance has recently fallen out of favor as a programming design solution
in many programming languages because it’s often at risk of sharing more code
than necessary. Subclasses shouldn’t always share all characteristics of their
parent class but will do so with inheritance. This can make a program’s design
less flexible. It also introduces the possibility of calling methods on
subclasses that don’t make sense or that cause errors because the methods don’t
apply to the subclass. In addition, some languages will only allow a subclass
to inherit from one class, further restricting the flexibility of a program’s
design.
-->
<p>L'héritage est récemment tombé en disgrâce en tant que solution de conception
dans plusieurs langages de programmation parce qu'il conduit souvent à partager
plus de code que nécessaire. Les classes mères ne devraient pas toujours
partager toutes leurs caractéristiques avec leurs classes filles, mais elles y
sont obligées avec l'héritage. Cela peut rendre la conception d'un programme
moins flexible. De plus, cela introduit la possibilité d'appeler des méthodes
sur des classes filles qui n'ont aucun sens ou qui entraînent des erreurs parce
que les méthodes ne s'appliquent pas à la classe fille. De plus, certains
langages ne permettront à une classe fille d'hériter que d'une seule classe, ce
qui restreint d'autant plus la flexibilité de la conception d'un programme.</p>
<!--
For these reasons, Rust takes a different approach, using trait objects instead
of inheritance. Let’s look at how trait objects enable polymorphism in Rust.
-->
<p>Voilà pourquoi Rust suit une autre approche, en utilisant des objets traits
plutôt que l'héritage. Jetons un œil à la façon dont les objets traits
permettent le polymorphisme en Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--19"><a class="header" href="#-attention-peinture-fraîche--19">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/231">Pull Request</a>.</p>
</blockquote>
<!--
## Using Trait Objects That Allow for Values of Different Types
-->
<h2 id="utiliser-les-objets-traits-qui-permettent-des-valeurs-de-types-différents"><a class="header" href="#utiliser-les-objets-traits-qui-permettent-des-valeurs-de-types-différents">Utiliser les objets traits qui permettent des valeurs de types différents</a></h2>
<!--
In Chapter 8, we mentioned that one limitation of vectors is that they can
store elements of only one type. We created a workaround in Listing 8-10 where
we defined a `SpreadsheetCell` enum that had variants to hold integers, floats,
and text. This meant we could store different types of data in each cell and
still have a vector that represented a row of cells. This is a perfectly good
solution when our interchangeable items are a fixed set of types that we know
when our code is compiled.
-->
<p>Au chapitre 8, nous avions mentionné qu'une limite des vecteurs est qu'ils ne
peuvent stocker des éléments que d'un seul type. Nous avions contourné le
problème dans l'encart 8-10 en définissant une énumération <code>Cellule</code> avec des
variantes pouvant contenir des entiers, des flottants et du texte. Ainsi, on
pouvait stocker différents types de données dans chaque cellule et quand même
avoir un vecteur qui représentait une rangée de cellules. C'est une très bonne
solution quand nos éléments interchangeables ne possèdent qu'un ensemble bien
déterminé de types que nous connaissons lors de la compilation de notre code.</p>
<!--
However, sometimes we want our library user to be able to extend the set of
types that are valid in a particular situation. To show how we might achieve
this, we’ll create an example graphical user interface (GUI) tool that iterates
through a list of items, calling a `draw` method on each one to draw it to the
screen—a common technique for GUI tools. We’ll create a library crate called
`gui` that contains the structure of a GUI library. This crate might include
some types for people to use, such as `Button` or `TextField`. In addition,
`gui` users will want to create their own types that can be drawn: for
instance, one programmer might add an `Image` and another might add a
`SelectBox`.
-->
<p>Cependant, nous avons parfois envie que l'utilisateur de notre bibliothèque
puisse étendre l'ensemble des types valides dans une situation donnée. Pour
montrer comment nous pourrions y parvenir, créons un exemple d'outil d'interface
graphique (GUI) qui itère sur une liste d'éléments et appelle une méthode
<code>afficher</code> sur chacun d'entre eux pour l'afficher à l'écran — une technique
courante pour les outils d'interface graphique. Créons une <em>crate</em> de
bibliothèque appelée <code>gui</code> qui contient la structure d'une bibliothèque
d'interface graphique. Cette <em>crate</em> pourrait inclure des types que les usagers
pourront utiliser, tels que <code>Bouton</code> ou <code>ChampDeTexte</code>. De plus, les
utilisateurs de <code>gui</code> voudront créer leurs propres types qui pourront être
affichés : par exemple, un développeur pourrait ajouter une <code>Image</code> et un autre
pourrait ajouter une <code>ListeDeroulante</code>.</p>
<!--
We won’t implement a fully fledged GUI library for this example but will show
how the pieces would fit together. At the time of writing the library, we can’t
know and define all the types other programmers might want to create. But we do
know that `gui` needs to keep track of many values of different types, and it
needs to call a `draw` method on each of these differently typed values. It
doesn’t need to know exactly what will happen when we call the `draw` method,
just that the value will have that method available for us to call.
-->
<p>Nous n'implémenterons pas une véritable bibliothèque d'interface graphique pour
cet exemple, mais nous verrons comment les morceaux pourraient s'assembler. Au
moment d'écrire la bibliothèque, nous ne pouvons pas savoir ni définir tous les
types que les autres développeurs auraient envie de créer. Mais nous savons que
<code>gui</code> doit gérer plusieurs valeurs de types différents et qu'elle
doit appeler la méthode <code>afficher</code> sur chacune de ces valeurs de types
différents. Il n'a pas besoin de savoir exactement ce qui arrivera quand on
appellera la méthode <code>afficher</code>, mais seulement de savoir que la valeur aura
cette méthode que nous pourrons appeler.</p>
<!--
To do this in a language with inheritance, we might define a class named
`Component` that has a method named `draw` on it. The other classes, such as
`Button`, `Image`, and `SelectBox`, would inherit from `Component` and thus
inherit the `draw` method. They could each override the `draw` method to define
their custom behavior, but the framework could treat all of the types as if
they were `Component` instances and call `draw` on them. But because Rust
doesn’t have inheritance, we need another way to structure the `gui` library to
allow users to extend it with new types.
-->
<p>Pour faire ceci dans un langage avec de l'héritage, nous pourrions définir une
classe <code>Composant</code> qui a une méthode <code>afficher</code>. Les autres
classes, telles que <code>Bouton</code>, <code>Image</code> et <code>ListeDeroulante</code>, hériteraient de
<code>Composant</code> et hériteraient ainsi de la méthode <code>afficher</code>. Elles pourraient
toutes redéfinir la méthode <code>afficher</code> avec leur comportement personnalisé,
mais l'environnement de développement pourrait considérer tous les types comme des instances de
<code>Composant</code> et appeler <code>afficher</code> sur chacun d'entre eux. Mais puisque Rust n'a
pas d'héritage, il nous faut un autre moyen de structurer la bibliothèque <code>gui</code>
pour permettre aux utilisateurs de la prolonger avec de nouveaux types.</p>
<!--
### Defining a Trait for Common Behavior
-->
<h3 id="définir-un-trait-pour-du-comportement-commun"><a class="header" href="#définir-un-trait-pour-du-comportement-commun">Définir un trait pour du comportement commun</a></h3>
<!--
To implement the behavior we want `gui` to have, we’ll define a trait named
`Draw` that will have one method named `draw`. Then we can define a vector that
takes a *trait object*. A trait object points to both an instance of a type
implementing our specified trait as well as a table used to look up trait
methods on that type at runtime. We create a trait object by specifying some
sort of pointer, such as a `&` reference or a `Box<T>` smart pointer, then the
`dyn` keyword, and then specifying the relevant trait. (We’ll talk about the
reason trait objects must use a pointer in Chapter 19 in the section
[“Dynamically Sized Types and the `Sized` Trait.”][dynamically-sized]<!--
ignore -- >) We can use trait objects in place of a generic or concrete type.
Wherever we use a trait object, Rust’s type system will ensure at compile time
that any value used in that context will implement the trait object’s trait.
Consequently, we don’t need to know all the possible types at compile time.
-->
<p>Pour implémenter le comportement que nous voulons donner à <code>gui</code>, nous
définirons un trait nommé <code>Affichable</code> qui aura une méthode nommée <code>afficher</code>.
Puis nous définirons un vecteur qui prend un <em>objet trait</em>. Un objet trait
pointe à la fois vers une instance d'un type implémentant le trait indiqué ainsi
que vers une table utilisée pour chercher les méthodes de trait de ce type à
l'exécution. Nous créons un objet trait en indiquant une sorte de pointeur, tel
qu'une référence <code>&amp;</code> ou un pointeur intelligent <code>Box&lt;T&gt;</code>, puis le mot-clé <code>dyn</code>
et enfin le trait en question. (Nous expliquerons pourquoi les objets traits
doivent utiliser un pointeur dans <a href="ch19-04-advanced-types.html">une section</a><!-- ignore -->
du chapitre 19.) Nous pouvons
utiliser des objets traits à la place d'un type générique ou concret. Partout où
nous utilisons un objet trait, le système de types de Rust s'assurera à la
compilation que n'importe quelle valeur utilisée dans ce contexte implémentera
le trait de l'objet trait. Ainsi, il n'est pas nécessaire de connaître tous les
types possibles à la compilation.</p>
<!--
We’ve mentioned that in Rust, we refrain from calling structs and enums
“objects” to distinguish them from other languages’ objects. In a struct or
enum, the data in the struct fields and the behavior in `impl` blocks are
separated, whereas in other languages, the data and behavior combined into one
concept is often labeled an object. However, trait objects *are* more like
objects in other languages in the sense that they combine data and behavior.
But trait objects differ from traditional objects in that we can’t add data to
a trait object. Trait objects aren’t as generally useful as objects in other
languages: their specific purpose is to allow abstraction across common
behavior.
-->
<p>Nous avons mentionné qu'en Rust, nous nous abstenons de qualifier les structures
et énumérations d'<em>objets</em> pour les distinguer des objets des autres langages.
Dans une structure ou une énumération, les données dans les champs de la
structure et le comportement dans les blocs <code>impl</code> sont séparés, alors que dans
d'autres langages, les données et le comportement se combinent en un concept
souvent qualifié d'objet. En revanche, les objets traits ressemblent davantage
aux objets des autres langages dans le sens où ils combinent des données et du
comportement. Mais les objets traits diffèrent des objets traditionnels dans le
sens où on ne peut pas ajouter des données à un objet trait. Les objets traits
ne sont généralement pas aussi utiles que les objets des autres langages : leur
but spécifique est de permettre de construire des abstractions de comportements
communs.</p>
<!--
Listing 17-3 shows how to define a trait named `Draw` with one method named
`draw`:
-->
<p>L'encart 17-3 illustre la façon de définir un trait nommé <code>Affichable</code> avec une
méthode nommée <code>afficher</code> :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
pub trait Draw {
    fn draw(&self);
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Affichable {
    fn afficher(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Affichable {
    fn afficher(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-3: Definition of the `Draw` trait</span>
-->
<p><span class="caption">Encart 17-3 : définition du trait <code>Affichable</code></span></p>
<!--
This syntax should look familiar from our discussions on how to define traits
in Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named
`Screen` that holds a vector named `components`. This vector is of type
`Box<dyn Draw>`, which is a trait object; it’s a stand-in for any type inside
a `Box` that implements the `Draw` trait.
-->
<p>Cette syntaxe devrait vous rappeler nos discussions sur comment définir des
traits au chapitre 10. Puis vient une nouvelle syntaxe : l'encart 17-4 définit
une structure <code>Ecran</code> qui contient un vecteur <code>composants</code>. Ce
vecteur est du type <code>Box&lt;dyn Affichable&gt;</code>, qui est un objet trait ; c'est un
bouche-trou pour n'importe quel type au sein d'un <code>Box</code> qui implémente le trait
<code>Affichable</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# pub trait Draw {
#     fn draw(&self);
# }
# 
pub struct Screen {
    pub components: Vec<Box<dyn Draw>>,
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Affichable {
</span><span class="boring">    fn afficher(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Ecran {
    pub composants: Vec&lt;Box&lt;dyn Affichable&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-4: Definition of the `Screen` struct with a
`components` field holding a vector of trait objects that implement the `Draw`
trait</span>
-->
<p><span class="caption">Encart 17-4 : définition de la structure <code>Ecran</code> avec un
champ <code>composants</code> contenant un vecteur d'objets traits qui implémentent le
trait <code>Affichable</code></span></p>
<!--
On the `Screen` struct, we’ll define a method named `run` that will call the
`draw` method on each of its `components`, as shown in Listing 17-5:
-->
<p>Sur la structure <code>Ecran</code>, nous allons définir une méthode nommée <code>executer</code> qui
appellera la méthode <code>afficher</code> sur chacun de ses <code>composants</code>, comme l'illustre
l'encart 17-5 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# pub trait Draw {
#     fn draw(&self);
# }
# 
# pub struct Screen {
#     pub components: Vec<Box<dyn Draw>>,
# }
# 
impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Affichable {
</span><span class="boring">    fn afficher(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Ecran {
</span><span class="boring">    pub composants: Vec&lt;Box&lt;dyn Affichable&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Ecran {
    pub fn executer(&amp;self) {
        for composant in self.composants.iter() {
            composant.afficher();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-5: A `run` method on `Screen` that calls the
`draw` method on each component</span>
-->
<p><span class="caption">Encart 17-5 : une méthode <code>executer</code> sur <code>Ecran</code> qui
appelle la méthode <code>afficher</code> sur chaque composant</span></p>
<!--
This works differently from defining a struct that uses a generic type
parameter with trait bounds. A generic type parameter can only be substituted
with one concrete type at a time, whereas trait objects allow for multiple
concrete types to fill in for the trait object at runtime. For example, we
could have defined the `Screen` struct using a generic type and a trait bound
as in Listing 17-6:
-->
<p>Cela ne fonctionne pas de la même manière que d'utiliser une structure avec un
paramètre de type générique avec des traits liés. Un paramètre de type générique
ne peut être remplacé que par un seul type concret à la fois, tandis que les
objets traits permettent à plusieurs types concrets de remplacer l'objet trait à
l'exécution. Par exemple, nous aurions pu définir la structure <code>Ecran</code> en
utilisant un type générique et un trait lié comme dans l'encart 17-6 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# pub trait Draw {
#     fn draw(&self);
# }
# 
pub struct Screen<T: Draw> {
    pub components: Vec<T>,
}

impl<T> Screen<T>
where
    T: Draw,
{
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Affichable {
</span><span class="boring">    fn afficher(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Ecran&lt;T: Affichable&gt; {
    pub composants: Vec&lt;T&gt;,
}

impl&lt;T&gt; Ecran&lt;T&gt;
where
    T: Affichable,
{
    pub fn executer(&amp;self) {
        for composant in self.composants.iter() {
            composant.afficher();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-6: An alternate implementation of the `Screen`
struct and its `run` method using generics and trait bounds</span>
-->
<p><span class="caption">Encart 17-6 : une implémentation différente de la
structure <code>Ecran</code> et de sa méthode <code>executer</code> en utilisant la généricité et les
traits liés</span></p>
<!--
This restricts us to a `Screen` instance that has a list of components all of
type `Button` or all of type `TextField`. If you’ll only ever have homogeneous
collections, using generics and trait bounds is preferable because the
definitions will be monomorphized at compile time to use the concrete types.
-->
<p>Cela nous restreint à une instance de <code>Ecran</code> qui a une liste de composants qui
sont soit tous de type <code>Bouton</code>, soit tous de type <code>ChampDeTexte</code>. Si vous ne
voulez que des collections homogènes, il est préférable d'utiliser la généricité
et les traits liés parce que les définitions seront monomorphisées à la
compilation pour utiliser les types concrets.</p>
<!--
On the other hand, with the method using trait objects, one `Screen` instance
can hold a `Vec<T>` that contains a `Box<Button>` as well as a
`Box<TextField>`. Let’s look at how this works, and then we’ll talk about the
runtime performance implications.
-->
<p>D'un autre côté, en utilisant des objets traits, une instance de <code>Ecran</code> peut
contenir un <code>Vec&lt;T&gt;</code> qui contient à la fois un <code>Box&lt;Bouton&gt;</code> et un
<code>Box&lt;ChampDeTexte&gt;</code>. Regardons comment cela fonctionne, puis nous parlerons
ensuite du coût en performances à l'exécution.</p>
<!--
### Implementing the Trait
-->
<h3 id="implémenter-le-trait"><a class="header" href="#implémenter-le-trait">Implémenter le trait</a></h3>
<!--
Now we’ll add some types that implement the `Draw` trait. We’ll provide the
`Button` type. Again, actually implementing a GUI library is beyond the scope
of this book, so the `draw` method won’t have any useful implementation in its
body. To imagine what the implementation might look like, a `Button` struct
might have fields for `width`, `height`, and `label`, as shown in Listing 17-7:
-->
<p>Ajoutons maintenant quelques types qui implémentent le trait <code>Affichable</code>. Nous
fournirons le type <code>Bouton</code>. Encore une fois, implémenter une vraie bibliothèque
d'interface graphique dépasse la portée de ce livre, alors la méthode <code>afficher</code>
n'aura pas d'implémentation utile dans son corps. Pour imaginer à quoi pourrait
ressembler l'implémentation, une structure <code>Bouton</code> pourrait avoir des champs
<code>largeur</code>, <code>hauteur</code> et <code>libelle</code>, comme l'illustre l'encart 17-7 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# pub trait Draw {
#     fn draw(&self);
# }
# 
# pub struct Screen {
#     pub components: Vec<Box<dyn Draw>>,
# }
# 
# impl Screen {
#     pub fn run(&self) {
#         for component in self.components.iter() {
#             component.draw();
#         }
#     }
# }
# 
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&self) {
        // code to actually draw a button
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub trait Affichable {
</span><span class="boring">    fn afficher(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Ecran {
</span><span class="boring">    pub composants: Vec&lt;Box&lt;dyn Affichable&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Ecran {
</span><span class="boring">    pub fn executer(&amp;self) {
</span><span class="boring">        for composant in self.composants.iter() {
</span><span class="boring">            composant.afficher();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Bouton {
    pub largeur: u32,
    pub hauteur: u32,
    pub libelle: String,
}

impl Affichable for Bouton {
    fn afficher(&amp;self) {
        // code servant vraiment à afficher un bouton
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-7: A `Button` struct that implements the
`Draw` trait</span>
-->
<p><span class="caption">Encart 17-7 : une structure <code>Bouton</code> qui implémente le
trait <code>Affichable</code></span></p>
<!--
The `width`, `height`, and `label` fields on `Button` will differ from the
fields on other components, such as a `TextField` type, that might have those
fields plus a `placeholder` field instead. Each of the types we want to draw on
the screen will implement the `Draw` trait but will use different code in the
`draw` method to define how to draw that particular type, as `Button` has here
(without the actual GUI code, which is beyond the scope of this chapter). The
`Button` type, for instance, might have an additional `impl` block containing
methods related to what happens when a user clicks the button. These kinds of
methods won’t apply to types like `TextField`.
-->
<p>Les champs <code>largeur</code>, <code>hauteur</code> et <code>libelle</code> de <code>Bouton</code> pourront ne pas être
les mêmes que ceux d'autres composants, comme un type <code>ChampDeTexte</code>, qui
pourrait avoir ces champs plus un champ <code>texte_de_substitution</code> à la place.
Chacun des types que nous voudrons afficher à l'écran implémentera le trait
<code>Affichable</code> mais utilisera du code différent dans la méthode <code>afficher</code> pour
définir comment afficher ce type en particulier, comme c'est le cas de <code>Bouton</code>
ici (sans le vrai code d'implémentation, qui dépasse le cadre de ce chapitre).
Le type <code>Bouton</code>, par exemple, pourrait avoir un bloc <code>impl</code> supplémentaire
contenant des méthodes en lien à ce qui arrive quand un utilisateur clique sur
le bouton. Ce genre de méthodes ne s'applique pas à des types comme
<code>ChampDeTexte</code>.</p>
<!--
If someone using our library decides to implement a `SelectBox` struct that has
`width`, `height`, and `options` fields, they implement the `Draw` trait on the
`SelectBox` type as well, as shown in Listing 17-8:
-->
<p>Si un utilisateur de notre bibliothèque décide d'implémenter une structure
<code>ListeDeroulante</code> avec des champs <code>largeur</code>, <code>hauteur</code> et <code>options</code>, il
implémentera également le trait <code>Affichable</code> sur le type <code>ListeDeroulante</code>,
comme dans l'encart 17-8 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec<String>,
}

impl Draw for SelectBox {
    fn draw(&self) {
        // code to actually draw a select box
    }
}
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore">use gui::Affichable;

struct ListeDeroulante {
    largeur: u32,
    hauteur: u32,
    options: Vec&lt;String&gt;,
}

impl Affichable for ListeDeroulante {
    fn afficher(&amp;self) {
        // code servant vraiment à afficher une liste déroulante
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
<span class="caption">Listing 17-8: Another crate using `gui` and implementing
the `Draw` trait on a `SelectBox` struct</span>
-->
<p><span class="caption">Encart 17-8 : une autre <em>crate</em> utilisant <code>gui</code> et
implémentant le trait <code>Affichable</code> sur une structure <code>ListeDeroulante</code></span></p>
<!--
Our library’s user can now write their `main` function to create a `Screen`
instance. To the `Screen` instance, they can add a `SelectBox` and a `Button`
by putting each in a `Box<T>` to become a trait object. They can then call the
`run` method on the `Screen` instance, which will call `draw` on each of the
components. Listing 17-9 shows this implementation:
-->
<p>L'utilisateur de notre bibliothèque peut maintenant écrire sa fonction <code>main</code>
pour créer une instance de <code>Ecran</code>. Il peut ajouter à l'instance de <code>Ecran</code> une
<code>ListeDeroulante</code> ou un <code>Bouton</code> en les mettant chacun dans un <code>Box&lt;T&gt;</code> pour en
faire des objets traits. Il peut ensuite appeler la méthode <code>executer</code> sur
l'instance de <code>Ecran</code>, qui appellera <code>afficher</code> sur chacun de ses composants.
L'encart 17-9 montre cette implémentation :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use gui::Draw;
# 
# struct SelectBox {
#     width: u32,
#     height: u32,
#     options: Vec<String>,
# }
# 
# impl Draw for SelectBox {
#     fn draw(&self) {
#         // code to actually draw a select box
#     }
# }
# 
use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No"),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };

    screen.run();
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use gui::Affichable;
</span><span class="boring">
</span><span class="boring">struct ListeDeroulante {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Affichable for ListeDeroulante {
</span><span class="boring">    fn afficher(&amp;self) {
</span><span class="boring">        // code servant vraiment à afficher une liste déroulante
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Bouton, Ecran};

fn main() {
    let ecran = Ecran {
        composants: vec![
            Box::new(ListeDeroulante {
                largeur: 75,
                hauteur: 10,
                options: vec![
                    String::from(&quot;Oui&quot;),
                    String::from(&quot;Peut-être&quot;),
                    String::from(&quot;Non&quot;),
                ],
            }),
            Box::new(Bouton {
                largeur: 50,
                hauteur: 10,
                libelle: String::from(&quot;OK&quot;),
            }),
        ],
    };

    ecran.executer();
}
</code></pre>
<!--
<span class="caption">Listing 17-9: Using trait objects to store values of
different types that implement the same trait</span>
-->
<p><span class="caption">Encart 17-9 : utilisation d'objets traits pour stocker des
valeurs de types différents qui implémentent le même trait</span></p>
<!--
When we wrote the library, we didn’t know that someone might add the
`SelectBox` type, but our `Screen` implementation was able to operate on the
new type and draw it because `SelectBox` implements the `Draw` trait, which
means it implements the `draw` method.
-->
<p>Quand nous avons écrit la bibliothèque, nous ne savions pas que quelqu'un
pourrait y ajouter le type <code>ListeDeroulante</code>, mais notre implémentation de
<code>Ecran</code> a pu opérer sur le nouveau type et l'afficher parce que
<code>ListeDeroulante</code> implémente le trait <code>Affichable</code>, ce qui veut dire qu'elle
implémente la méthode <code>afficher</code>.</p>
<!--
This concept—of being concerned only with the messages a value responds to
rather than the value’s concrete type—is similar to the concept of *duck
typing* in dynamically typed languages: if it walks like a duck and quacks
like a duck, then it must be a duck! In the implementation of `run` on `Screen`
in Listing 17-5, `run` doesn’t need to know what the concrete type of each
component is. It doesn’t check whether a component is an instance of a `Button`
or a `SelectBox`, it just calls the `draw` method on the component. By
specifying `Box<dyn Draw>` as the type of the values in the `components`
vector, we’ve defined `Screen` to need values that we can call the `draw`
method on.
-->
<p>Ce concept — se préoccuper uniquement des messages auxquels une valeur répond
plutôt que du type concret de la valeur — est similaire au concept du <em>duck
typing</em> (“typage canard”) dans les langages typés dynamiquement : si ça marche
comme un canard et que ça fait coin-coin comme un canard, alors ça doit être un
canard ! Dans l'implémentation de <code>executer</code> sur <code>Ecran</code> dans l'encart 17-5,
<code>executer</code> n'a pas besoin de connaître le type concret de chaque composant. Elle
ne vérifie pas si un composant est une instance de <code>Bouton</code> ou de
<code>ListeDeroulante</code>, elle ne fait qu'appeler la méthode <code>afficher</code> sur le
composant. En spécifiant <code>Box&lt;dyn Affichable&gt;</code> comme type des valeurs dans le
vecteur <code>composants</code>, nous avons défini que <code>Ecran</code> n'avait besoin que de valeurs
sur lesquelles on peut appeler la méthode <code>afficher</code>.</p>
<!--
The advantage of using trait objects and Rust’s type system to write code
similar to code using duck typing is that we never have to check whether a
value implements a particular method at runtime or worry about getting errors
if a value doesn’t implement a method but we call it anyway. Rust won’t compile
our code if the values don’t implement the traits that the trait objects need.
-->
<p>L'avantage d'utiliser les objets traits et le système de types de Rust pour
écrire du code plutôt que d'utiliser le <em>duck typing</em> est que nous n'avons
jamais besoin de vérifier si une valeur implémente une méthode en particulier à
l'exécution, ni de s'inquiéter d'avoir des erreurs si une valeur n'implémente
pas une méthode mais qu'on l'appelle quand même. Rust ne compilera pas notre
code si les valeurs n'implémentent pas les traits requis par les objets traits.</p>
<!--
For example, Listing 17-10 shows what happens if we try to create a `Screen`
with a `String` as a component:
-->
<p>Par exemple, l'encart 17-10 montre ce qui arrive si on essaie de créer un
<code>Ecran</code> avec une <code>String</code> comme composant :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from("Hi"))],
    };

    screen.run();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use gui::Ecran;

fn main() {
    let ecran = Ecran {
        composants: vec![Box::new(String::from(&quot;Salut&quot;))],
    };

    ecran.executer();
}
</code></pre>
<!--
<span class="caption">Listing 17-10: Attempting to use a type that doesn’t
implement the trait object’s trait</span>
-->
<p><span class="caption">Encart 17-10 : tentative d'utiliser un type qui
n'implémente pas le trait de l'objet trait</span></p>
<!--
We’ll get this error because `String` doesn’t implement the `Draw` trait:
-->
<p>Nous aurons cette erreur parce que <code>String</code> n'implémente pas le trait
<code>Affichable</code> :</p>
<!--
```console
$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `std::string::String: gui::Draw` is not satisfied
 -- > src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from("Hi"))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `gui::Draw` is not implemented for `std::string::String`
  |
  = note: required for the cast to the object type `dyn gui::Draw`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `std::string::String: gui::Affichable` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         composants: vec![Box::new(String::from(&quot;Salut&quot;))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `gui::Affichable` is not implemented for `std::string::String`
  |
  = note: required for the cast to the object type `dyn gui::Affichable`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
This error lets us know that either we’re passing something to `Screen` we
didn’t mean to pass and we should pass a different type or we should implement
`Draw` on `String` so that `Screen` is able to call `draw` on it.
-->
<p>L'erreur nous fait savoir que soit nous passons quelque chose à <code>Ecran</code> que nous
ne voulions pas lui passer et nous devrions lui passer un type différent, soit
nous devrions implémenter <code>Affichable</code> sur <code>String</code> de sorte que <code>Ecran</code> puisse
appeler <code>afficher</code> dessus.</p>
<!--
### Trait Objects Perform Dynamic Dispatch
-->
<h3 id="les-objets-traits-effectuent-de-la-répartition-dynamique"><a class="header" href="#les-objets-traits-effectuent-de-la-répartition-dynamique">Les objets traits effectuent de la répartition dynamique</a></h3>
<!--
Recall in the [“Performance of Code Using
Generics”][performance-of-code-using-generics]<!-- ignore -- > section in
Chapter 10 our discussion on the monomorphization process performed by the
compiler when we use trait bounds on generics: the compiler generates
nongeneric implementations of functions and methods for each concrete type
that we use in place of a generic type parameter. The code that results from
monomorphization is doing *static dispatch*, which is when the compiler knows
what method you’re calling at compile time. This is opposed to *dynamic
dispatch*, which is when the compiler can’t tell at compile time which method
you’re calling. In dynamic dispatch cases, the compiler emits code that at
runtime will figure out which method to call.
-->
<p>Rappelez-vous de notre discussion dans <a href="ch10-01-syntax.html">une
section</a><!-- ignore --> du
chapitre 10 à propos du processus de monomorphisation effectué par le
compilateur quand nous utilisons des traits liés sur des génériques : le
compilateur génère des implémentations non génériques de fonctions et de
méthodes pour chaque type concret que nous utilisons à la place d'un paramètre
de type générique. Le code résultant de la monomorphisation effectue du
<em>dispatch statique</em>, c'est-à-dire quand le compilateur sait quelle méthode
vous appelez à la compilation. Cela s'oppose au <em>dispatch dynamique</em>,
c'est-à-dire quand le compilateur ne peut pas déterminer à la compilation quelle
méthode vous appelez. Dans les cas de répartition dynamique, le compilateur émet du
code qui devra déterminer à l'exécution quelle méthode appeler.</p>
<!--
When we use trait objects, Rust must use dynamic dispatch. The compiler doesn’t
know all the types that might be used with the code that is using trait
objects, so it doesn’t know which method implemented on which type to call.
Instead, at runtime, Rust uses the pointers inside the trait object to know
which method to call. There is a runtime cost when this lookup happens that
doesn’t occur with static dispatch. Dynamic dispatch also prevents the compiler
from choosing to inline a method’s code, which in turn prevents some
optimizations. However, we did get extra flexibility in the code that we wrote
in Listing 17-5 and were able to support in Listing 17-9, so it’s a trade-off
to consider.
-->
<p>Quand nous utilisons des objets traits, Rust doit utiliser de la répartition
dynamique. Le compilateur ne connaît pas tous les types qui pourraient être
utilisés avec le code qui utilise des objets traits, donc il ne sait pas quelle
méthode implémentée sur quel type il doit appeler. À la place, lors de l'exécution, Rust
utilise les pointeurs à l'intérieur de l'objet trait pour savoir quelle méthode
appeler. Il y a un coût à l'exécution lors de la recherche de cette méthode qui
n'a pas lieu avec la répartition statique. La répartition dynamique empêche en outre
le compilateur de choisir de remplacer un appel de méthode par le code de cette
méthode, ce qui empêche par ricochet certaines optimisations. Cependant, cela a
permis de rendre plus flexible le code que nous avons écrit dans l'encart 17-5
et que nous avons pu supporter dans l'encart 17-9, donc c'est un compromis à
envisager.</p>
<!--
### Object Safety Is Required for Trait Objects
-->
<h3 id="la-sûreté-au-sens-de-lobjet-est-nécessaire-pour-les-objets-traits"><a class="header" href="#la-sûreté-au-sens-de-lobjet-est-nécessaire-pour-les-objets-traits">La sûreté au sens de l'objet est nécessaire pour les objets traits</a></h3>
<!--
You can only make *object-safe* traits into trait objects. Some complex rules
govern all the properties that make a trait object safe, but in practice, only
two rules are relevant. A trait is object safe if all the methods defined in
the trait have the following properties:
-->
<p>On ne peut transformer en objets traits que les traits <em>sûrs au sens de
l'objet</em> (<em>object-safe</em>). Quelques règles complexes régissent toutes les
propriétés qui rendent un objet trait sûr au sens de l'objet, mais en pratique,
seules deux règles sont pertinentes. Un trait est sûr au sens de l'objet si
toutes les méthodes définies sur le trait ont les propriétés suivantes :</p>
<!--
* The return type isn’t `Self`.
* There are no generic type parameters.
-->
<ul>
<li>Le type de retour n'est pas <code>Self</code>.</li>
<li>Il n'y a pas de paramètres de type génériques.</li>
</ul>
<!--
The `Self` keyword is an alias for the type we’re implementing the traits or
methods on. Trait objects must be object safe because once you’ve used a trait
object, Rust no longer knows the concrete type that’s implementing that trait.
If a trait method returns the concrete `Self` type, but a trait object forgets
the exact type that `Self` is, there is no way the method can use the original
concrete type. The same is true of generic type parameters that are filled in
with concrete type parameters when the trait is used: the concrete types become
part of the type that implements the trait. When the type is forgotten through
the use of a trait object, there is no way to know what types to fill in the
generic type parameters with.
-->
<p>Le mot-clé <code>Self</code> est un alias pour le type sur lequel nous implémentons les
traits ou les méthodes. Les objets traits doivent être sûrs au sens de l'objet
parce qu'une fois qu'on a utilisé un objet trait, Rust ne sait plus quel est le
type concret qui implémente ce trait. Si une méthode de trait retourne le type
concret <code>Self</code>, mais qu'un objet trait oublie le type exact représenté par
<code>Self</code>, il est impossible pour la méthode d'utiliser le type concret d'origine.
Il en va de même pour les paramètres de type génériques qui sont remplacés par
des paramètres de type concrets quand le trait est utilisé : les types concrets
deviennent partie intégrante du type qui implémente le trait. Lorsque le type
est oublié à cause de l'utilisation d'un objet trait, il devient impossible de
savoir par quels types remplacer les paramètres de type génériques.</p>
<!--
An example of a trait whose methods are not object safe is the standard
library’s `Clone` trait. The signature for the `clone` method in the `Clone`
trait looks like this:
-->
<p>Un exemple de trait dont les méthodes ne sont pas sûres au sens de l'objet est
le trait <code>Clone</code> de la bibliothèque standard. La signature de la méthode <code>clone</code>
du trait <code>Clone</code> ressemble à ceci :</p>
<!--
```rust
pub trait Clone {
    fn clone(&self) -> Self;
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `String` type implements the `Clone` trait, and when we call the `clone`
method on an instance of `String` we get back an instance of `String`.
Similarly, if we call `clone` on an instance of `Vec<T>`, we get back an
instance of `Vec<T>`. The signature of `clone` needs to know what type will
stand in for `Self`, because that’s the return type.
-->
<p>Le type <code>String</code> implémente le trait <code>Clone</code>, et quand on appelle la méthode
<code>clone</code> sur une instance de <code>String</code>, on récupère une instance de <code>String</code>. De
même, si on appelle <code>clone</code> sur une instance de <code>Vec&lt;T&gt;</code>, on récupère une
instance de <code>Vec&lt;T&gt;</code>. La signature de <code>clone</code> doit savoir à quel type correspond
<code>Self</code>, puisqu'il s'agit du type de retour.</p>
<!--
The compiler will indicate when you’re trying to do something that violates the
rules of object safety in regard to trait objects. For example, let’s say we
tried to implement the `Screen` struct in Listing 17-4 to hold types that
implement the `Clone` trait instead of the `Draw` trait, like this:
-->
<p>Le compilateur vous préviendra lorsque vous essayez de faire quelque chose qui
enfreint les règles de sûreté au sens de l'objet lors de l'utilisation des objets traits.
Par exemple, supposons que nous avons essayé d'implémenter la structure <code>Ecran</code>
de l'encart 17-4 en la faisant contenir des types qui implémentent le trait
<code>Clone</code> plutôt que le trait <code>Affichable</code>, comme ceci :</p>
<!--
```rust,ignore,does_not_compile
pub struct Screen {
    pub components: Vec<Box<dyn Clone>>,
}
```
-->
<pre><code class="language-rust ignore does_not_compile">pub struct Ecran {
    pub composants: Vec&lt;Box&lt;dyn Clone&gt;&gt;,
}
</code></pre>
<!--
We would get this error:
-->
<p>Nous aurions obtenu cette erreur :</p>
<!--
```console
$ cargo build
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 -- > src/lib.rs:2:5
  |
2 |     pub components: Vec<Box<dyn Clone>>,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be made into an object
  |
  = note: the trait cannot require that `Self : Sized`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0038`.
error: could not compile `gui`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo build
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --&gt; src/lib.rs:2:5
  |
2 |     pub composants: Vec&lt;Box&lt;dyn Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be made into an object
  |
  = note: the trait cannot require that `Self : Sized`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0038`.
error: could not compile `gui`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
This error means you can’t use this trait as a trait object in this way. If
you’re interested in more details on object safety, see [Rust RFC 255].
-->
<p>Cette erreur signifie que l'on ne peut pas utiliser ce trait comme d'un objet
trait de cette façon. Si vous souhaitez connaître plus de détails sur la sûreté
au sens de l'objet, référez-vous à la <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">RFC 255 de Rust</a> (en
anglais).</p>
<!-- markdownlint-disable -->
<!--
[Rust RFC 255]: https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md

[performance-of-code-using-generics]:
ch10-01-syntax.html#performance-of-code-using-generics
[dynamically-sized]: ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait
-->
<!-- markdownlint-restore -->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--20"><a class="header" href="#-attention-peinture-fraîche--20">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
## Implementing an Object-Oriented Design Pattern
-->
<h2 id="implémenter-un-patron-de-conception-orienté-objet"><a class="header" href="#implémenter-un-patron-de-conception-orienté-objet">Implémenter un patron de conception orienté-objet</a></h2>
<!--
The *state pattern* is an object-oriented design pattern. The crux of the
pattern is that a value has some internal state, which is represented by a set
of *state objects*, and the value’s behavior changes based on the internal
state. The state objects share functionality: in Rust, of course, we use
structs and traits rather than objects and inheritance. Each state object is
responsible for its own behavior and for governing when it should change into
another state. The value that holds a state object knows nothing about the
different behavior of the states or when to transition between states.
-->
<p>Le <em>patron état</em> est un patron de conception issu de l'orienté objet. Le point
essentiel du modèle est qu'une valeur a un état interne, qui est représenté par
un ensemble <em>d'états</em>, et le comportement de la valeur change en fonction de son
état interne. Les objets état partagent des fonctionnalités : en Rust, bien sûr,
nous utilisons des structures et des traits plutôt que des objets et de
l'héritage. Chaque objet état est responsable de son propre comportement et
décide lorsqu'il doit changer pour un autre état. La valeur contenue dans un
objet état ne sait rien sur les différents comportements des états et ne sait
pas quand il va changer d'état.</p>
<!--
Using the state pattern means when the business requirements of the program
change, we won’t need to change the code of the value holding the state or the
code that uses the value. We’ll only need to update the code inside one of the
state objects to change its rules or perhaps add more state objects. Let’s look
at an example of the state design pattern and how to use it in Rust.
-->
<p>L'utilisation du patron état signifie que lorsque les pré-requis du métier du
programme ont changé, nous n'avons pas besoin de changer le code à l'intérieur
de l'objet état ou le code qui utilise l'objet. Nous avons juste besoin de
modifier le code dans un des objets état pour changer son fonctionnement ou pour
ajouter d'autres objets état. Voyons un exemple du patron état et comment
l'utiliser en Rust.</p>
<!--
We’ll implement a blog post workflow in an incremental way. The blog’s final
functionality will look like this:
-->
<p>Nous allons implémenter un processus de publication de billets de blogs de
manière incrémentale. Les fonctionnalités finales du blog seront les suivantes :</p>
<!--
1. A blog post starts as an empty draft.
2. When the draft is done, a review of the post is requested.
3. When the post is approved, it gets published.
4. Only published blog posts return content to print, so unapproved posts can’t
   accidentally be published.
-->
<ol>
<li>Un billet de blog commence par un brouillon vide.</li>
<li>Lorsque le brouillon est terminé, une relecture du billet est demandée.</li>
<li>Lorsqu'un billet est approuvé, il est publié.</li>
<li>Seuls les billets de blog publiés retournent du contenu à afficher, donc les
billets non approuvés ne peuvent pas être publiés accidentellement.</li>
</ol>
<!--
Any other changes attempted on a post should have no effect. For example, if we
try to approve a draft blog post before we’ve requested a review, the post
should remain an unpublished draft.
-->
<p>Tous les autres changements effectués sur un billet n'auront pas d'effet. Par
exemple, si nous essayons d'approuver un brouillon de billet de blog avant
d'avoir demandé une relecture, le billet devrait rester à l'état de brouillon
non publié.</p>
<!--
Listing 17-11 shows this workflow in code form: this is an example usage of the
API we’ll implement in a library crate named `blog`. This won’t compile yet
because we haven’t implemented the `blog` crate yet.
-->
<p>L'encart 17-11 présente ce processus de publication sous forme de code : c'est
un exemple d'utilisation de l'API que nous allons implémenter dans une crate de
bibliothèque <code>blog</code>. Elle ne va pas encore se compiler car nous n'avons pas
encore implémenté la crate <code>blog</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use blog::Billet;

fn main() {
    let mut billet = Billet::new();

    billet.ajouter_texte(&quot;J'ai mangé une salade au déjeuner aujourd'hui&quot;);
    assert_eq!(&quot;&quot;, billet.contenu());

    billet.demander_relecture();
    assert_eq!(&quot;&quot;, billet.contenu());

    billet.approuver();
    assert_eq!(&quot;J'ai mangé une salade au déjeuner aujourd'hui&quot;, billet.contenu());
}
</code></pre>
<!--
<span class="caption">Listing 17-11: Code that demonstrates the desired
behavior we want our `blog` crate to have</span>
-->
<p><span class="caption">Encart 17-11 : du code qui montre le comportement attendu
de notre crate <code>blog</code></span></p>
<!--
We want to allow the user to create a new draft blog post with `Post::new`.
Then we want to allow text to be added to the blog post while it’s in the draft
state. If we try to get the post’s content immediately, before approval,
nothing should happen because the post is still a draft. We’ve added
`assert_eq!` in the code for demonstration purposes. An excellent unit test for
this would be to assert that a draft blog post returns an empty string from the
`content` method, but we’re not going to write tests for this example.
-->
<p>Nous voulons permettre à l'utilisateur de créer un nouveau brouillon de billet
de blog avec <code>Billet::new</code>. Ensuite nous voulons qu'il puisse ajouter du texte
au billet de blog tant qu'il est à l'état de brouillon. Si nous essayons
d'obtenir immédiatement le contenu du billet, avant qu'il soit relu, rien ne va
se passer car le billet est toujours un brouillon. Nous avons ajouté des
<code>assert_eq!</code> dans le code pour les besoins de la démonstration. Un excellent
test unitaire pour cela serait de vérifier qu'un brouillon de billet de blog
retourne bien une chaîne de caractères vide à partir de la méthode <code>contenu</code>,
mais nous n'allons pas écrire de tests pour cet exemple.</p>
<!--
Next, we want to enable a request for a review of the post, and we want
`content` to return an empty string while waiting for the review. When the post
receives approval, it should get published, meaning the text of the post will
be returned when `content` is called.
-->
<p>Ensuite, nous voulons permettre de demander une relecture du billet, et nous
souhaitons que <code>contenu</code> retourne toujours une chaîne de caractères vide pendant
que nous attendons la relecture. Lorsque la relecture du billet est approuvée,
il doit être publié, ce qui signifie que le texte du billet doit être retourné
lors de l'appel à <code>contenu</code>.</p>
<!--
Notice that the only type we’re interacting with from the crate is the `Post`
type. This type will use the state pattern and will hold a value that will be
one of three state objects representing the various states a post can be
in—draft, waiting for review, or published. Changing from one state to another
will be managed internally within the `Post` type. The states change in
response to the methods called by our library’s users on the `Post` instance,
but they don’t have to manage the state changes directly. Also, users can’t
make a mistake with the states, like publishing a post before it’s reviewed.
-->
<p>Remarquez que le seul type avec lequel nous interagissons avec la crate est le
type <code>Billet</code>. Ce type va utiliser le patron état et va héberger une valeur qui
sera un des trois objets état représentant les différents états dans lesquels
passent un billet : brouillon, en attente de relecture, ou publié. Le changement
d'un état à un autre sera géré en interne du type <code>Billet</code>. Les états vont
changer suite aux méthodes appelées par les utilisateurs de notre bibliothèque
sur l'instance de <code>Billet</code>, mais ils n'ont pas à gérer directement les
changements d'état. De plus, les utilisateurs ne peuvent pas faire d'erreur avec
les états, comme par exemple publier un billet avant qu'il soit relu.</p>
<!--
### Defining `Post` and Creating a New Instance in the Draft State
-->
<h3 id="définir-billet-et-créer-une-nouvelle-instance-à-létat-de-brouillon"><a class="header" href="#définir-billet-et-créer-une-nouvelle-instance-à-létat-de-brouillon">Définir <code>Billet</code> et créer une nouvelle instance à l'état de brouillon</a></h3>
<!--
Let’s get started on the implementation of the library! We know we need a
public `Post` struct that holds some content, so we’ll start with the
definition of the struct and an associated public `new` function to create an
instance of `Post`, as shown in Listing 17-12. We’ll also make a private
`State` trait. Then `Post` will hold a trait object of `Box<dyn State>`
inside an `Option<T>` in a private field named `state`. You’ll see why the
`Option<T>` is necessary in a bit.
-->
<p>Commençons l'implémentation de la bibliothèque ! Nous savons que nous aurons
besoin d'une structure publique <code>Billet</code> qui héberge du contenu, donc nous
allons commencer par définir cette structure et une fonction publique <code>new</code> qui
lui est associée pour créer une instance de <code>Billet</code>, comme dans l'encart 17-12.
Nous allons aussi créer un trait privé <code>Etat</code>. Ensuite <code>Billet</code> devra avoir un
champ privé <code>etat</code> pour y loger une <code>Option&lt;T&gt;</code> contenant un objet trait de
<code>Box&lt;dyn Etat&gt;</code>. Nous verrons plus tard l'intérêt du <code>Option&lt;T&gt;</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    pub fn new() -> Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Billet {
    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
    contenu: String,
}

impl Billet {
    pub fn new() -&gt; Billet {
        Billet {
            etat: Some(Box::new(Brouillon {})),
            contenu: String::new(),
        }
    }
}

trait Etat {}

struct Brouillon {}

impl Etat for Brouillon {}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-12: Definition of a `Post` struct and a `new`
function that creates a new `Post` instance, a `State` trait, and a `Draft`
struct</span>
-->
<p><span class="caption">Encart 17-12 : définition d'une structure <code>Billet</code> et
d'une fonction <code>new</code> qui crée une nouvelle instance de <code>Billet</code>, un trait
<code>Etat</code>, et une structure <code>Brouillon</code></span></p>
<!--
The `State` trait defines the behavior shared by different post states, and the
`Draft`, `PendingReview`, and `Published` states will all implement the `State`
trait. For now, the trait doesn’t have any methods, and we’ll start by defining
just the `Draft` state because that is the state we want a post to start in.
-->
<p>Le trait <code>Etat</code> définit le comportement partagé par plusieurs états de billet,
et les états <code>Brouillon</code>, <code>EnRelecture</code>, et <code>Publier</code> vont tous implémenter le
trait <code>Etat</code>. Pour l'instant, le trait n'a pas de méthode, et nous allons
commencer par définir uniquement l'état <code>Brouillon</code> car c'est l'état dans lequel
nous voulons créer un nouveau billet.</p>
<!--
When we create a new `Post`, we set its `state` field to a `Some` value that
holds a `Box`. This `Box` points to a new instance of the `Draft` struct. This
ensures whenever we create a new instance of `Post`, it will start out as a
draft. Because the `state` field of `Post` is private, there is no way to
create a `Post` in any other state! In the `Post::new` function, we set the
`content` field to a new, empty `String`.
-->
<p>Lorsque nous créons un nouveau <code>Billet</code>, nous assignons à son champ <code>etat</code> une
valeur <code>Some</code> qui contient une <code>Box</code>. Cette <code>Box</code> pointe sur une nouvelle
instance de la structure <code>Brouillon</code>. Cela garantira qu'à chaque fois que nous
créons une nouvelle instance de <code>Billet</code>, elle commencera à l'état de brouillon.
Comme le champ <code>etat</code> de <code>Billet</code> est privé, il n'y a pas d'autre manière de
créer un <code>Billet</code> dans un autre état ! Dans la fonction <code>Billet::new</code>, nous
assignons une nouvelle <code>String</code> vide au champ <code>contenu</code>.</p>
<!--
### Storing the Text of the Post Content
-->
<h3 id="stocker-le-texte-du-contenu-du-billet"><a class="header" href="#stocker-le-texte-du-contenu-du-billet">Stocker le texte du contenu du billet</a></h3>
<!--
Listing 17-11 showed that we want to be able to call a method named
`add_text` and pass it a `&str` that is then added to the text content of the
blog post. We implement this as a method rather than exposing the `content`
field as `pub`. This means we can implement a method later that will control
how the `content` field’s data is read. The `add_text` method is pretty
straightforward, so let’s add the implementation in Listing 17-13 to the `impl
Post` block:
-->
<p>L'encart 17-11 a montré que nous souhaitons appeler une méthode <code>ajouter_texte</code>
et lui passer un <code>&amp;str</code> qui est ensuite ajouté au contenu textuel du billet de
blog. Nous implémentons ceci avec une méthode plutôt que d'exposer publiquement
le champ <code>contenu</code> avec <code>pub</code>. Cela signifie que nous pouvons implémenter une
méthode plus tard qui va contrôler comment le champ <code>contenu</code> sera lu. La
méthode <code>ajouter_texte</code> est assez simple, donc ajoutons son implémentation dans
le bloc <code>Billet</code> de l'encart 17-13 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }
}
# 
# trait State {}
# 
# struct Draft {}
# 
# impl State for Draft {}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masquée ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
        self.contenu.push_str(texte);
    }
}
<span class="boring">
</span><span class="boring">trait Etat {}
</span><span class="boring">
</span><span class="boring">struct Brouillon {}
</span><span class="boring">
</span><span class="boring">impl Etat for Brouillon {}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-13: Implementing the `add_text` method to add
text to a post’s `content`</span>
-->
<p><span class="caption">Encart 17-13 : implémentation de la méthode
<code>ajouter_texte</code> pour ajouter du texte au <code>contenu</code> d'un billet</span></p>
<!--
The `add_text` method takes a mutable reference to `self`, because we’re
changing the `Post` instance that we’re calling `add_text` on. We then call
`push_str` on the `String` in `content` and pass the `text` argument to add to
the saved `content`. This behavior doesn’t depend on the state the post is in,
so it’s not part of the state pattern. The `add_text` method doesn’t interact
with the `state` field at all, but it is part of the behavior we want to
support.
-->
<p>La méthode <code>ajouter_texte</code> prend en argument une référence mutable vers <code>self</code>,
car nous changeons l'instance <code>Billet</code> sur laquelle nous appelons
<code>ajouter_texte</code>. Nous faisons ensuite appel à <code>push_str</code> sur le <code>String</code> dans
<code>contenu</code> et nous y envoyons l'argument <code>texte</code> pour l'ajouter au <code>contenu</code> déjà
stocké. Ce comportement ne dépend pas de l'état dans lequel est le billet, donc
cela ne fait pas partie du patron état. La méthode <code>ajouter_texte</code> n'interagit
pas du tout avec le champ <code>etat</code>, mais c'est volontaire.</p>
<!--
### Ensuring the Content of a Draft Post Is Empty
-->
<h3 id="sassurer-que-le-contenu-dun-brouillon-est-vide"><a class="header" href="#sassurer-que-le-contenu-dun-brouillon-est-vide">S'assurer que le contenu d'un brouillon est vide</a></h3>
<!--
Even after we’ve called `add_text` and added some content to our post, we still
want the `content` method to return an empty string slice because the post is
still in the draft state, as shown on line 7 of Listing 17-11. For now, let’s
implement the `content` method with the simplest thing that will fulfill this
requirement: always returning an empty string slice. We’ll change this later
once we implement the ability to change a post’s state so it can be published.
So far, posts can only be in the draft state, so the post content should always
be empty. Listing 17-14 shows this placeholder implementation:
-->
<p>Même si nous avons appelé <code>ajouter_texte</code> et ajouté du contenu dans notre
billet, nous voulons que la méthode <code>contenu</code> retourne toujours une slice de
chaîne de caractères vide car le billet est toujours à l'état de brouillon,
comme le montre la ligne 7 de l'encart 17-11. Implémentons maintenant la méthode
<code>contenu</code> de la manière la plus simple qui répond à cette consigne : toujours
retourner un slice de chaîne de caractères vide. Nous la changerons plus tard
lorsque nous implémenterons la capacité de changer l'état d'un billet afin qu'il
puisse être publié. Pour l'instant, les billets ne peuvent qu'être à l'état de
brouillon, donc le contenu du billet devrait toujours être vide. L'encart 17-14
montre l'implémentation de ceci :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
    pub fn content(&self) -> &str {
        ""
    }
}
# 
# trait State {}
# 
# struct Draft {}
# 
# impl State for Draft {}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masquée ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn contenu(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">
</span><span class="boring">trait Etat {}
</span><span class="boring">
</span><span class="boring">struct Brouillon {}
</span><span class="boring">
</span><span class="boring">impl Etat for Brouillon {}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-14: Adding a placeholder implementation for
the `content` method on `Post` that always returns an empty string slice</span>
-->
<p><span class="caption">Encart 17-14 : ajout d'une implémentation de la méthode
<code>contenu</code> sur <code>Billet</code> qui va toujours retourner une slice de chaîne de
caractères vide</span></p>
<!--
With this added `content` method, everything in Listing 17-11 up to line 7
works as intended.
-->
<p>Avec cette méthode <code>contenu</code> ajoutée, tout ce qu'il y a dans l'encart 17-11
fonctionne comme prévu jusqu'à la ligne 7.</p>
<!--
### Requesting a Review of the Post Changes Its State
-->
<h3 id="demander-une-relecture-du-billet-va-changer-son-état"><a class="header" href="#demander-une-relecture-du-billet-va-changer-son-état">Demander une relecture du billet va changer son état</a></h3>
<!--
Next, we need to add functionality to request a review of a post, which should
change its state from `Draft` to `PendingReview`. Listing 17-15 shows this code:
-->
<p>Ensuite, nous avons besoin d'ajouter une fonctionnalité pour demander la
relecture d'un billet, qui devrait changer son état de <code>Brouillon</code> à
<code>EnRelecture</code>. L'encart 17-15 montre ce code :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
#     pub fn content(&self) -> &str {
#         ""
#     }
# 
    pub fn request_review(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masquée ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn contenu(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn demander_relecture(&amp;mut self) {
        if let Some(s) = self.etat.take() {
            self.etat = Some(s.demander_relecture())
        }
    }
}

trait Etat {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
}

struct Brouillon {}

impl Etat for Brouillon {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        Box::new(EnRelecture {})
    }
}

struct EnRelecture {}

impl Etat for EnRelecture {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        self
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-15: Implementing `request_review` methods on
`Post` and the `State` trait</span>
-->
<p><span class="caption">Encart 17-15 : implémentation des méthodes
<code>demander_relecture</code> sur <code>Billet</code> et le trait <code>Etat</code></span></p>
<!--
We give `Post` a public method named `request_review` that will take a mutable
reference to `self`. Then we call an internal `request_review` method on the
current state of `Post`, and this second `request_review` method consumes the
current state and returns a new state.
-->
<p>Nous installons la méthode publique <code>demander_relecture</code> sur <code>Billet</code> qui va
prendre en argument une référence mutable à <code>self</code>. Ensuite nous appelons la
méthode interne <code>demander_relecture</code> sur l'état interne de <code>Billet</code>, et cette
seconde méthode <code>demander_relecture</code> consomme l'état en cours et applique un
nouvel état.</p>
<!--
We’ve added the `request_review` method to the `State` trait; all types that
implement the trait will now need to implement the `request_review` method.
Note that rather than having `self`, `&self`, or `&mut self` as the first
parameter of the method, we have `self: Box<Self>`. This syntax means the
method is only valid when called on a `Box` holding the type. This syntax takes
ownership of `Box<Self>`, invalidating the old state so the state value of the
`Post` can transform into a new state.
-->
<p>Nous avons ajouté la méthode <code>demander_relecture</code> sur le trait <code>Etat</code> ; tous les
types qui implémentent le trait vont maintenant devoir implémenter la méthode
<code>demander_relecture</code>. Remarquez qu'au lieu d'avoir <code>self</code>, <code>&amp;self</code>, ou
<code>&amp;mut self</code> en premier paramètre de la méthode, nous avons <code>self: Box&lt;Self&gt;</code>.
Cette syntaxe signifie que la méthode est valide uniquement lorsqu'on l'appelle
sur une <code>Box</code> qui contient ce type. Cette syntaxe prend possession de
<code>Box&lt;Self&gt;</code>, ce qui annule l'ancien état du <code>Billet</code> qui peut changer pour un
nouvel état.</p>
<!--
To consume the old state, the `request_review` method needs to take ownership
of the state value. This is where the `Option` in the `state` field of `Post`
comes in: we call the `take` method to take the `Some` value out of the `state`
field and leave a `None` in its place, because Rust doesn’t let us have
unpopulated fields in structs. This lets us move the `state` value out of
`Post` rather than borrowing it. Then we’ll set the post’s `state` value to the
result of this operation.
-->
<p>Pour consommer l'ancien état, la méthode <code>demander_relecture</code> a besoin de
prendre possession de la valeur d'état. C'est ce à quoi sert le <code>Option</code> dans le
champ <code>etat</code> de <code>Billet</code> : nous faisons appel à la méthode <code>take</code> pour obtenir
la valeur dans le <code>Some</code> du champ <code>etat</code> et le remplacer par <code>None</code>, car Rust ne
nous permet pas d'avoir des champs non renseignés dans des structures. Cela nous
permet d'extraire la valeur de <code>etat</code> d'un <code>Billet</code>, plutôt que de l'emprunter.
Ensuite, nous allons réaffecter le résultat de cette opération à <code>etat</code> du
<code>Billet</code> concerné.</p>
<!--
We need to set `state` to `None` temporarily rather than setting it directly
with code like `self.state = self.state.request_review();` to get ownership of
the `state` value. This ensures `Post` can’t use the old `state` value after
we’ve transformed it into a new state.
-->
<p>Nous devons assigner temporairement <code>None</code> à <code>etat</code> plutôt que de lui donner
directement avec code comme <code>self.etat = self.etat.demander_relecture();</code> car
nous voulons prendre possession de la valeur <code>etat</code>. Cela garantit que <code>Billet</code>
ne peut pas utiliser l'ancienne valeur de <code>etat</code> après qu'on ai changé cet état.</p>
<!--
The `request_review` method on `Draft` needs to return a new, boxed instance of
a new `PendingReview` struct, which represents the state when a post is waiting
for a review. The `PendingReview` struct also implements the `request_review`
method but doesn’t do any transformations. Rather, it returns itself, because
when we request a review on a post already in the `PendingReview` state, it
should stay in the `PendingReview` state.
-->
<p>La méthode <code>demander_relecture</code> sur <code>Brouillon</code> doit retourner une nouvelle
instance d'une structure <code>EnRelecture</code> dans une <code>Box</code>, qui représente l'état
lorsqu'un billet est en attente de relecture. La structure <code>EnRelecture</code>
implémente elle aussi la méthode <code>demander_relecture</code> mais ne fait aucune
modification. A la place, il se retourne lui-même, car lorsque nous demandons
une relecture sur un billet déjà à l'état <code>EnRelecture</code>, il doit rester à l'état
<code>EnRelecture</code>.</p>
<!--
Now we can start seeing the advantages of the state pattern: the
`request_review` method on `Post` is the same no matter its `state` value. Each
state is responsible for its own rules.
-->
<p>Désormais nous commençons à voir les avantages du patron état : la méthode
<code>demander_relecture</code> sur <code>Billet</code> est la même peu importe la valeur de son
<code>etat</code>. Chaque état est maître de son fonctionnement.</p>
<!--
We’ll leave the `content` method on `Post` as is, returning an empty string
slice. We can now have a `Post` in the `PendingReview` state as well as in the
`Draft` state, but we want the same behavior in the `PendingReview` state.
Listing 17-11 now works up to line 10!
-->
<p>Nous allons conserver la méthode <code>contenu</code> sur <code>Billet</code> comme elle l'est, elle
va continuer à retourner une slice de chaîne de caractères vide. Nous pouvons
maintenant avoir un <code>Billet</code> à l'état <code>Brouillon</code> ou <code>EnRelecture</code>, mais nous
voulons qu'il suive le même comportement lorsqu'il est dans l'état
<code>EnRelecture</code>. L'encart 17-11 fonctionne maintenant jusqu'à la ligne 10 !</p>
<!--
### Adding the `approve` Method that Changes the Behavior of `content`
-->
<h3 id="ajouter-une-méthode-approuver-qui-change-le-comportement-de-contenu"><a class="header" href="#ajouter-une-méthode-approuver-qui-change-le-comportement-de-contenu">Ajouter une méthode <code>approuver</code> qui change le comportement de <code>contenu</code></a></h3>
<!--
The `approve` method will be similar to the `request_review` method: it will
set `state` to the value that the current state says it should have when that
state is approved, as shown in Listing 17-16:
-->
<p>La méthode <code>approuver</code> ressemble à la méthode <code>demander_relecture</code> : elle va
changer <code>etat</code> pour la valeur que l'état actuel retournera lorsque cet état est
approuvé, comme le montre l'encart 17-16 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
#     pub fn content(&self) -> &str {
#         ""
#     }
# 
#     pub fn request_review(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.request_review())
#         }
#     }
# 
    pub fn approve(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
    fn approve(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    // --snip--
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         Box::new(PendingReview {})
#     }
# 
    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
    fn approve(self: Box<Self>) -> Box<dyn State> {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }

    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masquée ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn contenu(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn demander_relecture(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.demander_relecture())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approuver(&amp;mut self) {
        if let Some(s) = self.etat.take() {
            self.etat = Some(s.approuver())
        }
    }
}

trait Etat {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
}

struct Brouillon {}

impl Etat for Brouillon {
    // -- partie masquée ici --
<span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(EnRelecture {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        self
    }
}

struct EnRelecture {}

impl Etat for EnRelecture {
    // -- partie masquée ici --
<span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        Box::new(Publier {})
    }
}

struct Publier {}

impl Etat for Publier {
    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        self
    }

    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-16: Implementing the `approve` method on
`Post` and the `State` trait</span>
-->
<p><span class="caption">Encart 17-16 : implémentation de la méthode <code>approuver</code>
sur <code>Billet</code> et sur le trait <code>Etat</code></span></p>
<!--
We add the `approve` method to the `State` trait and add a new struct that
implements `State`, the `Published` state.
-->
<p>Nous avons ajouté la méthode <code>approuver</code> au trait <code>Etat</code> et ajouté une nouvelle
structure <code>Publier</code>, qui implémente <code>Etat</code>.</p>
<!--
Similar to `request_review`, if we call the `approve` method on a `Draft`, it
will have no effect because it will return `self`. When we call `approve` on
`PendingReview`, it returns a new, boxed instance of the `Published` struct.
The `Published` struct implements the `State` trait, and for both the
`request_review` method and the `approve` method, it returns itself, because
the post should stay in the `Published` state in those cases.
-->
<p>Comme pour <code>demander_relecture</code>, si nous faisons appel à la méthode <code>approuver</code>
sur un <code>Brouillon</code>, cela n'aura pas d'effet car elle va retourner <code>self</code>.
Lorsque nous appellerons <code>approuver</code> sur <code>EnRelecture</code>, elle va retourner une
nouvelle instance de la structure <code>Publier</code> dans une instance de <code>Box</code>. La
structure <code>Publier</code> implémente le trait <code>Etat</code>, et pour chacune des méthodes
<code>demander_relecture</code> et <code>approuver</code>, elle va retourner elle-même, car le billet
doit rester à l'état <code>Publier</code> dans ce cas-là.</p>
<!--
Now we need to update the `content` method on `Post`: if the state is
`Published`, we want to return the value in the post’s `content` field;
otherwise, we want to return an empty string slice, as shown in Listing 17-17:
-->
<p>Nous devons maintenant modifier la méthode <code>contenu</code> sur <code>Billet</code> : si l'état
est <code>Publier</code>, nous voulons retourner la valeur du champ <code>contenu</code> du billet ;
sinon nous retournons une slice de chaîne de caractères vide, comme dans
l'encart 17-17 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
impl Post {
    // --snip--
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
    pub fn content(&self) -> &str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
# 
#     pub fn request_review(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.request_review())
#         }
#     }
# 
#     pub fn approve(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.approve())
#         }
#     }
}
# 
# trait State {
#     fn request_review(self: Box<Self>) -> Box<dyn State>;
#     fn approve(self: Box<Self>) -> Box<dyn State>;
# }
# 
# struct Draft {}
# 
# impl State for Draft {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         Box::new(PendingReview {})
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# }
# 
# struct PendingReview {}
# 
# impl State for PendingReview {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         Box::new(Published {})
#     }
# }
# 
# struct Published {}
# 
# impl State for Published {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Billet {
    // -- partie masquée ici --
<span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn contenu(&amp;self) -&gt; &amp;str {
        self.etat.as_ref().unwrap().contenu(self)
    }
    // -- partie masquée ici --
<span class="boring">
</span><span class="boring">    pub fn demander_relecture(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.demander_relecture())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approuver(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.approuver())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait Etat {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Brouillon {}
</span><span class="boring">
</span><span class="boring">impl Etat for Brouillon {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(EnRelecture {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnRelecture {}
</span><span class="boring">
</span><span class="boring">impl Etat for EnRelecture {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(Publier {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Publier {}
</span><span class="boring">
</span><span class="boring">impl Etat for Publier {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 17-17: Updating the `content` method on `Post` to
delegate to a `content` method on `State`</span>
-->
<p><span class="caption">Encart 17-17 : correction de la méthode <code>contenu</code> de
<code>Billet</code> pour déléguer à la méthode <code>contenu</code> de <code>Etat</code></span></p>
<!--
Because the goal is to keep all these rules inside the structs that implement
`State`, we call a `content` method on the value in `state` and pass the post
instance (that is, `self`) as an argument. Then we return the value that is
returned from using the `content` method on the `state` value.
-->
<p>Comme notre but est de conserver toutes ces règles dans les structures qui
implémentent <code>Etat</code>, nous appelons une méthode <code>contenu</code> sur la valeur de
<code>etat</code> et nous lui passons en argument l'instance du billet (avec le <code>self</code>).
Nous retournons ensuite la valeur retournée par la méthode <code>contenu</code> sur la
valeur de <code>etat</code>.</p>
<!-- markdownlint-disable -->
<!--
We call the `as_ref` method on the `Option` because we want a reference to the
value inside the `Option` rather than ownership of the value. Because `state`
is an `Option<Box<dyn State>>`, when we call `as_ref`, an `Option<&Box<dyn State>>` is
returned. If we didn’t call `as_ref`, we would get an error because we can’t
move `state` out of the borrowed `&self` of the function parameter.
-->
<!-- markdownlint-enable -->
<p>Nous faisons appel à la méthode <code>as_ref</code> sur <code>Option</code> car nous voulons une
référence vers la valeur dans <code>Option</code> plutôt que d'en prendre possession. Comme
<code>etat</code> est un <code>Option&lt;Box&lt;dyn Etat&gt;&gt;</code>, lorsque nous faisons appel à <code>as_ref</code>,
une <code>Option&lt;&amp;Box&lt;dyn Etat&gt;&gt;</code> est retournée. Si nous n'avions pas fait appel à
<code>as_ref</code>, nous aurions obtenu une erreur car nous ne pouvons pas déplacer
<code>etat</code> du <code>&amp;self</code>, qui est emprunté, qui provient des paramètres de la fonction.</p>
<!--
We then call the `unwrap` method, which we know will never panic, because we
know the methods on `Post` ensure that `state` will always contain a `Some`
value when those methods are done. This is one of the cases we talked about in
the [“Cases In Which You Have More Information Than the
Compiler”][more-info-than-rustc]<!-- ignore -- > section of Chapter 9 when we
know that a `None` value is never possible, even though the compiler isn’t able
to understand that.
-->
<p>Nous faisons ensuite appel à la méthode <code>unwrap</code>, mais nous savons qu'elle ne
va jamais paniquer, car nous savons que les méthodes sur <code>Billet</code> vont toujours
garantir que <code>etat</code> contiendra toujours une valeur <code>Some</code> lorsqu'elles seront
utilisées. C'est un des cas dont nous avons parlé dans
<a href="ch09-03-to-panic-or-not-to-panic.html">une section</a><!-- ignore --> du chapitre 9 lorsque nous
savions qu'une valeur <code>None</code> ne serait jamais possible, même si le compilateur
n'est pas capable de le comprendre.</p>
<!-- markdownlint-disable -->
<!--
At this point, when we call `content` on the `&Box<dyn State>`, deref coercion will
take effect on the `&` and the `Box` so the `content` method will ultimately be
called on the type that implements the `State` trait. That means we need to add
`content` to the `State` trait definition, and that is where we’ll put the
logic for what content to return depending on which state we have, as shown in
Listing 17-18:
-->
<!-- markdownlint-enable -->
<p>A partir de là, lorsque nous faisons appel à <code>contenu</code> sur <code>&amp;Box&lt;dyn Etat&gt;</code>,
l'extrapolation de déréférencement va s'appliquer sur le <code>&amp;</code> et le <code>Box</code> pour
que la méthode <code>contenu</code> puisse finalement être appelée sur le type qui
implémente le trait <code>Etat</code>. Cela signifie que nous devons ajouter <code>contenu</code> à la
définition du trait <code>Etat</code>, et que c'est ici que nous allons placer la logique
pour le contenu à retourner en fonction de quel état nous avons, comme le montre
l'encart 17-18 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     state: Option<Box<dyn State>>,
#     content: String,
# }
# 
# impl Post {
#     pub fn new() -> Post {
#         Post {
#             state: Some(Box::new(Draft {})),
#             content: String::new(),
#         }
#     }
# 
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
#     pub fn content(&self) -> &str {
#         self.state.as_ref().unwrap().content(self)
#     }
# 
#     pub fn request_review(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.request_review())
#         }
#     }
# 
#     pub fn approve(&mut self) {
#         if let Some(s) = self.state.take() {
#             self.state = Some(s.approve())
#         }
#     }
# }
# 
trait State {
    // --snip--
#     fn request_review(self: Box<Self>) -> Box<dyn State>;
#     fn approve(self: Box<Self>) -> Box<dyn State>;
# 
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        ""
    }
}

// --snip--
# 
# struct Draft {}
# 
# impl State for Draft {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         Box::new(PendingReview {})
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# }
# 
# struct PendingReview {}
# 
# impl State for PendingReview {
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         Box::new(Published {})
#     }
# }
# 
struct Published {}

impl State for Published {
    // --snip--
#     fn request_review(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
#     fn approve(self: Box<Self>) -> Box<dyn State> {
#         self
#     }
# 
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        &post.content
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Billet {
</span><span class="boring">    etat: Option&lt;Box&lt;dyn Etat&gt;&gt;,
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Billet {
</span><span class="boring">    pub fn new() -&gt; Billet {
</span><span class="boring">        Billet {
</span><span class="boring">            etat: Some(Box::new(Brouillon {})),
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn contenu(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.etat.as_ref().unwrap().contenu(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn demander_relecture(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.demander_relecture())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approuver(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.etat.take() {
</span><span class="boring">            self.etat = Some(s.approuver())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait Etat {
    // -- partie masquée ici --
<span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt;;
</span><span class="boring">
</span>    fn contenu&lt;'a&gt;(&amp;self, billet: &amp;'a Billet) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// -- partie masquée ici --
<span class="boring">
</span><span class="boring">struct Brouillon {}
</span><span class="boring">
</span><span class="boring">impl Etat for Brouillon {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(EnRelecture {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnRelecture {}
</span><span class="boring">
</span><span class="boring">impl Etat for EnRelecture {
</span><span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        Box::new(Publier {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Publier {}

impl Etat for Publier {
    // -- partie masquée ici --
<span class="boring">    fn demander_relecture(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approuver(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Etat&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn contenu&lt;'a&gt;(&amp;self, billet: &amp;'a Billet) -&gt; &amp;'a str {
        &amp;billet.contenu
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-18: Adding the `content` method to the `State`
trait</span>
-->
<p><span class="caption">Encart 17-18 : ajout de la méthode <code>contenu</code> sur le trait
<code>Etat</code></span></p>
<!--
We add a default implementation for the `content` method that returns an empty
string slice. That means we don’t need to implement `content` on the `Draft`
and `PendingReview` structs. The `Published` struct will override the `content`
method and return the value in `post.content`.
-->
<p>Nous avons ajouté une implémentation par défaut pour la méthode <code>contenu</code> qui
retourne une slice de chaîne de caractères vide. Cela nous permet de ne pas
avoir à implémenter <code>contenu</code> sur les structures <code>Brouillon</code> et <code>EnRelecture</code>.
La structure <code>Publier</code> va remplacer la méthode <code>contenu</code> et retourner la valeur
présente dans <code>billet.contenu</code>.</p>
<!--
Note that we need lifetime annotations on this method, as we discussed in
Chapter 10. We’re taking a reference to a `post` as an argument and returning a
reference to part of that `post`, so the lifetime of the returned reference is
related to the lifetime of the `post` argument.
-->
<p>Remarquez aussi que nous devons annoter des durées de vie sur cette méthode,
comme nous l'avons vu au chapitre 10. Nous allons prendre en argument une
référence au <code>billet</code> et retourner une référence à une partie de ce <code>billet</code>,
donc la durée de vie retournée par la référence est liée à la durée de vie de
l'argument <code>billet</code>.</p>
<!--
And we’re done—all of Listing 17-11 now works! We’ve implemented the state
pattern with the rules of the blog post workflow. The logic related to the
rules lives in the state objects rather than being scattered throughout `Post`.
-->
<p>Et nous avons maintenant terminé, tout le code de l'encart 17-11 fonctionne,
désormais ! Nous avons implémenté le patron état avec les règles de notre
processus de publication définies pour notre blog. La logique des règles sont
intégrées dans les objets état plutôt que d'être dispersée un peu partout dans
<code>Billet</code>.</p>
<!--
### Trade-offs of the State Pattern
-->
<h3 id="les-désavantages-du-patron-état"><a class="header" href="#les-désavantages-du-patron-état">Les désavantages du patron état</a></h3>
<!--
We’ve shown that Rust is capable of implementing the object-oriented state
pattern to encapsulate the different kinds of behavior a post should have in
each state. The methods on `Post` know nothing about the various behaviors. The
way we organized the code, we have to look in only one place to know the
different ways a published post can behave: the implementation of the `State`
trait on the `Published` struct.
-->
<p>Nous avons démontré que Rust est capable d'implémenter le patron état qui est
orienté objet pour regrouper les différents types de comportement qu'un billet
doit avoir à chaque état. Les méthodes sur <code>Billet</code> ne savent rien des
différents comportements. De la manière dont nous avons organisé le code, nous
n'avons qu'à regarder à un seul endroit pour connaître les différents
comportements qu'un billet publié va suivre : l'implémentation du trait <code>Etat</code>
sur la structure <code>Publier</code>.</p>
<!--
If we were to create an alternative implementation that didn’t use the state
pattern, we might instead use `match` expressions in the methods on `Post` or
even in the `main` code that checks the state of the post and changes behavior
in those places. That would mean we would have to look in several places to
understand all the implications of a post being in the published state! This
would only increase the more states we added: each of those `match` expressions
would need another arm.
-->
<p>Si nous aurions utilité une autre façon d'implémenter ces règles sans utiliser
le patron état, nous aurions dû utiliser des expressions <code>match</code> dans les
méthodes de <code>Billet</code> ou même dans le code du <code>main</code> qui vérifie que l'état du
billet et les comportements associés aux changements d'états. Cela aurait eu
pour conséquence d'avoir à regarder à différents endroits pour comprendre toutes
les conséquences de la publication d'un billet ! Et ce code grossira au fur et
à mesure que nous ajouterons des états : chaque expression <code>match</code> devra avoir
des nouvelles branches pour ces nouveaux états.</p>
<!--
With the state pattern, the `Post` methods and the places we use `Post` don’t
need `match` expressions, and to add a new state, we would only need to add a
new struct and implement the trait methods on that one struct.
-->
<p>Avec le patron état, les méthodes de <code>Billet</code> et les endroits où nous utilisons
<code>Billet</code> n'ont pas besoin d'expressions <code>match</code>, et pour ajouter un nouvel état,
nous avons seulement besoin d'ajouter une nouvelle structure et d'implémenter
les méthodes du trait sur cette structure.</p>
<div id="suggestions-implementations">
<!--
The implementation using the state pattern is easy to extend to add more
functionality. To see the simplicity of maintaining code that uses the state
pattern, try a few of these suggestions:
-->
<p>L'implémentation qui utilise le patron état est facile à améliorer pour ajouter
plus de fonctionnalités. Pour découvrir la simplicité de maintenance du code qui
utilise le patron état, essayez d'accomplir certaines de ces suggestions :</p>
<!--
* Add a `reject` method that changes the post’s state from `PendingReview` back
  to `Draft`.
* Require two calls to `approve` before the state can be changed to `Published`.
* Allow users to add text content only when a post is in the `Draft` state.
  Hint: have the state object responsible for what might change about the
  content but not responsible for modifying the `Post`.
-->
<ul>
<li>Ajouter une méthode <code>rejeter</code> qui fait retourner l'état d'un billet de
<code>EnRelecture</code> en <code>Brouillon</code>.</li>
<li>Attendre deux appels à <code>approuver</code> avant que l'état puisse être changé en
<code>Publier</code>.</li>
<li>Permettre aux utilisateurs pour ajouter du contenu textuel uniquement
lorsqu'un billet est à l'état <code>Brouillon</code>. Astuce : l'objet état est
responsable de ce qui peut changer dans le contenu mais pas responsable de la
modification de <code>Billet</code>.</li>
</ul>
</div>
<!--
One downside of the state pattern is that, because the states implement the
transitions between states, some of the states are coupled to each other. If we
add another state between `PendingReview` and `Published`, such as `Scheduled`,
we would have to change the code in `PendingReview` to transition to
`Scheduled` instead. It would be less work if `PendingReview` didn’t need to
change with the addition of a new state, but that would mean switching to
another design pattern.
-->
<p>Un désavantage du patron état est que comme les états implémentent les
transitions en les états, certains des états sont reliés entre eux. Si nous
ajoutons un nouvel état entre <code>EnRelecture</code> et <code>Publier</code>, comme <code>Planifier</code>,
nous devrions alors changer le code dans <code>EnRelecture</code> pour qu'il passe ensuite
à l'état <code>Planifier</code> à la place de <code>Publier</code>. Cela représentera moins de travail
si <code>EnRelecture</code> n'a pas besoin de changer lorsqu'on ajoute un nouvel état, mais
cela signifiera alors qu'il faut changer de patron.</p>
<!--
Another downside is that we’ve duplicated some logic. To eliminate some of the
duplication, we might try to make default implementations for the
`request_review` and `approve` methods on the `State` trait that return `self`;
however, this would violate object safety, because the trait doesn’t know what
the concrete `self` will be exactly. We want to be able to use `State` as a
trait object, so we need its methods to be object safe.
-->
<p>Un autre désavantage et que nous avons de la logique en double. Pour éviter ces
doublons, nous devrions essayer de faire en sorte que les méthodes
<code>demander_relecture</code> et <code>approuver</code> qui retournent <code>self</code> deviennent les
implémentations par défaut sur le trait <code>Etat</code> ; cependant, cela violera la
sécurité des objets, car le trait ne sait pas ce qu'est exactement <code>self</code>. Nous
voulons pouvoir utiliser <code>Etat</code> en tant qu'objet trait, donc nous avons besoin
que ses méthodes soient sûres pour les objets.</p>
<!--
Other duplication includes the similar implementations of the `request_review`
and `approve` methods on `Post`. Both methods delegate to the implementation of
the same method on the value in the `state` field of `Option` and set the new
value of the `state` field to the result. If we had a lot of methods on `Post`
that followed this pattern, we might consider defining a macro to eliminate the
repetition (see the [“Macros”][macros]<!-- ignore -- > section in Chapter 19).
-->
<p>Nous avons aussi des doublons dans le code des méthodes <code>demander_relecture</code>
et <code>approuver</code> sur <code>Billet</code>. Ces deux méthodes délèguent leur travail aux mêmes
méthodes respectives sur la valeur du champ <code>etat</code> de type <code>Option</code> et assignent
la valeur au même champ <code>etat</code> à la fin. Si nous avions beaucoup de méthodes sur
<code>Billet</code> qui suivent cette logique, nous devrions considérer la création et
l'utilisation d'une macro pour éviter cette répétition (voir la
<a href="ch19-06-macros.html#macros">section dédiée</a><!-- ignore --> dans le chapitre 19).</p>
<!--
By implementing the state pattern exactly as it’s defined for object-oriented
languages, we’re not taking as full advantage of Rust’s strengths as we could.
Let’s look at some changes we can make to the `blog` crate that can make
invalid states and transitions into compile time errors.
-->
<p>En implémentant le patron état exactement comme il l'est défini pour les
langages orientés-objet, nous ne profitons pas pleinement des avantages de
Rust. Voyons voir si nous pouvons faire quelques changements pour que la crate
<code>blog</code> puisse lever des erreurs à la compilation lorsqu'elle aura détecté des
états ou des transitions invalides.</p>
<!--
#### Encoding States and Behavior as Types
-->
<h4 id="implémenter-les-états-et-les-comportements-avec-des-types"><a class="header" href="#implémenter-les-états-et-les-comportements-avec-des-types">Implémenter les états et les comportements avec des types</a></h4>
<!--
We’ll show you how to rethink the state pattern to get a different set of
trade-offs. Rather than encapsulating the states and transitions completely so
outside code has no knowledge of them, we’ll encode the states into different
types. Consequently, Rust’s type checking system will prevent attempts to use
draft posts where only published posts are allowed by issuing a compiler error.
-->
<p>Nous allons vous montrer comment repenser le patron état pour qu'il offre des
compromis différents. Plutôt que d'intégrer les états et les transitions
complètement de manière à ce que le code externe ne puissent pas les connaître,
nous allons transformer les états dans différents types. En conséquence, le
système de vérification de type de Rust va éviter d'utiliser des brouillons de
billets en provoquant une erreur du compilateur dans les endroits où ils seront
utilisés alors que seuls les billets publiés seront autorisés.</p>
<!--
Let’s consider the first part of `main` in Listing 17-11:
-->
<p>Considérons la première partie du <code>main</code> de l'encart 17-11 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
# use blog::Post;
# 
fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());
# 
#     post.request_review();
#     assert_eq!("", post.content());
# 
#     post.approve();
#     assert_eq!("I ate a salad for lunch today", post.content());
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use blog::Billet;
</span><span class="boring">
</span>fn main() {
    let mut billet = Billet::new();

    billet.ajouter_texte(&quot;J'ai mangé une salade au déjeuner aujourd'hui&quot;);
    assert_eq!(&quot;&quot;, billet.contenu());
<span class="boring">
</span><span class="boring">    billet.demander_relecture();
</span><span class="boring">    assert_eq!(&quot;&quot;, billet.contenu());
</span><span class="boring">
</span><span class="boring">    billet.approuver();
</span><span class="boring">    assert_eq!(&quot;J'ai mangé une salade au déjeuner aujourd'hui&quot;, billet.contenu());
</span>}
</code></pre>
<!--
We still enable the creation of new posts in the draft state using `Post::new`
and the ability to add text to the post’s content. But instead of having a
`content` method on a draft post that returns an empty string, we’ll make it so
draft posts don’t have the `content` method at all. That way, if we try to get
a draft post’s content, we’ll get a compiler error telling us the method
doesn’t exist. As a result, it will be impossible for us to accidentally
display draft post content in production, because that code won’t even compile.
Listing 17-19 shows the definition of a `Post` struct and a `DraftPost` struct,
as well as methods on each:
-->
<p>Nous pouvons toujours créer de nouveaux billets à l'état de brouillon en
utilisant <code>Billet::new</code> et ajouter du texte au contenu du billet. Mais au lieu
d'avoir une méthode <code>contenu</code> sur un brouillon de billet qui retourne une chaîne
de caractères vide, nous faisons en sorte que les brouillons de billets n'aient
même pas de méthode <code>contenu</code>. Ainsi, si nous essayons de récupérer le contenu
d'un brouillon de billet, nous obtenons une erreur de compilation qui nous
informera que la méthode n'existe pas. Finalement, il nous sera impossible de
publier le contenu d'un brouillon de billet en production, car ce code ne se
compilera même pas. L'encart 17-19 nous propose les définitions d'une structure
<code>Billet</code> et d'une structure <code>BrouillonDeBillet</code> ainsi que leurs méthodes :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -> DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&self) -> &str {
        &self.content
    }
}

impl DraftPost {
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Billet {
    contenu: String,
}

pub struct BrouillonDeBillet {
    contenu: String,
}

impl Billet {
    pub fn new() -&gt; BrouillonDeBillet {
        BrouillonDeBillet {
            contenu: String::new(),
        }
    }

    pub fn contenu(&amp;self) -&gt; &amp;str {
        &amp;self.contenu
    }
}

impl BrouillonDeBillet {
    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
        self.contenu.push_str(texte);
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-19: A `Post` with a `content` method and a
`DraftPost` without a `content` method</span>
-->
<p><span class="caption">Encart 17-19 : un <code>Billet</code> avec une méthode <code>contenu</code> et
un <code>BrouillonDeBillet</code> sans méthode <code>contenu</code></span></p>
<!--
Both the `Post` and `DraftPost` structs have a private `content` field that
stores the blog post text. The structs no longer have the `state` field because
we’re moving the encoding of the state to the types of the structs. The `Post`
struct will represent a published post, and it has a `content` method that
returns the `content`.
-->
<p>Les deux structures <code>Billet</code> et <code>BrouillonDeBillet</code> ont un champ privé <code>contenu</code>
qui stocke le texte du billet de blog. Les structures n'ont plus le champ <code>etat</code>
car nous avons déplacé la signification de l'état directement dans le nom de ces
types de structures. La structure <code>Billet</code> représente un billet publié, et a une
méthode <code>contenu</code> qui retourne le <code>contenu</code>.</p>
<!--
We still have a `Post::new` function, but instead of returning an instance of
`Post`, it returns an instance of `DraftPost`. Because `content` is private
and there aren’t any functions that return `Post`, it’s not possible to create
an instance of `Post` right now.
-->
<p>Nous avons toujours la fonction <code>Billet::new</code>, mais au lieu de retourner une
instance de <code>Billet</code>, elle va retourner une instance de <code>BrouillonDeBillet</code>.
Comme <code>contenu</code> est privé et qu'il n'y a pas de fonction qui retourne <code>Billet</code>,
il ne sera pas possible pour le moment de créer une instance de <code>Billet</code>.</p>
<!--
The `DraftPost` struct has an `add_text` method, so we can add text to
`content` as before, but note that `DraftPost` does not have a `content` method
defined! So now the program ensures all posts start as draft posts, and draft
posts don’t have their content available for display. Any attempt to get around
these constraints will result in a compiler error.
-->
<p>La structure <code>BrouillonDeBillet</code> a une méthode <code>ajouter_texte</code>, donc nous
pouvons ajouter du texte à <code>contenu</code> comme nous le faisions avant, mais
remarquez toutefois que <code>BrouillonDeBillet</code> n'a pas de méthode <code>contenu</code> de
défini ! Donc pour l'instant le programme s'assure que tous les billets
démarrent à l'état de brouillon, et que les brouillons ne proposent pas de
contenu à publier. Toute tentative d'outre-passer ces contraintes vont
déclencher des erreurs de compilation.</p>
<!--
#### Implementing Transitions as Transformations into Different Types
-->
<h4 id="implémenter-les-changements-détat-en-tant-que-changement-de-type"><a class="header" href="#implémenter-les-changements-détat-en-tant-que-changement-de-type">Implémenter les changements d'état en tant que changement de type</a></h4>
<!--
So how do we get a published post? We want to enforce the rule that a draft
post has to be reviewed and approved before it can be published. A post in the
pending review state should still not display any content. Let’s implement
these constraints by adding another struct, `PendingReviewPost`, defining the
`request_review` method on `DraftPost` to return a `PendingReviewPost`, and
defining an `approve` method on `PendingReviewPost` to return a `Post`, as
shown in Listing 17-20:
-->
<p>Donc, comment publier un billet ? Nous voulons renforcer la règle qui dit qu'un
brouillon de billet doit être relu et approuvé avant de pouvoir être publié. Un
billet à l'état de relecture doit continuer à ne pas montrer son contenu.
Implémentons ces contraintes en introduisant une nouvelle structure,
<code>BilletEnRelecture</code>, en définissant la méthode <code>demander_relecture</code> sur
<code>BrouillonDeBillet</code> pour retourner un <code>BilletEnRelecture</code>, et en définissant une
méthode <code>approuver</code> sur <code>BilletEnRelecture</code> pour qu'elle retourne un <code>Billet</code>,
comme le propose l'encart 17-20 :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# pub struct Post {
#     content: String,
# }
# 
# pub struct DraftPost {
#     content: String,
# }
# 
# impl Post {
#     pub fn new() -> DraftPost {
#         DraftPost {
#             content: String::new(),
#         }
#     }
# 
#     pub fn content(&self) -> &str {
#         &self.content
#     }
# }
# 
impl DraftPost {
    // --snip--
#     pub fn add_text(&mut self, text: &str) {
#         self.content.push_str(text);
#     }
# 
    pub fn request_review(self) -> PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -> Post {
        Post {
            content: self.content,
        }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Billet {
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct BrouillonDeBillet {
</span><span class="boring">    contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Billet {
</span><span class="boring">    pub fn new() -&gt; BrouillonDeBillet {
</span><span class="boring">        BrouillonDeBillet {
</span><span class="boring">            contenu: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn contenu(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.contenu
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl BrouillonDeBillet {
    // -- partie masquée ici --
<span class="boring">    pub fn ajouter_texte(&amp;mut self, texte: &amp;str) {
</span><span class="boring">        self.contenu.push_str(texte);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn demander_relecture(self) -&gt; BilletEnRelecture {
        BilletEnRelecture {
            contenu: self.contenu,
        }
    }
}

pub struct BilletEnRelecture {
    contenu: String,
}

impl BilletEnRelecture {
    pub fn approuver(self) -&gt; Billet {
        Billet {
            contenu: self.contenu,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-20: A `PendingReviewPost` that gets created by
calling `request_review` on `DraftPost` and an `approve` method that turns a
`PendingReviewPost` into a published `Post`</span>
-->
<p><span class="caption">Encart 17-20 : ajout d'un <code>BilletEnRelecture</code> qui est créé
par l'appel à <code>demander_relecture</code> sur <code>BrouillonDeBillet</code>, ainsi qu'une méthode
<code>approuver</code> qui transforme un <code>BilletEnRelecture</code> en <code>Billet</code> publié</span></p>
<!--
The `request_review` and `approve` methods take ownership of `self`, thus
consuming the `DraftPost` and `PendingReviewPost` instances and transforming
them into a `PendingReviewPost` and a published `Post`, respectively. This way,
we won’t have any lingering `DraftPost` instances after we’ve called
`request_review` on them, and so forth. The `PendingReviewPost` struct doesn’t
have a `content` method defined on it, so attempting to read its content
results in a compiler error, as with `DraftPost`. Because the only way to get a
published `Post` instance that does have a `content` method defined is to call
the `approve` method on a `PendingReviewPost`, and the only way to get a
`PendingReviewPost` is to call the `request_review` method on a `DraftPost`,
we’ve now encoded the blog post workflow into the type system.
-->
<p>Les méthodes <code>demander_relecture</code> et <code>approuver</code> prennent possession de <code>self</code>,
ce qui consomme les instances de <code>BrouillonDeBillet</code> et de <code>BilletEnRelecture</code>
pour les transformer respectivement en <code>BilletEnRelecture</code> et en <code>Billet</code>.
Ainsi, il ne restera plus d'instances de <code>BrouillonDeBillet</code> après avoir appelé
<code>approuver</code> sur elles, et ainsi de suite. La structure <code>BilletEnRelecture</code> n'a
pas de méthode <code>contenu</code> qui lui est définie, donc si on essaye de lire son
contenu, on obtient une erreur de compilation, comme avec <code>BrouillonDeBillet</code>.
Comme la seule manière d'obtenir une instance de <code>Billet</code> qui a une méthode
<code>contenu</code> de définie est d'appeler la méthode<code>approuver</code> sur un
<code>BilletEnRelecture</code>, et que la seule manière d'obtenir un <code>BilletEnRelecture</code>
est d'appeler la méthode <code>demander_relecture</code> sur un <code>BrouillonDeBillet</code>, nous
avons désormais intégré le processus de publication des billets de blog avec le
système de type.</p>
<!--
But we also have to make some small changes to `main`. The `request_review` and
`approve` methods return new instances rather than modifying the struct they’re
called on, so we need to add more `let post =` shadowing assignments to save
the returned instances. We also can’t have the assertions about the draft and
pending review post’s contents be empty strings, nor do we need them: we can’t
compile code that tries to use the content of posts in those states any longer.
The updated code in `main` is shown in Listing 17-21:
-->
<p>Mais nous devons aussi faire quelques petits changements dans le <code>main</code>. Les
méthodes <code>demander_relecture</code> et <code>approuver</code> retournent des nouvelles instances
au lieu de modifier la structure sur laquelle elles ont été appelées, donc nous
devons ajouter des assignations de masquage <code>let billet =</code> pour stocker les
nouvelles instances retournées. Nous ne pouvons pas non plus vérifier que le
contenu des brouillons de billets et ceux en cours de relecture soient bien
vides, donc nous n'en avons plus besoin : nous ne pouvons plus compiler du code
qui essaye d'utiliser le contenu d'un billet dans cet état. Le code du <code>main</code>
mis à jour est présenté dans l'encart 17-21 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}
```
-->
<pre><code class="language-rust ignore">use blog::Billet;

fn main() {
    let mut billet = Billet::new();

    billet.ajouter_texte(&quot;J'ai mangé une salade au déjeuner aujourd'hui&quot;);

    let billet = billet.demander_relecture();

    let billet = billet.approuver();

    assert_eq!(&quot;J'ai mangé une salade au déjeuner aujourd'hui&quot;, billet.contenu());
}
</code></pre>
<!--
<span class="caption">Listing 17-21: Modifications to `main` to use the new
implementation of the blog post workflow</span>
-->
<p><span class="caption">Encart 17-21 : modification de <code>main</code> pour utiliser la
nouvelle implémentation du processus de publication de billet de blog</span></p>
<!--
The changes we needed to make to `main` to reassign `post` mean that this
implementation doesn’t quite follow the object-oriented state pattern anymore:
the transformations between the states are no longer encapsulated entirely
within the `Post` implementation. However, our gain is that invalid states are
now impossible because of the type system and the type checking that happens at
compile time! This ensures that certain bugs, such as display of the content of
an unpublished post, will be discovered before they make it to production.
-->
<p>Les modifications dont nous avons besoin de faire au <code>main</code> pour réassigner
<code>billet</code> impliquent que cette implémentation ne suit plus exactement le patron
état orienté-objet : les changements d'états ne sont plus totalement intégrés
dans l'implémentation de <code>Billet</code>. Cependant, nous faisons en sorte que les
états invalides soient impossibles grâce au système de types et que la
vérification de type s'effectue à la compilation ! Cela garantit que certains
bogues, comme l'affichage du contenu d'un billet non publié, sera détecté avant
avant d'arriver en production.</p>
<!--
Try the tasks suggested for additional requirements that we mentioned at the
start of this section on the `blog` crate as it is after Listing 17-20 to see
what you think about the design of this version of the code. Note that some of
the tasks might be completed already in this design.
-->
<p>Essayez d'accomplir <a href="ch17-03-oo-design-patterns.html#suggestions-implementations">les suggestions proposées pour les conditions
supplémentaires que nous avons listés au début de cette
section</a>, sur la crate <code>blog</code> telle qu'elle est
après l'encart 17-20, pour vous faire une idée sur cette conception du code.
Notez aussi que certaines suggestions sont déjà accomplies implicitement grâce à
cette conception.</p>
<!--
We’ve seen that even though Rust is capable of implementing object-oriented
design patterns, other patterns, such as encoding state into the type system,
are also available in Rust. These patterns have different trade-offs. Although
you might be very familiar with object-oriented patterns, rethinking the
problem to take advantage of Rust’s features can provide benefits, such as
preventing some bugs at compile time. Object-oriented patterns won’t always be
the best solution in Rust due to certain features, like ownership, that
object-oriented languages don’t have.
-->
<p>Nous avons vu que même si Rust est capable d'implémenter des patrons de
conception orientés-objet, les autres patrons, comme intégrer l'état dans le
système de type, est aussi possible en Rust. Ces patrons ont différents
avantages et désavantages. Bien que vous soyez familier avec les patrons
orientés-objet, vous gagnerez à repenser les choses pour tirer avantage des
fonctionnalités de Rust, comme la détection de certains bogues à la compilation.
Les patrons orientés-objet ne sont pas toujours la meilleure solution en Rust à
cause de certaines de ses fonctionnalités, comme la possession, que les langages
orientés-objet n'ont pas.</p>
<!--
## Summary
-->
<h2 id="résumé-16"><a class="header" href="#résumé-16">Résumé</a></h2>
<!--
No matter whether or not you think Rust is an object-oriented language after
reading this chapter, you now know that you can use trait objects to get some
object-oriented features in Rust. Dynamic dispatch can give your code some
flexibility in exchange for a bit of runtime performance. You can use this
flexibility to implement object-oriented patterns that can help your code’s
maintainability. Rust also has other features, like ownership, that
object-oriented languages don’t have. An object-oriented pattern won’t always
be the best way to take advantage of Rust’s strengths, but is an available
option.
-->
<p>Que vous pensiez ou non que Rust est un langage orienté-objet après avoir lu ce
chapitre, vous savez maintenant que vous pouvez utiliser les objets trait pour
pouvoir obtenir certaines fonctionnalités orienté-objet en Rust. La répartition
dynamique peut offrir de la flexibilité à votre code en échange d'une perte de
performances à l'exécution. Vous pouvez utiliser cette flexibilité pour
implémenter des patrons orientés-objet qui puissent aider la maintenance de
votre code. Rust offre d'autres fonctionnalités, comme la possession, que les
langages orientés-objet n'ont pas. L'utilisation d'un patron orienté-objet n'est
pas toujours la meilleure manière de tirer parti des avantages de Rust, mais
cela reste une option disponible.</p>
<!--
Next, we’ll look at patterns, which are another of Rust’s features that enable
lots of flexibility. We’ve looked at them briefly throughout the book but
haven’t seen their full capability yet. Let’s go!
-->
<p>Dans le chapitre suivant, nous allons étudier les motifs, qui est une autre des
fonctionnalités de Rust qui offre beaucoup de flexibilité. Nous les avons
rencontrés brièvement dans le livre, mais nous n'avons pas encore vu tout leur
potentiel. C'est parti !</p>
<!-- markdownlint-disable -->
<!--
[more-info-than-rustc]: ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler
[macros]: ch19-06-macros.html#macros
-->
<!-- markdownlint-enable -->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--21"><a class="header" href="#-attention-peinture-fraîche--21">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/203">Pull Request</a>.</p>
</blockquote>
<!--
# Patterns and Matching
-->
<h1 id="les-motifs-et-le-filtrage-par-motif"><a class="header" href="#les-motifs-et-le-filtrage-par-motif">Les motifs et le filtrage par motif</a></h1>
<!--
Patterns are a special syntax in Rust for matching against the structure of
types, both complex and simple. Using patterns in conjunction with `match`
expressions and other constructs gives you more control over a program’s
control flow. A pattern consists of some combination of the following:
-->
<p>Les motifs ont une syntaxe spéciale en Rust pour pouvoir les filtrer sur la
structure des types, qu'elle soit simple ou complexe. L'utilisation de motifs
en collaboration avec l'expression <code>match</code> et d'autres constructions vous donne
plus contrôle sur le flux de contrôle de votre programme. Un motif concerne :</p>
<!--
* Literals
* Destructured arrays, enums, structs, or tuples
* Variables
* Wildcards
* Placeholders
-->
<ul>
<li>les littéraux</li>
<li>les tableaux déstructurés, les énumérations, les structures, ou les tuples</li>
<li>les variables</li>
<li>les jokers</li>
<li>les espaces réservés</li>
</ul>
<!--
These components describe the shape of the data we’re working with, which we
then match against values to determine whether our program has the correct data
to continue running a particular piece of code.
-->
<p>Les composants décrivent la forme d'une donnée avec laquelle nous travaillons,
que nous filtrons avec motifs de valeurs pour savoir si notre programme a la
donnée correcte pour continuer à exécuter un code qui en a besoin.</p>
<!--
To use a pattern, we compare it to some value. If the pattern matches the
value, we use the value parts in our code. Recall the `match` expressions in
Chapter 6 that used patterns, such as the coin-sorting machine example. If the
value fits the shape of the pattern, we can use the named pieces. If it
doesn’t, the code associated with the pattern won’t run.
-->
<p>Pour utiliser un motif, nous le comparons à quelques valeurs. Si le motif
correspond à la valeur, nous utilisons les éléments présents dans la valeur
pour notre code. Rappelez-vous que les expressions <code>match</code> du chapitre 6
utilisaient les motifs, comme pour la machine à trier la monnaie par exemple.
Si la valeur correspond à la forme d'un motif, nous pouvions utiliser le nom de
la pièce. Sinon, le code lié au motif n'était pas exécuté.</p>
<!--
This chapter is a reference on all things related to patterns. We’ll cover the
valid places to use patterns, the difference between refutable and irrefutable
patterns, and the different kinds of pattern syntax that you might see. By the
end of the chapter, you’ll know how to use patterns to express many concepts in
a clear way.
-->
<p>Ce chapitre sert de référence sur ce qui concerne les motifs. Nous allons voir
les moments appropriés pour utiliser les motifs, les différences entre les
motifs réfutables et irréfutables, et les différentes syntaxes de motifs que
vous pouvez rencontrer. A la fin de ce chapitre, vous saurez comment utiliser
les motifs pour exprimer clairement de nombreux concepts.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--22"><a class="header" href="#-attention-peinture-fraîche--22">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/205">Pull Request</a>.</p>
</blockquote>
<!--
## All the Places Patterns Can Be Used
-->
<h2 id="tous-les-endroits-où-les-motifs-peuvent-être-utilisés"><a class="header" href="#tous-les-endroits-où-les-motifs-peuvent-être-utilisés">Tous les endroits où les motifs peuvent être utilisés</a></h2>
<!--
Patterns pop up in a number of places in Rust, and you’ve been using them a lot
without realizing it! This section discusses all the places where patterns are
valid.
-->
<p>Les motifs apparaissent dans de nombreux endroits en Rust, et vous en avez
utilisé beaucoup sans vous en rendre compte ! Cette section va présenter les
différentes situations où l'utilisation des motifs est appropriée.</p>
<!--
### `match` Arms
-->
<h3 id="les-branches-des-match"><a class="header" href="#les-branches-des-match">Les branches des <code>match</code></a></h3>
<!--
As discussed in Chapter 6, we use patterns in the arms of `match` expressions.
Formally, `match` expressions are defined as the keyword `match`, a value to
match on, and one or more match arms that consist of a pattern and an
expression to run if the value matches that arm’s pattern, like this:
-->
<p>Comme nous l'avons vu au chapitre 6, nous utilisons les motifs dans les
branches des expressions <code>match</code>. Techniquement, les expressions <code>match</code> sont
définies avec le mot-clé <code>match</code>, une valeur sur laquelle procéder, et une ou
plusieurs branches qui constituent un motif, ainsi qu'une expression à exécuter
si la valeur correspond au motif de cette branche, comme ceci :</p>
<!--
```text
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}
```
-->
<pre><code class="language-text">match VALEUR {
    MOTIF =&gt; EXPRESSION,
    MOTIF =&gt; EXPRESSION,
    MOTIF =&gt; EXPRESSION,
}
</code></pre>
<!--
One requirement for `match` expressions is that they need to be *exhaustive* in
the sense that all possibilities for the value in the `match` expression must
be accounted for. One way to ensure you’ve covered every possibility is to have
a catchall pattern for the last arm: for example, a variable name matching any
value can never fail and thus covers every remaining case.
-->
<p>L'une des conditions à respecter pour les expressions <code>match</code> est qu'elle doit
être <em>exhaustive</em> dans le sens où toutes les possibilités pour la valeur dans
l'expression <code>match</code> doivent être prises en compte. Une façon de s'assurer que
vous avez couvert toutes les possibilités est d'avoir un motif passe-partout
pour la dernière branche : par exemple, une valeur quelconque ne pourra jamais
échouer car la dernière branche permet de couvrir tous les autres cas
possibles.</p>
<!--
A particular pattern `_` will match anything, but it never binds to a variable,
so it’s often used in the last match arm. The `_` pattern can be useful when
you want to ignore any value not specified, for example. We’ll cover the `_`
pattern in more detail in the [“Ignoring Values in a
Pattern”][ignoring-values-in-a-pattern]<!-- ignore -- > section later in this
chapter.
-->
<p>Le motif spécifique <code>_</code> va correspondre à tout, mais il ne fournira jamais de
variable, donc il est souvent utilisé dans la dernière branche. Le motif <code>_</code>
peut être utile lorsque vous souhaitez ignorer toutes les autres valeurs qui
n'ont pas été listées, par exemple. Nous allons voir plus en détail le motif
<code>_</code> dans une section
<a href="ch18-03-pattern-syntax.html">plus tard dans ce chapitre</a><!-- ignore -->.</p>
<!--
### Conditional `if let` Expressions
-->
<h3 id="les-expressions-conditionnelles-if-let"><a class="header" href="#les-expressions-conditionnelles-if-let">Les expressions conditionnelles <code>if let</code></a></h3>
<!--
In Chapter 6 we discussed how to use `if let` expressions mainly as a shorter
way to write the equivalent of a `match` that only matches one case.
Optionally, `if let` can have a corresponding `else` containing code to run if
the pattern in the `if let` doesn’t match.
-->
<p>Au chapitre 6, nous avons vu comment utiliser les expressions <code>if let</code>,
principalement pour pouvoir écrire l'équivalent d'un <code>match</code> qui ne correspond
qu'à un seul cas.
Accessoirement, <code>if let</code> peut avoir un <code>else</code> correspondant au code à exécuter
si le motif du <code>if let</code> ne correspond pas au premier critère.</p>
<!--
Listing 18-1 shows that it’s also possible to mix and match `if let`, `else
if`, and `else if let` expressions. Doing so gives us more flexibility than a
`match` expression in which we can express only one value to compare with the
patterns. Also, the conditions in a series of `if let`, `else if`, `else if
let` arms aren’t required to relate to each other.
-->
<p>L'encart 18-1 montre qu'il est aussi possible de conjuguer les expressions
<code>if let</code>, <code>else if</code>, et <code>else if let</code>. Faire ceci nous donne plus de
flexibilité qu'une expression <code>match</code> dans laquelle nous ne pouvons que
vérifier une seule valeur à comparer avec les motifs. De plus, dans une série
de branches <code>if let</code>, <code>else if</code>, et <code>else if let</code>, les conditions n'ont pas
besoin d'avoir les mêmes conditions et contextes.</p>
<!--
The code in Listing 18-1 shows a series of checks for several conditions that
decide what the background color should be. For this example, we’ve created
variables with hardcoded values that a real program might receive from user
input.
-->
<p>Le code de l'encart 18-1 montre une série de vérifications pour quelques
conditions qui décident quelle devrait être la couleur de fond. Pour cet
exemple, nous avons créé les variables avec des valeurs codées en dur qu'un
vrai programme devrait recevoir d'une saisie d'un utilisateur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {}, as the background", color);
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age > 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let couleur_favorite: Option&lt;&amp;str&gt; = None;
    let on_est_mardi = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(couleur) = couleur_favorite {
        println!(&quot;Utilisation de votre couleur favorite, {}, comme couleur de fond&quot;, couleur);
    } else if on_est_mardi {
        println!(&quot;Mardi, c'est le jour du vert !&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Utilisation du violet comme couleur de fond&quot;);
        } else {
            println!(&quot;Utilisation de l'orange comme couleur de fond&quot;);
        }
    } else {
        println!(&quot;Utilisation du bleu comme couleur de fond&quot;);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-1: Mixing `if let`, `else if`, `else if let`,
and `else`</span>
-->
<p><span class="caption">Encart 18-1 : mélange de <code>if let</code>, <code>else if</code>,
<code>else if let</code>, et <code>else</code></span></p>
<!--
If the user specifies a favorite color, that color is the background color. If
today is Tuesday, the background color is green. If the user specifies
their age as a string and we can parse it as a number successfully, the color
is either purple or orange depending on the value of the number. If none of
these conditions apply, the background color is blue.
-->
<p>Si l'utilisateur renseigne une couleur favorite, c'est cette couleur qui
devient la couleur de fond. Sinon, si nous sommes mardi, la couleur de fond
sera vert. Sinon, si l'utilisateur a renseigné son age dans une chaîne de
caractères et que nous pouvons l'interpréter comme un nombre avec succès, la
couleur de fond sera soit violet, soit orange en fonction de la valeur de ce
nombre. Si aucune de ces conditions s'applique, la couleur de fond sera bleu.</p>
<!--
This conditional structure lets us support complex requirements. With the
hardcoded values we have here, this example will print `Using purple as the
background color`.
-->
<p>Cette structure conditionnelle nous permet de répondre à des conditions
complexes. Avec les valeurs codées en dur que nous avons ici, cet exemple
devrait afficher <code>Utilisation du violet comme couleur de fond</code>.</p>
<!--
You can see that `if let` can also introduce shadowed variables in the same way
that `match` arms can: the line `if let Ok(age) = age` introduces a new
shadowed `age` variable that contains the value inside the `Ok` variant. This
means we need to place the `if age > 30` condition within that block: we can’t
combine these two conditions into `if let Ok(age) = age && age > 30`. The
shadowed `age` we want to compare to 30 isn’t valid until the new scope starts
with the curly bracket.
-->
<p>Vous pouvez constater que le <code>if let</code> nous permet d'utiliser les variables
masquées de la même manière que le fait le font les branches <code>match</code> : la ligne
<code>if let Ok(age) = age</code> crée une nouvelle variable masquée <code>age</code> qui contient la
valeur présente dans la variante <code>Ok</code>. Cela signifie que nous devons placer la
condition <code>if age &gt; 30</code> à l'intérieur de ce bloc : nous ne pouvons pas combiner
ces deux conditions dans une seule <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>. La
variable masquée <code>age</code> que nous souhaitons comparer à 30 n'est pas encore en
vigueur tant que la nouvelle portée entre les accolades n'a pas commencée.</p>
<!--
The downside of using `if let` expressions is that the compiler doesn’t check
exhaustiveness, whereas with `match` expressions it does. If we omitted the
last `else` block and therefore missed handling some cases, the compiler would
not alert us to the possible logic bug.
-->
<p>Le désavantage de l'utilisation des expressions <code>if let</code> est que le compilateur
ne vérifie pas l'exhaustivité, ce que fait l'expression <code>match</code>. Si nous avions
enlevé le dernier bloc <code>else</code> et ainsi que nous oublions de gérer certains cas,
le compilateur ne pourrait pas nous prévenir d'un possible bogue de logique.</p>
<!--
### `while let` Conditional Loops
-->
<h3 id="les-boucles-conditionelles-while-let"><a class="header" href="#les-boucles-conditionelles-while-let">les boucles conditionelles <code>while let</code></a></h3>
<!--
Similar in construction to `if let`, the `while let` conditional loop allows a
`while` loop to run for as long as a pattern continues to match. The example in
Listing 18-2 shows a `while let` loop that uses a vector as a stack and prints
the values in the vector in the opposite order in which they were pushed.
-->
<p>Comme les constructions <code>if let</code>, les boucles conditionnelles <code>while let</code>
permettent à une boucle <code>while</code> de s'exécuter aussi longtemps qu'un motif
continue à correspondre. L'exemple dans l'encart 18-2 montre une boucle
<code>while let</code> qui utilise un vecteur comme une pile et affiche les valeurs du
vecteur dans l'ordre opposé à celui dans lequel elles ont été insérées.</p>
<!--
```rust
# fn main() {
    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!("{}", top);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut pile = Vec::new();

    pile.push(1);
    pile.push(2);
    pile.push(3);

    while let Some(donnee_du_haut) = pile.pop() {
        println!(&quot;{}&quot;, donnee_du_haut);
    }
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut pile = Vec::new();

pile.push(1);
pile.push(2);
pile.push(3);

while let Some(donnee_du_haut) = pile.pop() {
    println!(&quot;{}&quot;, donnee_du_haut);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-2: Using a `while let` loop to print values
for as long as `stack.pop()` returns `Some`</span>
-->
<p><span class="caption">Encart 18-2 : utilisation d'une boucle <code>while let</code> pour
afficher les valeurs aussi longtemps que <code>pile.pop()</code> retourne une <code>Some</code></span></p>
<!--
This example prints 3, 2, and then 1. The `pop` method takes the last element
out of the vector and returns `Some(value)`. If the vector is empty, `pop`
returns `None`. The `while` loop continues running the code in its block as
long as `pop` returns `Some`. When `pop` returns `None`, the loop stops. We can
use `while let` to pop every element off our stack.
-->
<p>Cet exemple affiche 3, 2 puis ensuite 1. La méthode <code>pop</code> sort le dernier
élément du vecteur et retourne <code>Some(valeur)</code>. Si le vecteur est vide, <code>pop</code>
retourne alors <code>None</code>. La boucle <code>while</code> continue à exécuter le code de son bloc
aussi longtemps que <code>pop</code> retourne un <code>Some</code>. Lorsque <code>pop</code> retournera <code>None</code>,
la boucle s'arrêtera. Nous pouvons utiliser <code>while let</code> pour extraire tous les
éléments de la pile.</p>
<!--
### `for` Loops
-->
<h3 id="les-boucles-for"><a class="header" href="#les-boucles-for">Les boucles <code>for</code></a></h3>
<!--
In Chapter 3, we mentioned that the `for` loop is the most common loop
construction in Rust code, but we haven’t yet discussed the pattern that `for`
takes. In a `for` loop, the pattern is the value that directly follows the
keyword `for`, so in `for x in y` the `x` is the pattern.
-->
<p>Au chapitre 3, nous avions mentionné que la boucle <code>for</code> était la construction
de boucle la plus utilisé dans du code Rust, mais nous n'avons pas encore abordé
le motif que prend <code>for</code>. Dans une boucle <code>for</code>, le motif est la valeur qui suit
directement le mot-clé <code>for</code>, de sorte que <code>x</code> est le motif dans <code>for x in y</code>.</p>
<!--
Listing 18-3 demonstrates how to use a pattern in a `for` loop to destructure,
or break apart, a tuple as part of the `for` loop.
-->
<p>L'encart 18-3 montre comment utiliser un motif dans une boucle <code>for</code> pour
déstructurer, ou décomposer, un tuple comme étant une partie de la boucle <code>for</code>.</p>
<!--
```rust
# fn main() {
    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{} is at index {}", value, index);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (indice, valeur) in v.iter().enumerate() {
        println!(&quot;{} est à l'indice {}&quot;, valeur, indice);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-3: Using a pattern in a `for` loop to
destructure a tuple</span>
-->
<p><span class="caption">Encart 18-3 : utilisation d'un motif dans une boucle <code>for</code>
pour déstructurer un tuple</span></p>
<!--
The code in Listing 18-3 will print the following:
-->
<p>Le code de l'encart 18-3 va afficher ceci :</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a est à l'indice 0
b est à l'indice 1
c est à l'indice 2
</code></pre>
<!--
We use the `enumerate` method to adapt an iterator to produce a value and that
value’s index in the iterator, placed into a tuple. The first call to
`enumerate` produces the tuple `(0, 'a')`. When this value is matched to the
pattern `(index, value)`, `index` will be `0` and `value` will be `'a'`,
printing the first line of the output.
-->
<p>Nous avons utilisé la méthode <code>enumerate</code> pour produire une valeur et son indice
à partir d'un itérateur, que nous avons placé dans un tuple. Le premier appel à
<code>enumerate</code> va produire le tuple <code>(0, 'a')</code>. Lorsque cette valeur est adaptée au
motif <code>(indice, valeur)</code>, <code>indice</code> vaudra <code>0</code> et <code>valeur</code> vaudra <code>'a'</code>, et
affichera la première ligne sur la sortie.</p>
<!--
### `let` Statements
-->
<h3 id="les-instructions-let"><a class="header" href="#les-instructions-let">Les instructions <code>let</code></a></h3>
<!--
Prior to this chapter, we had only explicitly discussed using patterns with
`match` and `if let`, but in fact, we’ve used patterns in other places as well,
including in `let` statements. For example, consider this straightforward
variable assignment with `let`:
-->
<p>Avant d'arriver à ce chapitre, nous n'avions abordé explicitement l'utilisation
des motifs uniquement avec <code>match</code> et <code>if let</code>, mais en réalité, nous avons
utilisé les motifs dans d'autres endroits, y compris les instructions <code>let</code>. Par
exemple, considérons l'assignation à la variable suivante avec <code>let</code> :</p>
<!--
```rust
let x = 5;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<!--
Throughout this book, we’ve used `let` like this hundreds of times, and
although you might not have realized it, you were using patterns! More
formally, a `let` statement looks like this:
-->
<p>Tout au long de ce livre, nous avons utilisé <code>let</code> de cette manière des
centaines de fois, et malgré tout vous ne vous êtes probablement pas rendu
compte que vous utilisiez les motifs ! Plus formellement, une instruction <code>let</code>
ressemble à ceci :</p>
<!--
```text
let PATTERN = EXPRESSION;
```
-->
<pre><code class="language-text">let MOTIF = EXPRESSION;
</code></pre>
<!--
In statements like `let x = 5;` with a variable name in the `PATTERN` slot, the
variable name is just a particularly simple form of a pattern. Rust compares
the expression against the pattern and assigns any names it finds. So in the
`let x = 5;` example, `x` is a pattern that means “bind what matches here to
the variable `x`.” Because the name `x` is the whole pattern, this pattern
effectively means “bind everything to the variable `x`, whatever the value is.”
-->
<p>Dans des instructions comme <code>let x = 5;</code> avec un nom de variable dans
l'emplacement <code>MOTIF</code>, le nom de la variable est juste une forme simple de
motif. Rust compare l'expression avec le motif et assigne tous les noms qu'il
rencontre. Dans l'exemple <code>let x = 5;</code>, <code>x</code> est un motif qui signifie
“relie ce qui suit à la variable <code>x</code>”.  Comme le nom <code>x</code> est un motif en entier,
ce motif demande exactement dans ce cas “relie tout ce qui suit à la variable
<code>x</code>, peu importe quelle valeur c'est”.</p>
<!--
To see the pattern matching aspect of `let` more clearly, consider Listing
18-4, which uses a pattern with `let` to destructure a tuple.
-->
<p>Pour comprendre plus clairement l'aspect filtrage par motif de <code>let</code>, admettons
l'encart 18-4, qui utilise un motif avec <code>let</code> pour destructurer un tuple.</p>
<!--
```rust
# fn main() {
    let (x, y, z) = (1, 2, 3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-4: Using a pattern to destructure a tuple and
create three variables at once</span>
-->
<p><span class="caption">Encart 18-4 : utilisation d'un motif pour destructurer un
tuple et créer trois variables à la fois</span></p>
<!--
Here, we match a tuple against a pattern. Rust compares the value `(1, 2, 3)`
to the pattern `(x, y, z)` and sees that the value matches the pattern, so Rust
binds `1` to `x`, `2` to `y`, and `3` to `z`. You can think of this tuple
pattern as nesting three individual variable patterns inside it.
-->
<p>Ici, nous avons fait correspondre un tuple à un motif. Rust compare la valeur
<code>(1, 2, 3)</code> au motif <code>(x, y, z)</code> et constate que la valeur correspond au motif,
donc Rust relie <code>1</code> à <code>x</code>, <code>2</code> à <code>y</code>, et <code>3</code> à <code>z</code>. Vous pouvez ainsi considérer
que ce motif de tuple contient trois variables individuelles en son sein.</p>
<!--
If the number of elements in the pattern doesn’t match the number of elements
in the tuple, the overall type won’t match and we’ll get a compiler error. For
example, Listing 18-5 shows an attempt to destructure a tuple with three
elements into two variables, which won’t work.
-->
<p>Si le nombre d'éléments dans le motif ne correspondent pas au nombre d'éléments
dans le tuple, le type au complet ne va pas correspondre et nous allons obtenir
une erreur de compilation. Par exemple, l'encart 18-5 montre une tentative de
déstructurer un tuple avec trois éléments dans deux variables, ce qui ne va pas
fonctionner.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let (x, y) = (1, 2, 3);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 18-5: Incorrectly constructing a pattern whose
variables don’t match the number of elements in the tuple</span>
-->
<p><span class="caption">Encart 18-5 : construction incorrecte d'un motif dont les
variables ne vont pas correspondre au nombre d'éléments présents dans le tuple
</span></p>
<!--
Attempting to compile this code results in this type error:
-->
<p>Si vous essayez de compiler ce code, vous obtiendrez cette erreur de type :</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 -- > src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
If we wanted to ignore one or more of the values in the tuple, we could use `_`
or `..`, as you’ll see in the [“Ignoring Values in a
Pattern”][ignoring-values-in-a-pattern]<!-- ignore -- > section. If the problem
is that we have too many variables in the pattern, the solution is to make the
types match by removing variables so the number of variables equals the number
of elements in the tuple.
-->
<p>Si nous souhaitons ignorer une ou plusieurs valeurs dans un tuple, nous pouvons
utiliser <code>_</code> ou <code>..</code>, comme vous allez le voir à la dernière section de ce
chapitre. Si le problème est que nous avons trop de variables dans le motif, la
solution faire correspondre les types en enlevant les variables afin que le
nombre de variables corresponde au nombre d'éléments présents dans le tuple.</p>
<!--
### Function Parameters
-->
<h3 id="les-paramètres-de-fonctions"><a class="header" href="#les-paramètres-de-fonctions">Les paramètres de fonctions</a></h3>
<!--
Function parameters can also be patterns. The code in Listing 18-6, which
declares a function named `foo` that takes one parameter named `x` of type
`i32`, should by now look familiar.
-->
<p>Les paramètres de fonctions peuvent aussi être des motifs. Le code de l'encart
18-6 déclare une fonction <code>foo</code> qui prend un paramètre <code>x</code> de type <code>i32</code>.</p>
<!--
```rust
fn foo(x: i32) {
    // code goes here
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn fonction(x: i32) {
    // le code se place ici
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-6: A function signature uses patterns in the
parameters</span>
-->
<p><span class="caption">Encart 18-6 : une signature de fonction qui utilise des
motifs dans ses paramètres</span></p>
<!--
The `x` part is a pattern! As we did with `let`, we could match a tuple in a
function’s arguments to the pattern. Listing 18-7 splits the values in a tuple
as we pass it to a function.
-->
<p>La partie <code>x</code> est un motif ! Comme nous l'avons dit pour <code>let</code>, nous pouvons
faire correspondre le motif avec un tuple dans les arguments de la fonction.
L'encart 18-7 déstructure les valeurs d'un tuple que nous passons en argument
d'une fonction.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn afficher_coordonnees(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Coordonnées actuelles : ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    afficher_coordonnees(&amp;point);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-7: A function with parameters that destructure
a tuple</span>
-->
<p><span class="caption">Encart 18-7 : une fonction avec des paramètres qui
déstructurent un tuple</span></p>
<!--
This code prints `Current location: (3, 5)`. The values `&(3, 5)` match the
pattern `&(x, y)`, so `x` is the value `3` and `y` is the value `5`.
-->
<p>Ce code affiche <code>Coordonées actuelles : (3, 5)</code>. Les valeurs <code>&amp;(3, 5)</code>
correspondent au motif <code>&amp;(x, y)</code>, donc <code>x</code> a la valeur <code>3</code> et <code>y</code> a la valeur
<code>5</code>.</p>
<!--
We can also use patterns in closure parameter lists in the same way as in
function parameter lists, because closures are similar to functions, as
discussed in Chapter 13.
-->
<p>Nous pouvons aussi utiliser les motifs dans la liste des paramètres d'une
fermeture de la même manière que la liste des paramètres d'une fonction, car les
fermetures sont similaires aux fonctions, comme nous l'avons dit au chapitre 13.</p>
<!--
At this point, you’ve seen several ways of using patterns, but patterns don’t
work the same in every place we can use them. In some places, the patterns must
be irrefutable; in other circumstances, they can be refutable. We’ll discuss
these two concepts next.
-->
<p>A présent, vous avez vu plusieurs façons d'utiliser les motifs, mais les motifs
ne fonctionnent pas de la même manière dans toutes les situations où nous les
utilisons. Des fois, le motif sera irréfutable ; d'autres fois, il sera
réfutable. C'est ce que nous allons voir tout de suite.</p>
<!--
[ignoring-values-in-a-pattern]:
ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern
-->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--23"><a class="header" href="#-attention-peinture-fraîche--23">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/206">Pull Request</a>.</p>
</blockquote>
<!--
## Refutability: Whether a Pattern Might Fail to Match
-->
<h2 id="la-réfutabilité--lorsquun-motif-peut-échouer-à-correspondre"><a class="header" href="#la-réfutabilité--lorsquun-motif-peut-échouer-à-correspondre">La réfutabilité : lorsqu'un motif peut échouer à correspondre</a></h2>
<!--
Patterns come in two forms: refutable and irrefutable. Patterns that will match
for any possible value passed are *irrefutable*. An example would be `x` in the
statement `let x = 5;` because `x` matches anything and therefore cannot fail
to match. Patterns that can fail to match for some possible value are
*refutable*. An example would be `Some(x)` in the expression `if let Some(x) =
a_value` because if the value in the `a_value` variable is `None` rather than
`Some`, the `Some(x)` pattern will not match.
-->
<p>Les motifs se divisent en deux catégories : réfutables et irréfutables. Les
motifs qui vont correspondre à n'importe quelle valeur qu'on lui passe sont
<em>irréfutables</em>. Un exemple serait le <code>x</code> dans l'instruction <code>let x = 5;</code> car
<code>x</code> correspond à tout ce qui est possible et ainsi ne peut pas échouer à la
correspondance. Les motifs qui peuvent échouer à correspondre à quelques valeurs
sont <em>réfutables</em>. Un exemple serait <code>Some(x)</code> dans l'expression
<code>if let Some(x) = une_valeur</code> car si la valeur dans la variable <code>une_valeur</code> est
<code>None</code> au lieu de <code>Some</code>, le motif <code>Some(x)</code> ne correspondra pas.</p>
<!--
Function parameters, `let` statements, and `for` loops can only accept
irrefutable patterns, because the program cannot do anything meaningful when
values don’t match. The `if let` and `while let` expressions accept
refutable and irrefutable patterns, but the compiler warns against
irrefutable patterns because by definition they’re intended to handle possible
failure: the functionality of a conditional is in its ability to perform
differently depending on success or failure.
-->
<p>Les paramètres de fonctions, les instructions <code>let</code>, et les boucles <code>for</code>
peuvent seulement accepter des motifs irréfutables, car le programme ne peut
rien faire d'autre lorsque les valeurs ne correspondent pas. Les expressions
<code>if let</code> et <code>while let</code> acceptent les motifs réfutables et irréfutables, mais le
compilateur met en garde contre l'utilisation des motifs irréfutables dans ce
cas car par définition ces expressions sont prévues pour gérer un problème
éventuel : le but des conditions est de se comporter différemment en fonction de
la réussite ou de l'échec.</p>
<!--
In general, you shouldn’t have to worry about the distinction between refutable
and irrefutable patterns; however, you do need to be familiar with the concept
of refutability so you can respond when you see it in an error message. In
those cases, you’ll need to change either the pattern or the construct you’re
using the pattern with, depending on the intended behavior of the code.
-->
<p>De manière générale, vous ne devriez pas avoir à vous soucier des différences
entre les motifs réfutables et irréfutables ; en revanche, vous devez vous
familiariser avec le concept de réfutabilité afin que vous puissiez comprendre
lorsque vous le verrez dans un message d'erreur. Dans ce cas, vous allez avoir
besoin de changer soit le motif, soit la construction avec laquelle vous
utilisez, en fonction du comportement prévu du code.</p>
<!--
Let’s look at an example of what happens when we try to use a refutable pattern
where Rust requires an irrefutable pattern and vice versa. Listing 18-8 shows a
`let` statement, but for the pattern we’ve specified `Some(x)`, a refutable
pattern. As you might expect, this code will not compile.
-->
<p>Examinons un exemple de ce qu'il se passe lorsque nous essayons d'utiliser un
motif réfutable lorsque Rust prévoit d'utiliser un motif irréfutable, et
vice-versa. L'encart 18-8 montre une instruction <code>let</code>, mais pour le motif nous
avons renseigné <code>Some(x)</code>, un motif réfutable. Comme vous pouvez vous en douter,
ce code ne va pas se compiler.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let some_option_value: Option<i32> = None;
    let Some(x) = some_option_value;
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let une_option_quelconque: Option&lt;i32&gt; = None;
</span>    let Some(x) = une_option_quelconque;
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 18-8: Attempting to use a refutable pattern with
`let`</span>
-->
<p><span class="caption">Encart 18-8 : tentative d'utilisation d'un motif
réfutable avec <code>let</code></span></p>
<!--
If `some_option_value` was a `None` value, it would fail to match the pattern
`Some(x)`, meaning the pattern is refutable. However, the `let` statement can
only accept an irrefutable pattern because there is nothing valid the code can
do with a `None` value. At compile time, Rust will complain that we’ve tried to
use a refutable pattern where an irrefutable pattern is required:
-->
<p>Si <code>une_option_quelconque</code> était une valeur <code>None</code>, cela ferait échouer le motif
<code>Some(x)</code>, ce qui signifie que le motif est réfutable. Cependant, l'instruction
<code>let</code> ne peut accepter qu'un motif irréfutable car il n'y a pas d'instructions à
suivre dans le cas d'une valeur <code>None</code>. A la compilation, Rust s'y opposera en
expliquant que nous avons essayé d'utiliser un motif réfutable là où un motif
irréfutable est nécessaire :</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding: `None` not covered
 -- > src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an "irrefutable pattern", like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
help: you might want to use `if let` to ignore the variant that isn't matched
  |
3 |     if let Some(x) = some_option_value { /* */ }
  |

error: aborting due to previous error

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding: `None` not covered
 --&gt; src/main.rs:3:9
  |
3 |     let Some(x) = une_option_quelconque;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an &quot;irrefutable pattern&quot;, like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
help: you might want to use `if let` to ignore the variant that isn't matched
  |
3 |     if let Some(x) = une_option_quelconque { /* */ }
  |

error: aborting due to previous error

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Because we didn’t cover (and couldn’t cover!) every valid value with the
pattern `Some(x)`, Rust rightfully produces a compiler error.
-->
<p>Comme nous n'avons pas couvert (et nous ne pouvons pas le faire !) chaque
valeur possible avec le motif <code>Some(x)</code>, Rust génère une erreur de compilation,
à juste titre.</p>
<!--
To fix the problem where we have a refutable pattern where an irrefutable
pattern is needed, we can change the code that uses the pattern: instead of
using `let`, we can use `if let`. Then if the pattern doesn’t match, the code
will just skip the code in the curly brackets, giving it a way to continue
validly. Listing 18-9 shows how to fix the code in Listing 18-8.
-->
<p>Pour corriger le problème lorsque nous avons un motif réfutable où un motif
irréfutable est nécessaire, nous pouvons changer le code qui utilise ce motif :
au lieu d'utiliser <code>let</code>, nous pouvons utiliser <code>if let</code>. Ensuite, si le motif
ne correspond pas, le code va simplement sauter le code entre les accolades,
nous offrant la possibilité de continuer correctement. L'encart 18-9 montre
comment corriger le code de l'encart 18-8.</p>
<!--
```rust
# fn main() {
#     let some_option_value: Option<i32> = None;
    if let Some(x) = some_option_value {
        println!("{}", x);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let une_option_quelconque: Option&lt;i32&gt; = None;
</span>    if let Some(x) = une_option_quelconque {
        println!(&quot;{}&quot;, x);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-9: Using `if let` and a block with refutable
patterns instead of `let`</span>
-->
<p><span class="caption">Encart 18-9 : utilisation de <code>if let</code> et d'un bloc avec
un motif réfutable plutôt qu'un <code>let</code></span></p>
<!--
We’ve given the code an out! This code is perfectly valid, although it means we
cannot use an irrefutable pattern without receiving an error. If we give `if
let` a pattern that will always match, such as `x`, as shown in Listing 18-10,
the compiler will give a warning.
-->
<p>Ce code est parfaitement valide, bien que cela signifie que nous ne pouvons pas
utiliser un motif irréfutable sans avoir d'erreur. Si nous donnons au <code>if let</code>
un motif qui correspond toujours, comme pour <code>x</code> montré dans l'encart 18-10, le
compilateur va lever un avertissement.</p>
<!--
```rust
# fn main() {
    if let x = 5 {
        println!("{}", x);
    };
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    if let x = 5 {
        println!(&quot;{}&quot;, x);
    };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-10: Attempting to use an irrefutable pattern
with `if let`</span>
-->
<p><span class="caption">Encart 18-10 : tentative d'utiliser un motif irréfutable
avec <code>if let</code></span></p>
<!--
Rust complains that it doesn’t make sense to use `if let` with an irrefutable
pattern:
-->
<p>Rust explique que cela ne fait aucun sens d'utiliser <code>if let</code> avec un motif
irréfutable :</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable if-let pattern
 -- > src/main.rs:2:5
  |
2 | /     if let x = 5 {
3 | |         println!("{}", x);
4 | |     };
  | |_____^
  |
  = note: `#[warn(irrefutable_let_patterns)]` on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable if-let pattern
 --&gt; src/main.rs:2:5
  |
2 | /     if let x = 5 {
3 | |         println!(&quot;{}&quot;, x);
4 | |     };
  | |_____^
  |
  = note: `#[warn(irrefutable_let_patterns)]` on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
</code></pre>
<!--
For this reason, match arms must use refutable patterns, except for the last
arm, which should match any remaining values with an irrefutable pattern. Rust
allows us to use an irrefutable pattern in a `match` with only one arm, but
this syntax isn’t particularly useful and could be replaced with a simpler
`let` statement.
-->
<p>C'est pourquoi les branches de <code>match</code> doivent utiliser des motifs réfutables,
sauf pour la dernière branche, qui devrait correspondre à n'importe quelle
valeur grâce à son motif irréfutable. Rust nous permet d'utiliser un motif
irréfutable dans un <code>match</code> avec une seule branche, mais cette syntaxe n'est
pas particulièrement utile et devrait être remplacée par une instruction <code>let</code>
plus simple.</p>
<!--
Now that you know where to use patterns and the difference between refutable
and irrefutable patterns, let’s cover all the syntax we can use to create
patterns.
-->
<p>Maintenant que vous savez où utiliser les motifs et les différences entre les
motifs réfutables et irréfutables, voyons les syntaxes que nous pouvons
utiliser pour créer des motifs.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--24"><a class="header" href="#-attention-peinture-fraîche--24">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/207">Pull Request</a>.</p>
</blockquote>
<!--
## Pattern Syntax
-->
<h2 id="la-syntaxe-des-motifs"><a class="header" href="#la-syntaxe-des-motifs">La syntaxe des motifs</a></h2>
<!--
Throughout the book, you’ve seen examples of many kinds of patterns. In this
section, we gather all the syntax valid in patterns and discuss why you might
want to use each one.
-->
<p>A travers le livre, vous avez rencontré de nombreux types de motifs. Dans cette
section, nous allons rassembler toutes les syntaxes valides des motifs et
examiner les raisons pour lesquelles vous devriez utiliser chacune d'entre
elles.</p>
<!--
### Matching Literals
-->
<h3 id="correspondre-aux-littéraux"><a class="header" href="#correspondre-aux-littéraux">Correspondre aux littéraux</a></h3>
<!--
As you saw in Chapter 6, you can match patterns against literals directly. The
following code gives some examples:
-->
<p>Comme vous l'avez vu chapitre 6, vous pouvez faire directement correspondre des
motifs sur des littéraux. Le code suivant vous donne quelques exemples :</p>
<!--
```rust
# fn main() {
    let x = 1;

    match x {
        1 => println!("one"),
        2 => println!("two"),
        3 => println!("three"),
        _ => println!("anything"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!(&quot;un&quot;),
        2 =&gt; println!(&quot;deux&quot;),
        3 =&gt; println!(&quot;trois&quot;),
        _ =&gt; println!(&quot;n'importe quoi&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
This code prints `one` because the value in `x` is 1. This syntax is useful
when you want your code to take an action if it gets a particular concrete
value.
-->
<p>Ce code affiche <code>un</code> car la valeur dans <code>x</code> est <code>1</code>. Cette syntaxe est très
utile lorsque vous souhaitez que votre code fasse quelque chose s'il obtient une
valeur précise.</p>
<!--
### Matching Named Variables
-->
<h3 id="correspondre-à-des-variables-nommées"><a class="header" href="#correspondre-à-des-variables-nommées">Correspondre à des variables nommées</a></h3>
<!--
Named variables are irrefutable patterns that match any value, and we’ve used
them many times in the book. However, there is a complication when you use
named variables in `match` expressions. Because `match` starts a new scope,
variables declared as part of a pattern inside the `match` expression will
shadow those with the same name outside the `match` construct, as is the case
with all variables. In Listing 18-11, we declare a variable named `x` with the
value `Some(5)` and a variable `y` with the value `10`. We then create a
`match` expression on the value `x`. Look at the patterns in the match arms and
`println!` at the end, and try to figure out what the code will print before
running this code or reading further.
-->
<p>Les variables nommées sont des motifs irréfutables qui correspondent à
n'importe quelle valeur, et nous les avons utilisés de nombreuses foix dans le
livre. Cependant, il subsiste un problème lorsque vous utilisez les variables
nommées dans les expressions <code>match</code>. Comme <code>match</code> débute une nouvelle portée,
les variables utilisées comme étant une partie du motif de la construction
<code>match</code> vont masquer celles avec le même nom provenant de l'extérieur de la
construction <code>match</code>, comme c'est le cas avec toutes les variables. Dans
l'encart 18-11, nous déclarons une variable <code>x</code> avec la valeur <code>Some(5)</code> et une
variable <code>y</code> avec la valeur <code>10</code>. Nous créons alors une expression <code>match</code> sur
la valeur <code>x</code>. Observez les motifs sur les branches du <code>match</code> et du <code>println!</code>
à la fin, et essayez de deviner ce qui sera écrit avant d'exécuter ce code ou
de lire la suite.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(y) => println!("Matched, y = {:?}", y),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {:?}", x, y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;On a 50&quot;),
        Some(y) =&gt; println!(&quot;Correspondance, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Cas par défaut, x = {:?}&quot;, x),
    }

    println!(&quot;A la fin : x = {:?}, y = {:?}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-11: A `match` expression with an arm that
introduces a shadowed variable `y`</span>
-->
<p><span class="caption">Encart 18-11 : une expression <code>match</code> avec une branche
qui crée une variable masquée <code>y</code></span></p>
<!--
Let’s walk through what happens when the `match` expression runs. The pattern
in the first match arm doesn’t match the defined value of `x`, so the code
continues.
-->
<p>Voyons ce qui se passe lorsque l'expression <code>match</code> est utilisée. Le motif
présent dans la première branche du <code>match</code> ne correspond pas à la valeur
actuelle de <code>x</code>, donc le code continue.</p>
<!--
The pattern in the second match arm introduces a new variable named `y` that
will match any value inside a `Some` value. Because we’re in a new scope inside
the `match` expression, this is a new `y` variable, not the `y` we declared at
the beginning with the value 10. This new `y` binding will match any value
inside a `Some`, which is what we have in `x`. Therefore, this new `y` binds to
the inner value of the `Some` in `x`. That value is `5`, so the expression for
that arm executes and prints `Matched, y = 5`.
-->
<p>Le motif dans la seconde branche du <code>match</code> ajoute une nouvelle variable <code>y</code>
qui va correspondre à n'importe quelle valeur logée dans une valeur <code>Some</code>.
Comme nous sommes dans une nouvelle portée à l'intérieur de l'expression
<code>match</code>, c'est une nouvelle variable <code>y</code>, et non pas le <code>y</code> que nous avons
déclaré au début avec la valeur 10. Cette nouvelle correspondance <code>y</code> va
correspondre à n'importe quelle valeur à l'intérieur d'un <code>Some</code>, ce qui est
la situation présente actuellement dans <code>x</code>. Ainsi, ce nouveau <code>y</code> correspondra
à la valeur interne du <code>Some</code> présent dans <code>x</code>. Cette valeur est <code>5</code>, donc
l'expression de cette branche s'exécute et affiche <code>Correspondance, y = 5</code>.</p>
<!--
If `x` had been a `None` value instead of `Some(5)`, the patterns in the first
two arms wouldn’t have matched, so the value would have matched to the
underscore. We didn’t introduce the `x` variable in the pattern of the
underscore arm, so the `x` in the expression is still the outer `x` that hasn’t
been shadowed. In this hypothetical case, the `match` would print `Default
case, x = None`.
-->
<p>Si <code>x</code> aurait été une valeur <code>None</code> plutôt que <code>Some(5)</code>, les motifs présents
dans les deux premières branches n'auraient pas correspondu, donc la valeur qui
aurait correspondu serait celui avec le tiret du bas. Nous n'avons pas
introduit de nouvelle variable <code>x</code> qui est présente dans la branche du motif,
donc le <code>x</code> dans l'expression désigne toujours la variable <code>x</code> en dehors, qui
n'a pas été masquée. Dans ce cas, le <code>match</code> devrait afficher
<code>Cas par défaut, x = None</code>.</p>
<!--
When the `match` expression is done, its scope ends, and so does the scope of
the inner `y`. The last `println!` produces `at the end: x = Some(5), y = 10`.
-->
<p>Lorsque l'expression <code>match</code> est terminée, sa portée se termine, et avec elle
la portée de la variable interne <code>y</code>. Le dernier <code>println!</code> affiche
<code>A la fin : x = Some(5), y = 10</code>.</p>
<!--
To create a `match` expression that compares the values of the outer `x` and
`y`, rather than introducing a shadowed variable, we would need to use a match
guard conditional instead. We’ll talk about match guards later in the [“Extra
Conditionals with Match Guards”](#extra-conditionals-with-match-guards)<!--
ignore -- > section.
-->
<p>Pour créer une expression <code>match</code> qui compare les valeurs d'une variable
externe <code>x</code> et <code>y</code>, plutôt que d'utiliser une variable masquée, nous aurons
besoin d'utiliser à la place un contrôle de correspondance. Nous verrons les
contrôles de correspondance plus loin dans une des sections.</p>
<!--
### Multiple Patterns
-->
<h3 id="plusieurs-motifs"><a class="header" href="#plusieurs-motifs">Plusieurs motifs</a></h3>
<!--
In `match` expressions, you can match multiple patterns using the `|` syntax,
which means *or*. For example, the following code matches the value of `x`
against the match arms, the first of which has an *or* option, meaning if the
value of `x` matches either of the values in that arm, that arm’s code will
run:
-->
<p>Dans les expressions <code>match</code>, vous pouvez faire correspondre plusieurs motifs
en utilisant la syntaxe <code>|</code>, qui signifie <em>ou</em>. Par exemple, le code suivant
applique un <code>match</code> sur la valeur de <code>x</code>, la première des branches a une option
<em>ou</em>, ce qui signifie que si la valeur de <code>x</code> correspond à un de ces motifs de
cette branche, le code de cette branche sera exécuté :</p>
<!--
```rust
# fn main() {
    let x = 1;

    match x {
        1 | 2 => println!("one or two"),
        3 => println!("three"),
        _ => println!("anything"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!(&quot;un ou deux&quot;),
        3 =&gt; println!(&quot;trois&quot;),
        _ =&gt; println!(&quot;quelque chose d'autre&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
This code prints `one or two`.
-->
<p>Ce code va afficher <code>un ou deux</code>.</p>
<!--
### Matching Ranges of Values with `..=`
-->
<h3 id="faire-correspondre-un-intervalle-de-valeurs-avec-"><a class="header" href="#faire-correspondre-un-intervalle-de-valeurs-avec-">Faire correspondre un intervalle de valeurs avec <code>..=</code></a></h3>
<!--
The `..=` syntax allows us to match to an inclusive range of values. In the
following code, when a pattern matches any of the values within the range, that
arm will execute:
-->
<p>La syntaxe <code>..=</code> nous permet de faire correspondre un intervalle inclusif de
valeurs. Dans le code suivant, lorsqu'un motif correspond à une des valeurs
présentes dans l'intervalle, cette branche va s'exécuter :</p>
<!--
```rust
# fn main() {
    let x = 5;

    match x {
        1..=5 => println!("one through five"),
        _ => println!("something else"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!(&quot;de un à cinq&quot;),
        _ =&gt; println!(&quot;quelque chose d'autre&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
If `x` is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more
convenient than using the `|` operator to express the same idea; instead of
`1..=5`, we would have to specify `1 | 2 | 3 | 4 | 5` if we used `|`.
Specifying a range is much shorter, especially if we want to match, say, any
number between 1 and 1,000!
-->
<p>Si <code>x</code> vaut 1, 2, 3, 4 ou 5, la première branche va correspondre. Cette syntaxe
est plus pratique à utiliser que d'avoir à utiliser l'opérateur <code>|</code> pour
exprimer la même idée ; à la place de <code>1..=5</code> nous aurions dû préciser
<code>1 | 2 | 3 | 4 | 5</code> si nous avions dû utiliser <code>|</code>. Renseigner un intervalle
est bien plus court, en particulier si nous souhaitons correspondre aux valeurs
entre 1 et 1000 par exemple !</p>
<!--
Ranges are only allowed with numeric values or `char` values, because the
compiler checks that the range isn’t empty at compile time. The only types for
which Rust can tell if a range is empty or not are `char` and numeric values.
-->
<p>Les intervalles peuvent être des nombres ou des <code>char</code> (caractères), car le
compilateur vérifie que l'intervalle n'est pas vide au moment de la
compilation. Les seuls types pour lesquels Rust peut dire si un intervalle est
vide ou non sont pour les nombres et les <code>char</code>.</p>
<!--
Here is an example using ranges of `char` values:
-->
<p>Voici un exemple d'utilisation d'intervalles de <code>char</code> :</p>
<!--
```rust
# fn main() {
    let x = 'c';

    match x {
        'a'..='j' => println!("early ASCII letter"),
        'k'..='z' => println!("late ASCII letter"),
        _ => println!("something else"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!(&quot;lettre ASCII du début&quot;),
        'k'..='z' =&gt; println!(&quot;lettre ASCII de la fin&quot;),
        _ =&gt; println!(&quot;autre chose&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
Rust can tell that `c` is within the first pattern’s range and prints `early
ASCII letter`.
-->
<p>Rust peut nous dire que <code>c</code> est dans le premier intervalle du premier motif et
afficher <code>lettre ASCII du début</code>.</p>
<!--
### Destructuring to Break Apart Values
-->
<h3 id="destructurer-pour-séparer-les-valeurs"><a class="header" href="#destructurer-pour-séparer-les-valeurs">Destructurer pour séparer les valeurs</a></h3>
<!--
We can also use patterns to destructure structs, enums, tuples, and references
to use different parts of these values. Let’s walk through each value.
-->
<p>Nous pouvons aussi utiliser les motifs pour destructurer les structures, les
énumérations, les tuples et les références pour utiliser différentes parties de
ces valeurs. Passons en revue chacun des cas.</p>
<!--
#### Destructuring Structs
-->
<h4 id="destructurer-les-structures"><a class="header" href="#destructurer-les-structures">Destructurer les structures</a></h4>
<!--
Listing 18-12 shows a `Point` struct with two fields, `x` and `y`, that we can
break apart using a pattern with a `let` statement.
-->
<p>L'encart 18-12 montre une structure <code>Point</code> avec deux champs, <code>x</code> et <code>y</code>, que
nous pouvons séparer en utilisant un motif avec une instruction <code>let</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-12: Destructuring a struct’s fields into
separate variables</span>
-->
<p><span class="caption">Encart 18-12 : déstructuration des champs d'une structure
dans des variables séparées</span></p>
<!--
This code creates the variables `a` and `b` that match the values of the `x`
and `y` fields of the `p` struct. This example shows that the names of the
variables in the pattern don’t have to match the field names of the struct. But
it’s common to want the variable names to match the field names to make it
easier to remember which variables came from which fields.
-->
<p>Ce code créé les variables <code>a</code> et <code>b</code> qui correspondent aux valeurs des champs
<code>x</code> et <code>y</code> de la structure <code>p</code>. Cet exemple montre que les noms des variables
du motif n'ont pas à correspondre aux noms des champs de la structure. Mais il
est courant de vouloir que les noms des variables correspondent aux noms des
champs pour se rappeler plus facilement quelle variable provient de quel champ.</p>
<!--
Because having variable names match the fields is common and because writing
`let Point { x: x, y: y } = p;` contains a lot of duplication, there is a
shorthand for patterns that match struct fields: you only need to list the name
of the struct field, and the variables created from the pattern will have the
same names. Listing 18-13 shows code that behaves in the same way as the code
in Listing 18-12, but the variables created in the `let` pattern are `x` and
`y` instead of `a` and `b`.
-->
<p>Comme avoir des noms de variables qui correspondent aux champs est courant et
comme écrire <code>let Point { x: x, y: y } = p;</code> est assez répétitif, il existe un
raccourci pour les motifs qui correspondent aux champs des structures : vous
avez simplement besoin de lister le nom des champs de la structure, et les
variables créées à partir du motif auront les mêmes noms. L'encart 18-12 montre
du code qui se comporte de la même manière que le code de l'encart 18-12, mais
les variables créées dans le motif du <code>let</code> sont <code>x</code> et <code>y</code> au lieu de <code>a</code> et
<code>b</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-13: Destructuring struct fields using struct
field shorthand</span>
-->
<p><span class="caption">Encart 18-13 : déstructuration des champs d'une structure
en utilisant le raccourci pour les champs des structures</span></p>
<!--
This code creates the variables `x` and `y` that match the `x` and `y` fields
of the `p` variable. The outcome is that the variables `x` and `y` contain the
values from the `p` struct.
-->
<p>Ce code créé les variables <code>x</code> et <code>y</code> qui correspondent aux champs <code>x</code> et <code>y</code>
de la variable <code>p</code>. Il en résulte que les variables <code>x</code> et <code>y</code> contiennent les
valeurs correspondantes à la structure <code>p</code>.</p>
<!--
We can also destructure with literal values as part of the struct pattern
rather than creating variables for all the fields. Doing so allows us to test
some of the fields for particular values while creating variables to
destructure the other fields.
-->
<p>Nous pouvons aussi destructurer avec des valeurs littérales comme faisant partie
du motif de la structure plutôt que d'avoir à créer les variables pour tous les
champs. Ceci nous permet de tester certains champs pour des valeurs
particulières tout en créant les variables pour destructurer les autres champs.</p>
<!--
Listing 18-14 shows a `match` expression that separates `Point` values into
three cases: points that lie directly on the `x` axis (which is true when `y =
0`), on the `y` axis (`x = 0`), or neither.
-->
<p>L'encart 18-14 montre une expression <code>match</code> qui sépare les valeurs <code>Point</code>
en trois catégories : les points qui sont directement sur l'axe <code>x</code> (ce qui est
vrai lorsque <code>y = 0</code>), ceux directement sur l'axe <code>y</code> (<code>x = 0</code>), ou sur aucun
de ces deux axes.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# struct Point {
#     x: i32,
#     y: i32,
# }
# 
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {}", x),
        Point { x: 0, y } => println!("On the y axis at {}", y),
        Point { x, y } => println!("On neither axis: ({}, {})", x, y),
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;Sur l'axe x à la position {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;Sur l'axe y à la position {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;Sur aucun des axes : ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-14: Destructuring and matching literal values
in one pattern</span>
-->
<p><span class="caption">Encart 18-14 : déstructurer et faire correspondre des
valeurs littérales grâce à un seul motif</span></p>
<!--
The first arm will match any point that lies on the `x` axis by specifying that
the `y` field matches if its value matches the literal `0`. The pattern still
creates an `x` variable that we can use in the code for this arm.
-->
<p>La première branche va correspondre avec n'importe quel point qui se trouve sur
l'axe <code>x</code> en précisant que le champ <code>y</code> correspond au littéral <code>0</code>. Le motif va
toujours créer une variable <code>x</code> que nous pouvons utiliser dans le code de cette
branche.</p>
<!--
Similarly, the second arm matches any point on the `y` axis by specifying that
the `x` field matches if its value is `0` and creates a variable `y` for the
value of the `y` field. The third arm doesn’t specify any literals, so it
matches any other `Point` and creates variables for both the `x` and `y` fields.
-->
<p>De la même manière, la seconde branche correspondra avec tous les points sur
l'axe <code>y</code> en précisant que le champ <code>x</code> correspondra uniquement si sa valeur
est <code>0</code> et créera une variable <code>y</code> pour la valeur du champ <code>y</code>. La troisième
branche n'a pas besoin d'un littéral en particulier, donc elle correspondra à
n'importe quel autre <code>Point</code> et créera les variables pour les champs <code>x</code> et
<code>y</code>.</p>
<!--
In this example, the value `p` matches the second arm by virtue of `x`
containing a 0, so this code will print `On the y axis at 7`.
-->
<p>Dans cet exemple, la valeur <code>p</code> correspond avec la seconde branche car son <code>x</code>
vaut <code>0</code>, donc ce code va afficher <code>Sur l'axe y à la position 7</code>.</p>
<!--
#### Destructuring Enums
-->
<h4 id="destructurer-une-énumération"><a class="header" href="#destructurer-une-énumération">Destructurer une énumération</a></h4>
<!--
We’ve destructured enums earlier in this book, for example, when we
destructured `Option<i32>` in Listing 6-5 in Chapter 6. One detail we haven’t
mentioned explicitly is that the pattern to destructure an enum should
correspond to the way the data stored within the enum is defined. As an
example, in Listing 18-15 we use the `Message` enum from Listing 6-2 and write
a `match` with patterns that will destructure each inner value.
-->
<p>Nous avons destructuré les énumérations précédemment dans ce livre, par exemple
lorsque nous avions destructuré <code>Option&lt;i32&gt;</code> dans l'encart 6-5 du chapitre 6.
Un détail que nous n'avons pas précisé explicitement était que le motif pour
destructurer une énumération devait correspondre à la façon dont est défini les
données dans l'énumération. Par exemple, dans l'encart 18-15 nous utilisons
l'énumération <code>Message</code> de l'encart 6-2 et nous rajoutons un <code>match</code> avec des
motifs qui devraient destructurer chaque valeur interne.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.")
        }
        Message::Move { x, y } => {
            println!(
                "Move in the x direction {} and in the y direction {}",
                x, y
            );
        }
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => println!(
            "Change the color to red {}, green {}, and blue {}",
            r, g, b
        ),
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangerCouleur(0, 160, 255);

    match msg {
        Message::Quitter =&gt; {
            println!(&quot;La variante Quitter n'a pas de données à déstructurer.&quot;)
        }
        Message::Deplacer { x, y } =&gt; {
            println!(
                &quot;Déplacement de {} sur l'axe x et de {} sur l'axe y&quot;,
                x, y
            );
        }
        Message::Ecrire(text) =&gt; println!(&quot;Message textuel : {}&quot;, text),
        Message::ChangerCouleur(r, g, b) =&gt; println!(
            &quot;Changement des taux de rouge à {}, de vert à {}, et de bleu à {}&quot;,
            r, g, b
        ),
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-15: Destructuring enum variants that hold
different kinds of values</span>
-->
<p><span class="caption">Encart 18-15 : déstructuration des variantes d'une
énumération qui stocke différents types de valeurs</span></p>
<!--
This code will print `Change the color to red 0, green 160, and blue 255`. Try
changing the value of `msg` to see the code from the other arms run.
-->
<p>Ce code va afficher
<code>Changement des taux de rouge à 0, de vert à 160, et de bleu à 255</code>. Essayez de
changer la valeur de <code>message</code> pour voir le code qu'exécute les autres
branches.</p>
<!--
For enum variants without any data, like `Message::Quit`, we can’t destructure
the value any further. We can only match on the literal `Message::Quit` value,
and no variables are in that pattern.
-->
<p>Pour les variantes d'énumération sans aucune donnée, comme <code>Message::Quitter</code>,
nous ne pouvons pas destructurer de valeurs. Nous pouvons uniquement
correspondre à la valeur littérale <code>Message::Quitter</code>, et il n'y a pas de
variable dans ce motif.</p>
<!--
For struct-like enum variants, such as `Message::Move`, we can use a pattern
similar to the pattern we specify to match structs. After the variant name, we
place curly brackets and then list the fields with variables so we break apart
the pieces to use in the code for this arm. Here we use the shorthand form as
we did in Listing 18-13.
-->
<p>Pour les variantes d'énumération qui ressemblent aux structures, comme
<code>Message::Deplacer</code>, nous pouvons utiliser un motif similaire aux motifs que
nous utilisons pour correspondre aux structures. Après le nom de la variante,
nous utilisons des accolades et ensuite nous listons les champs avec des
variables afin de diviser les éléments à utiliser dans le code de cette
branche. Ici nous utilisons la forme raccourcie comme nous l'avons fait à
l'encart 18-13.</p>
<!--
For tuple-like enum variants, like `Message::Write` that holds a tuple with one
element and `Message::ChangeColor` that holds a tuple with three elements, the
pattern is similar to the pattern we specify to match tuples. The number of
variables in the pattern must match the number of elements in the variant we’re
matching.
-->
<p>Pour les variantes d'énumérations qui ressemblent à des tuples, comme
<code>Message::Ecrire</code> qui stocke un tuple avec un élément, et
<code>Message::ChangerCouleur</code> qui stocke un tuple avec trois éléments, le motif
ressemble au motif que nous renseignons pour correspondre aux tuples. Le nombre
de variables dans le motif doit correspondre aux nombre d'éléments dans la
variante qui correspond.</p>
<!--
#### Destructuring Nested Structs and Enums
-->
<h4 id="destructurer-des-structures-imbriquées-et-des-énumérations"><a class="header" href="#destructurer-des-structures-imbriquées-et-des-énumérations">Destructurer des structures imbriquées et des énumérations</a></h4>
<!--
Until now, all our examples have been matching structs or enums that were one
level deep. Matching can work on nested items too!
-->
<p>Jusqu'à présent, tous nos exemples avaient des correspondances avec structures
ou des énumérations qui avaient un seul niveau de profondeur. Les
correspondances fonctionnent aussi sur les éléments imbriqués !</p>
<!--
For example, we can refactor the code in Listing 18-15 to support RGB and HSV
colors in the `ChangeColor` message, as shown in Listing 18-16.
-->
<p>Par exemple, nous pouvons remanier le code de l'encart 18-15 pour pouvoir
utiliser des couleurs RVB et TSV dans le message <code>ChangerCouleur</code>, comme dans
l'encart 18-16.</p>
<!--
```rust
enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => println!(
            "Change the color to red {}, green {}, and blue {}",
            r, g, b
        ),
        Message::ChangeColor(Color::Hsv(h, s, v)) => println!(
            "Change the color to hue {}, saturation {}, and value {}",
            h, s, v
        ),
        _ => (),
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">enum Couleur {
    Rvb(i32, i32, i32),
    Tsv(i32, i32, i32),
}

enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(Couleur),
}

fn main() {
    let msg = Message::ChangerCouleur(Couleur::Tsv(0, 160, 255));

    match msg {
        Message::ChangerCouleur(Couleur::Rvb(r, v, b)) =&gt; println!(
            &quot;Changement des taux de rouge à {}, de vert à {}, et de bleu à {}&quot;,
            r, v, b
        ),
        Message::ChangerCouleur(Couleur::Tsv(t, s, v)) =&gt; println!(
            &quot;Changement des taux de teinte à {}, de saturation à {}, et de valeur à {}&quot;,
            t, s, v
        ),
        _ =&gt; (),
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-16: Matching on nested enums</span>
-->
<p><span class="caption">Encart 18-16 : correspondance avec des énumérations
imbriquées</span></p>
<!--
The pattern of the first arm in the `match` expression matches a
`Message::ChangeColor` enum variant that contains a `Color::Rgb` variant; then
the pattern binds to the three inner `i32` values. The pattern of the second
arm also matches a `Message::ChangeColor` enum variant, but the inner enum
matches the `Color::Hsv` variant instead. We can specify these complex
conditions in one `match` expression, even though two enums are involved.
-->
<p>Le motif de la première branche dans l'expression <code>match</code> correspond à la
variante d'énumération <code>Message::ChangerCouleur</code> qui contient une variante
<code>Couleur::Rvb</code> ; ensuite le motif fait correspondre des variables aux trois
valeurs <code>i32</code> à l'intérieur. Le motif de la seconde branche correspond aussi
à une variante de l'énumération de <code>Message::ChangerCouleur</code>, mais la valeur
interne correspond plutôt à la variante <code>Couleur::Tsv</code>. Nous pouvons renseigner
ces conditions complexes dans une seule expression <code>match</code>, même si nous la
faisons sur deux énumérations.</p>
<!--
#### Destructuring Structs and Tuples
-->
<h4 id="destructurer-des-structures-et-des-tuples"><a class="header" href="#destructurer-des-structures-et-des-tuples">Destructurer des structures et des tuples</a></h4>
<!--
We can mix, match, and nest destructuring patterns in even more complex ways.
The following example shows a complicated destructure where we nest structs and
tuples inside a tuple and destructure all the primitive values out:
-->
<p>Nous pouvons mélanger les correspondances et les motifs pour déstructurer des
éléments imbriqués de manière bien plus complexe. L'exemple suivant montre une
déstructuration complexe dans laquelle nous imbriquons des structures et des
tuples à l'intérieur d'un tuple et nous y destructurons toutes les valeurs
primitives :</p>
<!--
```rust
# fn main() {
#     struct Point {
#         x: i32,
#         y: i32,
#     }
# 
    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((pieds, pouces), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}
</span></code></pre></pre>
<!--
This code lets us break complex types into their component parts so we can use
the values we’re interested in separately.
-->
<p>Ce code nous permet de décomposer les parties qui composent des types complexes
pour pouvoir utiliser séparément les valeurs qui nous intéressent.</p>
<!--
Destructuring with patterns is a convenient way to use pieces of values, such
as the value from each field in a struct, separately from each other.
-->
<p>La déstructuration avec les motifs est un moyen efficace d'utiliser des parties
de valeurs, comme par exemple la valeur de chaque champ d'une structure,
indépendamment les unes des autres.</p>
<!--
### Ignoring Values in a Pattern
-->
<h3 id="ignorer-des-valeurs-dans-un-motif"><a class="header" href="#ignorer-des-valeurs-dans-un-motif">Ignorer des valeurs dans un motif</a></h3>
<!--
You’ve seen that it’s sometimes useful to ignore values in a pattern, such as
in the last arm of a `match`, to get a catchall that doesn’t actually do
anything but does account for all remaining possible values. There are a few
ways to ignore entire values or parts of values in a pattern: using the `_`
pattern (which you’ve seen), using the `_` pattern within another pattern,
using a name that starts with an underscore, or using `..` to ignore remaining
parts of a value. Let’s explore how and why to use each of these patterns.
-->
<p>Vous avez pu constater qu'il est parfois utile d'ignorer des valeurs dans un
motif, comme celle dans la dernière branche d'un <code>match</code>, pour obtenir un joker
qui ne fait rien mis à part qu'il représente toutes les autres valeurs
possibles. Il existe plusieurs façons d'ignorer des valeurs entières ou des
parties de valeurs dans un motif : l'utilisation du motif <code>_</code> (que vous avez
déjà vu), l'utilisation du motif <code>_</code> à l'intérieur d'un autre motif, utiliser
un nom qui commence avec un tiret bas, ou utiliser <code>..</code> pour ignorer les
parties restantes d'une valeur. Voyons comment et pourquoi utiliser ces motifs.</p>
<!--
#### Ignoring an Entire Value with `_`
-->
<h4 id="ignorer-une-valeur-entière-avec-_"><a class="header" href="#ignorer-une-valeur-entière-avec-_">Ignorer une valeur entière avec <code>_</code></a></h4>
<!--
We’ve used the underscore (`_`) as a wildcard pattern that will match any value
but not bind to the value. Although the underscore `_` pattern is especially
useful as the last arm in a `match` expression, we can use it in any pattern,
including function parameters, as shown in Listing 18-17.
-->
<p>Nous avons utilisé le tiret bas (<code>_</code>) comme un motif de joker qui devait
correspondre avec n'importe quelle valeur mais ne pouvait pas être assigné à
une valeur. Bien que le motif du tiret bas <code>_</code> est particulièrement utile dans
la dernière branche d'une expression <code>match</code>, nous pouvons l'utiliser dans
n'importe quel motif, y compris les paramètres de fonctions, comme montré dans
l'encart 18-17.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {}", y);
}

fn main() {
    foo(3, 4);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn fonction(_: i32, y: i32) {
    println!(&quot;Ce code utilise uniquement le paramètre y : {}&quot;, y);
}

fn main() {
    fonction(3, 4);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-17: Using `_` in a function signature</span>
-->
<p><span class="caption">Encart 18-17 : utilisation d'un <code>_</code> dans la signature
d'une fonction</span></p>
<!--
This code will completely ignore the value passed as the first argument, `3`,
and will print `This code only uses the y parameter: 4`.
-->
<p>Ce code va complètement ignorer la valeur envoyée en premier argument, <code>3</code>, et
va afficher <code>Ce code utilise uniquement le paramètre y : 4</code>.</p>
<!--
In most cases when you no longer need a particular function parameter, you
would change the signature so it doesn’t include the unused parameter. Ignoring
a function parameter can be especially useful in some cases, for example, when
implementing a trait when you need a certain type signature but the function
body in your implementation doesn’t need one of the parameters. The compiler
will then not warn about unused function parameters, as it would if you used a
name instead.
-->
<p>Dans la plupart des cas lorsque vous n'avez pas besoin d'un paramètre d'une
fonction, vous pouvez changer la signature pour qu'elle n'inclue pas le
paramètre non utilisé. Ignorer un paramètre de fonction peut être
particulièrement utile dans certains cas, comme par exemple, lors de
l'implémentation d'un trait lorsque vous avez besoin d'un certain type de
signature mais que le corps de la fonction dans votre implémentation n'a pas
besoin d'un des paramètres. Le compilateur ne vous avertira plus que ces
paramètres de fonction ne sont pas utilisés, ce qui serait le cas si vous
utilisiez un nom à la place.</p>
<!--
#### Ignoring Parts of a Value with a Nested `_`
-->
<h4 id="ignorer-des-parties-dune-valeur-en-utilisant-un-_-imbriqué"><a class="header" href="#ignorer-des-parties-dune-valeur-en-utilisant-un-_-imbriqué">Ignorer des parties d'une valeur en utilisant un <code>_</code> imbriqué</a></h4>
<!--
We can also use `_` inside another pattern to ignore just part of a value, for
example, when we want to test for only part of a value but have no use for the
other parts in the corresponding code we want to run. Listing 18-18 shows code
responsible for managing a setting’s value. The business requirements are that
the user should not be allowed to overwrite an existing customization of a
setting but can unset the setting and give it a value if it is currently unset.
-->
<p>Nous pouvons aussi utiliser <code>_</code> au sein d'un autre motif pour ignorer
uniquement une partie d'une valeur, par exemple, si nous souhaitons tester
qu'une seule partie d'une valeur mais que nous n'utilisons pas les autres
parties dans le code que nous souhaitons exécuter. L'encart 18-18 montre du
code qui s'occupe de gérer une valeur d'un réglage. Les règles métier sont que
l'utilisateur ne doit pas pouvoir réécrire un réglage personnalisé mais peut
annuler le réglage et lui donner une valeur s'il est bien inexistant.</p>
<!--
```rust
# fn main() {
    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) => {
            println!("Can't overwrite an existing customized value");
        }
        _ => {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {:?}", setting_value);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut valeur_du_reglage = Some(5);
    let nouvelle_valeur_du_reglage = Some(10);

    match (valeur_du_reglage, nouvelle_valeur_du_reglage) {
        (Some(_), Some(_)) =&gt; {
            println!(&quot;Vous ne pouvez pas écraser une valeur déjà existante&quot;);
        }
        _ =&gt; {
            valeur_du_reglage = nouvelle_valeur_du_reglage;
        }
    }

    println!(&quot;Le réglage vaut {:?}&quot;, valeur_du_reglage);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-18: Using an underscore within patterns that
match `Some` variants when we don’t need to use the value inside the
`Some`</span>
-->
<p><span class="caption">Encart 18-18 : utilisation d'un tiret bas dans des motifs
qui correspondent avec des variantes <code>Some</code> lorsque nous n'avons pas besoin
d'utiliser la valeur à l'intérieur du <code>Some</code></span></p>
<!--
This code will print `Can't overwrite an existing customized value` and then
`setting is Some(5)`. In the first match arm, we don’t need to match on or use
the values inside either `Some` variant, but we do need to test for the case
when `setting_value` and `new_setting_value` are the `Some` variant. In that
case, we print why we’re not changing `setting_value`, and it doesn’t get
changed.
-->
<p>Ce code va afficher <code>Vous ne pouvez pas écraser une valeur déjà existante</code> et
ensuite <code>Le réglage vaut Some(5)</code>. Dans la première branche, nous n'avons pas
besoin de récupérer ou d'utiliser les valeurs à l'intérieur de chacune des
variantes <code>Some</code>, mais nous avons besoin de tester les cas lorsque
<code>valeur_du_reglage</code> et <code>nouvelle_valeur_du_reglage</code> vaudront la variante
<code>Some</code>. Dans ce cas, nous écrivons que nous n'allons pas changer
<code>valeur_du_reglage</code>, et il ne changera pas.</p>
<!--
In all other cases (if either `setting_value` or `new_setting_value` are
`None`) expressed by the `_` pattern in the second arm, we want to allow
`new_setting_value` to become `setting_value`.
-->
<p>Dans tous les autres cas (lorsque soit <code>valeur_du_reglage</code>, soit
<code>nouvelle_valeur_du_reglage</code> vaut <code>None</code>) qui correspondront avec le motif
<code>_</code> de la seconde branche, nous voulons permettre à la valeur de
<code>nouvelle_valeur_du_reglage</code> de remplacer celle de <code>valeur_du_reglage</code>.</p>
<!--
We can also use underscores in multiple places within one pattern to ignore
particular values. Listing 18-19 shows an example of ignoring the second and
fourth values in a tuple of five items.
-->
<p>Nous pouvons aussi utiliser les tirets bas à plusieurs endroits dans un même
motif pour ignorer des valeurs précises. L'encart 18-19 montre un exemple qui
ignore la seconde et quatrième valeur dans un tuple de cinq éléments.</p>
<!--
```rust
# fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) => {
            println!("Some numbers: {}, {}, {}", first, third, fifth)
        }
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let nombres = (2, 4, 8, 16, 32);

    match nombres {
        (premier, _, troisieme, _, cinquieme) =&gt; {
            println!(&quot;Voici quelques nombres : {}, {}, {}&quot;, premier, troisieme, cinquieme)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-19: Ignoring multiple parts of a tuple</span>
-->
<p><span class="caption">Encart 18-19 : on ignore plusieurs éléments d'un tuple
</span></p>
<!--
This code will print `Some numbers: 2, 8, 32`, and the values 4 and 16 will be
ignored.
-->
<p>Ce code va afficher <code>Voici quelques nombres : 2, 8, 32</code>, et les valeurs 4 et 16
seront ignorées.</p>
<!--
#### Ignoring an Unused Variable by Starting Its Name with `_`
-->
<h4 id="ignorer-une-variable-non-utilisée-en-démarrant-son-nom-avec-un-_"><a class="header" href="#ignorer-une-variable-non-utilisée-en-démarrant-son-nom-avec-un-_">Ignorer une variable non utilisée en démarrant son nom avec un <code>_</code></a></h4>
<!--
If you create a variable but don’t use it anywhere, Rust will usually issue a
warning because that could be a bug. But sometimes it’s useful to create a
variable you won’t use yet, such as when you’re prototyping or just starting a
project. In this situation, you can tell Rust not to warn you about the unused
variable by starting the name of the variable with an underscore. In Listing
18-20, we create two unused variables, but when we run this code, we should
only get a warning about one of them.
-->
<p>Si vous créez une variable mais que vous ne l'utilisez nulle part, Rust va
lancer un avertissement car cela est peut-être un bogue. Mais parfois il est
utile de créer une variable que vous n'utilisez pas encore, ce qui peut arriver
lorsque vous créez un prototype ou créez un projet. Dans ce genre de situation,
vous pouvez demander à Rust de ne pas vous avertir de la variable non utilisée
en débutant le nom de la variable avec un tiret bas. Dans l'encart 18-20, nous
créons deux variables non utilisées, mais lorsque nous compilerons ce code,
nous n'aurons qu'un seul avertissement sur une seule d'entre elles.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-20: Starting a variable name with an
underscore to avoid getting unused variable warnings</span>
-->
<p><span class="caption">Encart 18-20 : démarrer le nom d'une variable avec un
tiret bas pour éviter d'avoir des avertissements à propos de variables non
utilisées</span></p>
<!--
Here we get a warning about not using the variable `y`, but we don’t get a
warning about not using the variable preceded by the underscore.
-->
<p>Ici nous avons un avertissement qui nous prévient que nous n'utilisons pas la
variable <code>y</code>, mais nous n'avons pas d'avertissement à propos de la variable qui
a le nom qui commence par un tiret bas.</p>
<!--
Note that there is a subtle difference between using only `_` and using a name
that starts with an underscore. The syntax `_x` still binds the value to the
variable, whereas `_` doesn’t bind at all. To show a case where this
distinction matters, Listing 18-21 will provide us with an error.
-->
<p>Remarquez comme la différence est subtile entre l'utilisation d'uniquement <code>_</code>
et un nom qui commence par un tiret bas. La syntaxe <code>_x</code> continue à associer la
valeur à une variable, alors que <code>_</code> ne le fait pas du tout. Pour montrer un
cas où cette différence est importante, l'encart 18-21 va nous donner une
erreur.</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{:?}", s);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Salutations !&quot;));

    if let Some(_s) = s {
        println!(&quot;j'ai trouvé une chaine de caractères&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 18-21: An unused variable starting with an
underscore still binds the value, which might take ownership of the value</span>
-->
<p><span class="caption">Encart 18-21 : une variable non utilisée qui commence par
un tiret bas continue à assigner la valeur, qui pourrait prendre possession de
la valeur</span></p>
<!--
We’ll receive an error because the `s` value will still be moved into `_s`,
which prevents us from using `s` again. However, using the underscore by itself
doesn’t ever bind to the value. Listing 18-22 will compile without any errors
because `s` doesn’t get moved into `_`.
-->
<p>Nous allons obtenir une erreur car la valeur <code>s</code> est toujours déplacée dans
<code>_s</code>, ce qui nous empêche d'utiliser <code>s</code> ensuite. Cependant, l'utilisation du
tiret bas tout seul n'assigne jamais la valeur à quelque chose. L'encart 18-22
va se compiler sans aucune erreur car <code>s</code> n'est pas déplacé dans <code>_</code>.</p>
<!--
```rust
# fn main() {
    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{:?}", s);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Salutations !&quot;));

    if let Some(_) = s {
        println!(&quot;j'ai trouvé une chaine de caractères&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-22: Using an underscore does not bind the
value</span>
-->
<p><span class="caption">Encart 18-22 : l'utilisation d'un tiret bas n'assigne pas
la valeur</span></p>
<!--
This code works just fine because we never bind `s` to anything; it isn’t moved.
-->
<p>Ce code fonctionne correctement car nous n'assignons jamais <code>s</code> à quelque
chose ; elle n'est jamais déplacée.</p>
<!--
#### Ignoring Remaining Parts of a Value with `..`
-->
<h4 id="ignorer-les-éléments-restants-dune-valeur-avec-"><a class="header" href="#ignorer-les-éléments-restants-dune-valeur-avec-">Ignorer les éléments restants d'une valeur avec <code>..</code></a></h4>
<!--
With values that have many parts, we can use the `..` syntax to use only a few
parts and ignore the rest, avoiding the need to list underscores for each
ignored value. The `..` pattern ignores any parts of a value that we haven’t
explicitly matched in the rest of the pattern. In Listing 18-23, we have a
`Point` struct that holds a coordinate in three-dimensional space. In the
`match` expression, we want to operate only on the `x` coordinate and ignore
the values in the `y` and `z` fields.
-->
<p>Avec les valeurs qui ont de nombreux éléments, nous pouvons utiliser la syntaxe
<code>..</code> pour utiliser uniquement quelques éléments et ignorer les autres, ce qui
évite d'avoir à faire une liste de tirets bas pour chacune des valeurs
ignorées. Le motif <code>..</code> ignore tous les éléments d'une valeur qui ne
correspondent pas explicitement au reste du motif. Dans l'encart 18-23, nous
avons une structure <code>Point</code> qui stocke des coordonnées dans un espace
tridimensionnel. Dans l'expression <code>match</code>, nous souhaitons utiliser uniquement
la coordonnée <code>x</code> et ignorer les valeurs des champs <code>y</code> et <code>z</code>.</p>
<!--
```rust
# fn main() {
    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } => println!("x is {}", x),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origine = Point { x: 0, y: 0, z: 0 };

    match origine {
        Point { x, .. } =&gt; println!(&quot;x vaut {}&quot;, x),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-23: Ignoring all fields of a `Point` except
for `x` by using `..`</span>
-->
<p><span class="caption">Encart 18-23 : on ignore tous les champs d'un <code>Point</code>, à
l'exception de <code>x</code>, en utilisant <code>..</code></span></p>
<!--
We list the `x` value and then just include the `..` pattern. This is quicker
than having to list `y: _` and `z: _`, particularly when we’re working with
structs that have lots of fields in situations where only one or two fields are
relevant.
-->
<p>Nous ajoutons la valeur <code>x</code> et juste ensuite nous insérons le motif <code>..</code>. C'est
plus rapide que d'avoir à rajouter <code>y: _</code> et <code>z: _</code>, en particulier lorsque
nous travaillons avec des structures qui ont beaucoup de champs alors qu'un
seul champ ou deux nous intéressent.</p>
<!--
The syntax `..` will expand to as many values as it needs to be. Listing 18-24
shows how to use `..` with a tuple.
-->
<p>La syntaxe <code>..</code> va s'étendre à toutes les valeurs qu'elle devra couvrir.
L'encart 18-24 montre comment utiliser <code>..</code> avec un tuple.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) => {
            println!("Some numbers: {}, {}", first, last);
        }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombres = (2, 4, 8, 16, 32);

    match nombres {
        (premier, .., dernier) =&gt; {
            println!(&quot;Voici quelques nombres : {}, {}&quot;, premier, dernier);
        }
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-24: Matching only the first and last values in
a tuple and ignoring all other values</span>
-->
<p><span class="caption">Encart 18-24 : on correspond uniquement avec la première
et la dernière valeur d'un tuple et nous ignorons toutes les autres valeurs
</span></p>
<!--
In this code, the first and last value are matched with `first` and `last`. The
`..` will match and ignore everything in the middle.
-->
<p>Dans ce code, la première et la dernière valeur correspondent à <code>premier</code> et
<code>dernier</code>. Le <code>..</code> va correspondre et ignorer tout ce qui se trouve entre les
deux.</p>
<!--
However, using `..` must be unambiguous. If it is unclear which values are
intended for matching and which should be ignored, Rust will give us an error.
Listing 18-25 shows an example of using `..` ambiguously, so it will not
compile.
-->
<p>Cependant, l'utilisation de <code>..</code> peut être ambigu. S'il n'est pas clair de
savoir quelles sont les valeurs qui doivent correspondre et celles qui doivent
être ignorées, Rust va nous donner une erreur. L'encart 18-25 nous montre un
exemple d'utilisation ambigu de <code>..</code>, donc il ne se compilera pas.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) => {
            println!("Some numbers: {}", second)
        },
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let nombres = (2, 4, 8, 16, 32);

    match nombres {
        (.., second, ..) =&gt; {
            println!(&quot;Voici quelques nombres : {}&quot;, second)
        },
    }
}
</code></pre>
<!--
<span class="caption">Listing 18-25: An attempt to use `..` in an ambiguous
way</span>
-->
<p><span class="caption">Encart 18-25 : une tentative d'utilisation de <code>..</code> de
manière ambigu</span></p>
<!--
When we compile this example, we get this error:
-->
<p>Lorsque nous compilons cet  exemple, nous obtenons l'erreur suivante :</p>
<!--
```console
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 -- > src/main.rs:5:22
  |
5 |         (.., second, ..) => {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: aborting due to previous error

error: could not compile `patterns`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: aborting due to previous error

error: could not compile `patterns`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
It’s impossible for Rust to determine how many values in the tuple to ignore
before matching a value with `second` and then how many further values to
ignore thereafter. This code could mean that we want to ignore `2`, bind
`second` to `4`, and then ignore `8`, `16`, and `32`; or that we want to ignore
`2` and `4`, bind `second` to `8`, and then ignore `16` and `32`; and so forth.
The variable name `second` doesn’t mean anything special to Rust, so we get a
compiler error because using `..` in two places like this is ambiguous.
-->
<p>Il n'est pas possible pour Rust de déterminer combien de valeurs sont à ignorer
dans le tuple avant de faire correspondre une valeur avec <code>second</code> et ensuite
combien d'autres à ignorer après cela. Ce code pourrait signifier que nous
voulons ignorer <code>2</code>, faire correspondre <code>second</code> avec <code>4</code>, en ensuite ignorer
<code>8</code>, <code>16</code>, et <code>32</code> ; ou que nous souhaitons ignorer <code>2</code> et <code>4</code>, et faire
correspondre <code>second</code> à <code>8</code>, et ignorer ensuite <code>16</code> et <code>32</code> ; et ainsi de
suite. Le nom de la variable <code>second</code> ne signifie pas grand-chose pour Rust,
donc nous obtenons une erreur de compilation à cause de l'utilisation de <code>..</code>
à deux endroits qui rendent la situation ambigu.</p>
<!--
### Extra Conditionals with Match Guards
-->
<h3 id="plus-de-conditions-avec-les-contrôles-de-correspondance"><a class="header" href="#plus-de-conditions-avec-les-contrôles-de-correspondance">Plus de conditions avec les contrôles de correspondance</a></h3>
<!--
A *match guard* is an additional `if` condition specified after the pattern in
a `match` arm that must also match, along with the pattern matching, for that
arm to be chosen. Match guards are useful for expressing more complex ideas
than a pattern alone allows.
-->
<p>Un <em>contrôle de correspondance</em> est une condition <code>if</code> supplémentaire renseignée
après le motif d'une branche d'un <code>match</code> qui doit elle aussi correspondre, de
même que le filtrage par motif, pour que cette branche soit choisie. Les
contrôles de correspondance sont utiles pour exprimer des idées plus complexes
que celles permises par les motifs tout seuls.</p>
<!--
The condition can use variables created in the pattern. Listing 18-26 shows a
`match` where the first arm has the pattern `Some(x)` and also has a match
guard of `if x < 5`.
-->
<p>La condition peut utiliser des variables créées dans le motif. L'encart 18-26
montre un <code>match</code> dans lequel la première branche a le motif <code>Some(x)</code> et
procède aussi au contrôle de correspondance <code>if x &lt; 5</code>.</p>
<!--
```rust
# fn main() {
    let num = Some(4);

    match num {
        Some(x) if x < 5 => println!("less than five: {}", x),
        Some(x) => println!("{}", x),
        None => (),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let nombre = Some(4);

    match nombre {
        Some(x) if x &lt; 5 =&gt; println!(&quot;moins que cinq : {}&quot;, x),
        Some(x) =&gt; println!(&quot;{}&quot;, x),
        None =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-26: Adding a match guard to a pattern</span>
-->
<p><span class="caption">Encart 18-26 : ajout d'un contrôle de correspondance à un
motif</span></p>
<!--
This example will print `less than five: 4`. When `num` is compared to the
pattern in the first arm, it matches, because `Some(4)` matches `Some(x)`. Then
the match guard checks whether the value in `x` is less than `5`, and because
it is, the first arm is selected.
-->
<p>Cet exemple va afficher <code>moins que cinq : 4</code>. Lorsque <code>nombre</code> est comparé au
motif de la première branche, il va correspondre, car <code>Some(4)</code> correspond à
<code>Some(x)</code>. Ensuite, le contrôle de correspondance vérifie si la valeur dans <code>x</code>
est inférieure à <code>5</code>, et comme c'est le cas, la première branche est choisie.</p>
<!--
If `num` had been `Some(10)` instead, the match guard in the first arm would
have been false because 10 is not less than 5. Rust would then go to the second
arm, which would match because the second arm doesn’t have a match guard and
therefore matches any `Some` variant.
-->
<p>Si <code>nombre</code> aurait été plutôt <code>Some(10)</code>, le contrôle de correspondance de la
première branche aurait été faux car 10 n'est pas inférieur à 5. Rust serait
donc allé à la seconde branche, qui devrait correspondre car la seconde branche
n'a pas de contrôle de correspondance et correspond parfois à la variante
<code>Some</code>.</p>
<!--
There is no way to express the `if x < 5` condition within a pattern, so the
match guard gives us the ability to express this logic.
-->
<p>Il n'y a pas d'autre moyen d'exprimer la condition <code>if x &lt; 5</code> dans un motif,
donc le contrôle de correspondance nous donne la possibilité d'exprimer cette
logique.</p>
<!--
In Listing 18-11, we mentioned that we could use match guards to solve our
pattern-shadowing problem. Recall that a new variable was created inside the
pattern in the `match` expression instead of using the variable outside the
`match`. That new variable meant we couldn’t test against the value of the
outer variable. Listing 18-27 shows how we can use a match guard to fix this
problem.
-->
<p>Dans l'encart 18-11, nous avions mentionné le fait que nous pouvions utiliser
des contrôles de correspondance pour résoudre notre problème de masquage dans
le motif. Souvenez-vous qu'une nouvelle variable avait été créée à l'intérieur
du motif dans l'expression <code>match</code> au lieu d'utiliser la variable située à
l'extérieur du <code>match</code>. Cette nouvelle variable implique que nous ne pouvons
pas comparer avec la variable qui se situe à l'extérieur. L'encart 18-27 nous
montre comment nous pouvons utiliser un contrôle de correspondance pour
répondre à ce besoin.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(n) if n == y => println!("Matched, n = {}", n),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {}", x, y);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Nous obtenons 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Nous avons une correspondance, n = {}&quot;, n),
        _ =&gt; println!(&quot;Cas par défaut, x = {:?}&quot;, x),
    }

    println!(&quot;Au final : x = {:?}, y = {}&quot;, x, y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-27: Using a match guard to test for equality
with an outer variable</span>
-->
<p><span class="caption">Encart 18-27 : utilisation d'un contrôle de
correspondance pour vérifier l'égalité avec une variable externe au bloc</span></p>
<!--
This code will now print `Default case, x = Some(5)`. The pattern in the second
match arm doesn’t introduce a new variable `y` that would shadow the outer `y`,
meaning we can use the outer `y` in the match guard. Instead of specifying the
pattern as `Some(y)`, which would have shadowed the outer `y`, we specify
`Some(n)`. This creates a new variable `n` that doesn’t shadow anything because
there is no `n` variable outside the `match`.
-->
<p>Ce code va maintenant afficher <code>Cas par défaut, x = Some(5)</code>. Le motif de la
seconde branche du <code>match</code> ne crée pas de nouvelle variable <code>y</code> qui masquerait
le <code>y</code> externe, ce qui signifie que nous pouvons utiliser le <code>y</code> externe dans
le contrôle de correspondance. Au lieu de renseigner le motif comme étant
<code>Some(y)</code>, ce qui aurait masqué le <code>y</code> externe, nous renseignons <code>Some(n)</code>.
Cela va créer une nouvelle variable <code>n</code> qui ne masque rien car il n'y a pas de
variable <code>n</code> à l'extérieur du <code>match</code>.</p>
<!--
The match guard `if n == y` is not a pattern and therefore doesn’t introduce
new variables. This `y` *is* the outer `y` rather than a new shadowed `y`, and
we can look for a value that has the same value as the outer `y` by comparing
`n` to `y`.
-->
<p>Le contrôle de correspondance <code>if n == y</code> n'est pas un motif et donc il
n'introduit pas de nouvelle variable. Ce <code>y</code> <em>est</em> la variable externe <code>y</code> au
lieu d'être une nouvelle variable masquée <code>y</code>, et nous pouvons comparer une
valeur qui a la même valeur que le <code>y</code> externe en comparant <code>n</code> à <code>y</code>.</p>
<!--
You can also use the *or* operator `|` in a match guard to specify multiple
patterns; the match guard condition will apply to all the patterns. Listing
18-28 shows the precedence of combining a match guard with a pattern that uses
`|`. The important part of this example is that the `if y` match guard applies
to `4`, `5`, *and* `6`, even though it might look like `if y` only applies to
`6`.
-->
<p>Vous pouvez aussi utiliser l'opérateur <em>ou</em> <code>|</code> dans un contrôle de
correspondance pour y renseigner plusieurs motifs ; la condition du contrôle de
correspondance s'effectuera alors sur tous les motifs. L'encart 18-28 montre la
priorité de combinaison d'un contrôle de correspondance sur un motif qui
utilise <code>|</code>. La partie importante de cet exemple est que le contrôle de
correspondance <code>if y</code> s'applique sur <code>4</code>, <code>5</code>, <em>et</em> <code>6</code>, même si <code>if y</code> semble
s'appliquer uniquement à <code>6</code>.</p>
<!--
```rust
# fn main() {
    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y => println!("yes"),
        _ => println!("no"),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
        _ =&gt; println!(&quot;no&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-28: Combining multiple patterns with a match
guard</span>
-->
<p><span class="caption">Encart 18-28 : combinaison de plusieurs motifs avec un
contrôle de correspondance</span></p>
<!--
The match condition states that the arm only matches if the value of `x` is
equal to `4`, `5`, or `6` *and* if `y` is `true`. When this code runs, the
pattern of the first arm matches because `x` is `4`, but the match guard `if y`
is false, so the first arm is not chosen. The code moves on to the second arm,
which does match, and this program prints `no`. The reason is that the `if`
condition applies to the whole pattern `4 | 5 | 6`, not only to the last value
`6`. In other words, the precedence of a match guard in relation to a pattern
behaves like this:
-->
<p>La condition de correspondance signifie que la branche correspond uniquement si
la valeur de <code>x</code> vaut <code>4</code>, <code>5</code>, ou <code>6</code> <em>et</em> que <code>y</code> vaut <code>true</code>. Lorsque ce
code s'exécute, le motif de la première branche correspond car <code>x</code> vaut 4, mais
le contrôle de correspondance <code>if y</code> est faux, donc ce programme affiche <code>no</code>.
La raison est que la condition <code>if</code> s'applique à tout le motif <code>4 | 5 | 6</code>, et
pas seulement à la dernière valeur <code>6</code>. Autrement dit, la priorité d'un
contrôle de correspondance avec un motif se comporte comme ceci :</p>
<!--
```text
(4 | 5 | 6) if y => ...
```
-->
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<!--
rather than this:
-->
<p>plutôt que comme ceci :</p>
<!--
```text
4 | 5 | (6 if y) => ...
```
-->
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<!--
After running the code, the precedence behavior is evident: if the match guard
were applied only to the final value in the list of values specified using the
`|` operator, the arm would have matched and the program would have printed
`yes`.
-->
<p>Après avoir exécuté le code, le fonctionnement des priorités devient évident :
si le contrôle de correspondance était seulement appliqué à la dernière valeur
renseignée avec l'opérateur <code>|</code>, la branche correspondrait et le programme
aurait affiché <code>yes</code>.</p>
<!--
### `@` Bindings
-->
<h3 id="capturer-des-valeurs-avec-"><a class="header" href="#capturer-des-valeurs-avec-">Capturer des valeurs avec <code>@</code></a></h3>
<!--
The *at* operator (`@`) lets us create a variable that holds a value at the
same time we’re testing that value to see whether it matches a pattern. Listing
18-29 shows an example where we want to test that a `Message::Hello` `id` field
is within the range `3..=7`. But we also want to bind the value to the variable
`id_variable` so we can use it in the code associated with the arm. We could
name this variable `id`, the same as the field, but for this example we’ll use
a different name.
-->
<p>L'opérateur <code>@</code> nous permet de créer une variable qui stocke une valeur en même
temps que nous testons cette valeur pour vérifier si elle correspond à un
motif. L'encart 18-29 montre un exemple dans lequel nous souhaitons tester
qu'un champ <code>id</code> d'un <code>Message::Hello</code> est dans un intervalle <code>3..=7</code>. Mais
nous voulons aussi associer la valeur à la variable <code>id_variable</code> pour que nous
puissions l'utiliser dans le code associé à la branche. Nous aurions pu nommer
cette variable avec le même nom que le champ <code>id</code>, mais pour cet exemple nous
allons utiliser un nom différent.</p>
<!--
```rust
# fn main() {
    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } => println!("Found an id in range: {}", id_variable),
        Message::Hello { id: 10..=12 } => {
            println!("Found an id in another range")
        }
        Message::Hello { id } => println!("Found some other id: {}", id),
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!(&quot;Nous avons trouvé un id dans l'intervalle : {}&quot;, id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&quot;Nous avons trouvé un id dans un autre intervalle&quot;)
        }
        Message::Hello { id } =&gt; println!(&quot;Nous avons trouvé un autre id : {}&quot;, id),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-29: Using `@` to bind to a value in a pattern
while also testing it</span>
-->
<p><span class="caption">Encart 18-29 : utilisation de <code>@</code> pour lier une valeur
d'un motif à une variable pendant qu'on la teste</span></p>
<!--
This example will print `Found an id in range: 5`. By specifying `id_variable
@` before the range `3..=7`, we’re capturing whatever value matched the range
while also testing that the value matched the range pattern.
-->
<p>Cet exemple va afficher <code>Nous avons trouvé un id dans l'intervalle : 5</code>. En
renseignant <code>id_variable @</code> avant l'intervalle <code>3..=7</code>, nous capturons la
valeur qui correspond à l'intervalle pendant que nous vérifions que la valeur
correspond au motif de l'intervalle.</p>
<!--
In the second arm, where we only have a range specified in the pattern, the code
associated with the arm doesn’t have a variable that contains the actual value
of the `id` field. The `id` field’s value could have been 10, 11, or 12, but
the code that goes with that pattern doesn’t know which it is. The pattern code
isn’t able to use the value from the `id` field, because we haven’t saved the
`id` value in a variable.
-->
<p>Dans la seconde branche, où nous avons uniquement un intervalle renseigné dans
le motif, le code associé à la branche n'a pas besoin d'une variable qui
contient la valeur actuelle du champ <code>id</code>. La valeur du champ <code>id</code> aurait pu
être 10, 11, ou 12, mais le code associé à ce motif ne saura pas quelle est sa
valeur. Le code du motif n'est pas capable d'utiliser la valeur du champ <code>id</code>,
car nous n'avons pas enregistré <code>id</code> dans une variable.</p>
<!--
In the last arm, where we’ve specified a variable without a range, we do have
the value available to use in the arm’s code in a variable named `id`. The
reason is that we’ve used the struct field shorthand syntax. But we haven’t
applied any test to the value in the `id` field in this arm, as we did with the
first two arms: any value would match this pattern.
-->
<p>Dans la dernière branche, nous avons renseigné une variable sans intervalle,
nous avons la valeur qui peut être utilisée dans le code de la branche, dans la
variable <code>id</code>. La raison à cela est que nous avons utilisé la syntaxe
raccourcie pour les champs des structures. Mais nous n'avons pas appliqué de
tests à la valeur sur le champ <code>id</code> de cette branche, comme nous l'avions fait
avec les deux premières branches : n'importe quelle valeur correspondra à ce
motif.</p>
<!--
Using `@` lets us test a value and save it in a variable within one pattern.
-->
<p>L'utilisation de <code>@</code> nous permet de tester une valeur et de l'enregistrer dans
une variable au sein d'un seul et même motif.</p>
<!--
## Summary
-->
<h2 id="résumé-17"><a class="header" href="#résumé-17">Résumé</a></h2>
<!--
Rust’s patterns are very useful in that they help distinguish between different
kinds of data. When used in `match` expressions, Rust ensures your patterns
cover every possible value, or your program won’t compile. Patterns in `let`
statements and function parameters make those constructs more useful, enabling
the destructuring of values into smaller parts at the same time as assigning to
variables. We can create simple or complex patterns to suit our needs.
-->
<p>Les motifs de Rust sont très utiles lorsque nous devons distinguer différents
types de données. Lorsque nous les avions utilisés dans les expressions
<code>match</code>, Rust s'est assuré que vos motifs couvent l'intégralité de toutes
valeurs possibles, ou alors votre programme ne se compilait pas. Les motifs
dans les instructions <code>let</code> et les paramètres de fonction rendre ces
constructions encore plus utiles, permettant de déstructurer les valeurs en
parties plus petites tout en les assignant à des variables. Nous pouvons créer
des motifs très simples ou alors plus complexes pour répondre à nos besoins.</p>
<!--
Next, for the penultimate chapter of the book, we’ll look at some advanced
aspects of a variety of Rust’s features.
-->
<p>Dans le chapitre suivant, qui sera l'avant-dernier du livre, nous allons
découvrir quelques aspects avancés de l'éventail de fonctionnalités de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--25"><a class="header" href="#-attention-peinture-fraîche--25">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/208">Pull Request</a>.</p>
</blockquote>
<!--
# Advanced Features
-->
<h1 id="les-fonctionnalités-avancées"><a class="header" href="#les-fonctionnalités-avancées">Les fonctionnalités avancées</a></h1>
<!--
By now, you’ve learned the most commonly used parts of the Rust programming
language. Before we do one more project in Chapter 20, we’ll look at a few
aspects of the language you might run into every once in a while. You can use
this chapter as a reference for when you encounter any unknowns when using
Rust. The features you’ll learn to use in this chapter are useful in very
specific situations. Although you might not reach for them often, we want to
make sure you have a grasp of all the features Rust has to offer.
-->
<p>Jusqu'ici, vous avez appris les fonctionnalités les plus utilisées du langage
de programmation Rust. Avant de commencer le nouveau projet du chapitre 20, nous
allons regarder quelques aspects du langage que vous pourriez rencontrer de
temps à autre. Vous pouvez utiliser ce chapitre comme étant une référence
lorsque vous rencontrerez des éléments inconnus lorsque vous utiliserez Rust.
Les fonctionnalités que vous allez découvrir dans ce chapitre sont utiles dans
de nombreuses situations spécifiques. Même si vous n'allez pas les rencontrer
très souvent, nous voulons nous assurer que vous comprenez bien toutes les
fonctionnalités qu'offrent Rust.</p>
<!--
In this chapter, we’ll cover:
-->
<p>Dans ce chapitre, nous allons voir :</p>
<!--
* Unsafe Rust: how to opt out of some of Rust’s guarantees and take
  responsibility for manually upholding those guarantees
* Advanced traits: associated types, default type parameters, fully qualified
  syntax, supertraits, and the newtype pattern in relation to traits
* Advanced types: more about the newtype pattern, type aliases, the never type,
  and dynamically sized types
* Advanced functions and closures: function pointers and returning closures
* Macros: ways to define code that defines more code at compile time
-->
<ul>
<li>Le <em>unsafe</em> de Rust : comment désactiver certaines garanties de Rust et
prendre la responsabilité de veiller manuellement à ces garanties</li>
<li>Les traits avancés : les types associés, les types de paramètres par défaut,
la syntaxe entièrement détaillée, les supertraits, et le motif newtype en lien
avec les traits</li>
<li>Les types avancés : en savoir plus sur le motif newtype, les alias de type, le
type never, et les types à taille dynamique</li>
<li>Les fonctions et fermetures avancées : les pointeurs de fonctions et retourner
des fermetures</li>
<li>Les macros : une manière de définir du code qui écrit encore plus de code au
moment de la compilation</li>
</ul>
<!--
It’s a panoply of Rust features with something for everyone! Let’s dive in!
-->
<p>Voilà une pléthore de fonctionnalités de Rust dans lesquelles chacun y trouvera
son compte ! Commençons tout de suite !</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--26"><a class="header" href="#-attention-peinture-fraîche--26">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/210">Pull Request</a>.</p>
</blockquote>
<!--
## Unsafe Rust
-->
<h2 id="le-rust-non-sécurisé-unsafe"><a class="header" href="#le-rust-non-sécurisé-unsafe">Le Rust non sécurisé (<code>unsafe</code>)</a></h2>
<!--
All the code we’ve discussed so far has had Rust’s memory safety guarantees
enforced at compile time. However, Rust has a second language hidden inside it
that doesn’t enforce these memory safety guarantees: it’s called *unsafe Rust*
and works just like regular Rust, but gives us extra superpowers.
-->
<p>Tout le code Rust dont nous avons abordé jusqu'à présent a bénéficié des
garanties de sécurité de la mémoire, vérifiées à la compilation. Cependant, Rust
a un second langage caché en son sein qui n'appliquent pas ces vérifications
pour la sécurité de la mémoire : il s'appelle le <em>Rust non sécurisé</em> et
fonctionne comme le Rust habituel, mais fournit quelques super-pouvoirs
supplémentaires.</p>
<!--
Unsafe Rust exists because, by nature, static analysis is conservative. When
the compiler tries to determine whether or not code upholds the guarantees,
it’s better for it to reject some valid programs rather than accept some
invalid programs. Although the code might be okay, as far as Rust is able to
tell, it’s not! In these cases, you can use unsafe code to tell the compiler,
“Trust me, I know what I’m doing.” The downside is that you use it at your own
risk: if you use unsafe code incorrectly, problems due to memory unsafety, such
as null pointer dereferencing, can occur.
-->
<p>Le Rust non sécurisé existe car, par nature, l'analyse statique est conservatif.
Lorsque le compilateur essaye de déterminer si le code respecte ou non les
garanties, il vaut mieux rejeter quelques programmes valides plutôt que
d'accepter quelques programmes invalides. Bien que le code puisse être correct,
dès que Rust n'est pas capable de le comprendre, il ne l'est plus ! Dans ce cas,
vous pouvez utiliser du code non sécurisé pour dire au compilateur “fais-moi
confiance, je sais ce que je fait”. La contrepartie pour cela est que vous
l'utilisez à vos risques et périls : si vous écrivez du code non sécurisé de
manière incorrecte, des problèmes liés à la sécurité de la mémoire peuvent se
produire, comme le déréférencement d'un pointeur vide par exemple.</p>
<!--
Another reason Rust has an unsafe alter ego is that the underlying computer
hardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you
couldn’t do certain tasks. Rust needs to allow you to do low-level systems
programming, such as directly interacting with the operating system or even
writing your own operating system. Working with low-level systems programming
is one of the goals of the language. Let’s explore what we can do with unsafe
Rust and how to do it.
-->
<p>Une autre raison pour laquelle Rust embarque son alter-ego non sécurisé est que
le matériel des ordinateurs sur lequel il repose n'est pas sécurisé par essence.
Si Rust ne vous laisse pas procéder à des opérations non sécurisées, vous ne
pourrez pas faire certaines choses. Rust doit pouvoir vous permettre de
développer du code bas-niveau, comme pouvoir interagir directement avec le
système d'exploitation ou même écrire votre propre système d'exploitation.
Pouvoir travailler avec des systèmes bas-niveau est un des objectifs du langage.
Voyons ce que nous pouvons faire avec le Rust non sécurisé et comment le faire.</p>
<!--
### Unsafe Superpowers
-->
<h3 id="les-super-pouvoirs-du-code-non-sécurisé"><a class="header" href="#les-super-pouvoirs-du-code-non-sécurisé">Les super-pouvoirs du code non sécurisé</a></h3>
<!--
To switch to unsafe Rust, use the `unsafe` keyword and then start a new block
that holds the unsafe code. You can take five actions in unsafe Rust, called
*unsafe superpowers*, that you can’t in safe Rust. Those superpowers include
the ability to:
-->
<p>Pour pouvoir utiliser le Rust non sécurisé, il faut utiliser le mot-clé <code>unsafe</code>
et ensuite créer un nouveau bloc qui contient le code non sécurisé. Vous pouvez
faire cinq actions en Rust non sécurisé, qui s'appellent <em>les super-pouvoirs du
non sécurisé</em>, que vous ne pouvez pas faire en Rust sécurisé. Ces super-pouvoirs
permettent de :</p>
<!--
* Dereference a raw pointer
* Call an unsafe function or method
* Access or modify a mutable static variable
* Implement an unsafe trait
* Access fields of `union`s
-->
<ul>
<li>Déréférencer un pointeur brut</li>
<li>Faire appel à une fonction ou une méthode non sécurisée</li>
<li>Lire ou modifier une variable statique mutable</li>
<li>Implémenter un trait non sécurisé</li>
<li>Accéder aux champs des <code>union</code></li>
</ul>
<!--
It’s important to understand that `unsafe` doesn’t turn off the borrow checker
or disable any other of Rust’s safety checks: if you use a reference in unsafe
code, it will still be checked. The `unsafe` keyword only gives you access to
these five features that are then not checked by the compiler for memory
safety. You’ll still get some degree of safety inside of an unsafe block.
-->
<p>Il est important de comprendre que <code>unsafe</code> ne désactive pas le vérificateur
d'emprunt et ne désactive pas les autres vérifications de sécurité de Rust : si
vous utilisez une référence dans du code non sécurisé, elle sera toujours
vérifiée. Le mot-clé <code>unsafe</code> vous donne seulement accès à ces cinq
fonctionnalités qui ne sont alors pas vérifiées par le compilateur pour veiller
à la sécurité de la mémoire. Vous conservez un certain niveau de sécurité à
l'intérieur d'un bloc <code>unsafe</code>.</p>
<!--
In addition, `unsafe` does not mean the code inside the block is necessarily
dangerous or that it will definitely have memory safety problems: the intent is
that as the programmer, you’ll ensure the code inside an `unsafe` block will
access memory in a valid way.
-->
<p>De plus, <code>unsafe</code> ne signifie pas que le code à l'intérieur du bloc est
obligatoirement dangereux ou qu'il va forcément avoir des problèmes de sécurité
mémoire : le but étant qu'en tant que développeur, vous vous assurez que le code
à l'intérieur d'un bloc <code>unsafe</code> va accéder correctement à la mémoire.</p>
<!--
People are fallible, and mistakes will happen, but by requiring these five
unsafe operations to be inside blocks annotated with `unsafe` you’ll know that
any errors related to memory safety must be within an `unsafe` block. Keep
`unsafe` blocks small; you’ll be thankful later when you investigate memory
bugs.
-->
<p>Personne n'est parfait, les erreurs arrivent, et en nécessitant que ces cinq
opérations non sécurisés se trouvent dans des blocs marqués d'un <code>unsafe</code>, vous
saurez que des erreurs liées à la sécurité de la mémoire se trouveront dans un
bloc <code>unsafe</code>. Essayez de minimiser la taille des blocs <code>unsafe</code> ; vous ne le
regretterez pas lorsque vous diagnostiquerez des bogues de mémoire.</p>
<!--
To isolate unsafe code as much as possible, it’s best to enclose unsafe code
within a safe abstraction and provide a safe API, which we’ll discuss later in
the chapter when we examine unsafe functions and methods. Parts of the standard
library are implemented as safe abstractions over unsafe code that has been
audited. Wrapping unsafe code in a safe abstraction prevents uses of `unsafe`
from leaking out into all the places that you or your users might want to use
the functionality implemented with `unsafe` code, because using a safe
abstraction is safe.
-->
<p>Pour isoler autant que possible le code non sécurisé, il vaut mieux intégrer du
code non sécurisé dans une abstraction et fournir ainsi une API sécurisée, ce
que nous verrons plus tard dans ce chapitre lorsque nous examinerons les
fonctions et méthodes non sécurisées. Certaines parties de la bibliothèque
standard sont implémentés comme étant des abstractions sécurisées et basées sur
du code non sécurisé qui a été audité. Envelopper du code non sécurisé dans une
abstraction sécurisée évite l'utilisation de <code>unsafe</code> de se propager dans des
endroits où vous ou vos utilisateurs souhaiteraient éviter d'utiliser les
fonctionnalités du code <code>unsafe</code>, car utiliser une abstraction sécurisée doit
être sûre.</p>
<!--
Let’s look at each of the five unsafe superpowers in turn. We’ll also look at
some abstractions that provide a safe interface to unsafe code.
-->
<p>Analysons chacun à leur tour les cinq super-pouvoirs. Nous allons aussi
découvrir quelques abstractions qui fournissent une interface sécurisée pour
faire fonctionner du code non sécurisé.</p>
<!--
### Dereferencing a Raw Pointer
-->
<h3 id="déréférencer-un-pointeur-brut"><a class="header" href="#déréférencer-un-pointeur-brut">Déréférencer un pointeur brut</a></h3>
<!--
In Chapter 4, in the [“Dangling References”][dangling-references]<!-- ignore
-- > section, we mentioned that the compiler ensures references are always
valid. Unsafe Rust has two new types called *raw pointers* that are similar to
references. As with references, raw pointers can be immutable or mutable and
are written as `*const T` and `*mut T`, respectively. The asterisk isn’t the
dereference operator; it’s part of the type name. In the context of raw
pointers, *immutable* means that the pointer can’t be directly assigned to
after being dereferenced.
-->
<p>Au chapitre 4, dans la section
<a href="ch04-02-references-and-borrowing.html#les-r%C3%A9f%C3%A9rences-pendouillantes">“Les références pendouillantes”</a><!-- ignore -->, nous
avions mentionné que le compilateur s'assure que les références sont toujours
valides. Le Rust non sécurisé a deux nouveaux types qui s'appellent les
<em>pointeurs brut</em> qui ressemblent aux références. Comme les références, les
pointeurs bruts peuvent être immuables ou mutables et s'écrivent respectivement
<code>*const T</code> et <code>*mut T</code>. L'astérisque n'est pas l'opérateur de déréférencement ;
il fait partie du nom du type. Dans un contexte de pointeur brut, <em>immuable</em>
signifie que le pointeur ne peut pas être affecté directement après avoir été
déréférencé.</p>
<!--
Different from references and smart pointers, raw pointers:
-->
<p>Par rapport aux références et les pointeurs intelligents, les pointeurs
bruts peuvent :</p>
<!--
* Are allowed to ignore the borrowing rules by having both immutable and
  mutable pointers or multiple mutable pointers to the same location
* Aren’t guaranteed to point to valid memory
* Are allowed to be null
* Don’t implement any automatic cleanup
-->
<ul>
<li>ignorer les règles d'emprunt en ayant plusieurs pointeurs tant immuables que
mutables ou en ayant plusieurs pointeurs mutables qui pointent vers le même
endroit.</li>
<li>ne pas être obligé de pointer sur un emplacement mémoire valide</li>
<li>être autorisé à avoir la valeur nulle</li>
<li>ne pas implémenter de fonctionnalité de nettoyage automatique</li>
</ul>
<!--
By opting out of having Rust enforce these guarantees, you can give up
guaranteed safety in exchange for greater performance or the ability to
interface with another language or hardware where Rust’s guarantees don’t apply.
-->
<p>En renonçant à ce que Rust fasse respecter ces garanties, vous pouvez sacrifier
la sécurité garantie pour obtenir de meilleures performances ou avoir la
possibilité de vous interfacer avec un autre langage ou matériel pour lesquels
les garanties de Rust ne s'appliquent pas.</p>
<!--
Listing 19-1 shows how to create an immutable and a mutable raw pointer from
references.
-->
<p>L'encart 19-1 montre comment créer un pointeur brut immuable et mutable à partir
de références.</p>
<!--
```rust
# fn main() {
    let mut num = 5;

    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut nombre = 5;

    let r1 = &amp;nombre as *const i32;
    let r2 = &amp;mut nombre as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-1: Creating raw pointers from references</span>
-->
<p><span class="caption">Encart 19-1 : création de pointeurs bruts à partir de
références</span></p>
<!--
Notice that we don’t include the `unsafe` keyword in this code. We can create
raw pointers in safe code; we just can’t dereference raw pointers outside an
unsafe block, as you’ll see in a bit.
-->
<p>Remarquez que nous n'incorporons pas le mot-clé <code>unsafe</code> dans ce code. Nous
pouvons créer des pointeurs bruts dans du code sécurisé ; nous ne pouvons
simplement pas déréférencer les pointeurs bruts à l'extérieur d'un bloc non
sécurisé, comme vous allez le constater d'ici peu.</p>
<!--
We’ve created raw pointers by using `as` to cast an immutable and a mutable
reference into their corresponding raw pointer types. Because we created them
directly from references guaranteed to be valid, we know these particular raw
pointers are valid, but we can’t make that assumption about just any raw
pointer.
-->
<p>Nous avons créé des pointeurs bruts en utilisant <code>as</code> pour transformer les
références immuables et mutables en leur type de pointeur brut correspondant.
Comme nous les avons créés directement à partir de références qui sont garanties
d'être valides, nous savons que ces pointeurs bruts seront valides, mais nous ne
pouvons pas faire cette déduction sur tous les pointeurs bruts.</p>
<!--
Next, we’ll create a raw pointer whose validity we can’t be so certain of.
Listing 19-2 shows how to create a raw pointer to an arbitrary location in
memory. Trying to use arbitrary memory is undefined: there might be data at
that address or there might not, the compiler might optimize the code so there
is no memory access, or the program might error with a segmentation fault.
Usually, there is no good reason to write code like this, but it is possible.
-->
<p>Ensuite, nous allons créer un pointeur brut dont la validité n'est pas
certaine. L'encart 19-2 montre comment créer un pointeur brut vers un
emplacement arbitraire de la mémoire. Essayer d'utiliser de la mémoire
arbitraire est incertain : il peut y avoir des données à cette adresse, ou il
peut ne pas y en avoir, le programme peut déboucher sur une erreur de
segmentation. Habituellement, il n'y a pas de bonne raison d'écrire du code
comme celui-ci, mais c'est possible.</p>
<!--
```rust
# fn main() {
    let address = 0x012345usize;
    let r = address as *const i32;
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let addresse = 0x012345usize;
    let r = addresse as *const i32;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-2: Creating a raw pointer to an arbitrary
memory address</span>
-->
<p><span class="caption">Encart 19-2 : création d'un pointeur brut vers une
adresse mémoire arbitraire</span></p>
<!--
Recall that we can create raw pointers in safe code, but we can’t *dereference*
raw pointers and read the data being pointed to. In Listing 19-3, we use the
dereference operator `*` on a raw pointer that requires an `unsafe` block.
-->
<p>Souvenez-vous que nous pouvons créer des pointeurs bruts dans du code sécurisé,
mais que nous ne pouvons pas y <em>déréférencer</em> les pointeurs bruts et lire les
données sur lesquelles ils pointent. Dans l'encart 19-3, nous utilisons
l'opérateur de déréférencement <code>*</code> sur un pointeur brut qui nécessite un bloc
<code>unsafe</code>.</p>
<!--
```rust,unsafe
# fn main() {
    let mut num = 5;

    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;

    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust unsafe"><span class="boring">fn main() {
</span>    let mut nombre = 5;

    let r1 = &amp;nombre as *const i32;
    let r2 = &amp;mut nombre as *mut i32;

    unsafe {
        println!(&quot;r1 vaut : {}&quot;, *r1);
        println!(&quot;r2 vaut : {}&quot;, *r2);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-3: Dereferencing raw pointers within an
`unsafe` block</span>
-->
<p><span class="caption">Encart 19-3 : déréférencement d'un pointeur brut à
l'intérieur d'un bloc <code>unsafe</code></span></p>
<!--
Creating a pointer does no harm; it’s only when we try to access the value that
it points at that we might end up dealing with an invalid value.
-->
<p>La création de pointeur ne pose pas de problèmes ; c'est seulement lorsque nous
essayons d'accéder aux valeurs sur lesquelles elles pointent qu'on risque
d'obtenir une valeur invalide.</p>
<!--
Note also that in Listing 19-1 and 19-3, we created `*const i32` and `*mut i32`
raw pointers that both pointed to the same memory location, where `num` is
stored. If we instead tried to create an immutable and a mutable reference to
`num`, the code would not have compiled because Rust’s ownership rules don’t
allow a mutable reference at the same time as any immutable references. With
raw pointers, we can create a mutable pointer and an immutable pointer to the
same location and change data through the mutable pointer, potentially creating
a data race. Be careful!
-->
<p>Remarquez aussi que dans les encarts 19-1 et 19-3, nous avons créé les
pointeurs bruts <code>*const i32</code> et <code>*mut i32</code> qui pointent tous les deux au même
endroit de la mémoire, où <code>nombre</code> est stocké. Si nous avions plutôt tenté de
créer une référence immuable et une mutable vers <code>nombre</code>, le code n'aurait pas
compilé à cause des règles de possession de Rust qui ne permettent pas d'avoir
une référence mutable en même temps qu'une ou plusieurs références immuables.
Avec les pointeurs bruts, nous pouvons créer un pointeur mutable et un pointeur
immuable vers le même endroit et changer la donnée via le pointeur mutable, en
risquant un accès concurrent. Soyez vigilant !</p>
<!--
With all of these dangers, why would you ever use raw pointers? One major use
case is when interfacing with C code, as you’ll see in the next section,
[“Calling an Unsafe Function or
Method.”](#calling-an-unsafe-function-or-method)<!-- ignore -- > Another case is
when building up safe abstractions that the borrow checker doesn’t understand.
We’ll introduce unsafe functions and then look at an example of a safe
abstraction that uses unsafe code.
-->
<p>Avec tous ces dangers, pourquoi vous risquer à utiliser les pointeurs bruts ?
Une des utilisations majeures et lorsque nous nous interfacons avec du code
C, comme vous allez le découvrir dans la section suivante. Une autre
utilisation est lorsque nous créons une abstraction sécurisée qui le
vérificateur d'emprunt ne comprends pas. Nous allons découvrir les fonctions
non sécurisées et ensuite voir un exemple d'une abstraction sécurisée qui
utilise du code non sécurisé.</p>
<!--
### Calling an Unsafe Function or Method
-->
<h3 id="faire-appel-à-une-fonction-ou-une-méthode-non-sécurisée"><a class="header" href="#faire-appel-à-une-fonction-ou-une-méthode-non-sécurisée">Faire appel à une fonction ou une méthode non sécurisée</a></h3>
<!--
The second type of operation that requires an unsafe block is calls to unsafe
functions. Unsafe functions and methods look exactly like regular functions and
methods, but they have an extra `unsafe` before the rest of the definition. The
`unsafe` keyword in this context indicates the function has requirements we
need to uphold when we call this function, because Rust can’t guarantee we’ve
met these requirements. By calling an unsafe function within an `unsafe` block,
we’re saying that we’ve read this function’s documentation and take
responsibility for upholding the function’s contracts.
-->
<p>Le second type d'opération qui nécessite un bloc <code>unsafe</code> est l'appel à des
fonctions non sécurisées. Les fonctions et méthodes non sécurisées ressemblent
exactement pareil que les méthodes et fonctions habituelles, mais ont un
<code>unsafe</code> en plus devant le reste de leur définition. Le mot-clé <code>unsafe</code> dans
ce cas signifie que la fonction a des exigences à respecter pour pouvoir y
faire appel, car Rust ne peut pas garantir que nous avons rempli ces exigences.
En faisant appel à une fonction non sécurisée dans un bloc <code>unsafe</code>, nous
signalons que nous avons lu la documentation de cette fonction et pris la
responsabilité de respecter les conditions d'utilisation de la fonction.</p>
<!--
Here is an unsafe function named `dangerous` that doesn’t do anything in its
body:
-->
<p>Voici une fonction non sécurisée <code>dangereux</code>, qui ne fait rien dans son corps :</p>
<!--
```rust,unsafe
# fn main() {
    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust unsafe"><span class="boring">fn main() {
</span>    unsafe fn dangereux() {}

    unsafe {
        dangereux();
    }
<span class="boring">}
</span></code></pre></pre>
<!--
We must call the `dangerous` function within a separate `unsafe` block. If we
try to call `dangerous` without the `unsafe` block, we’ll get an error:
-->
<p>Nous devons faire appel à la fonction <code>dangereux</code> dans un bloc <code>unsafe</code> séparé.
Si nous essayons d'appeler <code>dangereux</code> sans le bloc <code>unsafe</code>, nous obtenons une
erreur :</p>
<!--
```console
$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 -- > src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

error: aborting due to previous error

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangereux();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

error: aborting due to previous error

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
By inserting the `unsafe` block around our call to `dangerous`, we’re asserting
to Rust that we’ve read the function’s documentation, we understand how to use
it properly, and we’ve verified that we’re fulfilling the contract of the
function.
-->
<p>En ajoutant le bloc <code>unsafe</code> autour de notre appel à <code>dangereux</code>, nous
signalons à Rust que nous avons lu la documentation de la fonction, que nous
comprenons comment l'utiliser correctement, et que nous avons vérifié que nous
répondons bien aux exigences de la fonction.</p>
<!--
Bodies of unsafe functions are effectively `unsafe` blocks, so to perform other
unsafe operations within an unsafe function, we don’t need to add another
`unsafe` block.
-->
<p>Les corps des fonctions non sécurisées sont bien des blocs <code>unsafe</code>, donc pour
pouvoir procéder à d'autres opérations non sécurisées dans une fonction non
sécurisée, nous n'avons pas besoin d'ajouter un autre bloc <code>unsafe</code>.</p>
<!--
#### Creating a Safe Abstraction over Unsafe Code
-->
<h4 id="créer-une-abstraction-sécurisée-sur-du-code-non-sécurisé"><a class="header" href="#créer-une-abstraction-sécurisée-sur-du-code-non-sécurisé">Créer une abstraction sécurisée sur du code non sécurisé</a></h4>
<!--
Just because a function contains unsafe code doesn’t mean we need to mark the
entire function as unsafe. In fact, wrapping unsafe code in a safe function is
a common abstraction. As an example, let’s study a function from the standard
library, `split_at_mut`, that requires some unsafe code and explore how we
might implement it. This safe method is defined on mutable slices: it takes one
slice and makes it two by splitting the slice at the index given as an
argument. Listing 19-4 shows how to use `split_at_mut`.
-->
<p>Ce n'est pas parce qu'une fonction contient du code non sécurisé que nous devons
forcément marquer l'intégralité de cette fonction comme non sécurisée. En fait,
envelopper du code non sécurisé dans une fonction sécurisée est une abstraction
courante. Par exemple, étudions une fonction de la bibliothèque standard,
<code>split_at_mut</code>, qui nécessite du code non sécurisé, et étudions comment nous
devrions l'implémenter. Cette méthode sécurisée est définie sur des slices
mutables : elle prend une slice en paramètre et en créée deux autres en divisant
la slice à l'indice donné en argument. L'encart 19-4 montre comment utiliser
<code>split_at_mut</code>.</p>
<!--
```rust
# fn main() {
    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &mut [1, 2, 3]);
    assert_eq!(b, &mut [4, 5, 6]);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-4: Using the safe `split_at_mut`
function</span>
-->
<p><span class="caption">Encart 19-4 : utilisation de la fonction sécurisée
<code>split_at_mut</code></span></p>
<!--
We can’t implement this function using only safe Rust. An attempt might look
something like Listing 19-5, which won’t compile. For simplicity, we’ll
implement `split_at_mut` as a function rather than a method and only for slices
of `i32` values rather than for a generic type `T`.
-->
<p>Nous ne pouvons pas implémenter cette fonction en utilisant uniquement du Rust
sécurisé. Une tentative en ce sens ressemblerait à l'encart 19-5, qui ne se
compilera pas. Par simplicité, nous allons implémenter <code>split_at_mut</code> comme une
fonction plutôt qu'une méthode et seulement pour des slices de valeurs <code>i32</code> au
lieu d'un type générique <code>T</code>.</p>
<!--
```rust,ignore,does_not_compile
fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = slice.len();

    assert!(mid <= len);

    (&mut slice[..mid], &mut slice[mid..])
}
# 
# fn main() {
#     let mut vector = vec![1, 2, 3, 4, 5, 6];
#     let (left, right) = split_at_mut(&mut vector, 3);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid], &amp;mut slice[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 19-5: An attempted implementation of
`split_at_mut` using only safe Rust</span>
-->
<p><span class="caption">Encart 19-5 : une tentative d'implémentation de
<code>split_at_mut</code> en utilisant uniquement du Rust sécurisé</span></p>
<!--
This function first gets the total length of the slice. Then it asserts that
the index given as a parameter is within the slice by checking whether it’s
less than or equal to the length. The assertion means that if we pass an index
that is greater than the length to split the slice at, the function will panic
before it attempts to use that index.
-->
<p>Cette fonction commence par obtenir la longueur totale de la slice. Elle
vérifie ensuite que l'indice donné en paramètre est bien à l'intérieur de la
slice en vérifiant s'il est inférieur ou égal à la longueur. La vérification
implique que si nous envoyons un indice qui est plus grand que la longueur de
la slice à découper, la fonction va paniquer avant d'essayer d'utiliser cet
indice.</p>
<!--
Then we return two mutable slices in a tuple: one from the start of the
original slice to the `mid` index and another from `mid` to the end of the
slice.
-->
<p>Ensuite, nous retournons deux slices mutables dans un tuple : une à partir du
début de la slice initiale jusqu'à l'indice <code>mod</code> et une autre à partir de
l'indice jusqu'à la fin de la slice.</p>
<!--
When we try to compile the code in Listing 19-5, we’ll get an error.
-->
<p>Lorsque nous essayons de compiler le code de l'encart 19-5, nous allons obtenir
une erreur.</p>
<!--
```console
$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 -- > src/main.rs:6:30
  |
1 | fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
  |                        - let's call the lifetime of this reference `'1`
...
6 |     (&mut slice[..mid], &mut slice[mid..])
  |     -------------------------^^^^^--------
  |     |     |                  |
  |     |     |                  second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*slice` is borrowed for `'1`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 --&gt; src/main.rs:6:30
  |
1 | fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                        - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut slice[..mid], &amp;mut slice[mid..])
  |     -------------------------^^^^^--------
  |     |     |                  |
  |     |     |                  second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*slice` is borrowed for `'1`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Rust’s borrow checker can’t understand that we’re borrowing different parts of
the slice; it only knows that we’re borrowing from the same slice twice.
Borrowing different parts of a slice is fundamentally okay because the two
slices aren’t overlapping, but Rust isn’t smart enough to know this. When we
know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.
-->
<p>Le vérificateur d'emprunt de Rust ne comprend pas que nous empruntons
différentes parties de la slice ; il comprend seulement que nous empruntons la
même slice à deux reprises. L'emprunt de différentes parties d'une slice ne
pose fondamentalement pas de problèmes car les deux slices ne se chevauchent
pas, mais Rust n'est pas suffisamment intelligent pour comprendre ceci. Lorsque
nous savons que ce code est correct, mais que Rust ne le sait pas, il est
approprié d'utiliser du code non sécurisé.</p>
<!--
Listing 19-6 shows how to use an `unsafe` block, a raw pointer, and some calls
to unsafe functions to make the implementation of `split_at_mut` work.
-->
<p>L'encart 19-6 montre comment utiliser un bloc <code>unsafe</code>, un pointeur brut, et
quelques appels à des fonctions non sécurisées pour construire une
implémentation de <code>split_at_mut</code> qui fonctionne.</p>
<!--
```rust,unsafe
use std::slice;

fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid <= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
# 
# fn main() {
#     let mut vector = vec![1, 2, 3, 4, 5, 6];
#     let (left, right) = split_at_mut(&mut vector, 3);
# }
```
-->
<pre><pre class="playground"><code class="language-rust unsafe">use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-6: Using unsafe code in the implementation of
the `split_at_mut` function</span>
-->
<p><span class="caption">Encart 19-6 : utilisation de code non sécurisé dans
l'implémentation de la fonction <code>split_at_mut</code></span></p>
<!--
Recall from [“The Slice Type”][the-slice-type]<!-- ignore -- > section in
Chapter 4 that slices are a pointer to some data and the length of the slice.
We use the `len` method to get the length of a slice and the `as_mut_ptr`
method to access the raw pointer of a slice. In this case, because we have a
mutable slice to `i32` values, `as_mut_ptr` returns a raw pointer with the type
`*mut i32`, which we’ve stored in the variable `ptr`.
-->
<p>Souvenez-vous de la section <a href="ch04-03-slices.html#le-type-slice">“Le type slice”</a><!-- ignore --> du
chapitre 4 dans laquelle nous avions dit qu'un slice est défini par un pointeur
vers une donnée ainsi qu'une longueur de la slice. Nous avons utilisé la méthode
<code>len</code> pour obtenir la longueur d'une slice ainsi que la méthode <code>as_mut_ptr</code>
pour accéder au pointeur brut d'une slice. Dans ce cas, comme nous avons une
slice mutable de valeurs <code>i32</code>, <code>as_mut_ptr</code> retourne un pointeur brut avec le
type <code>*mut i32</code>, que nous avons stocké dans la variable <code>ptr</code>.</p>
<!--
We keep the assertion that the `mid` index is within the slice. Then we get to
the unsafe code: the `slice::from_raw_parts_mut` function takes a raw pointer
and a length, and it creates a slice. We use this function to create a slice
that starts from `ptr` and is `mid` items long. Then we call the `add`
method on `ptr` with `mid` as an argument to get a raw pointer that starts at
`mid`, and we create a slice using that pointer and the remaining number of
items after `mid` as the length.
-->
<p>Nous avons conservé la vérification que l'indice <code>mid</code> soit dans la slice.
Ensuite, nous utilisons le code non sécurisé : la fonction
<code>slice::from_raw_parts_mut</code> prend en paramètre un pointeur brut et une longueur,
et elle créée une slice. Nous utilisons cette fonction pour créer une slice qui
débute à <code>ptr</code> et qui est long de <code>mid</code> éléments. Ensuite nous faisons appel à
la méthode <code>add</code> sur <code>ptr</code> avec <code>mid</code> en argument pour obtenir un pointeur
brut qui démarre à <code>mid</code>, et nous créons une slice qui utilise ce pointeur et
le nombre restant d'éléments après <code>mid</code> pour la longueur.</p>
<!--
The function `slice::from_raw_parts_mut` is unsafe because it takes a raw
pointer and must trust that this pointer is valid. The `add` method on raw
pointers is also unsafe, because it must trust that the offset location is also
a valid pointer. Therefore, we had to put an `unsafe` block around our calls to
`slice::from_raw_parts_mut` and `add` so we could call them. By looking at
the code and by adding the assertion that `mid` must be less than or equal to
`len`, we can tell that all the raw pointers used within the `unsafe` block
will be valid pointers to data within the slice. This is an acceptable and
appropriate use of `unsafe`.
-->
<p>La fonction <code>slice::from_raw_parts_mut</code> est non sécurisé car elle prend en
argument un pointeur brut et doit avoir confiance en la validité de ce pointeur.
La méthode <code>add</code> sur les pointeurs bruts est aussi non sécurisée, car elle
doit croire que l'emplacement décalé est aussi un pointeur valide. Voilà
pourquoi nous avons placé un bloc <code>unsafe</code> autour de nos appels à
<code>slice::from_raw_parts_mut</code> et <code>add</code> afin que nous puissions les appeler. En
analysant le code et en ayant ajouté la vérification que <code>mid</code> doit être
inférieur ou égal à <code>len</code>, nous pouvons affirmer que tous les pointeurs bruts
utilisés dans le bloc <code>unsafe</code> sont des pointeurs valides vers les données de la
slice. C'est une utilisation acceptable et appropriée de <code>unsafe</code>.</p>
<!--
Note that we don’t need to mark the resulting `split_at_mut` function as
`unsafe`, and we can call this function from safe Rust. We’ve created a safe
abstraction to the unsafe code with an implementation of the function that uses
`unsafe` code in a safe way, because it creates only valid pointers from the
data this function has access to.
-->
<p>Remarquez que nous n'avons pas eu besoin de marquer la fonction résultante
<code>split_at_mut</code> comme étant <code>unsafe</code>, et que nous pouvons faire appel à cette
fonction dans du code Rust sécurisé. Nous avons créé une abstraction sécurisée
du code non sécurisé avec une implémentation de la fonction qui utilise de
manière sécurisée du code non sécurisé, car elle créée uniquement des pointeurs
valides à partir des données dont cette fonction a accès.</p>
<!--
In contrast, the use of `slice::from_raw_parts_mut` in Listing 19-7 would
likely crash when the slice is used. This code takes an arbitrary memory
location and creates a slice 10,000 items long.
-->
<p>En contre-partie, l'utilisation de <code>slice::from_raw_parts_mut</code> dans l'encart
19-7 peut planter lorsque la slice sera utilisée. Ce code prend un emplacement
arbitraire dans la mémoire et crée un slice de 10 000 éléments.</p>
<!--
```rust,unsafe
# fn main() {
    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let slice: &[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
# }
```
-->
<pre><pre class="playground"><code class="language-rust unsafe"><span class="boring">fn main() {
</span>    use std::slice;

    let addresse = 0x01234usize;
    let r = addresse as *mut i32;

    let slice: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-7: Creating a slice from an arbitrary memory
location</span>
-->
<p><span class="caption">Encart 19-7 : création d'une slice à partir d'un
emplacement mémoire arbitraire</span></p>
<!--
We don’t own the memory at this arbitrary location, and there is no guarantee
that the slice this code creates contains valid `i32` values. Attempting to use
`slice` as though it’s a valid slice results in undefined behavior.
-->
<p>Nous ne possédons par la mémoire à cet emplacement arbitraire, et il n'y a
aucune garantie que la slice créée par ce code contient des valeurs <code>i32</code>
valides. La tentative d'utilisation <code>slice</code> sera soumis à un comportement
imprévisible même si elle est une slice valide.</p>
<!--
#### Using `extern` Functions to Call External Code
-->
<h4 id="utiliser-des-fonctions-extern-pour-faire-appel-à-du-code-externe"><a class="header" href="#utiliser-des-fonctions-extern-pour-faire-appel-à-du-code-externe">Utiliser des fonctions <code>extern</code> pour faire appel à du code externe</a></h4>
<!--
Sometimes, your Rust code might need to interact with code written in another
language. For this, Rust has a keyword, `extern`, that facilitates the creation
and use of a *Foreign Function Interface (FFI)*. An FFI is a way for a
programming language to define functions and enable a different (foreign)
programming language to call those functions.
-->
<p>Parfois, votre code Rust peut avoir besoin d'interagir avec du code écrit dans
d'autres langages. Dans ce cas, Rust propose un mot-clé, <code>extern</code>, qui facilite
la création et l'utilisation du <em>Foreign Function Interface (FFI)</em>. Le FFI est
un outil permettant à un langage de programmation de définir des fonctions et
permettre à différents langages de programmation de faire appel à ces
fonctions.</p>
<!--
Listing 19-8 demonstrates how to set up an integration with the `abs` function
from the C standard library. Functions declared within `extern` blocks are
always unsafe to call from Rust code. The reason is that other languages don’t
enforce Rust’s rules and guarantees, and Rust can’t check them, so
responsibility falls on the programmer to ensure safety.
-->
<p>L'encart 19-8 montre comment régler l'intégration avec la fonction <code>abs</code> de la
bibliothèque standard du C. Les fonctions déclarées dans les blocs <code>extern</code>
sont toujours non sécurisés lorsqu'on les utilise dans du code Rust. La raison
à cela est que les autres langages n'appliquent pas les règles et garanties de
Rust, et Rust ne peut pas les vérifier, donc la responsabilité de les utiliser
en toute sécurité revient au développeur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,unsafe
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust unsafe">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;La valeur absolue de -3 selon le langage C : {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust unsafe">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;La valeur absolue de -3 selon le langage C : {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-8: Declaring and calling an `extern` function
defined in another language</span>
-->
<p><span class="caption">Encart 19-8 : déclaration et appel à une fonction externe
qui est définie dans un autre langage</span></p>
<!--
Within the `extern "C"` block, we list the names and signatures of external
functions from another language we want to call. The `"C"` part defines which
*application binary interface (ABI)* the external function uses: the ABI
defines how to call the function at the assembly level. The `"C"` ABI is the
most common and follows the C programming language’s ABI.
-->
<p>Au sein du bloc <code>extern &quot;C&quot;</code>, nous listons les noms et les signatures des
fonctions externes de l'autre langage que nous souhaitons solliciter. La partie
&quot;C&quot; définit quelle est l'<em>application binary interface (ABI)</em> que la fonction
doit utiliser : l'ABI définit comment faire appel à la fonction au niveau
assembleur. L'ABI <code>&quot;C&quot;</code> est la plus courante et respecte l'ABI du langage de
programmation C.</p>
<!--
> #### Calling Rust Functions from Other Languages
>
> We can also use `extern` to create an interface that allows other languages
> to call Rust functions. Instead of an `extern` block, we add the `extern`
> keyword and specify the ABI to use just before the `fn` keyword. We also need
> to add a `#[no_mangle]` annotation to tell the Rust compiler not to mangle
> the name of this function. *Mangling* is when a compiler changes the name
> we’ve given a function to a different name that contains more information for
> other parts of the compilation process to consume but is less human readable.
> Every programming language compiler mangles names slightly differently, so
> for a Rust function to be nameable by other languages, we must disable the
> Rust compiler’s name mangling.
>
> In the following example, we make the `call_from_c` function accessible from
> C code, after it’s compiled to a shared library and linked from C:
>
> ```rust
> #[no_mangle]
> pub extern "C" fn call_from_c() {
>     println!("Just called a Rust function from C!");
> }
> ```
>
> This usage of `extern` does not require `unsafe`.
-->
<blockquote>
<h4 id="faire-appel-à-des-fonctions-rust-dans-dautres-langages"><a class="header" href="#faire-appel-à-des-fonctions-rust-dans-dautres-langages">Faire appel à des fonctions Rust dans d'autres langages</a></h4>
<p>Nous pouvons aussi utiliser <code>extern</code> pour créer une interface qui permet à
d'autres langages de faire appel à des fonctions Rust. Au lieu d'avoir un
bloc <code>extern</code>, nous ajoutons le mot-clé <code>extern</code> et nous renseignons l'ABI
à utiliser juste avant le mot-clé <code>fn</code>. Nous avons aussi besoin d'ajouter
l'annotation <code>#[no_mangle]</code> pour dire au compilateur Rust de ne pas déformer
le nom de cette fonction. La <em>déformation</em> s'effectue lorsqu'un compilateur
change le nom que nous avons donné à une fonction pour un nom qui contient
plus d'informations pour d'autres étapes du processus de compilation, mais
qui est moins lisible par l'humain. Tous les compilateurs de langages de
programmation déforment les noms de façon légèrement différente, donc pour
que le nom d'une fonction Rust soit utilisable par d'autres langages, nous
devons désactiver la déformation du nom par le compilateur de Rust.</p>
</blockquote>
<!--
### Accessing or Modifying a Mutable Static Variable
-->
<h3 id="lire-ou-modifier-une-variable-statique-mutable"><a class="header" href="#lire-ou-modifier-une-variable-statique-mutable">Lire ou modifier une variable statique mutable</a></h3>
<!--
Until now, we’ve not talked about *global variables*, which Rust does support
but can be problematic with Rust’s ownership rules. If two threads are
accessing the same mutable global variable, it can cause a data race.
-->
<p>Jusqu'à présent, nous n'avons pas parlé des <em>variables globales</em>, que Rust
accepte mais qui peuvent poser des problèmes avec les règles de possession de
Rust. Si deux tâches accèdent en même temps à la même variable globale, cela
peut causer un accès concurrent.</p>
<!--
In Rust, global variables are called *static* variables. Listing 19-9 shows an
example declaration and use of a static variable with a string slice as a
value.
-->
<p>En Rust, les variables globales s'appellent des variables <em>statiques</em>. L'encart
19-9 montre un exemple de déclaration et d'utilisation d'une variable statique
avec une slice de chaîne de caractères comme valeur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
static HELLO_WORLD: &str = "Hello, world!";

fn main() {
    println!("name is: {}", HELLO_WORLD);
}
```
-->
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;Cela vaut : {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-9: Defining and using an immutable static
variable</span>
-->
<p><span class="caption">Encart 19-9 : définition et utilisation d'une variable
statique immuable</span></p>
<!--
Static variables are similar to constants, which we discussed in the
[“Differences Between Variables and
Constants”][differences-between-variables-and-constants]<!-- ignore -- >
section in Chapter 3. The names of static variables are in
`SCREAMING_SNAKE_CASE` by convention, and we *must* annotate the variable’s
type, which is `&'static str` in this example. Static variables can only store
references with the `'static` lifetime, which means the Rust compiler can
figure out the lifetime; we don’t need to annotate it explicitly. Accessing an
immutable static variable is safe.
-->
<p>Les variables statiques ressemblent aux constantes, que nous avons vu dans la
section
<a href="ch03-01-variables-and-mutability.html#diff%C3%A9rences-entre-les-variables-et-les-constantes">“Différences entre les variables et les constantes”</a><!-- ignore -->
du chapitre 3. Les noms des variables statiques sont par convention en
<code>SCREAMING_SNAKE_CASE</code>, et nous <em>devons</em> obligatoirement renseigner le type de
la variable, qui est <code>&amp;'static str</code> dans cet exemple. Les variables statiques
peuvent uniquement stocker des références avec la durée de vie <code>'static</code>, ce
qui signifie que le compilateur Rust peut comprendre sa durée de vie ; nous
n'avons pas besoin de la renseigner explicitement. L'accès à une variable
statique immuable est sécurisé.</p>
<!--
Constants and immutable static variables might seem similar, but a subtle
difference is that values in a static variable have a fixed address in memory.
Using the value will always access the same data. Constants, on the other hand,
are allowed to duplicate their data whenever they’re used.
-->
<p>Les constantes et les variables statiques immuables se ressemblent, mais leur
différence subtile est que les valeurs dans les variables statiques sont une
adresse fixe en mémoire. L'utilisation de sa valeur va toujours accéder à la
même donnée. Les constantes en revanche, peuvent reproduire leurs données à
chaque fois qu'elles sont utilisées.</p>
<!--
Another difference between constants and static variables is that static
variables can be mutable. Accessing and modifying mutable static variables is
*unsafe*. Listing 19-10 shows how to declare, access, and modify a mutable
static variable named `COUNTER`.
-->
<p>Une autre différence entre les constantes et les variables statiques est que
les variables statiques peuvent être mutables. Lire et modifier des variables
statiques mutables est <em>non sécurisé</em>. L'encart 19-10 montre comment déclarer,
lire et modifier la variable statique mutable <code>COMPTEUR</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,unsafe
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust unsafe">static mut COMPTEUR: u32 = 0;

fn ajouter_au_compteur(valeur: u32) {
    unsafe {
        COMPTEUR += valeur;
    }
}

fn main() {
    ajouter_au_compteur(3);

    unsafe {
        println!(&quot;COMPTEUR : {}&quot;, COMPTEUR);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-10: Reading from or writing to a mutable
static variable is unsafe</span>
-->
<p><span class="caption">Encart 19-10 : la lecture et l'écriture d'une variable
statique mutable est non sécurisé</span></p>
<!--
As with regular variables, we specify mutability using the `mut` keyword. Any
code that reads or writes from `COUNTER` must be within an `unsafe` block. This
code compiles and prints `COUNTER: 3` as we would expect because it’s single
threaded. Having multiple threads access `COUNTER` would likely result in data
races.
-->
<p>Comme avec les variables classiques, nous renseignons la mutabilité en
utilisant le mot-clé <code>mut</code>. Tout code qui lit ou modifie <code>COMPTEUR</code> doit se
trouver dans un bloc <code>unsafe</code>. Ce code se compile et affiche <code>COMPTEUR : 3</code>
comme nous l'espérions car nous n'avons qu'une seule tâche. Si nous avions
plusieurs tâches qui accèdent à <code>COMPTEUR</code> nous pourrions avoir un accès
concurrent.</p>
<!--
With mutable data that is globally accessible, it’s difficult to ensure there
are no data races, which is why Rust considers mutable static variables to be
unsafe. Where possible, it’s preferable to use the concurrency techniques and
thread-safe smart pointers we discussed in Chapter 16 so the compiler checks
that data accessed from different threads is done safely.
-->
<p>Avec les données mutables qui sont globalement accessibles, il devient
difficile de s'assurer qu'il n'y a pas d'accès concurrent, c'est pourquoi Rust
considère les variables statiques mutables comme étant non sécurisées. Lorsque
c'est possible, il vaut mieux utiliser les techniques de concurrence et les
pointeurs intelligents adaptés au multitâche que nous avons vu au chapitre 16,
afin que le compilateur puisse vérifier que les données qu'utilisent les
différentes tâches sont sécurisées.</p>
<!--
### Implementing an Unsafe Trait
-->
<h3 id="implémenter-un-trait-non-sécurisé"><a class="header" href="#implémenter-un-trait-non-sécurisé">Implémenter un trait non sécurisé</a></h3>
<!--
The final action that works only with `unsafe` is implementing an unsafe trait.
A trait is unsafe when at least one of its methods has some invariant that the
compiler can’t verify. We can declare that a trait is `unsafe` by adding the
`unsafe` keyword before `trait` and marking the implementation of the trait as
`unsafe` too, as shown in Listing 19-11.
-->
<p>La dernière action qui fonctionne uniquement avec <code>unsafe</code> est l'implémentation
d'un trait non sécurisé. Un trait n'est pas sécurisé lorsque au moins une de ses
méthodes contient une invariante que le compilateur ne peut pas vérifier. Nous
pouvons déclarer un trait qui n'est pas sécurisé en ajoutant le mot-clé <code>unsafe</code>
devant <code>trait</code> et en marquant aussi l'implémentation du trait comme <code>unsafe</code>,
comme dans l'encart 19-11.</p>
<!--
```rust,unsafe
unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust unsafe">unsafe trait Foo {
    // les méthodes vont ici
}

unsafe impl Foo for i32 {
    // les implémentations des méthodes vont ici
}

fn main() {}
</code></pre></pre>
<!--
<span class="caption">Listing 19-11: Defining and implementing an unsafe
trait</span>
-->
<p><span class="caption">Encart 19-11 : définition et implémentation d'un trait non
sécurisé</span></p>
<!--
By using `unsafe impl`, we’re promising that we’ll uphold the invariants that
the compiler can’t verify.
-->
<p>En utilisant <code>unsafe impl</code>, nous promettons que nous veillons aux invariantes
que le compilateur ne peut pas vérifier.</p>
<!--
As an example, recall the `Sync` and `Send` marker traits we discussed in the
[“Extensible Concurrency with the `Sync` and `Send`
Traits”][extensible-concurrency-with-the-sync-and-send-traits]<!-- ignore -- >
section in Chapter 16: the compiler implements these traits automatically if
our types are composed entirely of `Send` and `Sync` types. If we implement a
type that contains a type that is not `Send` or `Sync`, such as raw pointers,
and we want to mark that type as `Send` or `Sync`, we must use `unsafe`. Rust
can’t verify that our type upholds the guarantees that it can be safely sent
across threads or accessed from multiple threads; therefore, we need to do
those checks manually and indicate as such with `unsafe`.
-->
<p>Par exemple, souvenez-vous des traits <code>Sync</code> et <code>Send</code> que nous avions découvert
dans une section du
<a href="ch16-04-extensible-concurrency-sync-and-send.html">chapitre 16</a><!-- ignore --> :
le compilateur implémente automatiquement ces traits si nos types sont
entièrement composés des types <code>Send</code> et <code>Sync</code>. Si nous implémentions un type
qui contenait un type qui n'était pas <code>Send</code> ou <code>Sync</code>, comme des pointeurs
bruts, et nous souhaitions marquer ce type comme étant <code>Send</code> ou <code>Sync</code>, nous
aurions dû utiliser <code>unsafe</code>. Rust ne peut pas vérifier que notre type respecte
les garanties pour que ce type puisse être envoyé en toute sécurité entre des
tâches ou qu'il puisse être utilisé par plusieurs tâches ; toutefois, nous avons
besoin de faire ces vérifications manuellement et les signaler avec <code>unsafe</code>.</p>
<!--
### Accessing Fields of a Union
-->
<h3 id="utiliser-des-champs-dun-union"><a class="header" href="#utiliser-des-champs-dun-union">Utiliser des champs d'un Union</a></h3>
<!--
A `union` is similar to a `struct`, but only one declared field is used in a
particular instance at one time. Unions are primarily used to interface with
unions in C code. Accessing union fields is unsafe because Rust can’t guarantee
the type of the data currently being stored in the union instance. You can
learn more about unions in [the reference][reference].
-->
<p>Un <code>union</code> ressemble à une <code>struct</code>, mais un seul champ de ceux déclarés est
utilisé dans une instance précise au même moment. Les unions sont principalement
utilisés pour s'interfacer avec les unions du code C. L'accès aux champs des
unions n'est pas sécurisé car Rust ne peut pas garantir le type de données qui
est actuellement stockée dans l'instance de l'union. Vous pouvez en apprendre
plus sur les unions dans <a href="https://doc.rust-lang.org/reference/items/unions.html">the reference</a>.</p>
<!--
### When to Use Unsafe Code
-->
<h3 id="quand-utiliser-du-code-non-sécurisé"><a class="header" href="#quand-utiliser-du-code-non-sécurisé">Quand utiliser du code non sécurisé</a></h3>
<!--
Using `unsafe` to take one of the five actions (superpowers) just discussed
isn’t wrong or even frowned upon. But it is trickier to get `unsafe` code
correct because the compiler can’t help uphold memory safety. When you have a
reason to use `unsafe` code, you can do so, and having the explicit `unsafe`
annotation makes it easier to track down the source of problems when they occur.
-->
<p>L'utilisation de <code>unsafe</code> pour s'approprier une des cinq actions (ou
super-pouvoirs) que nous venons d'aborder n'est pas une mauvaise chose et ne doit
pas être mal vu. Mais il est plus difficile de sécuriser du code <code>unsafe</code> car le
compilateur ne peut pas aider à garantir la sécurité de la mémoire. Lorsque vous
avez une bonne raison d'utiliser du code non sécurisé, vous pouvez le faire, et
vous aurez l'annotation explicite <code>unsafe</code> pour faciliter la recherche de la
source de problèmes lorsqu'ils surviennent.</p>
<!--
[dangling-references]:
ch04-02-references-and-borrowing.html#dangling-references
[differences-between-variables-and-constants]:
ch03-01-variables-and-mutability.html#differences-between-variables-and-constants
[extensible-concurrency-with-the-sync-and-send-traits]:
ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits
[the-slice-type]: ch04-03-slices.html#the-slice-type
[reference]: ../reference/items/unions.html
-->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--27"><a class="header" href="#-attention-peinture-fraîche--27">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/211">Pull Request</a>.</p>
</blockquote>
<!--
## Advanced Traits
-->
<h2 id="les-traits-avancés"><a class="header" href="#les-traits-avancés">Les traits avancés</a></h2>
<!--
We first covered traits in the [“Traits: Defining Shared
Behavior”][traits-defining-shared-behavior]<!-- ignore -- > section of Chapter
10, but as with lifetimes, we didn’t discuss the more advanced details. Now
that you know more about Rust, we can get into the nitty-gritty.
-->
<p>Nous avons vu les traits dans une section du chapitre 10, mais comme les durées
de vie, nous n'avons pas abordé certains détails. Maintenant que vous en savez
plus sur Rust, nous pouvons entrer dans le vif du sujet.</p>
<!--
### Specifying Placeholder Types in Trait Definitions with Associated Types
-->
<h3 id="placer-des-types-à-remplacer-dans-les-définitions-des-traits-grâce-aux-types-associés"><a class="header" href="#placer-des-types-à-remplacer-dans-les-définitions-des-traits-grâce-aux-types-associés">Placer des types à remplacer dans les définitions des traits grâce aux types associés</a></h3>
<!--
*Associated types* connect a type placeholder with a trait such that the trait
method definitions can use these placeholder types in their signatures. The
implementor of a trait will specify the concrete type to be used in this type’s
place for the particular implementation. That way, we can define a trait that
uses some types without needing to know exactly what those types are until the
trait is implemented.
-->
<p>Les <em>types associés</em> connectent un type à remplacer avec un trait afin que la
définition des méthodes puisse utiliser ces types à remplacer dans leur
signature. Celui qui implémente un trait doit renseigner un type concret pour
être utilisé à la place du type à remplacer pour cette implémentation précise.
Ainsi, nous pouvons définir un trait qui utilise certains types sans avoir
besoin de savoir exactement quels sont ces types jusqu'à ce que ce trait soit
implémenté.</p>
<!--
We’ve described most of the advanced features in this chapter as being rarely
needed. Associated types are somewhere in the middle: they’re used more rarely
than features explained in the rest of the book but more commonly than many of
the other features discussed in this chapter.
-->
<p>Nous avions dit que vous aurez rarement besoin de la plupart des
fonctionnalités avancées de ce chapitre. Les types associés sont un entre-deux :
ils sont utilisés plus rarement que les fonctionnalités expliquées dans le reste
de ce livre, mais on les rencontre plus fréquemment que de nombreuses
fonctionnalités de ce chapitre.</p>
<!--
One example of a trait with an associated type is the `Iterator` trait that the
standard library provides. The associated type is named `Item` and stands in
for the type of the values the type implementing the `Iterator` trait is
iterating over. In [“The `Iterator` Trait and the `next`
Method”][the-iterator-trait-and-the-next-method]<!-- ignore -- > section of
Chapter 13, we mentioned that the definition of the `Iterator` trait is as
shown in Listing 19-12.
-->
<p>Un exemple de trait avec un type associé est le trait <code>Iterator</code> que fournit la
bibliothèque standard. Le type associé <code>Item</code> permet de renseigner le type des
valeurs que le type qui implémente le trait <code>Iterator</code> parcours. Dans une
section du chapitre 13, nous avons mentionné que la définition du trait
<code>Iterator</code> ressemblait à cet encart 19-12.</p>
<!--
```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-12: The definition of the `Iterator` trait
that has an associated type `Item`</span>
-->
<p><span class="caption">Encart 19-12 : la définition du trait <code>Iterator</code> qui a un
type <code>Item</code> associé</span></p>
<!--
The type `Item` is a placeholder type, and the `next` method’s definition shows
that it will return values of type `Option<Self::Item>`. Implementors of the
`Iterator` trait will specify the concrete type for `Item`, and the `next`
method will return an `Option` containing a value of that concrete type.
-->
<p>Le type <code>Item</code> est un type à remplacer, et la définition de la méthode <code>next</code>
informe qu'elle va retourner des valeurs du type <code>Option&lt;Self::Item&gt;</code>. Ceux qui
implémenterons le trait <code>Iterator</code> devront renseigner un type concret pour
<code>Item</code>, et la méthode <code>next</code> va retourner une <code>Option</code> qui contiendra une
valeur de ce type concret.</p>
<!--
Associated types might seem like a similar concept to generics, in that the
latter allow us to define a function without specifying what types it can
handle. So why use associated types?
-->
<p>Les types associés ressemblent au même concept que les génériques, car ces
derniers nous permettent de définir une fonction sans avoir à renseigner les
types avec lesquels elle travaille. Donc pourquoi utiliser les types associés ?</p>
<!--
Let’s examine the difference between the two concepts with an example from
Chapter 13 that implements the `Iterator` trait on the `Counter` struct. In
Listing 13-21, we specified that the `Item` type was `u32`:
-->
<p>Examinons les différences entre les deux concepts grâce à un exemple du
chapitre 13 qui implémente le trait <code>Iterator</code> sur la structure <code>Compteur</code>.
Dans l'encart 13-21, nous avions renseigné que le type <code>Item</code> était <code>u32</code> :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
# struct Counter {
#     count: u32,
# }
# 
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
# 
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // --snip--
#         if self.count < 5 {
#             self.count += 1;
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
# 
# fn main() {}
```
-->
<pre><code class="language-rust ignore"><span class="boring">struct Compteur {
</span><span class="boring">    compteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Compteur {
</span><span class="boring">    fn new() -&gt; Compteur {
</span><span class="boring">        Compteur { compteur: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Compteur {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // -- partie masquée ici --
<span class="boring">        if self.compteur &lt; 5 {
</span><span class="boring">            self.compteur += 1;
</span><span class="boring">            Some(self.compteur)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
This syntax seems comparable to that of generics. So why not just define the
`Iterator` trait with generics, as shown in Listing 19-13?
-->
<p>Cette syntaxe ressemble aux génériques. Donc pourquoi uniquement définir le
trait <code>Iterator</code> avec les génériques, comme dans l'encart 19-13 ?</p>
<!--
```rust
pub trait Iterator<T> {
    fn next(&mut self) -> Option<T>;
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-13: A hypothetical definition of the
`Iterator` trait using generics</span>
-->
<p><span class="caption">Encart 19-13 : une définition hypothétique du trait
<code>Iterator</code> en utilisant des génériques</span></p>
<!--
The difference is that when using generics, as in Listing 19-13, we must
annotate the types in each implementation; because we can also implement
`Iterator<String> for Counter` or any other type, we could have multiple
implementations of `Iterator` for `Counter`. In other words, when a trait has a
generic parameter, it can be implemented for a type multiple times, changing
the concrete types of the generic type parameters each time. When we use the
`next` method on `Counter`, we would have to provide type annotations to
indicate which implementation of `Iterator` we want to use.
-->
<p>La différence est que lorsque vous utilisez les génériques, comme dans l'encart
19-13, nous devons annoter les types dans chaque implémentation ; et comme nous
pouvons aussi implémenter <code>Iterator&lt;String&gt; for Compteur</code> sur d'autres types,
nous pourrions alors avoir plusieurs implémentations de <code>Iterator</code> pour
<code>Compteur</code>. Autrement dit, lorsqu'un trait a un paramètre générique, il peut
être implémenté sur un type plusieurs fois, en changeant à chaque fois le type
concret du paramètre de type générique. Lorsque nous utilisons la méthode <code>next</code>
sur <code>Compteur</code>, nous devons appliquer une annotation de type pour indiquer
quelle implémentation de <code>Iterator</code> nous souhaitons utiliser.</p>
<!--
With associated types, we don’t need to annotate types because we can’t
implement a trait on a type multiple times. In Listing 19-12 with the
definition that uses associated types, we can only choose what the type of
`Item` will be once, because there can only be one `impl Iterator for Counter`.
We don’t have to specify that we want an iterator of `u32` values everywhere
that we call `next` on `Counter`.
-->
<p>Avec les types associés, nous n'avons pas besoin d'annoter les types car nous
n'implémentons pas un trait plusieurs fois sur un même type. Dans l'encart
19-12 qui contient la définition qui utilise les types associés, nous pouvons
uniquement choisir une seule fois quel sera le type de <code>Item</code>, car il ne peut
y avoir qu'un seul <code>impl Iterator for Compteur</code>. Nous n'avons pas eu à préciser
que nous souhaitions avoir un itérateur de valeurs <code>u32</code> à chaque fois que nous
faisons appel à <code>next</code> sur <code>Compteur</code>.</p>
<!--
### Default Generic Type Parameters and Operator Overloading
-->
<h3 id="les-paramètres-de-types-génériques-par-défaut-et-la-surcharge-dopérateur"><a class="header" href="#les-paramètres-de-types-génériques-par-défaut-et-la-surcharge-dopérateur">Les paramètres de types génériques par défaut et la surcharge d'opérateur</a></h3>
<!--
When we use generic type parameters, we can specify a default concrete type for
the generic type. This eliminates the need for implementors of the trait to
specify a concrete type if the default type works. The syntax for specifying a
default type for a generic type is `<PlaceholderType=ConcreteType>` when
declaring the generic type.
-->
<p>Lorsque nous utilisons les paramètres de types génériques, nous pouvons
renseigner un type concret par défaut pour le type générique. Cela évite de
contraindre ceux qui implémentent ce trait d'avoir à renseigner un type concret
si celui par défaut fonctionne bien. La syntaxe pour renseigner un type par
défaut pour un type générique est <code>&lt;TypeARemplacer=TypeConcret&gt;</code> lorsque nous
déclarons le type générique.</p>
<!--
A great example of a situation where this technique is useful is with operator
overloading. *Operator overloading* is customizing the behavior of an operator
(such as `+`) in particular situations.
-->
<p>Un bon exemple d'une situation pour laquelle cette technique est utile est avec
la surcharge d'opérateurs. <em>La surcharge d'opérateur</em> permet de personnaliser
le comportement d'un opérateur (comme <code>+</code>) dans des cas particuliers.</p>
<!--
Rust doesn’t allow you to create your own operators or overload arbitrary
operators. But you can overload the operations and corresponding traits listed
in `std::ops` by implementing the traits associated with the operator. For
example, in Listing 19-14 we overload the `+` operator to add two `Point`
instances together. We do this by implementing the `Add` trait on a `Point`
struct:
-->
<p>Rust ne vous permet pas de créer vos propres opérateurs ou de surcharger des
opérateurs. Mais vous pouvez surcharger les opérations et les traits listés
dans <code>std::ops</code> en implémentant les traits associés à l'opérateur. Par exemple,
dans l'encart 19-14 nous surchargeons l'opérateur <code>+</code> pour additionner ensemble
deux instances de <code>Point</code>. Nous pouvons faire cela en implémentant le trait
<code>Add</code> sur une structure <code>Point</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-14: Implementing the `Add` trait to overload
the `+` operator for `Point` instances</span>
-->
<p><span class="caption">Encart 19-14 : implémentation du trait <code>Add</code> pour
surcharger l'opérateur <code>+</code> pour les instances de <code>Point</code></span></p>
<!--
The `add` method adds the `x` values of two `Point` instances and the `y`
values of two `Point` instances to create a new `Point`. The `Add` trait has an
associated type named `Output` that determines the type returned from the `add`
method.
-->
<p>La méthode <code>add</code> ajoute les valeurs <code>x</code> de deux instances de <code>Point</code> ainsi que
les valeurs <code>y</code> de deux instances de <code>Point</code> pour créer un nouveau <code>Point</code>. Le
trait <code>Add</code> a un type associé <code>Output</code> qui détermine le type retourné pour la
méthode <code>add</code>.</p>
<!--
The default generic type in this code is within the `Add` trait. Here is its
definition:
-->
<p>Le type générique par défaut dans ce code est dans le trait <code>Add</code>. Voici sa
définition :</p>
<!--
```rust
trait Add<Rhs=Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code should look generally familiar: a trait with one method and an
associated type. The new part is `Rhs=Self`: this syntax is called *default
type parameters*. The `Rhs` generic type parameter (short for “right hand
side”) defines the type of the `rhs` parameter in the `add` method. If we don’t
specify a concrete type for `Rhs` when we implement the `Add` trait, the type
of `Rhs` will default to `Self`, which will be the type we’re implementing
`Add` on.
-->
<p>Ce code devrait vous être familier : un trait avec une méthode et un type
associé. La nouvelle partie concerne <code>Rhs=Self</code> : cette syntaxe s'appelle les
<em>paramètres de types par défaut</em>. Le paramètre de type générique <code>Rhs</code>
(c'est le raccourci de “Right Hand Side”) qui définit le type du paramètre
<code>rhs</code> dans la méthode <code>add</code>. Si nous ne renseignons pas de type concret pour
<code>Rhs</code> lorsque nous implémentons le trait <code>Add</code>, le type de <code>Rhs</code> sera par
défaut <code>Self</code>, qui sera le type sur lequel nous implémentons <code>Add</code>.</p>
<!--
When we implemented `Add` for `Point`, we used the default for `Rhs` because we
wanted to add two `Point` instances. Let’s look at an example of implementing
the `Add` trait where we want to customize the `Rhs` type rather than using the
default.
-->
<p>Lorsque nous avons implémenté <code>Add</code> sur <code>Point</code>, nous avons utilisé la valeur
par défaut de <code>Rhs</code> car nous voulions additionner deux instances de <code>Point</code>.
Voyons un exemple d'implémentation du trait <code>Add</code> dans lequel nous souhaitons
personnaliser le type <code>Rhs</code> plutôt que d'utiliser celui par défaut.</p>
<!--
We have two structs, `Millimeters` and `Meters`, holding values in different
units. We want to add values in millimeters to values in meters and have the
implementation of `Add` do the conversion correctly. We can implement `Add` for
`Millimeters` with `Meters` as the `Rhs`, as shown in Listing 19-15.
-->
<p>Nous avons deux structures, <code>Millimetres</code> et <code>Metres</code>, qui stockent des valeurs
dans différentes unités. Nous voulons pouvoir additionner les valeurs en
millimètres avec les valeurs en mètres et appliquer l'implémentation de <code>Add</code>
pour pouvoir faire la conversion correctement. Nous pouvons implémenter <code>Add</code>
sur <code>Millimetres</code> avec <code>Metres</code> comme étant le <code>Rhs</code>, comme dans l'encart 19-15.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;

struct Milimetres(u32);
struct Metres(u32);

impl Add&lt;Metres&gt; for Milimetres {
    type Output = Milimetres;

    fn add(self, other: Metres) -&gt; Milimetres {
        Milimetres(self.0 + (other.0 * 1000))
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-15: Implementing the `Add` trait on
`Millimeters` to add `Millimeters` to `Meters`</span>
-->
<p><span class="caption">Encart 19-15 : implémentation du trait <code>Add</code> sur
<code>Milimetres</code> pour pouvoir addition <code>Milimetres</code> à <code>Metres</code></span></p>
<!--
To add `Millimeters` and `Meters`, we specify `impl Add<Meters>` to set the
value of the `Rhs` type parameter instead of using the default of `Self`.
-->
<p>Pour additionner <code>Milimetres</code> et <code>Metres</code>, nous renseignons
<code>impl Add&lt;Metres&gt;</code> pour régler la valeur du paramètre de type <code>Rhs</code> au lieu
d'utiliser la valeur par défaut <code>Self</code>.</p>
<!--
You’ll use default type parameters in two main ways:
-->
<p>Vous utiliserez les paramètres de types par défaut dans deux principaux cas :</p>
<!--
* To extend a type without breaking existing code
* To allow customization in specific cases most users won’t need
-->
<ul>
<li>Pour étendre un type sans casser le code existant</li>
<li>Pour permettre la personnalisation dans des cas spécifiques que la plupart
des utilisateurs n'auront pas</li>
</ul>
<!--
The standard library’s `Add` trait is an example of the second purpose:
usually, you’ll add two like types, but the `Add` trait provides the ability to
customize beyond that. Using a default type parameter in the `Add` trait
definition means you don’t have to specify the extra parameter most of the
time. In other words, a bit of implementation boilerplate isn’t needed, making
it easier to use the trait.
-->
<p>Le trait <code>Add</code> de la bibliothèque standard est un exemple du second cas :
généralement, vous additionnez deux types similaires, mais le trait <code>Add</code> offre
la possibilité de personnaliser cela. L'utilisation d'un paramètre de type par
défaut dans la définition du trait <code>Add</code> signifie que vous n'aurez pas à
renseigner de paramètre en plus la plupart du temps. Autrement dit, il n'est
pas nécessaire d'avoir recours à des assemblages de code, ce qui facilite
l'utilisation du trait.</p>
<!--
The first purpose is similar to the second but in reverse: if you want to add a
type parameter to an existing trait, you can give it a default to allow
extension of the functionality of the trait without breaking the existing
implementation code.
-->
<p>Le premier cas est similaire au second mais dans le cas inverse : si vous
souhaitez ajouter un paramètre de type à un trait existant, vous pouvez lui en
donner un par défaut pour permettre l'ajout des fonctionnalités du trait sans
casser l'implémentation actuelle du code.</p>
<!--
### Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name
-->
<h3 id="la-syntaxe-totalement-définie-pour-clarifier-les-appels-à-des-méthodes-qui-ont-le-même-nom"><a class="header" href="#la-syntaxe-totalement-définie-pour-clarifier-les-appels-à-des-méthodes-qui-ont-le-même-nom">La syntaxe totalement définie pour clarifier les appels à des méthodes qui ont le même nom</a></h3>
<!--
Nothing in Rust prevents a trait from having a method with the same name as
another trait’s method, nor does Rust prevent you from implementing both traits
on one type. It’s also possible to implement a method directly on the type with
the same name as methods from traits.
-->
<p>Il n'y a rien en Rust qui évite qu'un trait d'avoir une méthode avec le même
nom qu'une autre méthode d'un autre trait, ni de vous empêcher d'implémenter
d'implémenter ces deux traits sur un même type. Il est aussi possible
d'implémenter directement une méthode avec le même nom que celle présente dans
les traits sur ce type.</p>
<!--
When calling methods with the same name, you’ll need to tell Rust which one you
want to use. Consider the code in Listing 19-16 where we’ve defined two traits,
`Pilot` and `Wizard`, that both have a method called `fly`. We then implement
both traits on a type `Human` that already has a method named `fly` implemented
on it. Each `fly` method does something different.
-->
<p>Lorsque nous faisons appel à des méthodes qui ont un conflit de nom, vous devez
préciser à Rust précisément celui que vous souhaitez utiliser. Imaginons le
code dans l'encart 19-16 dans lequel nous avons défini deux traits, <code>Pilote</code> et
<code>Magicien</code>, qui ont tous les deux une méthode <code>voler</code>. Lorsque nous
implémentons les deux traits sur un type <code>Humain</code> qui a déjà une méthode
<code>voler</code> qui lui a été implémenté. Chaque méthode <code>voler</code> fait quelque chose de
différent.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&self) {
        println!("*waving arms furiously*");
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">trait Pilote {
    fn voler(&amp;self);
}

trait Magicien {
    fn voler(&amp;self);
}

struct Humain;

impl Pilote for Humain {
    fn voler(&amp;self) {
        println!(&quot;Ici le capitaine qui vous parle.&quot;);
    }
}

impl Magicien for Humain {
    fn voler(&amp;self) {
        println!(&quot;Décolage !&quot;);
    }
}

impl Humain {
    fn voler(&amp;self) {
        println!(&quot;*agite frénétiquement ses bras*&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-16: Two traits are defined to have a `fly`
method and are implemented on the `Human` type, and a `fly` method is
implemented on `Human` directly</span>
-->
<p><span class="caption">Encart 19-16 : deux traits qui ont une méthode <code>voler</code>
et qui sont implémentés sur le type <code>Humain</code>, et une méthode <code>voler</code> est aussi
implémentée directement sur <code>Humain</code></span></p>
<!--
When we call `fly` on an instance of `Human`, the compiler defaults to calling
the method that is directly implemented on the type, as shown in Listing 19-17.
-->
<p>Lorsque nous utilisons <code>voler</code> sur une instance de <code>Humain</code>, le compilateur
fait appel par défaut à la méthode qui est directement implémentée sur le type,
comme le montre l'encart 19-17.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# trait Pilot {
#     fn fly(&self);
# }
# 
# trait Wizard {
#     fn fly(&self);
# }
# 
# struct Human;
# 
# impl Pilot for Human {
#     fn fly(&self) {
#         println!("This is your captain speaking.");
#     }
# }
# 
# impl Wizard for Human {
#     fn fly(&self) {
#         println!("Up!");
#     }
# }
# 
# impl Human {
#     fn fly(&self) {
#         println!("*waving arms furiously*");
#     }
# }
# 
fn main() {
    let person = Human;
    person.fly();
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilote {
</span><span class="boring">    fn voler(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Magicien {
</span><span class="boring">    fn voler(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Humain;
</span><span class="boring">
</span><span class="boring">impl Pilote for Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;Ici le capitaine qui vous parle.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Magicien for Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;Décolage !&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;*agite frénétiquement ses bras*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let une_personne = Humain;
    une_personne.voler();
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-17: Calling `fly` on an instance of
`Human`</span>
-->
<p><span class="caption">Encart 19-17 : utilisation de <code>voler</code> sur une instance de
<code>Humain</code></span></p>
<!--
Running this code will print `*waving arms furiously*`, showing that Rust
called the `fly` method implemented on `Human` directly.
-->
<p>L'exécution de ce code va afficher <code>*agite frénétiquement ses bras*</code>, ce qui
démontre que Rust a appelé la méthode <code>voler</code> implémentée directement sur
<code>Humain</code>.</p>
<!--
To call the `fly` methods from either the `Pilot` trait or the `Wizard` trait,
we need to use more explicit syntax to specify which `fly` method we mean.
Listing 19-18 demonstrates this syntax.
-->
<p>Pour faire appel aux méthodes <code>voler</code> des traits <code>Pilote</code> ou <code>Magicien</code>, nous
devons utiliser une syntaxe plus explicite pour préciser quelle méthode <code>voler</code>
nous souhaitons utiliser. L'encart 19-18 montre cette syntaxe.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# trait Pilot {
#     fn fly(&self);
# }
# 
# trait Wizard {
#     fn fly(&self);
# }
# 
# struct Human;
# 
# impl Pilot for Human {
#     fn fly(&self) {
#         println!("This is your captain speaking.");
#     }
# }
# 
# impl Wizard for Human {
#     fn fly(&self) {
#         println!("Up!");
#     }
# }
# 
# impl Human {
#     fn fly(&self) {
#         println!("*waving arms furiously*");
#     }
# }
# 
fn main() {
    let person = Human;
    Pilot::fly(&person);
    Wizard::fly(&person);
    person.fly();
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilote {
</span><span class="boring">    fn voler(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Magicien {
</span><span class="boring">    fn voler(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Humain;
</span><span class="boring">
</span><span class="boring">impl Pilote for Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;Ici le capitaine qui vous parle.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Magicien for Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;Décolage !&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Humain {
</span><span class="boring">    fn voler(&amp;self) {
</span><span class="boring">        println!(&quot;*agite frénétiquement ses bras*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let une_personne = Humain;
    Pilote::voler(&amp;une_personne);
    Magicien::voler(&amp;une_personne);
    une_personne.voler();
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-18: Specifying which trait’s `fly` method we
want to call</span>
-->
<p><span class="caption">Encart 19-18 : préciser quelle méthode <code>voler</code> de quel
trait nous souhaitons utiliser</span></p>
<!--
Specifying the trait name before the method name clarifies to Rust which
implementation of `fly` we want to call. We could also write
`Human::fly(&person)`, which is equivalent to the `person.fly()` that we used
in Listing 19-18, but this is a bit longer to write if we don’t need to
disambiguate.
-->
<p>Si on renseigne le nom du trait avant le nom de la méthode, cela indique à Rust
quelle implémentation de <code>voler</code> nous souhaitons utiliser. Nous pouvons aussi
écrire <code>Humain::voler(&amp;une_personne)</code>, qui est équivalent à
<code>une_personne.voler()</code> que nous avons utilisé dans l'encart 19-18, mais c'est
un peu plus long à écrire si nous n'avons pas besoin de préciser les choses.</p>
<!--
Running this code prints the following:
-->
<p>L'exécution de ce code affiche ceci :</p>
<!--
```console
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
```
-->
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
Ici le capitaine qui vous parle.
Décolage !
*agite frénétiquement ses bras*
</code></pre>
<!--
Because the `fly` method takes a `self` parameter, if we had two *types* that
both implement one *trait*, Rust could figure out which implementation of a
trait to use based on the type of `self`.
-->
<p>Comme la méthode <code>voler</code> prends un paramètre <code>self</code>, si nous avions deux
<em>types</em> qui implémentaient chacun un des deux <em>traits</em>, Rust pourrait en
déduire quelle implémentation de quel trait à utiliser en fonction du type
de <code>self</code>.</p>
<!--
However, associated functions that are part of traits don’t have a `self`
parameter. When two types in the same scope implement that trait, Rust can’t
figure out which type you mean unless you use *fully qualified syntax*. For
example, the `Animal` trait in Listing 19-19 has the associated function
`baby_name`, the implementation of `Animal` for the struct `Dog`, and the
associated function `baby_name` defined on `Dog` directly.
-->
<p>Cependant, les fonctions associées qui font partie des traits n'ont pas de
paramètre <code>self</code>. Lorsque deux types de la même portée implémentent ce trait,
Rust ne peut pas en déduire quel type vous sous-entendez jusqu'à ce que vous
utilisiez la <em>syntaxe totalement définie</em>. Par exemple, le trait <code>Animal</code> de
l'encart 19-19 a une fonction associée <code>nom_bebe</code>, l'implémentation de
<code>Animal</code> sur la structure <code>Chien</code>, et la fonction associée <code>nom_bebe</code> définie
directement sur <code>Chien</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
}
```
-->
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn nom_bebe() -&gt; String;
}

struct Chien;

impl Chien {
    fn nom_bebe() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Chien {
    fn nom_bebe() -&gt; String {
        String::from(&quot;chiot&quot;)
    }
}

fn main() {
    println!(&quot;Un bébé chien s'appelle un {}&quot;, Chien::nom_bebe());
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-19: A trait with an associated function and a
type with an associated function of the same name that also implements the
trait</span>
-->
<p><span class="caption">Encart 19-19 : un trait avec une fonction associée et un
type avec une autre fonction associée qui porte le même nom et qui implémente
aussi ce trait</span></p>
<!--
This code is for an animal shelter that wants to name all puppies Spot, which
is implemented in the `baby_name` associated function that is defined on `Dog`.
The `Dog` type also implements the trait `Animal`, which describes
characteristics that all animals have. Baby dogs are called puppies, and that
is expressed in the implementation of the `Animal` trait on `Dog` in the
`baby_name` function associated with the `Animal` trait.
-->
<p>Ce code a été conçu pour un refuge à animaux qui souhaite que tous leurs chiots
soient nommés Spot, ce qui est implémenté dans la fonction associée <code>nom_bebe</code>
de <code>Chien</code>. Le type <code>Chien</code> implémente lui aussi le trait <code>Animal</code>, qui décrit
les caractéristiques que tous les animaux doivent avoir. Les bébés chiens
doivent s'appeler des chiots, et ceci est exprimé dans l'implémentation du
trait <code>Animal</code> sur <code>Chien</code> dans la fonction <code>nom_bebe</code> associée au trait
<code>Animal</code>.</p>
<!--
In `main`, we call the `Dog::baby_name` function, which calls the associated
function defined on `Dog` directly. This code prints the following:
-->
<p>Dans le <code>main</code>, nous faisons appel à la fonction <code>Chien::nom_bebe</code>, qui fait
appel à la fonction associée directement définie sur <code>Chien</code>. Ce code affiche
ceci :</p>
<!--
```console
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
```
-->
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
</code></pre>
<!--
This output isn’t what we wanted. We want to call the `baby_name` function that
is part of the `Animal` trait that we implemented on `Dog` so the code prints
`A baby dog is called a puppy`. The technique of specifying the trait name that
we used in Listing 19-18 doesn’t help here; if we change `main` to the code in
Listing 19-20, we’ll get a compilation error.
-->
<p>Ce résultat n'est pas celui que nous souhaitons. Nous voulons appeler la
fonction <code>nom_bebe</code> qui fait partie du trait <code>Animal</code> que nous avons implémenté
sur <code>Chien</code> afin que le code affiche <code>Un bébé chien s'appelle un chiot</code>. La
technique pour préciser le nom du trait que nous avons utilisé ne va pas nous
aider ici ; si nous changeons le <code>main</code> par le code de l'encart 19-20, nous
allons avoir une erreur de compilation.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# trait Animal {
#     fn baby_name() -> String;
# }
# 
# struct Dog;
# 
# impl Dog {
#     fn baby_name() -> String {
#         String::from("Spot")
#     }
# }
# 
# impl Animal for Dog {
#     fn baby_name() -> String {
#         String::from("puppy")
#     }
# }
# 
fn main() {
    println!("A baby dog is called a {}", Animal::baby_name());
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn nom_bebe() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Chien;
</span><span class="boring">
</span><span class="boring">impl Chien {
</span><span class="boring">    fn nom_bebe() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Chien {
</span><span class="boring">    fn nom_bebe() -&gt; String {
</span><span class="boring">        String::from(&quot;chiot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;Un bébé chien s'appelle un {}&quot;, Animal::nom_bebe());
}
</code></pre>
<!--
<span class="caption">Listing 19-20: Attempting to call the `baby_name`
function from the `Animal` trait, but Rust doesn’t know which implementation to
use</span>
-->
<p><span class="caption">Encart 19-20 : tentative d'appel à la fonction <code>nom_bebe</code>
du trait <code>Animal</code>, mais Rust ne sait pas quelle implémentation utiliser</span></p>
<!--
Because `Animal::baby_name` is an associated function rather than a method, and
thus doesn’t have a `self` parameter, Rust can’t figure out which
implementation of `Animal::baby_name` we want. We’ll get this compiler error:
-->
<p>Comme <code>Animal::nom_bebe</code> est une fonction associée plutôt qu'une méthode, et
qu'elle n'a pas de paramètre <code>self</code>, Rust ne peut pas savoir quelle
implémentation de <code>Animal::nom_bebe</code> nous souhaitons utiliser. Nous obtenons
alors cette erreur de compilation :</p>
<!--
```console
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0283]: type annotations needed
  -- > src/main.rs:20:43
   |
2  |     fn baby_name() -> String;
   |     ------------------------- required by `Animal::baby_name`
...
20 |     println!("A baby dog is called a {}", Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^ cannot infer type
   |
   = note: cannot resolve `_: Animal`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0283`.
error: could not compile `traits-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0283]: type annotations needed
  --&gt; src/main.rs:20:43
   |
2  |     fn nom_bebe() -&gt; String;
   |     ------------------------ required by `Animal::nom_bebe`
...
20 |     println!(&quot;Un bébé chien s'appelle un {}&quot;, Animal::nom_bebe());
   |                                               ^^^^^^^^^^^^^^^^ cannot infer type
   |
   = note: cannot resolve `_: Animal`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0283`.
error: could not compile `traits-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
To disambiguate and tell Rust that we want to use the implementation of
`Animal` for `Dog`, we need to use fully qualified syntax. Listing 19-21
demonstrates how to use fully qualified syntax.
-->
<p>Pour expliquer à Rust que nous souhaitons utiliser l'implémentation de <code>Animal</code>
pour <code>Chien</code>, nous devons utiliser la syntaxe totalement définie. L'encart
19-21 montre comment utiliser la syntaxe totalement définie.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# trait Animal {
#     fn baby_name() -> String;
# }
# 
# struct Dog;
# 
# impl Dog {
#     fn baby_name() -> String {
#         String::from("Spot")
#     }
# }
# 
# impl Animal for Dog {
#     fn baby_name() -> String {
#         String::from("puppy")
#     }
# }
# 
fn main() {
    println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn nom_bebe() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Chien;
</span><span class="boring">
</span><span class="boring">impl Chien {
</span><span class="boring">    fn nom_bebe() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Chien {
</span><span class="boring">    fn nom_bebe() -&gt; String {
</span><span class="boring">        String::from(&quot;chiot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;Un bébé chien s'appelle un {}&quot;, &lt;Chien as Animal&gt;::nom_bebe());
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-21: Using fully qualified syntax to specify
that we want to call the `baby_name` function from the `Animal` trait as
implemented on `Dog`</span>
-->
<p><span class="caption">Encart 19-21 : utilisation de la syntaxe totalement
définie pour préciser que nous souhaitons appeler la fonction <code>nom_bebe</code> du
trait <code>Animal</code> comme il est implémenté sur <code>Chien</code></span></p>
<!--
We’re providing Rust with a type annotation within the angle brackets, which
indicates we want to call the `baby_name` method from the `Animal` trait as
implemented on `Dog` by saying that we want to treat the `Dog` type as an
`Animal` for this function call. This code will now print what we want:
-->
<p>Nous avons donné à Rust une annotation de type entre des chevrons, ce qui
indique que nous souhaitons appeler la méthode <code>nom_bebe</code> du trait <code>Animal</code>
comme elle est implémentée sur <code>Chien</code> en indiquant que nous souhaitons traiter
le type <code>Chien</code> comme étant un <code>Animal</code> pour cet appel de fonction. Ce code va
désormais afficher ce que nous souhaitons :</p>
<!--
```console
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
```
-->
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
Un bébé chien s'appelle un chiot
</code></pre>
<!--
In general, fully qualified syntax is defined as follows:
-->
<p>De manière générale, une syntaxe totalement définie est définie comme ceci :</p>
<!--
```rust,ignore
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```
-->
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(destinataire_si_methode, argument_suivant, ...);
</code></pre>
<!--
For associated functions, there would not be a `receiver`: there would only be
the list of other arguments. You could use fully qualified syntax everywhere
that you call functions or methods. However, you’re allowed to omit any part of
this syntax that Rust can figure out from other information in the program. You
only need to use this more verbose syntax in cases where there are multiple
implementations that use the same name and Rust needs help to identify which
implementation you want to call.
-->
<p>Pour les fonctions associées, il n'y a pas de <code>destinataire</code> : il n'y a qu'une
liste d'arguments. Vous pouvez utiliser la syntaxe totalement définie n'importe
où vous faites appel à des fonctions ou des méthodes. Cependant, vous pouvez
éviter de renseigner n'importe quelle partie de cette syntaxe que Rust peut en
déduire à partir d'autres informations présentes dans le code. Vous avez
seulement besoin d'utiliser cette syntaxe plus verbeuse dans les cas où il y a
plusieurs implémentations qui utilisent le même nom et que Rust doit être aidé
pour identifier quelle implémentation vous souhaitez appeler.</p>
<!--
### Using Supertraits to Require One Trait’s Functionality Within Another Trait
-->
<h3 id="utiliser-les-supertraits-pour-utiliser-la-fonctionnalité-dun-trait-dans-un-autre-trait"><a class="header" href="#utiliser-les-supertraits-pour-utiliser-la-fonctionnalité-dun-trait-dans-un-autre-trait">Utiliser les supertraits pour utiliser la fonctionnalité d'un trait dans un autre trait</a></h3>
<!--
Sometimes, you might need one trait to use another trait’s functionality. In
this case, you need to rely on the dependent trait also being implemented.
The trait you rely on is a *supertrait* of the trait you’re implementing.
-->
<p>Des fois, vous pourriez avoir besoin d'un trait pour utiliser une autre
fonctionnalité d'un trait. Dans ce cas, vous devez pouvoir compter sur le fait
que le trait dépendant soit bien implémenté. Le trait sur lequel vous comptez
est alors un <em>supertrait</em> du trait que vous implémentez.</p>
<!--
For example, let’s say we want to make an `OutlinePrint` trait with an
`outline_print` method that will print a value framed in asterisks. That is,
given a `Point` struct that implements `Display` to result in `(x, y)`, when we
call `outline_print` on a `Point` instance that has `1` for `x` and `3` for
`y`, it should print the following:
-->
<p>Par exemple, imaginons que nous souhaitons créer un trait <code>OutlinePrint</code> qui
offre une méthode <code>outline_print</code> affiche une valeur entourée d'astérisques.
Pour une structure <code>Point</code> qui implémente <code>Display</code> pour afficher <code>(x, y)</code>,
lorsque nous faisons appel à <code>outline_print</code> sur une instance de <code>Point</code> qui a
<code>1</code> pour valeur de <code>x</code> et <code>3</code> pour <code>y</code>, cela devrait afficher ceci :</p>
<!--
```text
**********
*        *
* (1, 3) *
*        *
**********
```
-->
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<!--
In the implementation of `outline_print`, we want to use the `Display` trait’s
functionality. Therefore, we need to specify that the `OutlinePrint` trait will
work only for types that also implement `Display` and provide the functionality
that `OutlinePrint` needs. We can do that in the trait definition by specifying
`OutlinePrint: Display`. This technique is similar to adding a trait bound to
the trait. Listing 19-22 shows an implementation of the `OutlinePrint` trait.
-->
<p>Dans l'implémentation de <code>outline_print</code>, nous souhaitons utiliser la
fonctionnalité du trait <code>Display</code>. Toutefois, nous devons renseigner que le
trait <code>OutlinePrint</code> fonctionnera uniquement pour les types qui auront aussi
implémenté <code>Display</code> et qui fourniront la fonctionnalité dont a besoin
<code>OutlinePrint</code>. Nous pouvons faire ceci dans la définition du trait en
renseignant <code>OutlinePrint: Display</code>. Cette technique ressemble à l'ajout d'un
trait lié au trait. L'encart 19-22 montre une implémentation du trait
<code>OutlinePrint</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let valeur = self.to_string();
        let largeur = valeur.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
        println!(&quot;* {} *&quot;, valeur);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-22: Implementing the `OutlinePrint` trait that
requires the functionality from `Display`</span>
-->
<p><span class="caption">Encart 19-22 : implémentation du trait <code>OutlinePrint</code> qui
nécessite la fonctionnalité offerte par <code>Display</code></span></p>
<!--
Because we’ve specified that `OutlinePrint` requires the `Display` trait, we
can use the `to_string` function that is automatically implemented for any type
that implements `Display`. If we tried to use `to_string` without adding a
colon and specifying the `Display` trait after the trait name, we’d get an
error saying that no method named `to_string` was found for the type `&Self` in
the current scope.
-->
<p>Comme nous avons précisé que <code>OutlinePrint</code> nécessite le trait <code>Display</code>, nous
pouvons utiliser la fonction <code>to_string</code> qui est automatiquement implémentée
pour n'importe quel type qui implémente <code>Display</code>. Si nous avions essayé
d'utiliser <code>to_string</code> sans ajouter un double-point et en renseignant le trait
<code>Display</code> après le nom du trait, nous obtiendrons alors une erreur qui nous
informerait qu'il n'y a pas de méthode <code>to_string</code> pour le type <code>&amp;Self</code> dans la
portée courante.</p>
<!--
Let’s see what happens when we try to implement `OutlinePrint` on a type that
doesn’t implement `Display`, such as the `Point` struct:
-->
<p>Voyons ce qui ce passe lorsque nous essayons d'implémenter <code>OutlinePrint</code> sur
un type qui n'implémente pas <code>Display</code>, comme la structure <code>Point</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::fmt;
# 
# trait OutlinePrint: fmt::Display {
#     fn outline_print(&self) {
#         let output = self.to_string();
#         let len = output.len();
#         println!("{}", "*".repeat(len + 4));
#         println!("*{}*", " ".repeat(len + 2));
#         println!("* {} *", output);
#         println!("*{}*", " ".repeat(len + 2));
#         println!("{}", "*".repeat(len + 4));
#     }
# }
# 
struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
# 
# fn main() {
#     let p = Point { x: 1, y: 3 };
#     p.outline_print();
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let valeur = self.to_string();
</span><span class="boring">        let largeur = valeur.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, valeur);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}
</span></code></pre>
<!--
We get an error saying that `Display` is required but not implemented:
-->
<p>Nous obtenons une erreur qui dit que <code>Display</code> est nécessaire mais n'est pas
implémenté :</p>
<!--
```console
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  -- > src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
To fix this, we implement `Display` on `Point` and satisfy the constraint that
`OutlinePrint` requires, like so:
-->
<p>Pour régler cela, nous implémentons <code>Display</code> sur <code>Point</code> afin de répondre aux
besoins de <code>OutlinePrint</code>, comme ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# trait OutlinePrint: fmt::Display {
#     fn outline_print(&self) {
#         let output = self.to_string();
#         let len = output.len();
#         println!("{}", "*".repeat(len + 4));
#         println!("*{}*", " ".repeat(len + 2));
#         println!("* {} *", output);
#         println!("*{}*", " ".repeat(len + 2));
#         println!("{}", "*".repeat(len + 4));
#     }
# }
# 
# struct Point {
#     x: i32,
#     y: i32,
# }
# 
# impl OutlinePrint for Point {}
# 
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
# 
# fn main() {
#     let p = Point { x: 1, y: 3 };
#     p.outline_print();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let valeur = self.to_string();
</span><span class="boring">        let largeur = valeur.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, valeur);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(largeur + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(largeur + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}
</span></code></pre></pre>
<!--
Then implementing the `OutlinePrint` trait on `Point` will compile
successfully, and we can call `outline_print` on a `Point` instance to display
it within an outline of asterisks.
-->
<p>Suite à cela, l'implémentation du trait <code>OutlinePrint</code> sur <code>Point</code> va se
compiler avec succès, et nous pourrons appeler <code>outline_print</code> sur une instance
de <code>Point</code> pour l'afficher dans le cadre constitué d'astérisques.</p>
<!--
### Using the Newtype Pattern to Implement External Traits on External Types
-->
<h3 id="utiliser-le-motif-newtype-pour-implémenter-des-traits-externes-sur-des-types-externes"><a class="header" href="#utiliser-le-motif-newtype-pour-implémenter-des-traits-externes-sur-des-types-externes">Utiliser le motif newtype pour implémenter des traits externes sur des types externes</a></h3>
<!--
In Chapter 10 in the [“Implementing a Trait on a
Type”][implementing-a-trait-on-a-type]<!-- ignore -- > section, we mentioned
the orphan rule that states we’re allowed to implement a trait on a type as
long as either the trait or the type are local to our crate. It’s possible to
get around this restriction using the *newtype pattern*, which involves
creating a new type in a tuple struct. (We covered tuple structs in the
[“Using Tuple Structs without Named Fields to Create Different
Types”][tuple-structs]<!-- ignore -- > section of Chapter 5.) The tuple struct
will have one field and be a thin wrapper around the type we want to implement
a trait for. Then the wrapper type is local to our crate, and we can implement
the trait on the wrapper. *Newtype* is a term that originates from the Haskell
programming language. There is no runtime performance penalty for using this
pattern, and the wrapper type is elided at compile time.
-->
<p>Dans <a href="ch10-02-traits.html">une section</a><!-- ignore --> du chapitre
10, nous avions mentionné la règle de l'orphelin qui énonçait que nous pouvions
implémenter un trait sur un type à condition tant que le trait ou le type soit
local à notre crate. Il est possible de contourner cette restriction en
utilisant le <em>motif newtype</em>, ce qui implique de créer un nouveau type dans une
structure tuple (nous avons vu les structures tuple dans la section
<a href="ch05-01-defining-structs.html#utilisation-de-structures-tuples-sans-champ-nomm%C3%A9-pour-cr%C3%A9er-des-types-diff%C3%A9rents">“Utilisation de structures tuples sans champ nommé pour créer des types différents”</a><!-- ignore -->
du chapitre 5). La structure tuple aura un champ et sera une petite enveloppe
pour le type sur lequel nous souhaitons implémenter le trait. Ensuite, le type
enveloppant est local à notre crate, et nous pouvons lui implémenter un trait.
<em>Newtype</em> est un terme qui provient du langage de programmation Haskell. Il n'y
a pas de conséquence sur les performance à l'exécution pour l'utilisation de ce
motif, et le type enveloppant est résolu à la compilation.</p>
<!--
As an example, let’s say we want to implement `Display` on `Vec<T>`, which the
orphan rule prevents us from doing directly because the `Display` trait and the
`Vec<T>` type are defined outside our crate. We can make a `Wrapper` struct
that holds an instance of `Vec<T>`; then we can implement `Display` on
`Wrapper` and use the `Vec<T>` value, as shown in Listing 19-23.
-->
<p>Comme exemple, disons que nous souhaitons implémenter <code>Display</code> sur <code>Vec&lt;T&gt;</code>, ce
que la règle de l'orphelin nous empêche directement de faire car le trait
<code>Display</code> et le type <code>Vec&lt;T&gt;</code> sont définis en dehors de notre crate. Nous
pouvons construire une structure <code>Enveloppe</code> qui possède une instance de
<code>Vec&lt;T&gt;</code> ; et ensuite nous pouvons implémenter <code>Display</code> sur <code>Enveloppe</code> et
utiliser la valeur <code>Vec&lt;T&gt;</code>, comme dans l'encart 19-23.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Enveloppe(Vec&lt;String&gt;);

impl fmt::Display for Enveloppe {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Enveloppe(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-23: Creating a `Wrapper` type around
`Vec<String>` to implement `Display`</span>
-->
<p><span class="caption">Encart 19-23 : création d'un type <code>Enveloppe</code> autour de
<code>Vec&lt;String&gt;</code> pour implémenter <code>Display</code></span></p>
<!--
The implementation of `Display` uses `self.0` to access the inner `Vec<T>`,
because `Wrapper` is a tuple struct and `Vec<T>` is the item at index 0 in the
tuple. Then we can use the functionality of the `Display` type on `Wrapper`.
-->
<p>L'implémentation de <code>Display</code> utilise <code>self.0</code> pour accéder à la valeur de
<code>Vec&lt;T&gt;</code>, car <code>Enveloppe</code> est une structure tuple et <code>Vec&lt;T&gt;</code> est l'élément à
l'indice 0 du tuple. Ensuite, nous pouvons utiliser la fonctionnalité du type
<code>Display</code> sur <code>Enveloppe</code>.</p>
<!--
The downside of using this technique is that `Wrapper` is a new type, so it
doesn’t have the methods of the value it’s holding. We would have to implement
all the methods of `Vec<T>` directly on `Wrapper` such that the methods
delegate to `self.0`, which would allow us to treat `Wrapper` exactly like a
`Vec<T>`. If we wanted the new type to have every method the inner type has,
implementing the `Deref` trait (discussed in Chapter 15 in the [“Treating Smart
Pointers Like Regular References with the `Deref`
Trait”][smart-pointer-deref]<!-- ignore -- > section) on the `Wrapper` to return
the inner type would be a solution. If we don’t want the `Wrapper` type to have
all the methods of the inner type—for example, to restrict the `Wrapper` type’s
behavior—we would have to implement just the methods we do want manually.
-->
<p>Le désavantage d'utiliser cette technique est que <code>Enveloppe</code> est un nouveau
type, dont il n'implémente pas toutes les méthodes de la valeur qu'il possède.
Il faudrait implémenter toutes les méthodes de <code>Vec&lt;T&gt;</code> directement sur
<code>Enveloppe</code> afin que les méthodes délèguent à <code>self.0</code>, ce qui nous permettrait
d'utiliser <code>Enveloppe</code> exactement comme un <code>Vec&lt;T&gt;</code>. Si nous voulions que le
nouveau type ait toutes les méthodes du type qu'il possède, l'implémentation du
trait <code>Deref</code> (que nous avons vu dans
<a href="ch15-02-deref.html">une section du chapitre 15</a><!-- ignore -->) sur
<code>Enveloppe</code> pour retourner le type interne pourrait être une solution. Si nous
ne souhaitons pas que le type <code>Enveloppe</code> ait toutes les méthodes du type qu'il
possède (par exemple, pour limiter les fonctionnalités du type <code>Enveloppe</code>),
nous devrions implémenter manuellement que les méthodes que nous souhaitons.</p>
<!--
Now you know how the newtype pattern is used in relation to traits; it’s also a
useful pattern even when traits are not involved. Let’s switch focus and look
at some advanced ways to interact with Rust’s type system.
-->
<p>Maintenant vous savez comment le motif newtype est utilisé en lien avec les
traits ; c'est aussi un motif très utile même lorsque les traits ne sont pas
concernés. Changeons de sujet et découvrons d'autres techniques avancées pour
interagir avec le système de type de Rust.</p>
<!-- markdownlint-disable -->
<!--
[implementing-a-trait-on-a-type]:
ch10-02-traits.html#implementing-a-trait-on-a-type
[the-iterator-trait-and-the-next-method]:
ch13-02-iterators.html#the-iterator-trait-and-the-next-method
[traits-defining-shared-behavior]:
ch10-02-traits.html#traits-defining-shared-behavior
[smart-pointer-deref]: ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait
[tuple-structs]: ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types
-->
<!-- markdownlint-restore -->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--28"><a class="header" href="#-attention-peinture-fraîche--28">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/218">Pull Request</a>.</p>
</blockquote>
<!--
## Advanced Types
-->
<h2 id="les-types-avancés"><a class="header" href="#les-types-avancés">Les types avancés</a></h2>
<!--
The Rust type system has some features that we’ve mentioned in this book but
haven’t yet discussed. We’ll start by discussing newtypes in general as we
examine why newtypes are useful as types. Then we’ll move on to type aliases, a
feature similar to newtypes but with slightly different semantics. We’ll also
discuss the `!` type and dynamically sized types.
-->
<p>Le système de type de Rust offre quelques fonctionnalités que nous avons
mentionné dans ce livre mais que nous n'avons pas encore étudié. Nous allons
commencer par voir les newtypes en général lorsque nous examinerons pourquoi
les newtypes sont des types utiles. Ensuite nous nous pencherons sur les alias
de type, une fonctionnalité qui ressemble aux newtypes mais avec quelques
différences sémantiques. Nous allons aussi voir le type <code>!</code> et les types à
taille dynamique.</p>
<!--
> Note: The next section assumes you’ve read the earlier section [“Using the
> Newtype Pattern to Implement External Traits on External
> Types.”][using-the-newtype-pattern]<!-- ignore -- >
-->
<blockquote>
<p>Remarque : cette section suppose que vous avez lu la
<a href="ch19-03-advanced-traits.html">section précédente</a><!-- ignore --></p>
</blockquote>
<!--
### Using the Newtype Pattern for Type Safety and Abstraction
-->
<h3 id="utiliser-le-motif-newtype-pour-la-sécurité-et-labstraction-des-types"><a class="header" href="#utiliser-le-motif-newtype-pour-la-sécurité-et-labstraction-des-types">Utiliser le motif newtype pour la sécurité et l'abstraction des types</a></h3>
<!--
The newtype pattern is useful for tasks beyond those we’ve discussed so far,
including statically enforcing that values are never confused and indicating
the units of a value. You saw an example of using newtypes to indicate units in
Listing 19-15: recall that the `Millimeters` and `Meters` structs wrapped `u32`
values in a newtype. If we wrote a function with a parameter of type
`Millimeters`, we couldn’t compile a program that accidentally tried to call
that function with a value of type `Meters` or a plain `u32`.
-->
<p>Le motif newtype est utile pour des tâches qui se prolongent en dehors de ce
que nous avons vu jusqu'à présent, notamment pour faire en sorte statiquement
que les valeurs ne soient jamais confondues et pour indiquer les unités d'une
valeur. Vous avez vu un exemple d'utilisation des newtypes pour indiquer des
unités dans l'encart 19-15 : souvenez-vous des structures <code>Milimetres</code> et
<code>Metres</code> qui englobaient des valeurs <code>u32</code> dans ces newtypes. Si nous avions
écrit une fonction avec un paramètre de type <code>Milimetres</code>, nous ne pourrions
pas compiler un programme qui fait accidentellement appel à cette fonction avec
une valeur du type <code>Metres</code> ou un <code>u32</code> pur.</p>
<!--
Another use of the newtype pattern is in abstracting away some implementation
details of a type: the new type can expose a public API that is different from
the API of the private inner type if we used the new type directly to restrict
the available functionality, for example.
-->
<p>Une autre utilisation du motif newtype est de rendre abstrait certains détails
d'implémentation d'un type : le newtype peut exposer une API publique qui est
différente de l'API du type interne privé si nous avons utilisé directement le
newtype pour restreindre les fonctionnalités disponibles, par exemple.</p>
<!--
Newtypes can also hide internal implementation. For example, we could provide a
`People` type to wrap a `HashMap<i32, String>` that stores a person’s ID
associated with their name. Code using `People` would only interact with the
public API we provide, such as a method to add a name string to the `People`
collection; that code wouldn’t need to know that we assign an `i32` ID to names
internally. The newtype pattern is a lightweight way to achieve encapsulation
to hide implementation details, which we discussed in the [“Encapsulation that
Hides Implementation
Details”][encapsulation-that-hides-implementation-details]<!-- ignore -- >
section of Chapter 17.
-->
<p>Les newtypes peuvent aussi masquer des implémentations internes. Par exemple,
nous pouvons fournir un type <code>Personnes</code> pour embarquer un
<code>HashMap&lt;i32, String&gt;</code> qui stocke un identifiant d'une personne associé à son
nom. Le code qui utilisera <code>Personnes</code> ne pourra utiliser que l'API publique
que nous fournissons, comme une méthode pour ajouter une chaîne de caractères
de caractère qui est un nom à la collection <code>Personnes</code> ; ce code n'aura pas
besoin de savoir que nous assignons en interne un identifiant <code>i32</code> aux noms.
Le motif newtype est une façon allégée de procéder à de l'encapsulation pour
masquer des détails d'implémentation, comme nous l'avons vu dans <a href="ch17-01-what-is-oo.html">une partie du
chapitre 17</a><!-- ignore -->.</p>
<!--
### Creating Type Synonyms with Type Aliases
-->
<h3 id="créer-des-synonymes-de-noms-avec-les-alias-de-type"><a class="header" href="#créer-des-synonymes-de-noms-avec-les-alias-de-type">Créer des synonymes de noms avec les alias de type</a></h3>
<!--
Along with the newtype pattern, Rust provides the ability to declare a *type
alias* to give an existing type another name. For this we use the `type`
keyword. For example, we can create the alias `Kilometers` to `i32` like so:
-->
<p>En plus du motif newtype, Rust fournit la possibilité de déclarer un <em>alias de
type</em> pour donner un autre nom à un type déjà existant. Pour faire cela, nous
utilisons le mot-clé <code>type</code>. Par exemple, nous pouvons créer l'alias
<code>Kilometres</code> pour un <code>i32</code>, comme ceci :</p>
<!--
```rust
# fn main() {
    type Kilometers = i32;
# 
#     let x: i32 = 5;
#     let y: Kilometers = 5;
# 
#     println!("x + y = {}", x + y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometres = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometres = 5;
</span><span class="boring">
</span><span class="boring">    println!(&quot;x + y = {}&quot;, x + y);
</span><span class="boring">}
</span></code></pre></pre>
<!--
Now, the alias `Kilometers` is a *synonym* for `i32`; unlike the `Millimeters`
and `Meters` types we created in Listing 19-15, `Kilometers` is not a separate,
new type. Values that have the type `Kilometers` will be treated the same as
values of type `i32`:
-->
<p>Désormais, l'alias <code>Kilometres</code> est un <em>synonyme</em> de <code>i32</code> ; contrairement aux
types <code>Milimetres</code> et <code>Metres</code> que nous avons créé dans l'encart 19-15,
<code>Kilometres</code> n'est pas un newtype séparé. Les valeurs qui ont le type
<code>Kilometre</code> seront traités comme si elles étaient du type <code>i32</code> :</p>
<!--
```rust
# fn main() {
    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometres = i32;

    let x: i32 = 5;
    let y: Kilometres = 5;

    println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Kilometres = i32;

let x: i32 = 5;
let y: Kilometres = 5;

println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<!--
Because `Kilometers` and `i32` are the same type, we can add values of both
types and we can pass `Kilometers` values to functions that take `i32`
parameters. However, using this method, we don’t get the type checking benefits
that we get from the newtype pattern discussed earlier.
-->
<p>Comme <code>Kilometres</code> et <code>i32</code> sont du même type, nous pouvons additionner les
valeurs des deux types et nous pouvons envoyer des valeurs <code>Kilometres</code> aux
fonctions qui prennent des paramètres <code>i32</code>. Cependant, en utilisant cette
méthode, nous ne bénéficions pas des bienfaits de la vérification du type que
nous avions avec le motif newtype que nous avons vu précédemment.</p>
<!--
The main use case for type synonyms is to reduce repetition. For example, we
might have a lengthy type like this:
-->
<p>L'utilisation principale pour les synonymes de types est de réduire la
répétition. Par exemple, nous pourrions avoir un type un peu long comme
celui-ci :</p>
<!--
```rust,ignore
Box<dyn Fn() + Send + 'static>
```
-->
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;
</code></pre>
<!--
Writing this lengthy type in function signatures and as type annotations all
over the code can be tiresome and error prone. Imagine having a project full of
code like that in Listing 19-24.
-->
<p>L'écriture de ce type un peu long dans des signatures de fonctions et comme
annotations de types tout au long du code peut être fatigante et faciliter les
erreurs. Imaginez avoir un projet avec plein de code comme celui dans l'encart
19-24.</p>
<!--
```rust
# fn main() {
    let f: Box<dyn Fn() + Send + 'static> = Box::new(|| println!("hi"));

    fn takes_long_type(f: Box<dyn Fn() + Send + 'static>) {
        // --snip--
    }

    fn returns_long_type() -> Box<dyn Fn() + Send + 'static> {
        // --snip--
#         Box::new(|| ())
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;salut&quot;));

    fn prend_un_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // -- partie masquée ici --
    }

    fn retourne_un_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // -- partie masquée ici --
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-24: Using a long type in many places</span>
-->
<p><span class="caption">Encart 19-24 : utilisation d'un long type dans de nombreux
endroits</span></p>
<!--
A type alias makes this code more manageable by reducing the repetition. In
Listing 19-25, we’ve introduced an alias named `Thunk` for the verbose type and
can replace all uses of the type with the shorter alias `Thunk`.
-->
<p>Un alias de type simplifie ce code en réduisant la répétition. Dans l'encart
19-25, nous avons ajouté un alias <code>Thunk</code> pour ce type verbeux et qui peut
remplacer tous ses cas d'emploi du type avec l'alias <code>Thunk</code>, plus court.</p>
<!--
```rust
# fn main() {
    type Thunk = Box<dyn Fn() + Send + 'static>;

    let f: Thunk = Box::new(|| println!("hi"));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -> Thunk {
        // --snip--
#         Box::new(|| ())
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!(&quot;salut&quot;));

    fn prend_un_long_type(f: Thunk) {
        // -- partie masquée ici --
    }

    fn retourne_un_long_type() -&gt; Thunk {
        // -- partie masquée ici --
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-25: Introducing a type alias `Thunk` to reduce
repetition</span>
-->
<p><span class="caption">Encart 19-25 : ajout et utilisation d'un alias <code>Thunk</code>
pour réduire les répétitions</span></p>
<!--
This code is much easier to read and write! Choosing a meaningful name for a
type alias can help communicate your intent as well (*thunk* is a word for code
to be evaluated at a later time, so it’s an appropriate name for a closure that
gets stored).
-->
<p>Ce code est plus facile à lire et écrire ! Choisir un nom plus explicite pour
un alias peut aussi vous aider à communiquer ce que vous voulez faire (<em>thunk</em>
est un terme désignant du code qui peut être évalué plus tard, donc c'est un nom
approprié pour une fermeture qui est stockée).</p>
<!--
Type aliases are also commonly used with the `Result<T, E>` type for reducing
repetition. Consider the `std::io` module in the standard library. I/O
operations often return a `Result<T, E>` to handle situations when operations
fail to work. This library has a `std::io::Error` struct that represents all
possible I/O errors. Many of the functions in `std::io` will be returning
`Result<T, E>` where the `E` is `std::io::Error`, such as these functions in
the `Write` trait:
-->
<p>Les alias de type sont couramment utilisés avec le type <code>Result&lt;T, E&gt;</code> pour
réduire la répétition. Regardez le module <code>std::io</code> de la bibliothèque standard.
Les opérations d'entrée/sortie retournent parfois un <code>Result&lt;T, E&gt;</code> pour gérer
les situations lorsque les opérations échouent. Cette bibliothèque a une
structure <code>std::io::Error</code> qui représente toutes les erreurs possibles
d'entrée/sortie. De nombreuses fonctions dans <code>std::io</code> vont retourner un
<code>Result&lt;T, E&gt;</code> avec <code>E</code> qui est <code>std::io::Error</code>, ces fonctions sont dans le
trait <code>Write</code> :</p>
<!--
```rust
use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize, Error>;
    fn flush(&mut self) -> Result<(), Error>;

    fn write_all(&mut self, buf: &[u8]) -> Result<(), Error>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<(), Error>;
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `Result<..., Error>` is repeated a lot. As such, `std::io` has this type of
alias declaration:
-->
<p>Le <code>Result&lt;..., Error&gt;</code> est répété plein de fois. Ainsi, <code>std::io</code> a ce type de
déclaration d'alias :</p>
<!--
```rust
# use std::fmt;
# 
type Result<T> = std::result::Result<T, std::io::Error>;
# 
# pub trait Write {
#     fn write(&mut self, buf: &[u8]) -> Result<usize>;
#     fn flush(&mut self) -> Result<()>;
# 
#     fn write_all(&mut self, buf: &[u8]) -> Result<()>;
#     fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
Because this declaration is in the `std::io` module, we can use the fully
qualified alias `std::io::Result<T>`—that is, a `Result<T, E>` with the `E`
filled in as `std::io::Error`. The `Write` trait function signatures end up
looking like this:
-->
<p>Comme cette déclaration est dans le module <code>std::io</code>, nous pouvons utiliser
l'alias <code>std::io::Result&lt;T&gt;</code> — qui est un <code>Result&lt;T, E&gt;</code> avec le <code>E</code> qui est
déjà renseigné comme étant un <code>std::io::Error</code>. Les fonctions du trait <code>Write</code>
ressemblent finalement à ceci :</p>
<!--
```rust
# use std::fmt;
# 
# type Result<T> = std::result::Result<T, std::io::Error>;
# 
pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;

    fn write_all(&mut self, buf: &[u8]) -> Result<()>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
The type alias helps in two ways: it makes code easier to write *and* it gives
us a consistent interface across all of `std::io`. Because it’s an alias, it’s
just another `Result<T, E>`, which means we can use any methods that work on
`Result<T, E>` with it, as well as special syntax like the `?` operator.
-->
<p>L'alias de type nous aide sur deux domaines : il permet de faciliter l'écriture
du code <em>et</em> il nous donne une interface uniforme pour tout <code>std::io</code>. Comme
c'est un alias, c'est simplement un autre <code>Result&lt;T, E&gt;</code>, ce qui signifie que
nous pouvons utiliser n'importe quelle méthode qui fonctionne avec
<code>Result&lt;T, E&gt;</code>, ainsi que les syntaxes spéciales comme l'opérateur <code>?</code>.</p>
<!--
### The Never Type that Never Returns
-->
<h3 id="le-type-jamais-qui-ne-retourna-pas-de-valeur"><a class="header" href="#le-type-jamais-qui-ne-retourna-pas-de-valeur">Le type &quot;jamais&quot;, qui ne retourna pas de valeur</a></h3>
<!--
Rust has a special type named `!` that’s known in type theory lingo as the
*empty type* because it has no values. We prefer to call it the *never type*
because it stands in the place of the return type when a function will never
return. Here is an example:
-->
<p>Rust a un type spécial qui s'appelle <code>!</code> qui est connu dans le vocabulaire de
la théorie des types comme étant le <em>type vide</em> car il n'a pas de valeur. Nous
préférons appeler cela le <em>type jamais</em> car il remplace le type de retour
lorsqu'une fonction ne va jamais retourner quelque chose. Voici un exemple :</p>
<!--
```rust
fn bar() -> ! {
    // --snip--
#     panic!();
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">fn bar() -&gt; ! {
    // -- partie masquée ici --
<span class="boring">    panic!();
</span>}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<pre><code class="language-rust ignore">fn bar() -&gt; ! {
    // -- partie masquée ici --
}
</code></pre>
<!--
This code is read as “the function `bar` returns never.” Functions that return
never are called *diverging functions*. We can’t create values of the type `!`
so `bar` can never possibly return.
-->
<p>Ce code peut être interprété comme “la fonction <code>bar</code> qui ne retourne pas de
valeur”. Les fonctions qui ne retournent pas de valeur s'appellent des
<em>fonctions divergentes</em>. Nous ne pouvons pas créer de valeurs de type <code>!</code> donc
<code>bar</code> afin que <code>bar</code> ne puisse jamais retourner de valeur.</p>
<!--
But what use is a type you can never create values for? Recall the code from
Listing 2-5; we’ve reproduced part of it here in Listing 19-26.
-->
<p>Mais à quoi sert un type dont on ne peut jamais créer de valeurs ?
Souvenez-vous du code de l'encart 2-5 ; nous avons reproduit une partie de
celui-ci dans l'encart 19-26.</p>
<!--
```rust,ignore
# use rand::Rng;
# use std::cmp::Ordering;
# use std::io;
# 
# fn main() {
#     println!("Guess the number!");
# 
#     let secret_number = rand::thread_rng().gen_range(1..101);
# 
#     println!("The secret number is: {}", secret_number);
# 
#     loop {
#         println!("Please input your guess.");
# 
#         let mut guess = String::new();
# 
#         // --snip--
# 
#         io::stdin()
#             .read_line(&mut guess)
#             .expect("Failed to read line");
# 
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
# 
#         println!("You guessed: {}", guess);
# 
#         // --snip--
# 
#         match guess.cmp(&secret_number) {
#             Ordering::Less => println!("Too small!"),
#             Ordering::Greater => println!("Too big!"),
#             Ordering::Equal => {
#                 println!("You win!");
#                 break;
#             }
#         }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Devinez le nombre !&quot;);
</span><span class="boring">
</span><span class="boring">    let nombre_secret = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Le nombre secret est : {}&quot;, nombre_secret);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Veuillez entrer un nombre.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut supposition = String::new();
</span><span class="boring">
</span><span class="boring">        // -- partie masquée ici --
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut supposition)
</span><span class="boring">            .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</span><span class="boring">
</span>        let supposition: u32 = match supposition.trim().parse() {
            Ok(nombre) =&gt; nombre,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!(&quot;Votre nombre : {}&quot;, supposition);
</span><span class="boring">
</span><span class="boring">        // -- partie masquée ici --
</span><span class="boring">
</span><span class="boring">        match supposition.cmp(&amp;nombre_secret) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Vous avez gagné !&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 19-26: A `match` with an arm that ends in
`continue`</span>
-->
<p><span class="caption">Encart 19-26 : un <code>match</code> avec une branche qui finit par
un <code>continue</code></span></p>
<!--
At the time, we skipped over some details in this code. In Chapter 6 in [“The
`match` Control Flow Operator”][the-match-control-flow-operator]<!-- ignore
-- > section, we discussed that `match` arms must all return the same type. So,
for example, the following code doesn’t work:
-->
<p>A l'époque, nous avions sauté quelques détails dans ce code. Dans la section
<a href="ch06-02-match.html#la-structure-de-contr%C3%B4le-match">“La structure de contrôle
<code>match</code>”</a><!-- ignore --> du chapitre 6, nous
avons vu que les branches d'un <code>match</code> doivent toutes retourner le même type.
Donc, par exemple, le code suivant ne fonctionne pas :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
#     let guess = "3";
    let guess = match guess.trim().parse() {
        Ok(_) => 5,
        Err(_) => "hello",
    };
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let supposition = &quot;3&quot;;
</span>    let supposition = match supposition.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; &quot;salut&quot;,
    };
<span class="boring">}
</span></code></pre>
<pre><code class="language-rust ignore does_not_compile">let supposition = match supposition.trim().parse() {
    Ok(_) =&gt; 5,
    Err(_) =&gt; &quot;salut&quot;,
}
</code></pre>
<!--
The type of `guess` in this code would have to be an integer *and* a string,
and Rust requires that `guess` have only one type. So what does `continue`
return? How were we allowed to return a `u32` from one arm and have another arm
that ends with `continue` in Listing 19-26?
-->
<p>Le type de <code>supposition</code> dans ce code devrait être un entier <em>et</em> une chaîne de
caractères, et Rust nécessite que <code>supposition</code> n'ait qu'un seul type possible.
Donc que retourne <code>continue</code> ? Pourquoi pouvons-nous retourner un <code>u32</code> dans
une branche et avoir une autre branche qui finit avec un <code>continue</code> dans
l'encart 19-26 ?</p>
<!--
As you might have guessed, `continue` has a `!` value. That is, when Rust
computes the type of `guess`, it looks at both match arms, the former with a
value of `u32` and the latter with a `!` value. Because `!` can never have a
value, Rust decides that the type of `guess` is `u32`.
-->
<p>Comme vous l'avez deviné, <code>continue</code> a une valeur <code>!</code>. Ainsi, lorsque Rust
calcule le type de <code>supposition</code>, il regarde les deux branches, la première
avec une valeur <code>u32</code> et la seconde avec une valeur <code>!</code>. Comme <code>!</code> ne peut
jamais retourner de valeur, Rust décide alors que le type de <code>supposition</code> est
<code>u32</code>.</p>
<!--
The formal way of describing this behavior is that expressions of type `!` can
be coerced into any other type. We’re allowed to end this `match` arm with
`continue` because `continue` doesn’t return a value; instead, it moves control
back to the top of the loop, so in the `Err` case, we never assign a value to
`guess`.
-->
<p>Une façon classique de décrire ce comportement est de dire que les expressions
du type <code>!</code> peuvent être transformées dans n'importe quel type. Nous pouvons
finir cette branche de <code>match</code> avec <code>continue</code> car <code>continue</code> ne retourne pas
de valeur ; à la place, il retourne le contrôle en haut de la boucle, donc dans
le cas d'un <code>Err</code>, nous n'assignons jamais de valeur à <code>supposition</code>.</p>
<!--
The never type is useful with the `panic!` macro as well. Remember the `unwrap`
function that we call on `Option<T>` values to produce a value or panic? Here
is its definition:
-->
<p>Ce type &quot;jamais&quot; est aussi utile avec la macro <code>panic!</code>. Vous souvenez-vous que
la fonction <code>unwrap</code> que nous appelons sur les valeurs <code>Option&lt;T&gt;</code> fournissent
une valeur, ou paniquent ? Voici sa définition :</p>
<!--
```rust,ignore
# enum Option<T> {
#     Some(T),
#     None,
# }
# 
# use crate::Option::*;
# 
impl<T> Option<T> {
    pub fn unwrap(self) -> T {
        match self {
            Some(val) => val,
            None => panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<!--
In this code, the same thing happens as in the `match` in Listing 19-26: Rust
sees that `val` has the type `T` and `panic!` has the type `!`, so the result
of the overall `match` expression is `T`. This code works because `panic!`
doesn’t produce a value; it ends the program. In the `None` case, we won’t be
returning a value from `unwrap`, so this code is valid.
-->
<p>Dans ce code, il se passe la même chose que l'encart 19-26 : Rust constate que
<code>val</code> est du type <code>T</code> et que <code>panic!</code> est du type <code>!</code>, donc le résultat de
l'ensemble de l'expression <code>match</code> est <code>T</code>. Ce code fonctionne car <code>panic!</code> ne
produit pas de valeur ; il termine le programme. Dans le cas d'un <code>None</code>, nous
ne retournons pas une valeur de <code>unwrap</code>, donc ce code est valide.</p>
<!--
One final expression that has the type `!` is a `loop`:
-->
<p>Une des expressions qui sont du type <code>!</code> est le <code>loop</code> :</p>
<!--
```rust,ignore
# fn main() {
    print!("forever ");

    loop {
        print!("and ever ");
    }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!(&quot;pour toujours &quot;);

    loop {
        print!(&quot;et toujours &quot;);
    }
<span class="boring">}
</span></code></pre>
<!--
Here, the loop never ends, so `!` is the value of the expression. However, this
wouldn’t be true if we included a `break`, because the loop would terminate
when it got to the `break`.
-->
<p>Ici, la boucle ne se termine jamais, donc <code>!</code> est la valeur de cette
expression. En revanche, cela ne sera pas vrai si nous utilisons un <code>break</code>,
car la boucle va s'arrêter lorsqu'elle rencontrera le <code>break</code>.</p>
<!--
### Dynamically Sized Types and the `Sized` Trait
-->
<h3 id="les-types-à-taille-dynamique-et-le-trait-sized"><a class="header" href="#les-types-à-taille-dynamique-et-le-trait-sized">Les types à taille dynamique et le trait <code>Sized</code></a></h3>
<!--
Due to Rust’s need to know certain details, such as how much space to allocate
for a value of a particular type, there is a corner of its type system that can
be confusing: the concept of *dynamically sized types*. Sometimes referred to
as *DSTs* or *unsized types*, these types let us write code using values whose
size we can know only at runtime.
-->
<p>Vu qu'il est nécessaire pour Rust de connaître certains détails, comme la
quantité d'espace à allouer à une valeur d'un type donné, il y a un aspect de
ce système de type qui peut être déroutant : le concept des <em>types à taille
dynamique</em>. Parfois appelés <em>DST</em> (Dynamically Sized Types) ou <em>types sans
taille</em>, ces types nous permettent d'écrire du code qui utilisent des valeurs
qui ne peuvent être connues uniquement à l'exécution.</p>
<!--
Let’s dig into the details of a dynamically sized type called `str`, which
we’ve been using throughout the book. That’s right, not `&str`, but `str` on
its own, is a DST. We can’t know how long the string is until runtime, meaning
we can’t create a variable of type `str`, nor can we take an argument of type
`str`. Consider the following code, which does not work:
-->
<p>Voyons les détails d'un type à taille dynamique qui s'appelle <code>str</code>, que nous
avons utilisé dans ce livre. Plus précisément <code>&amp;str</code>, car <code>str</code> en lui-même est
un DST. Nous ne connaître la longueur de la chaîne de caractère qu'à
l'exécution, ce qui signifie que nous ne pouvons pas ni créer une variable de
type <code>str</code>, ni prendre prendre en argument un type <code>str</code>. Imaginons le code
suivant, qui ne devrait pas fonctionner :</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    let s1: str = "Hello there!";
    let s2: str = "How's it going?";
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = &quot;Salut tout le monde !&quot;;
    let s2: str = &quot;Comment ça va ?&quot;;
<span class="boring">}
</span></code></pre>
<!--
Rust needs to know how much memory to allocate for any value of a particular
type, and all values of a type must use the same amount of memory. If Rust
allowed us to write this code, these two `str` values would need to take up the
same amount of space. But they have different lengths: `s1` needs 12 bytes of
storage and `s2` needs 15. This is why it’s not possible to create a variable
holding a dynamically sized type.
-->
<p>Rust a besoin de savoir combien de mémoire allouer pour chaque valeur d'un type
donné, et toutes les valeurs de ce type doivent utiliser la même quantité de
mémoire. Si Rust nous aurait autorisé à écrire ce code, ces deux valeurs <code>str</code>
devraient occuper la même quantité de mémoire. Mais elles ont deux longueurs
différentes : <code>s1</code> prend 21 octets en mémoire alors que <code>s2</code> en a besoin de 15.
C'est pourquoi il est impossible de créer une variable qui stocke un type à
taille dynamique.</p>
<!--
So what do we do? In this case, you already know the answer: we make the types
of `s1` and `s2` a `&str` rather than a `str`. Recall that in the [“String
Slices”][string-slices]<!-- ignore -- > section of Chapter 4, we said the slice
data structure stores the starting position and the length of the slice.
-->
<p>Donc qu'est-ce qu'on peut faire ? Dans ce cas, vous connaissez déjà la réponse :
nous faisons en sorte que le type de <code>s1</code> et <code>s2</code> soit <code>&amp;str</code> plutôt que <code>str</code>.
Souvenez-vous que dans la section
<a href="ch04-03-slices.html#les-slices-de-cha%C3%AEnes-de-caract%C3%A8res">“Les slices de chaînes de caractères”</a><!-- ignore -->
du chapitre 4, nous avions dit que la structure de données slice stockait
l'emplacement de départ et la longueur de la slice.</p>
<!--
So although a `&T` is a single value that stores the memory address of where
the `T` is located, a `&str` is *two* values: the address of the `str` and its
length. As such, we can know the size of a `&str` value at compile time: it’s
twice the length of a `usize`. That is, we always know the size of a `&str`, no
matter how long the string it refers to is. In general, this is the way in
which dynamically sized types are used in Rust: they have an extra bit of
metadata that stores the size of the dynamic information. The golden rule of
dynamically sized types is that we must always put values of dynamically sized
types behind a pointer of some kind.
-->
<p>Aussi, bien qu'un <code>&amp;T</code> soit une seule valeur qui stocke l'adresse mémoire d'où
se trouve le <code>T</code>, un <code>&amp;str</code> représente <em>deux</em> valeurs : l'adresse du <code>str</code> et sa
longueur. Ainsi, nous pouvons connaître la taille d'une valeur <code>&amp;str</code> à la
compilation : elle vaut deux fois la taille d'un <code>usize</code>. Ce faisant, nous
connaissons toujours la taille d'un <code>&amp;str</code>, peu importe la longueur de la chaîne
de caractères sur laquelle cela pointe. Généralement, c'est comme cela que les
types à taille dynamique sont utilisés en Rust : ils ont des métadonnées
supplémentaires qui stockent la taille des informations dynamiques. La règle
d'or des types à taille dynamique est que nous devons toujours placer les
valeurs à types à taille dynamique dans une sorte de pointeur.</p>
<!--
We can combine `str` with all kinds of pointers: for example, `Box<str>` or
`Rc<str>`. In fact, you’ve seen this before but with a different dynamically
sized type: traits. Every trait is a dynamically sized type we can refer to by
using the name of the trait. In Chapter 17 in the [“Using Trait Objects That
Allow for Values of Different
Types”][using-trait-objects-that-allow-for-values-of-different-types]<!--
ignore -- > section, we mentioned that to use traits as trait objects, we must
put them behind a pointer, such as `&dyn Trait` or `Box<dyn Trait>` (`Rc<dyn
Trait>` would work too).
-->
<p>Nous pouvons combiner <code>str</code> avec n'importe quel type de pointeur : par exemple,
<code>Box&lt;str&gt;</code> ou <code>Rc&lt;str&gt;</code>. En fait, vous avez vu cela déjà auparavant mais avec un
type à taille dynamique : les traits. Chaque trait est un type à taille
dynamique auquel nous pouvons nous référer en utilisant le nom du trait. Dans
<a href="ch17-02-trait-objects.html">une section</a><!--
ignore --> du chapitre 17, nous avions mentionné que pour utiliser les traits
comme des objets traits, nous devions les utiliser avec un pointeur, comme le
<code>&amp;dyn Trait</code> ou <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> devrait aussi fonctionner).</p>
<!--
To work with DSTs, Rust has a particular trait called the `Sized` trait to
determine whether or not a type’s size is known at compile time. This trait is
automatically implemented for everything whose size is known at compile time.
In addition, Rust implicitly adds a bound on `Sized` to every generic function.
That is, a generic function definition like this:
-->
<p>Pour pouvoir travailler avec les DST, Rust a un trait particulier <code>Sized</code> pour
déterminer si oui ou non la taille d'un type est connue à la compilation. Ce
trait est automatiquement implémenté sur tout ce qui a une taille connue à la
compilation. De plus, Rust ajoute implicitement le trait lié <code>Sized</code> sur chaque
fonction générique. Ainsi, la définition d'une fonction générique comme
celle-ci :</p>
<!--
```rust,ignore
fn generic<T>(t: T) {
    // --snip--
}
```
-->
<pre><code class="language-rust ignore">fn generique&lt;T&gt;(t: T) {
    // -- partie masquée ici --
}
</code></pre>
<!--
is actually treated as though we had written this:
-->
<p>... est en réalité traitée comme si nous avions écris ceci :</p>
<!--
```rust,ignore
fn generic<T: Sized>(t: T) {
    // --snip--
}
```
-->
<pre><code class="language-rust ignore">fn generique&lt;T: Sized&gt;(t: T) {
    // -- partie masquée ici --
}
</code></pre>
<!--
By default, generic functions will work only on types that have a known size at
compile time. However, you can use the following special syntax to relax this
restriction:
-->
<p>Par défaut, les fonctions génériques vont fonctionner uniquement sur les types
qui ont une taille connue à la compilation. Cependant, vous pouvez utiliser la
syntaxe spéciale suivante pour éviter cette restriction :</p>
<!--
```rust,ignore
fn generic<T: ?Sized>(t: &T) {
    // --snip--
}
```
-->
<pre><code class="language-rust ignore">fn generique&lt;T: ?Sized&gt;(t: &amp;T) {
    // -- partie masquée ici --
}
</code></pre>
<!--
A trait bound on `?Sized` is the opposite of a trait bound on `Sized`: we would
read this as “`T` may or may not be `Sized`.” This syntax is only available for
`Sized`, not any other traits.
-->
<p>Le trait lié <code>?Sized</code> est l'opposé du trait lié <code>Sized</code> : nous pourrions lire
ceci comme étant “<code>T</code> peut être ou non un <code>Sized</code>”. Cette syntaxe est disponible
uniquement pour <code>Sized</code>, et non pas pour les autres traits.</p>
<!--
Also note that we switched the type of the `t` parameter from `T` to `&T`.
Because the type might not be `Sized`, we need to use it behind some kind of
pointer. In this case, we’ve chosen a reference.
-->
<p>Remarquez aussi que nous avons changé le type du paramètre <code>t</code> de <code>T</code> en <code>&amp;T</code>.
Comme ce type pourrait ne pas être un <code>Sized</code>, nous devons l'utiliser avec
quelque chose qui sert de pointeur. Dans ce cas, nous avons choisi une
référence.</p>
<!--
Next, we’ll talk about functions and closures!
-->
<p>Dans la partie suivante, nous allons parler des fonctions et des fermetures !</p>
<!--
[encapsulation-that-hides-implementation-details]:
ch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details
[string-slices]: ch04-03-slices.html#string-slices
[the-match-control-flow-operator]:
ch06-02-match.html#the-match-control-flow-operator
[using-trait-objects-that-allow-for-values-of-different-types]:
ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[using-the-newtype-pattern]: ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types
-->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--29"><a class="header" href="#-attention-peinture-fraîche--29">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/219">Pull Request</a>.</p>
</blockquote>
<!--
## Advanced Functions and Closures
-->
<h2 id="les-fonctions-et-fermetures-avancées"><a class="header" href="#les-fonctions-et-fermetures-avancées">Les fonctions et fermetures avancées</a></h2>
<!--
Next, we’ll explore some advanced features related to functions and
closures, which include function pointers and returning closures.
-->
<p>Maintenant, nous allons explorer quelques fonctionnalités avancées liées aux
fonctions et aux fermetures, comme les pointeurs de fonctions et retourner des
fermetures.</p>
<!--
### Function Pointers
-->
<h3 id="pointeurs-de-fonctions"><a class="header" href="#pointeurs-de-fonctions">Pointeurs de fonctions</a></h3>
<!--
We’ve talked about how to pass closures to functions; you can also pass regular
functions to functions! This technique is useful when you want to pass a
function you’ve already defined rather than defining a new closure. Doing this
with function pointers will allow you to use functions as arguments to other
functions. Functions coerce to the type `fn` (with a lowercase f), not to be
confused with the `Fn` closure trait. The `fn` type is called a *function
pointer*. The syntax for specifying that a parameter is a function pointer is
similar to that of closures, as shown in Listing 19-27.
-->
<p>Nous avons déjà vu comment envoyer des fermetures dans des fonctions ; mais vous
pouvez aussi envoyer des fonctions classiques dans d'autres fonctions ! Cette
technique est utile lorsque vous souhaitez envoyer une fonction que vous avez
déjà définie plutôt que de définir une nouvelle fermeture. Vous pouvez faire
ceci avec des pointeurs de fonctions, qui vous permettent d'utiliser des
fonctions en argument d'autres fonctions. Les fonctions nécessitent le type <code>fn</code>
(avec un f minuscule), à ne pas confondre avec le trait de fermeture <code>Fn</code>. Le
type <code>fn</code> s'appelle un <em>pointeur de fonction</em>. La syntaxe pour renseigner qu'un
paramètre est un pointeur de fonction ressemble à celle des fermetures, comme
vous pouvez le voir dans l'encart 19-27.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {}", answer);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn ajouter_un(x: i32) -&gt; i32 {
    x + 1
}

fn le_faire_deux_fois(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let reponse = le_faire_deux_fois(ajouter_un, 5);

    println!(&quot;La réponse est : {}&quot;, reponse);
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-27: Using the `fn` type to accept a function
pointer as an argument</span>
-->
<p><span class="caption">Encart 19-27 : utiliser le type <code>fn</code> pour accepter un
pointeur de fonction en argument</span></p>
<!--
This code prints `The answer is: 12`. We specify that the parameter `f` in
`do_twice` is an `fn` that takes one parameter of type `i32` and returns an
`i32`. We can then call `f` in the body of `do_twice`. In `main`, we can pass
the function name `add_one` as the first argument to `do_twice`.
-->
<p>Ce code affiche <code>La réponse est : 12</code>. Nous avons précisé que le paramètre <code>f</code>
dans <code>le_faire_deux_fois</code> est une <code>fn</code> qui prend en argument un paramètre du
type <code>i32</code> et retourne un <code>i32</code>. Nous pouvons ensuite appeler <code>f</code> dans le corps
de <code>le_faire_deux_fois</code>. Dans <code>main</code>, nous pouvons envoyer le nom de la fonction
<code>add_one</code> dans le premier argument de <code>le_faire_deux_fois</code>.</p>
<!--
Unlike closures, `fn` is a type rather than a trait, so we specify `fn` as the
parameter type directly rather than declaring a generic type parameter with one
of the `Fn` traits as a trait bound.
-->
<p>Contrairement aux fermetures, <code>fn</code> est un type plutôt qu'un trait, donc nous
renseignons <code>fn</code> directement comme type de paramètre plutôt que de déclarer un
paramètre de type générique avec un des traits <code>Fn</code> liés.</p>
<!--
Function pointers implement all three of the closure traits (`Fn`, `FnMut`, and
`FnOnce`), so you can always pass a function pointer as an argument for a
function that expects a closure. It’s best to write functions using a generic
type and one of the closure traits so your functions can accept either
functions or closures.
-->
<p>Les pointeurs de fonctions implémentent tous les trois traits de fermeture
(<code>Fn</code>, <code>FnMut</code>, et <code>FnOnce</code>), afin que vous puissiez toujours envoyer un
pointeur de fonction en argument d'une fonction qui attendait une fermeture. Il
vaut mieux écrire des fonctions qui utilisent un type générique et un des traits
de fermetures afin que vos fonctions puissent accepter soit des fonctions, soit
des fermetures.</p>
<!--
An example of where you would want to only accept `fn` and not closures is when
interfacing with external code that doesn’t have closures: C functions can
accept functions as arguments, but C doesn’t have closures.
-->
<p>Un exemple dans lequel vous voudriez accepter uniquement des <code>fn</code>, et non pas
des fermetures, est lorsque vous vous interfacez avec du code externe qui n'a
pas de fermetures : les fonctions C peuvent accepter des fonctions en argument,
mais le C n'a pas fermetures.</p>
<!--
As an example of where you could use either a closure defined inline or a named
function, let’s look at a use of `map`. To use the `map` function to turn a
vector of numbers into a vector of strings, we could use a closure, like this:
-->
<p>Un autre exemple dans lequel vous pouvez utiliser soit une fermeture définie en
une seule ligne ou le nom d'une fonction, est lorsque vous utilisez <code>map</code>. Pour
utiliser la fonction <code>map</code> pour transformer un vecteur de nombres en vecteur de
chaînes de caractères, nous pouvons utiliser une fermeture, comme ceci :</p>
<!--
```rust
# fn main() {
    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec<String> =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let liste_de_nombres = vec![1, 2, 3];
    let liste_de_chaines: Vec&lt;String&gt; =
        liste_de_nombres.iter().map(|i| i.to_string()).collect();
<span class="boring">}
</span></code></pre></pre>
<!--
Or we could name a function as the argument to `map` instead of the closure,
like this:
-->
<p>Ou alors nous pouvons utiliser le nom d'une fonction en argument de <code>map</code> plutôt
qu'une fermeture, comme ceci :</p>
<!--
```rust
# fn main() {
    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec<String> =
        list_of_numbers.iter().map(ToString::to_string).collect();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let liste_de_nombres = vec![1, 2, 3];
    let liste_de_chaines: Vec&lt;String&gt; =
        liste_de_nombres.iter().map(ToString::to_string).collect();
<span class="boring">}
</span></code></pre></pre>
<!--
Note that we must use the fully qualified syntax that we talked about earlier
in the [“Advanced Traits”][advanced-traits]<!-- ignore -- > section because
there are multiple functions available named `to_string`. Here, we’re using the
`to_string` function defined in the `ToString` trait, which the standard
library has implemented for any type that implements `Display`.
-->
<p>Notez que nous devons utiliser la syntaxe complète que nous avons vu
précédemment dans <a href="ch19-03-advanced-traits.html">la section précédente</a><!-- ignore --> car il
y a plusieurs fonctions de disponibles qui s'appellent <code>to_string</code>. Ici, nous
utilisons la fonction <code>to_string</code> définie dans le trait <code>ToString</code>, que la
bibliothèque standard a implémenté sur chaque type qui implémente <code>Display</code>.</p>
<!--
We have another useful pattern that exploits an implementation detail of tuple
structs and tuple-struct enum variants. These types use `()` as initializer
syntax, which looks like a function call. The initializers are actually
implemented as functions returning an instance that’s constructed from their
arguments. We can use these initializer functions as function pointers that
implement the closure traits, which means we can specify the initializer
functions as arguments for methods that take closures, like so:
-->
<p>Nous avons un autre motif utile qui exploite un détail de l'implémentation des
structures tuple et des variantes d'énumérations de structures de tuples. Ces
types utilisent <code>()</code> comme syntaxe d'initialisation, qui ressemble à un appel de
fonction. Les initialisateurs sont actuellement implémentés comme étant des
fonctions qui retournent une instance qui est construite avec leurs propres
arguments. Nous pouvons utiliser ces fonctions d'initialisation comme étant des
pointeurs de fonctions qui implémentent les traits de fermetures, ce qui
signifie que nous pouvons renseigner les fonctions d'initialisation en argument
de méthodes qui prennent en argument des fermetures, comme ceci :</p>
<!--
```rust
# fn main() {
    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec<Status> = (0u32..20).map(Status::Value).collect();
# }
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Statut {
        Valeur(u32),
        Stop,
    }

    let liste_de_statuts: Vec&lt;Statut&gt; = (0u32..20).map(Statut::Valeur).collect();
<span class="boring">}
</span></code></pre></pre>
<!--
Here we create `Status::Value` instances using each `u32` value in the range
that `map` is called on by using the initializer function of `Status::Value`.
Some people prefer this style, and some people prefer to use closures. They
compile to the same code, so use whichever style is clearer to you.
-->
<p>Nous avons ici créé des instances de <code>Statut::Valeur</code> en utilisant chacune des
valeurs <code>u32</code> présentes dans l'intervalle sur laquelle nous appelons <code>map</code> en
utilisant la fonction d'initialisation de <code>Statut::Valeur</code>. Certaines personnes
préfèrent ce style, et d'autres préfèrent utiliser des fermetures. Ces deux cas
se compilent pour faire la même chose, donc vous pouvez utiliser le style qui
vous conviens le plus.</p>
<!--
### Returning Closures
-->
<h3 id="retourner-des-fermetures"><a class="header" href="#retourner-des-fermetures">Retourner des fermetures</a></h3>
<!--
Closures are represented by traits, which means you can’t return closures
directly. In most cases where you might want to return a trait, you can instead
use the concrete type that implements the trait as the return value of the
function. But you can’t do that with closures because they don’t have a
concrete type that is returnable; you’re not allowed to use the function
pointer `fn` as a return type, for example.
-->
<p>Les fermetures sont représentées par des traits, ce qui signifie que vous ne
pouvez pas retourner directement des fermetures. Dans la plupart des cas où vous
voudrez retourner un trait, vous pouvez utiliser à la place le type concret qui
implémente le trait comme valeur de retour de la fonction. Mais vous ne pouvez
pas faire ceci avec les fermetures car elles n'ont pas de type concret qu'elles
peuvent retourner ; vous n'êtes pas autorisé à utiliser le pointeur de fonction
<code>fn</code> comme type de retour, par exemple.</p>
<!--
The following code tries to return a closure directly, but it won’t compile:
-->
<p>Le code suivant essaye de retourner directement une fermeture, mais ne peut pas
se compiler :</p>
<!--
```rust,ignore,does_not_compile
fn returns_closure() -> dyn Fn(i32) -> i32 {
    |x| x + 1
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn retourne_une_fermeture() -&gt; dyn Fn(i32) -&gt; i32 {
    |x| x + 1
}
</code></pre>
<!--
The compiler error is as follows:
-->
<p>Voici l'erreur de compilation :</p>
<!--
```console
$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0277]: the size for values of type `(dyn std::ops::Fn(i32) -> i32 + 'static)` cannot be known at compilation time
 -- > src/lib.rs:1:25
  |
1 | fn returns_closure() -> dyn Fn(i32) -> i32 {
  |                         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for `(dyn std::ops::Fn(i32) -> i32 + 'static)`
  = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>
  = note: the return type of a function must have a statically known size

error[E0308]: mismatched types
 -- > src/lib.rs:2:5
  |
1 | fn returns_closure() -> dyn Fn(i32) -> i32 {
  |                         ------------------ expected `(dyn std::ops::Fn(i32) -> i32 + 'static)` because of return type
2 |     |x| x + 1
  |     ^^^^^^^^^ expected trait `std::ops::Fn`, found closure
  |
  = note: expected trait object `(dyn std::ops::Fn(i32) -> i32 + 'static)`
                  found closure `[closure@src/lib.rs:2:5: 2:14]`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.
error: could not compile `functions-example`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0277]: the size for values of type `(dyn std::ops::Fn(i32) -&gt; i32 + 'static)` cannot be known at compilation time
 --&gt; src/lib.rs:1:25
  |
1 | fn retourne_une_fermeture() -&gt; dyn Fn(i32) -&gt; i32 {
  |                                ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for `(dyn std::ops::Fn(i32) -&gt; i32 + 'static)`
  = note: to learn more, visit &lt;https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
  = note: the return type of a function must have a statically known size

error[E0308]: mismatched types
 --&gt; src/lib.rs:2:5
  |
1 | fn retourne_une_fermeture() -&gt; dyn Fn(i32) -&gt; i32 {
  |                                ------------------ expected `(dyn std::ops::Fn(i32) -&gt; i32 + 'static)` because of return type
2 |     |x| x + 1
  |     ^^^^^^^^^ expected trait `std::ops::Fn`, found closure
  |
  = note: expected trait object `(dyn std::ops::Fn(i32) -&gt; i32 + 'static)`
                  found closure `[closure@src/lib.rs:2:5: 2:14]`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.
error: could not compile `functions-example`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The error references the `Sized` trait again! Rust doesn’t know how much space
it will need to store the closure. We saw a solution to this problem earlier.
We can use a trait object:
-->
<p>Encore l'erreur du trait <code>Sized</code> ! Rust ne sait pas combien de mémoire sera
nécessaire pour stocker la fermeture. Nous avons vu une solution à ce problème
précédemment. Nous pouvons utiliser un objet trait :</p>
<!--
```rust
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn retourne_une_fermeture() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code will compile just fine. For more about trait objects, refer to the
section [“Using Trait Objects That Allow for Values of Different
Types”][using-trait-objects-that-allow-for-values-of-different-types]<!--
ignore -- > in Chapter 17.
-->
<p>Ce code va se compiler à merveille. Pour en savoir plus sur les objets trait,
rendez-vous
<a href="ch17-02-trait-objects.html">à la section</a><!--
ignore --> du chapitre 17.</p>
<!--
Next, let’s look at macros!
-->
<p>Maintenant, penchons-nous sur les macros !</p>
<!--
[advanced-traits]:
ch19-03-advanced-traits.html#advanced-traits
[using-trait-objects-that-allow-for-values-of-different-types]:
ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
-->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--30"><a class="header" href="#-attention-peinture-fraîche--30">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/212">Pull Request</a>.</p>
</blockquote>
<!--
## Macros
-->
<h2 id="les-macros"><a class="header" href="#les-macros">Les macros</a></h2>
<!--
We’ve used macros like `println!` throughout this book, but we haven’t fully
explored what a macro is and how it works. The term *macro* refers to a family
of features in Rust: *declarative* macros with `macro_rules!` and three kinds
of *procedural* macros:
-->
<p>Nous avons déjà utilisé des macros tout au long de ce livre, comme <code>println!</code>,
mais nous n'avons pas exploré en profondeur ce qu'est une macro et comment
elles fonctionnent. Le terme <em>macro</em> revoit à une famille de fonctionnalités de
Rust : les macros <em>déclaratives</em> avec <code>macro_rules!</code> et trois types de macros
<em>procédurales</em> :</p>
<!--
* Custom `#[derive]` macros that specify code added with the `derive` attribute
  used on structs and enums
* Attribute-like macros that define custom attributes usable on any item
* Function-like macros that look like function calls but operate on the tokens
  specified as their argument
-->
<ul>
<li>Des macros <code>#[derive]</code> personnalisées qui renseigne du code ajouté grâce à
l'attribut <code>derive</code> utilisé sur les structures et les énumérations</li>
<li>Les macros qui ressemblent à des attributs qui définissent des attributs
personnalisés qui sont utilisables sur n'importe quel élément</li>
<li>Les macros qui ressemblent à des fonctions mais qui opèrent sur les éléments
renseignés en argument</li>
</ul>
<!--
We’ll talk about each of these in turn, but first, let’s look at why we even
need macros when we already have functions.
-->
<p>Nous allons voir chacune d'entre elles à leur tour, mais avant, posons-nous la
question de pourquoi nous avons besoin de macros alors que nous avons déjà les
fonctions.</p>
<!--
### The Difference Between Macros and Functions
-->
<h3 id="la-différence-entre-les-macros-et-les-fonctions"><a class="header" href="#la-différence-entre-les-macros-et-les-fonctions">La différence entre les macros et les fonctions</a></h3>
<!--
Fundamentally, macros are a way of writing code that writes other code, which
is known as *metaprogramming*. In Appendix C, we discuss the `derive`
attribute, which generates an implementation of various traits for you. We’ve
also used the `println!` and `vec!` macros throughout the book. All of these
macros *expand* to produce more code than the code you’ve written manually.
-->
<p>Essentiellement, les macros sont une façon d'écrire du code qui écrit un autre
code, ce qui s'appelle la <em>métaprogrammation</em>. Dans l'annexe C, nous verrons
l'attribut <code>derive</code>, qui génère une implémentation de différents traits pour
vous. Nous avons aussi utilisé les macros <code>println!</code> et <code>vec!</code> dans ce livre.
Toutes ces macros <em>se déploient</em> pour produire plus de code que celui que vous
avez écrit manuellement.</p>
<!--
Metaprogramming is useful for reducing the amount of code you have to write and
maintain, which is also one of the roles of functions. However, macros have
some additional powers that functions don’t.
-->
<p>La métaprogrammation est utile pour réduire la quantité de code que vous avez à
écrire et à maintenir, ce qui est aussi un des rôles des fonctions. Cependant,
les macros ont quelques pouvoirs en plus que les fonctions n'ont pas.</p>
<!--
A function signature must declare the number and type of parameters the
function has. Macros, on the other hand, can take a variable number of
parameters: we can call `println!("hello")` with one argument or
`println!("hello {}", name)` with two arguments. Also, macros are expanded
before the compiler interprets the meaning of the code, so a macro can, for
example, implement a trait on a given type. A function can’t, because it gets
called at runtime and a trait needs to be implemented at compile time.
-->
<p>La signature d'une fonction doit déclarer le nombre et le type de paramètres
qu'à cette fonction. Les macros, d'un autre côté, peuvent prendre un nombre
variable de paramètres : nous pouvons faire appel à <code>println!(&quot;salut&quot;)</code> avec un
seul argument, ou <code>println!(&quot;salut {}&quot;, nom)</code> avec deux arguments. Aussi, les
macros se déploient avant que le compilateur interprète la signification du
code, donc une macro peut, par exemple, implémenter un trait sur un type donné.
Une fonction ne peut pas le faire, car elle est exécutée à l'exécution et un
trait doit être implémenté à la compilation.</p>
<!--
The downside to implementing a macro instead of a function is that macro
definitions are more complex than function definitions because you’re writing
Rust code that writes Rust code. Due to this indirection, macro definitions are
generally more difficult to read, understand, and maintain than function
definitions.
-->
<p>Le désavantage d'implémenter une macro par rapport à une fonction est que les
définitions de macros sont plus complexes que les définitions de fonction car
vous écrivez du code Rust qui écrit lui-même du code Rust. A cause de cette
approche, les définitions de macro sont généralement plus difficiles à lire,
comprendre et maintenir que les définitions de fonctions.</p>
<!--
Another important difference between macros and functions is that you must
define macros or bring them into scope *before* you call them in a file, as
opposed to functions you can define anywhere and call anywhere.
-->
<p>Une autre différence importante entre les macros et les fonctions est que vous
devez définir les macros ou les importer dans la portée <em>avant</em> de les utiliser
dans le fichier, contrairement aux fonctions que vous pouvez définir n'importe
où et y faire appel n'importe où.</p>
<!--
### Declarative Macros with `macro_rules!` for General Metaprogramming
-->
<h3 id="les-macros-déclaratives-avec-macro_rules-pour-la-métaprogrammation-générale"><a class="header" href="#les-macros-déclaratives-avec-macro_rules-pour-la-métaprogrammation-générale">Les macros déclaratives avec <code>macro_rules!</code> pour la métaprogrammation générale</a></h3>
<!--
The most widely used form of macros in Rust is *declarative macros*. These are
also sometimes referred to as “macros by example,” “`macro_rules!` macros,” or
just plain “macros.” At their core, declarative macros allow you to write
something similar to a Rust `match` expression. As discussed in Chapter 6,
`match` expressions are control structures that take an expression, compare the
resulting value of the expression to patterns, and then run the code associated
with the matching pattern. Macros also compare a value to patterns that are
associated with particular code: in this situation, the value is the literal
Rust source code passed to the macro; the patterns are compared with the
structure of that source code; and the code associated with each pattern, when
matched, replaces the code passed to the macro. This all happens during
compilation.
-->
<p>La forme la plus utilisée de macro en Rust est la <em>macro déclarative</em>. Elles
sont parfois appelées “macros définies par un exemple”,
“macros <code>macro_rules!</code>”, ou simplement “macros”. Au fond, les macros
déclaratives vous permettent d'écrire quelque chose de similaire à une
expression <code>match</code> de Rust. Comme nous l'avons vu au chapitre 6, les
expressions <code>match</code> sont des structures de contrôle qui prennent en argument
une expression, compare la valeur qui en résulte avec les motifs, et ensuite
exécute le code associé au motif qui correspond. Les macros comparent elles
aussi une valeur avec des motifs qui sont associés à code particulier : dans
cette situation, la valeur est littéralement le code source Rust envoyé à la
macro ; les motifs sont comparés avec la structure de ce code source ; et le
code associé à chaque motif vient remplacer le code passé à la macro, lorsqu'il
correspond. Tout ceci se passe lors de la compilation.</p>
<!--
To define a macro, you use the `macro_rules!` construct. Let’s explore how to
use `macro_rules!` by looking at how the `vec!` macro is defined. Chapter 8
covered how we can use the `vec!` macro to create a new vector with particular
values. For example, the following macro creates a new vector containing three
integers:
-->
<p>Pour définir une macro, il faut utiliser la construction <code>macro_rules!</code>.
Explorons l'utilisation de <code>macro_rules!</code> en observant comment la macro <code>vec!</code>
est définie. Le chapitre 8 nous a permis de comprendre comment utiliser la
macro <code>vec!</code> pour créer un nouveau vecteur avec des valeurs précises. Par
exemple, la macro suivante crée un nouveau vecteur qui contient trois entiers :</p>
<!--
```rust
let v: Vec<u32> = vec![1, 2, 3];
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<!--
We could also use the `vec!` macro to make a vector of two integers or a vector
of five string slices. We wouldn’t be able to use a function to do the same
because we wouldn’t know the number or type of values up front.
-->
<p>Nous aurions pu aussi utiliser la macro <code>vec!</code> pour créer un vecteur de deux
entiers ou un vecteur de cinq slices de chaînes de caractères. Nous n'aurions
pas pu utiliser une fonction pour faire la même chose car nous n'aurions pas pu
connaître le nombre ou le type de valeurs au départ.</p>
<!--
Listing 19-28 shows a slightly simplified definition of the `vec!` macro.
-->
<p>L'encart 19-28 montre une définition légèrement simplifiée de la macro <code>vec!</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-28: A simplified version of the `vec!` macro
definition</span>
-->
<p><span class="caption">Encart 19-28 : une version simplifiée de la définition de
la macro <code>vec!</code></span></p>
<!--
> Note: The actual definition of the `vec!` macro in the standard library
> includes code to preallocate the correct amount of memory up front. That code
> is an optimization that we don’t include here to make the example simpler.
-->
<blockquote>
<p>Remarque : la définition actuelle de la macro <code>vec!</code> de la bibliothèque
standard embarque du code pour pré-allouer la bonne quantité de mémoire en
amont. Ce code est une optimisation que nous n'allons pas intégrer ici pour
simplifier l'exemple.</p>
</blockquote>
<!--
The `#[macro_export]` annotation indicates that this macro should be made
available whenever the crate in which the macro is defined is brought into
scope. Without this annotation, the macro can’t be brought into scope.
-->
<p>L'annotation <code>#[macro_export]</code> indique que cette macro doit être disponible à
chaque fois que la crate dans laquelle la macro est définie est importée dans
la portée. Sans cette annotation, la macro ne pourrait pas être importée dans
la portée.</p>
<!--
We then start the macro definition with `macro_rules!` and the name of the
macro we’re defining *without* the exclamation mark. The name, in this case
`vec`, is followed by curly brackets denoting the body of the macro definition.
-->
<p>Ensuite, nous commençons la définition de la macro avec <code>macro_rules!</code> suivi du
nom de la macro que nous définissons <em>sans</em> le point d'exclamation. Le nom, qui
dans ce cas est <code>vec</code>, est suivi par des accolades indiquant le corps de la
définition de la macro.</p>
<!--
The structure in the `vec!` body is similar to the structure of a `match`
expression. Here we have one arm with the pattern `( $( $x:expr ),* )`,
followed by `=>` and the block of code associated with this pattern. If the
pattern matches, the associated block of code will be emitted. Given that this
is the only pattern in this macro, there is only one valid way to match; any
other pattern will result in an error. More complex macros will have more than
one arm.
-->
<p>La structure dans le corps de <code>vec!</code> ressemble à la structure d'une expression
<code>match</code>. Ici nous avons une branche avec le motif <code>( $( $x:expr ), * )</code>, suivi
par <code>=&gt;</code> et le code du bloc associé à ce motif. Si le motif correspond, le bloc
de code associé sera déployé. Etant donné que c'est le seul motif dans cette
macro, il n'y a qu'une seule bonne façon d'y correspondre ; tout autre motif va
déboucher sur une erreur. Des macros plus complexes auront plus qu'une seule
branche.</p>
<!--
Valid pattern syntax in macro definitions is different than the pattern syntax
covered in Chapter 18 because macro patterns are matched against Rust code
structure rather than values. Let’s walk through what the pattern pieces in
Listing 19-28 mean; for the full macro pattern syntax, see [the reference].
-->
<p>La syntaxe correcte pour un motif dans les définitions de macros est différente
de la syntaxe de motif que nous avons vu au chapitre 18 car les motifs de
macros sont comparés à des structures de code Rust plutôt qu'à des valeurs.
Examinons la signification des éléments du motif de l'encart 19-28 ; pour voir
l'intégralité de la syntaxe du motif de la macro, rendez-vous
<a href="https://doc.rust-lang.org/reference/macros-by-example.html">à la documentation</a>.</p>
<!--
[the reference]: ../reference/macros-by-example.html
-->
<!--
First, a set of parentheses encompasses the whole pattern. A dollar sign (`$`)
is next, followed by a set of parentheses that captures values that match the
pattern within the parentheses for use in the replacement code. Within `$()` is
`$x:expr`, which matches any Rust expression and gives the expression the name
`$x`.
-->
<p>Premièrement, un jeu de parenthèses englobent l'intégralité du motif. Ensuite
vient le symbole dollar (<code>$</code>), suivi par un jeu de parenthèses qui capturent les
valeurs qui correspondent au motif entre les parenthèses pour les utiliser dans
le code de remplacement. A l'intérieur du <code>$()</code> nous avons <code>$x:expr</code>, qui
correspond à n'importe quelle expression Rust et donne le nom <code>$x</code> à
l'expression.</p>
<!--
The comma following `$()` indicates that a literal comma separator character
could optionally appear after the code that matches the code in `$()`. The `*`
specifies that the pattern matches zero or more of whatever precedes the `*`.
-->
<p>La virgule qui suit le <code>$()</code> signifie que cette virgule littérale comme
caractère littéral de séparation peut optionnellement apparaître après le code
qui correspond au code du <code>$()</code>. Le <code>*</code> informe que ce motif correspond à zéro
ou plus éléments répétés correspondant à ce qui précède ce <code>*</code>.</p>
<!--
When we call this macro with `vec![1, 2, 3];`, the `$x` pattern matches three
times with the three expressions `1`, `2`, and `3`.
-->
<p>Lorsque nous faisons appel à cette macro avec <code>vec![1, 2, 3];</code>, le motif <code>$x</code>
correspond à trois reprises avec les trois expressions <code>1</code>, <code>2</code>, et <code>3</code>.</p>
<!--
Now let’s look at the pattern in the body of the code associated with this arm:
`temp_vec.push()` within `$()*` is generated for each part that matches `$()`
in the pattern zero or more times depending on how many times the pattern
matches. The `$x` is replaced with each expression matched. When we call this
macro with `vec![1, 2, 3];`, the code generated that replaces this macro call
will be the following:
-->
<p>Maintenant, penchons-nous sur le motif dans le corps du code associé à cette
branche : <code>temp_vec.push()</code> dans le <code>$()*</code> est généré pour chacune des parties
qui correspondent au <code>$()</code> dans le motif pour zéro ou plus de fois, en fonction
de combien de fois le motif correspond. Le <code>$x</code> est remplacé par chaque
expression qui correspond. Lorsque nous faisons appel à cette macro avec
<code>vec![1, 2, 3];</code>, le code généré qui remplace cet appel de macro ressemblera à
ceci :</p>
<!--
```rust,ignore
{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
```
-->
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
</code></pre>
<!--
We’ve defined a macro that can take any number of arguments of any type and can
generate code to create a vector containing the specified elements.
-->
<p>Nous avons défini une macro qui peut prendre n'importe quel nombre d'arguments
de n'importe quel type et qui peut générer du code pour créer un vecteur qui
contient les éléments renseignés.</p>
<!--
There are some strange edge cases with `macro_rules!`. In the future, Rust will
have a second kind of declarative macro that will work in a similar fashion but
fix some of these edge cases. After that update, `macro_rules!` will be
effectively deprecated. With this in mind, as well as the fact that most Rust
programmers will *use* macros more than *write* macros, we won’t discuss
`macro_rules!` any further. To learn more about how to write macros, consult
the online documentation or other resources, such as [“The Little Book of Rust
Macros”][tlborm].
-->
<p>Il subsiste quelques cas marginaux étranges avec <code>macro_rules!</code>. Bientôt, Rust
rajoutera un second type de macro déclarative qui fonctionnera de la même
manière mais qui corrigera ces cas marginaux. Après cette mise à jour,
<code>macro_rules!</code> sera dépréciée. En sachant cela, ainsi que le fait que la
plupart des développeurs Rust vont plus <em>utiliser</em> les macros <em>qu'écrire</em> des
macros, nous ne verrons plus à nouveau <code>macro_rules!</code> à l'avenir. Pour en
savoir plus sur l'écriture des macros, consultez la documentation en ligne, ou
d'autres ressources comme <a href="https://danielkeep.github.io/tlborm/book/index.html">“The Little Book of Rust Macros”</a>.</p>
<!--
[tlborm]: https://danielkeep.github.io/tlborm/book/index.html
-->
<!--
### Procedural Macros for Generating Code from Attributes
-->
<h3 id="les-macros-procédurales-pour-générer-du-code-à-partir-des-attributs"><a class="header" href="#les-macros-procédurales-pour-générer-du-code-à-partir-des-attributs">Les macros procédurales pour générer du code à partir des attributs</a></h3>
<!--
The second form of macros is *procedural macros*, which act more like functions
(and are a type of procedure). Procedural macros accept some code as an input,
operate on that code, and produce some code as an output rather than matching
against patterns and replacing the code with other code as declarative macros
do.
-->
<p>La seconde forme de macro est la <em>macro procédurale</em>, qui se comporte plus
comme des fonctions (et sont un type de procédure). Les macros procédurales
prennent du code en entrée, travaille sur ce code, et produit du code en sortie
plutôt que de faire des correspondances sur des motifs et remplacer du code
avec un autre code, comme le font les macros déclaratives.</p>
<!--
The three kinds of procedural macros (custom derive, attribute-like, and
function-like) all work in a similar fashion.
-->
<p>Les trois types de macros procédurales (les dérivées personnalisées, celles qui
ressemblent aux attributs, et celles qui ressemblent à des fonctions)
fonctionnent toutes de la même manière.</p>
<!--
When creating procedural macros, the definitions must reside in their own crate
with a special crate type. This is for complex technical reasons that we hope
to eliminate in the future. Using procedural macros looks like the code in
Listing 19-29, where `some_attribute` is a placeholder for using a specific
macro.
-->
<p>Lorsque vous créez une macro procédurale, les définitions doivent être rangées
dans leur propre crate avec un type spécial de crate. Ceci pour des raisons
techniques complexes que nous espérons supprimer dans l'avenir. L'utilisation
des macros procédurales ressemble au code de l'encart 19-29, dans lequel
<code>un_attribut_quelconque</code> est un emplacement pour l'utilisation d'une macro
spécifique.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {
}
```
-->
<pre><code class="language-rust ignore">use proc_macro;

#[un_attribut_quelconque]
pub fn un_nom_quelconque(entree: TokenStream) -&gt; TokenStream {
}
</code></pre>
<!--
<span class="caption">Listing 19-29: An example of using a procedural
macro</span>
-->
<p><span class="caption">Encart 19-29 : un exemple d'utilisation d'une macro
procédurale</span></p>
<!--
The function that defines a procedural macro takes a `TokenStream` as an input
and produces a `TokenStream` as an output. The `TokenStream` type is defined by
the `proc_macro` crate that is included with Rust and represents a sequence of
tokens. This is the core of the macro: the source code that the macro is
operating on makes up the input `TokenStream`, and the code the macro produces
is the output `TokenStream`. The function also has an attribute attached to it
that specifies which kind of procedural macro we’re creating. We can have
multiple kinds of procedural macros in the same crate.
-->
<p>La fonction qui définit une macro procédurale prend un <code>TokenStream</code> en entrée
et produit un <code>TokenStream</code> en sortie. Le type <code>TokenStream</code> est défini par la
crate <code>proc_macro</code> qui est fournie par Rust et représente une séquence de
jetons. C'est le cœur de la macro : le code source sur lequel la macro opère
compose l'entrée <code>TokenStream</code>, et le code que la macro produit est une sortie
<code>TokenStream</code>. La fonction a aussi un attribut qui lui est rattaché qui
renseigne quel genre de macro procédurale nous créons. Nous pouvons avoir
différents types de macros procédurales dans la même crate.</p>
<!--
Let’s look at the different kinds of procedural macros. We’ll start with a
custom derive macro and then explain the small dissimilarities that make the
other forms different.
-->
<p>Voyons maintenant les différents types de macros procédurales. Nous allons
commencer par une macro dérivée personnalisée et nous expliquerons ensuite les
petites différences avec les autres types.</p>
<!--
### How to Write a Custom `derive` Macro
-->
<h3 id="comment-écrire-une-macro-dérivée-personnalisée"><a class="header" href="#comment-écrire-une-macro-dérivée-personnalisée">Comment écrire une macro dérivée personnalisée</a></h3>
<!--
Let’s create a crate named `hello_macro` that defines a trait named
`HelloMacro` with one associated function named `hello_macro`. Rather than
making our crate users implement the `HelloMacro` trait for each of their
types, we’ll provide a procedural macro so users can annotate their type with
`#[derive(HelloMacro)]` to get a default implementation of the `hello_macro`
function. The default implementation will print `Hello, Macro! My name is
TypeName!` where `TypeName` is the name of the type on which this trait has
been defined. In other words, we’ll write a crate that enables another
programmer to write code like Listing 19-30 using our crate.
-->
<p>Créons une crate <code>hello_macro</code> qui définit un trait qui s'appelle <code>HelloMacro</code>
avec une fonction associée <code>hello_macro</code>. Plutôt que de contraindre les
utilisateurs de notre crate à implémenter le trait <code>HelloMacro</code> sur chacun de
leurs types, nous allons fournir une macro procédurale qui permettra aux
utilisateurs de pouvoir annoter leur type avec <code>#[derive(HelloMacro)]</code> afin
d'obtenir une implémentation par défaut de la fonction <code>hello_macro</code>.
L'implémentation par défaut affichera <code>Hello, Macro ! Mon nom est TypeName !</code>,
dans lequel <code>TypeName</code> est le nom du type sur lequel ce trait a été défini.
Autrement dit, nous allons écrire une crate qui permet à un autre développeur
d'écrire du code comme l'encart 19-30 en utilisant notre crate.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<!--
<span class="caption">Listing 19-30: The code a user of our crate will be able
to write when using our procedural macro</span>
-->
<p><span class="caption">Encart 19-30 : le code qu'un utilisateur de notre crate
pourra écrire lorsqu'il utilisera notre macro procédurale</span></p>
<!--
This code will print `Hello, Macro! My name is Pancakes!` when we’re done. The
first step is to make a new library crate, like this:
-->
<p>Ce code va afficher <code>Hello, Macro ! Mon nom est Pancakes !</code> lorsque vous en
aurez fini. La première étape est de créer une nouvelle crate de bibliothèque,
comme ceci :</p>
<!--
```console
$ cargo new hello_macro --lib
```
-->
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<!--
Next, we’ll define the `HelloMacro` trait and its associated function:
-->
<p>Ensuite, nous allons définir le trait <code>HelloMacro</code> et sa fonction associée :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
pub trait HelloMacro {
    fn hello_macro();
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait HelloMacro {
    fn hello_macro();
}
<span class="boring">}
</span></code></pre></pre>
<!--
We have a trait and its function. At this point, our crate user could implement
the trait to achieve the desired functionality, like so:
-->
<p>Nous avons maintenant un trait et sa fonction. A partir de là, notre
utilisateur de la crate peut implémenter le trait pour accomplir la
fonctionnalité souhaitée, comme ceci :</p>
<!--
```rust,ignore
use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}
```
-->
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro ! Mon nom est Pancakes !&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<!--
However, they would need to write the implementation block for each type they
wanted to use with `hello_macro`; we want to spare them from having to do this
work.
-->
<p>Cependant, l'utilisateur doit écrire le bloc d'implémentation pour chacun des
types qu'il souhaite utiliser avec <code>hello_macro</code> ; nous souhaitons leur
épargner de faire ce travail.</p>
<!--
Additionally, we can’t yet provide the `hello_macro` function with default
implementation that will print the name of the type the trait is implemented
on: Rust doesn’t have reflection capabilities, so it can’t look up the type’s
name at runtime. We need a macro to generate code at compile time.
-->
<p>De plus, nous ne pouvons pas encore fournir la fonction <code>hello_macro</code> avec
l'implémentation par défaut qui va afficher le nom du type du trait sur lequel
nous l'implémentons : Rust n'est pas réflexif, donc il ne peut pas connaître le
nom du type à l'exécution. Nous avons besoin d'une macro pour générer le code à
la compilation.</p>
<!--
The next step is to define the procedural macro. At the time of this writing,
procedural macros need to be in their own crate. Eventually, this restriction
might be lifted. The convention for structuring crates and macro crates is as
follows: for a crate named `foo`, a custom derive procedural macro crate is
called `foo_derive`. Let’s start a new crate called `hello_macro_derive` inside
our `hello_macro` project:
-->
<p>La prochaine étape est de définir la macro procédurale. A l'heure de l'écriture
de ces lignes, les macros procédurales au besoin d'être placées dans leur
propre crate. Cette restriction pourra éventuellement être levée. La convention
pour structurer les crates et les crates de macros est la suivante : pour
une crate <code>foo</code>, une crate de macro procédurale personnalisée de dérivée doit
s'appeler <code>foo_derive</code>. Créons une nouvelle crate <code>hello_macro_derive</code> au sein
de notre projet <code>hello_macro</code> :</p>
<!--
```console
$ cargo new hello_macro_derive --lib
```
-->
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<!--
Our two crates are tightly related, so we create the procedural macro crate
within the directory of our `hello_macro` crate. If we change the trait
definition in `hello_macro`, we’ll have to change the implementation of the
procedural macro in `hello_macro_derive` as well. The two crates will need to
be published separately, and programmers using these crates will need to add
both as dependencies and bring them both into scope. We could instead have the
`hello_macro` crate use `hello_macro_derive` as a dependency and re-export the
procedural macro code. However, the way we’ve structured the project makes it
possible for programmers to use `hello_macro` even if they don’t want the
`derive` functionality.
-->
<p>Nos deux crates sont étroitement liées, donc nous créons la crate de macro
procédurale à l'intérieur du dossier de notre crate <code>hello_macro</code>. Si nous
changeons la définition du trait dans <code>hello_macro</code>, nous aurons aussi à
changer l'implémentation de la macro procédurale dans <code>hello_macro_derive</code>. Les
deux crates vont devoir être publiées séparément, et les développeurs qui vont
utiliser ces crates vont avoir besoin d'ajouter les deux dépendances et les
importer dans la portée. Nous pouvons plutôt faire en sorte que la crate
<code>hello_macro</code> utilise <code>hello_macro_derive</code> comme dépendance et ré-exporter le
code de la macro procédurale. Cependant, la façon dont nous avons structuré le
projet donne la possibilité aux développeurs d'utiliser <code>hello_macro</code> même s'ils
ne veulent pas la fonctionnalité <code>derive</code>.</p>
<!--
We need to declare the `hello_macro_derive` crate as a procedural macro crate.
We’ll also need functionality from the `syn` and `quote` crates, as you’ll see
in a moment, so we need to add them as dependencies. Add the following to the
*Cargo.toml* file for `hello_macro_derive`:
-->
<p>Nous devons déclarer la crate <code>hello_macro_derive</code> comme étant une crate de
macro procédurale. Nous allons aussi avoir besoin des fonctionnalités des
crates <code>syn</code> et <code>quote</code>, comme vous allez de constater bientôt, donc nous
allons les ajouter comme dépendances. Ajoutez ceci dans le fichier <em>Cargo.toml</em>
de <code>hello_macro_derive</code> :</p>
<!--
<span class="filename">Filename: hello_macro_derive/Cargo.toml</span>
-->
<p><span class="filename">Fichier : hello_macro_derive/Cargo.toml</span></p>
<!--
```toml
[lib]
proc-macro = true

[dependencies]
syn = "1.0"
quote = "1.0"
```
-->
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;1.0&quot;
quote = &quot;1.0&quot;
</code></pre>
<!--
To start defining the procedural macro, place the code in Listing 19-31 into
your *src/lib.rs* file for the `hello_macro_derive` crate. Note that this code
won’t compile until we add a definition for the `impl_hello_macro` function.
-->
<p>Pour commencer à définir la macro procédurale, placez le code de l'encart 19-31
dans votre fichier <em>src/lib.rs</em> de la crate <code>hello_macro_derive</code>. Notez que ce
code ne se compilera pas tant que nous n'ajouterons pas une définition pour la
fonction <code>impl_hello_macro</code>.</p>
<!--
<span class="filename">Filename: hello_macro_derive/src/lib.rs</span>
-->
<p><span class="filename">Fichier : hello_macro_derive/src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&ast)
}
```
-->
<pre><code class="language-rust ignore does_not_compile">extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construit une représentation du code Rust en arborescence
    // syntaxique que nous pouvons manipuler
    let ast = syn::parse(input).unwrap();

    // Construit l'implémentation du trait
    impl_hello_macro(&amp;ast)
}
</code></pre>
<!--
<span class="caption">Listing 19-31: Code that most procedural macro crates
will require in order to process Rust code</span>
-->
<p><span class="caption">Encart 19-31 : du code que la plupart des macros
procédurales auront besoin pour travailler avec du code Rust</span></p>
<!--
Notice that we’ve split the code into the `hello_macro_derive` function, which
is responsible for parsing the `TokenStream`, and the `impl_hello_macro`
function, which is responsible for transforming the syntax tree: this makes
writing a procedural macro more convenient. The code in the outer function
(`hello_macro_derive` in this case) will be the same for almost every
procedural macro crate you see or create. The code you specify in the body of
the inner function (`impl_hello_macro` in this case) will be different
depending on your procedural macro’s purpose.
-->
<p>Remarquez que nous avons divisé le code dans la fonction <code>hello_macro_derive</code>,
qui est responsable de parcourir le <code>TokenStream</code>, et la fonction
<code>impl_hello_macro</code>, qui est responsable de transformer l'arborescence
syntaxique : cela facilite l'écriture de la macro procédurale. Le code dans la
fonction englobante (qui est <code>hello_macro_derive</code> dans notre cas) sera le même
pour presque toutes les crates de macro procédurales que vous allez voir ou
créer. Le code que vous renseignez dans le corps de la fonction (qui est
<code>impl_hello_macro</code> dans notre cas) diffèrera en fonction de ce que fait votre
macro procédurale.</p>
<!--
We’ve introduced three new crates: `proc_macro`, [`syn`], and [`quote`]. The
`proc_macro` crate comes with Rust, so we didn’t need to add that to the
dependencies in *Cargo.toml*. The `proc_macro` crate is the compiler’s API that
allows us to read and manipulate Rust code from our code.
-->
<p>Nous avons ajouté trois nouvelles crates : <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a>, et <a href="https://crates.io/crates/quote"><code>quote</code></a>.
La crate <code>proc_macro</code> est fournie par Rust, donc nous n'avons pas besoin de
l'ajouter aux dépendances dans <em>Cargo.toml</em>. La crate <code>proc_macro</code> fournit une
API du compilateur qui nous permet de lire et manipuler le code Rust à partir de
notre code.</p>
<!--
[`syn`]: https://crates.io/crates/syn
[`quote`]: https://crates.io/crates/quote
-->
<!--
The `syn` crate parses Rust code from a string into a data structure that we
can perform operations on. The `quote` crate turns `syn` data structures back
into Rust code. These crates make it much simpler to parse any sort of Rust
code we might want to handle: writing a full parser for Rust code is no simple
task.
-->
<p>La crate <code>syn</code> transforme le code Rust d'une chaîne de caractères en une
structure de données sur laquelle nous pouvons procéder à des opérations. La
crate <code>quote</code> re-transforme les structures de données de <code>syn</code> en code Rust.
Ces crates facilite le parcours de toute sorte de code Rust que nous aurions
besoin de gérer : l'écriture d'un interpréteur complet de code Rust n'a jamais
été aussi facile.</p>
<!--
The `hello_macro_derive` function will be called when a user of our library
specifies `#[derive(HelloMacro)]` on a type. This is possible because we’ve
annotated the `hello_macro_derive` function here with `proc_macro_derive` and
specified the name, `HelloMacro`, which matches our trait name; this is the
convention most procedural macros follow.
-->
<p>La fonction <code>hello_macro_derive</code> va être appelée lorsqu'un utilisateur de notre
bibliothèque utilisera <code>#[derive(HelloMacro)]</code> sur un type. Cela sera possible
car nous avons annoté notre fonction <code>hello_macro_derive</code> avec
<code>proc_macro_derive</code> et nous avons renseigné le nom, <code>HelloMacro</code>, qui
correspond au nom de notre trait ; c'est la convention que la plupart des
macros procédurales doivent suivre.</p>
<!--
The `hello_macro_derive` function first converts the `input` from a
`TokenStream` to a data structure that we can then interpret and perform
operations on. This is where `syn` comes into play. The `parse` function in
`syn` takes a `TokenStream` and returns a `DeriveInput` struct representing the
parsed Rust code. Listing 19-32 shows the relevant parts of the `DeriveInput`
struct we get from parsing the `struct Pancakes;` string:
-->
<p>La fonction <code>hello_macro_derive</code> commence par convertir le <code>input</code> qui est un
<code>TokenStream</code> en une structure de données que nous pouvons ensuite interpréter
et y faire des opérations dessus. C'est là que <code>syn</code> rentre en jeu. La fonction
<code>parse</code> de <code>syn</code> prend un <code>TokenStream</code> et retourne une structure <code>DeriveInput</code>
qui représente le code Rust. L'encart 19-32 montre les parties intéressantes de
la structure <code>DeriveInput</code> que nous obtenons en convertissant la chaîne de
caractères <code>struct Pancakes;</code> :</p>
<!--
```rust,ignore
DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
```
-->
<pre><code class="language-rust ignore">DeriveInput {
    // -- partie masquée ici --

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
</code></pre>
<!--
<span class="caption">Listing 19-32: The `DeriveInput` instance we get when
parsing the code that has the macro’s attribute in Listing 19-30</span>
-->
<p><span class="caption">Encart 19-32 : l'instance de <code>DeriveInput</code> que nous
obtenons lorsque nous convertissons le code qui l'attribut de la macro dans
l'encart 19-30</span></p>
<!--
The fields of this struct show that the Rust code we’ve parsed is a unit struct
with the `ident` (identifier, meaning the name) of `Pancakes`. There are more
fields on this struct for describing all sorts of Rust code; check the [`syn`
documentation for `DeriveInput`][syn-docs] for more information.
-->
<p>Les champs de cette structure montrent que ce code Rust que nous avons converti
est une structure unitaire avec l'<code>ident</code> (raccourci de <code>identifier</code>, qui
désigne le nom) <code>Pancakes</code>. Il y a d'autres champs sur cette structure
décrivant toutes sortes de codes Rust ; regardez la
<a href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html">documentation de <code>syn</code> pour <code>DeriveInput</code></a> pour en savoir plus.</p>
<!--
[syn-docs]: https://docs.rs/syn/1.0/syn/struct.DeriveInput.html
-->
<!--
Soon we’ll define the `impl_hello_macro` function, which is where we’ll build
the new Rust code we want to include. But before we do, note that the output
for our derive macro is also a `TokenStream`. The returned `TokenStream` is
added to the code that our crate users write, so when they compile their crate,
they’ll get the extra functionality that we provide in the modified
`TokenStream`.
-->
<p>Bientôt, nous définirons la fonction <code>impl_hello_macro</code>, qui nous permettra de
construire de nous code Rust que nous souhaitons injecter. Mais avant de faire
cela, remarquez que la sortie de notre macro derive est aussi un <code>TokenStream</code>.
Le <code>TokenStream</code> retourné est ajouté au code que les utilisateurs de notre
crate ont écrit, donc lorsqu'ils compilent leur crate, ils récupéreront la
fonctionnalité additionnelle que nous injectons dans le <code>TokenStream</code> modifié.</p>
<!--
You might have noticed that we’re calling `unwrap` to cause the
`hello_macro_derive` function to panic if the call to the `syn::parse` function
fails here. It’s necessary for our procedural macro to panic on errors because
`proc_macro_derive` functions must return `TokenStream` rather than `Result` to
conform to the procedural macro API. We’ve simplified this example by using
`unwrap`; in production code, you should provide more specific error messages
about what went wrong by using `panic!` or `expect`.
-->
<p>Vous avez peut-être remarqué que nous faisons appel à <code>unwrap</code> pour faire
paniquer la fonction <code>hello_macro_derive</code> si l'appel à la fonction <code>syn::parse</code>
que nous faisons échoue. Il est nécessaire de faire paniquer notre macro
procédurale si elle rencontre des erreurs car les fonctions <code>proc_macro_derive</code>
doivent retourner un <code>TokenStream</code> plutôt qu'un <code>Result</code> pour se conformer à
l'API de la macro procédurale. Nous avons simplifié cet exemple en utilisant
<code>unwrap</code> ; dans du code en production, vous devriez renseigner des messages
d'erreur plus précis sur ce qui s'est mal passé en utilisant <code>panic!</code> ou
<code>expect</code>.</p>
<!--
Now that we have the code to turn the annotated Rust code from a `TokenStream`
into a `DeriveInput` instance, let’s generate the code that implements the
`HelloMacro` trait on the annotated type, as shown in Listing 19-33.
-->
<p>Maintenant que nous avons le code pour transformer le code Rust annoté d'un
<code>TokenStream</code> en une instance de <code>DeriveInput</code>, créons le code qui implémente le
trait <code>HelloMacro</code> sur le type annoté, comme l'encart 19-33.</p>
<!--
<span class="filename">Filename: hello_macro_derive/src/lib.rs</span>
-->
<p><span class="filename">Fichier : hello_macro_derive/src/lib.rs</span></p>
<!--
```rust,ignore
# extern crate proc_macro;
# 
# use proc_macro::TokenStream;
# use quote::quote;
# use syn;
# 
# #[proc_macro_derive(HelloMacro)]
# pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
#     // Construct a representation of Rust code as a syntax tree
#     // that we can manipulate
#     let ast = syn::parse(input).unwrap();
# 
#     // Build the trait implementation
#     impl_hello_macro(&ast)
# }
# 
fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">extern crate proc_macro;
</span><span class="boring">
</span><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">use syn;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construit une représentation du code Rust en arborescence
</span><span class="boring">    // syntaxique que nous pouvons manipuler
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Construit l'implémentation du trait
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let nom = &amp;ast.ident;
    let generation = quote! {
        impl HelloMacro for #nom {
            fn hello_macro() {
                println!(&quot;Hello, Macro ! Mon nom est {}&quot;, stringify!(#nom));
            }
        }
    };
    generation.into()
}
</code></pre>
<!--
<span class="caption">Listing 19-33: Implementing the `HelloMacro` trait using
the parsed Rust code</span>
-->
<p><span class="caption">Encart 19-33 : implémentation du trait <code>HelloMacro</code> en
utilisant le code Rust interprété</span></p>
<!--
We get an `Ident` struct instance containing the name (identifier) of the
annotated type using `ast.ident`. The struct in Listing 19-32 shows that when
we run the `impl_hello_macro` function on the code in Listing 19-30, the
`ident` we get will have the `ident` field with a value of `"Pancakes"`. Thus,
the `name` variable in Listing 19-33 will contain an `Ident` struct instance
that, when printed, will be the string `"Pancakes"`, the name of the struct in
Listing 19-30.
-->
<p>Nous obtenons une instance de structure <code>Ident</code> qui contient le nom
(<code>identifier</code>) du type annoté en utilisant <code>ast.ident</code>. La structure de l'encart
19-32 montre ceci lorsque nous exécutons la fonction <code>impl_hello_macro</code> sur le
code de l'encart 19-30, le <code>ident</code> que nous obtenons aura le champ <code>ident</code> avec
la valeur <code>&quot;Pancakes&quot;</code>. Ainsi, la variable <code>nom</code> de l'encart 19-33 contiendra
une instance de la structure <code>Ident</code> qui, une fois affichée, sera la chaîne de
caractères <code>&quot;Pancakes&quot;</code>, le nom de la structure de l'encart 19-30.</p>
<!--
The `quote!` macro lets us define the Rust code that we want to return. The
compiler expects something different to the direct result of the `quote!`
macro’s execution, so we need to convert it to a `TokenStream`. We do this by
calling the `into` method, which consumes this intermediate representation and
returns a value of the required `TokenStream` type.
-->
<p>La macro <code>quote!</code> nous permet de définir le code Rust que nous souhaitons
retourner. Le compilateur attend quelque chose de différent en résultat que le
ce qui correspond à l'exécution de <code>quote!</code>, donc nous devons le convertir en
<code>TokenStream</code>. Nous faisons ceci en faisant appel à la méthode <code>into</code>, qui se
base sur cette représentation intermédiaire et retourne une valeur attendue,
comme ici du type <code>TokenStream</code>.</p>
<!--
The `quote!` macro also provides some very cool templating mechanics: we can
enter `#name`, and `quote!` will replace it with the value in the variable
`name`. You can even do some repetition similar to the way regular macros work.
Check out [the `quote` crate’s docs][quote-docs] for a thorough introduction.
-->
<p>La macro <code>quote!</code> fournit aussi quelques mécaniques de gabarit intéressantes :
nous pouvons entrer <code>#nom</code>, et <code>quote!</code> va le remplacer avec la valeur dans la
variable <code>nom</code>. Vous pouvez même procéder à quelques répétions de façon
similaire au fonctionnement des macros classiques. Regardez dans
<a href="https://docs.rs/quote">la documentation de <code>quote</code></a> pour une présentation plus détaillée.</p>
<!--
[quote-docs]: https://docs.rs/quote
-->
<!--
We want our procedural macro to generate an implementation of our `HelloMacro`
trait for the type the user annotated, which we can get by using `#name`. The
trait implementation has one function, `hello_macro`, whose body contains the
functionality we want to provide: printing `Hello, Macro! My name is` and then
the name of the annotated type.
-->
<p>Nous souhaitons que notre macro procédurale génère une implémentation de notre
trait <code>HelloMacro</code> pour le type que l'utilisateur a annoté, que nous pouvons
obtenir en utilisant <code>#nom</code>. L'implémentation du trait utilise une fonction,
<code>hello_macro</code>, dont le corps contient la fonctionnalité que nous souhaitons
fournir : l'affichage de <code>Hello, Macro ! Mon nom est</code> suivi par le nom du type
annoté.</p>
<!--
The `stringify!` macro used here is built into Rust. It takes a Rust
expression, such as `1 + 2`, and at compile time turns the expression into a
string literal, such as `"1 + 2"`. This is different than `format!` or
`println!`, macros which evaluate the expression and then turn the result into
a `String`. There is a possibility that the `#name` input might be an
expression to print literally, so we use `stringify!`. Using `stringify!` also
saves an allocation by converting `#name` to a string literal at compile time.
-->
<p>La macro <code>stringify!</code> utilisée ici est écrite en Rust. Elle prend en argument
une expression Rust, comme <code>1 + 2</code>, et à la compilation transforme l'expression
en une chaîne de caractères littérale, comme <code>&quot;1 + 2&quot;</code>. Cela est différent de
<code>format!</code> ou de <code>println!</code>, des macros qui évaluent l'expression et retourne
ensuite le résultat dans une <code>String</code>. Il est possible que l'entrée <code>#nom</code> soit
une expression à écrire littéralement, donc nous utilisons <code>stringify!</code>.
L'utilisation de <code>stringify!</code> évite aussi une allocation en convertissant <code>#nom</code>
en une chaine de caractères littérale à la compilation.</p>
<!--
At this point, `cargo build` should complete successfully in both `hello_macro`
and `hello_macro_derive`. Let’s hook up these crates to the code in Listing
19-30 to see the procedural macro in action! Create a new binary project in
your *projects* directory using `cargo new pancakes`. We need to add
`hello_macro` and `hello_macro_derive` as dependencies in the `pancakes`
crate’s *Cargo.toml*. If you’re publishing your versions of `hello_macro` and
`hello_macro_derive` to [crates.io](https://crates.io/), they would be regular
dependencies; if not, you can specify them as `path` dependencies as follows:
-->
<p>Maintenant, <code>cargo build</code> devrait fonctionner correctement pour <code>hello_macro</code> et
<code>hello_macro_derive</code>. Relions maintenant ces crates au code de l'encart 19-30
pour voir les macros procédurales à l'oeuvre ! Créez un nouveau projet binaire
dans votre dossier <em>projects</em> en utilisant <code>cargo new pancakes</code>. Nous avons
besoin d'ajouter <code>hello_macro</code> et <code>hello_macro_derive</code> comme dépendances dans le
<em>Cargo.toml</em> de la crate <code>pancakes</code>. Si vous publiez vos versions de
<code>hello_macro</code> et de <code>hello_macro_derive</code> sur <a href="https://crates.io">crates.io</a>,
elles sont des dépendances classiques ; sinon, vous pouvez les renseigner comme
dépendance locale avec <code>path</code> comme ceci :</p>
<!--
```toml
[dependencies]
hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
```
-->
<pre><code class="language-toml">[dependencies]
hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<!--
Put the code in Listing 19-30 into *src/main.rs*, and run `cargo run`: it
should print `Hello, Macro! My name is Pancakes!` The implementation of the
`HelloMacro` trait from the procedural macro was included without the
`pancakes` crate needing to implement it; the `#[derive(HelloMacro)]` added the
trait implementation.
-->
<p>Renseignez le code l'encart 19-30 dans <em>src/main.rs</em>, puis lancez <code>cargo run</code> :
cela devrait afficher <code>Hello, Macro ! Mon nom est Pancakes !</code>. L'implémentation
du trait <code>HelloMacro</code> à l'aide de la macro procédurale est injectée sans que la
crate <code>pancakes</code> n'ai besoin de le faire manuellement ; le
<code>#[derive(HelloMacro)]</code> a rajouté automatiquement l'implémentation du trait.</p>
<!--
Next, let’s explore how the other kinds of procedural macros differ from custom
derive macros.
-->
<p>Maintenant, découvrons comment les autres types de macros procédurales se
distinguent des macros derive personnalisées.</p>
<!--
### Attribute-like macros
-->
<h3 id="les-macros-qui-ressemblent-à-des-attributs"><a class="header" href="#les-macros-qui-ressemblent-à-des-attributs">Les macros qui ressemblent à des attributs</a></h3>
<!--
Attribute-like macros are similar to custom derive macros, but instead of
generating code for the `derive` attribute, they allow you to create new
attributes. They’re also more flexible: `derive` only works for structs and
enums; attributes can be applied to other items as well, such as functions.
Here’s an example of using an attribute-like macro: say you have an attribute
named `route` that annotates functions when using a web application framework:
-->
<p>Les macros qui ressemblent à des attributs ressemblent aux macros derive
personnalisées, mais au lieu de générer du code pour l'attribut <code>derive</code>, elles
vous permettent de créer des nouveaux attributs. Elles sont aussi plus
flexibles : <code>derive</code> fonctionne uniquement pour les structures et les
énumérations ; les attributs peuvent être aussi appliqués aux autres éléments,
comme les fonctions. Voici un exemple d'utilisation d'une macro qui ressemble à
un attribut : imaginons que vous avez un attribut <code>chemin</code> qui est une
annotation pour des fonctions lorsque vous utilisez un environnement de
développement d'application web :</p>
<!--
```rust,ignore
#[route(GET, "/")]
fn index() {
```
-->
<pre><code class="language-rust ignore">#[chemin(GET, &quot;/&quot;)]
fn index() {
</code></pre>
<!--
This `#[route]` attribute would be defined by the framework as a procedural
macro. The signature of the macro definition function would look like this:
-->
<p>Cet attribut <code>#[chemin]</code> sera défini par l'environnement de développement comme
étant une macro procédurale. La signature de la fonction de définition de la
macro ressemblera à ceci :</p>
<!--
```rust,ignore
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
```
-->
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn chemin(attribut: TokenStream, element: TokenStream) -&gt; TokenStream {
</code></pre>
<!--
Here, we have two parameters of type `TokenStream`. The first is for the
contents of the attribute: the `GET, "/"` part. The second is the body of the
item the attribute is attached to: in this case, `fn index() {}` and the rest
of the function’s body.
-->
<p>Maintenant, nous avons deux paramètres de type <code>TokenStream</code>. Le premier
correspond au contenu de l'attribut : la partie <code>GET, &quot;/&quot;</code>. Le second est le
corps de l'élément sur lequel cet attribut sera appliqué : dans notre cas,
<code>fn index() {}</code> et le reste du corps de la fonction.</p>
<!--
Other than that, attribute-like macros work the same way as custom derive
macros: you create a crate with the `proc-macro` crate type and implement a
function that generates the code you want!
-->
<p>Mis à part cela, les macros qui ressemblent à des attributs fonctionnent de la
même manière que les macros derive personnalisées : vous générez une crate avec
le type de la crate <code>proc-macro</code> et implémentez une fonction qui génèrera le
code que vous souhaitez !</p>
<!--
### Function-like macros
-->
<h3 id="les-macros-qui-ressemblent-à-des-fonctions"><a class="header" href="#les-macros-qui-ressemblent-à-des-fonctions">Les macros qui ressemblent à des fonctions</a></h3>
<!--
Function-like macros define macros that look like function calls. Similarly to
`macro_rules!` macros, they’re more flexible than functions; for example, they
can take an unknown number of arguments. However, `macro_rules!` macros can be
defined only using the match-like syntax we discussed in the section
[“Declarative Macros with `macro_rules!` for General Metaprogramming”][decl]
earlier. Function-like macros take a `TokenStream` parameter and their
definition manipulates that `TokenStream` using Rust code as the other two
types of procedural macros do. An example of a function-like macro is an `sql!`
macro that might be called like so:
-->
<p>Les macros qui ressemblent à des fonctions définissent des macros qui
ressemblent à des appels de fonction. De la même manière que les macros
<code>macro_rules!</code>, elles sont plus flexibles que les fonctions ; par exemple, elles
peuvent prendre une quantité non finie d'arguments. Cependant, les macros
<code>macro_rules!</code> peuvent être définies uniquement en utilisant la syntaxe qui
ressemble à <code>match</code> que nous avons vu dans <a href="ch19-06-macros.html#les-macros-d%C3%A9claratives-avec-macro_rules-pour-la-m%C3%A9taprogrammation-g%C3%A9n%C3%A9rale">une section précédente</a>. Les
macros qui ressemblent à des fonctions prennent en paramètre un <code>TokenStream</code> et
leurs définitions manipulent ce <code>TokenStream</code> en utilisant du code Rust comme le
font les deux autres types de macros procédurales. Voici un exemple d'une macro
qui ressemble à une fonction qui est une macro <code>sql!</code> qui devrait être utilisée
comme ceci :</p>
<!--
[decl]: #declarative-macros-with-macro_rules-for-general-metaprogramming
-->
<!--
```rust,ignore
let sql = sql!(SELECT * FROM posts WHERE id=1);
```
-->
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM publications WHERE id=1);
</code></pre>
<!--
This macro would parse the SQL statement inside it and check that it’s
syntactically correct, which is much more complex processing than a
`macro_rules!` macro can do. The `sql!` macro would be defined like this:
-->
<p>Cette macro devrait interpréter l'instruction SQL qu'on lui envoie et vérifier
si elle est syntaxiquement correcte, ce qui est un procédé bien plus complexe
que ce qu'une macro <code>macro_rules!</code> peut faire. La macro <code>sql!</code> sera définie
comme ceci :</p>
<!--
```rust,ignore
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
```
-->
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
</code></pre>
<!--
This definition is similar to the custom derive macro’s signature: we receive
the tokens that are inside the parentheses and return the code we wanted to
generate.
-->
<p>Cette définition ressemble à la signature de la macro derive personnalisée :
nous récupérons les éléments entre parenthèses et retournons le code que nous
souhaitons générer.</p>
<!--
## Summary
-->
<h2 id="résumé-18"><a class="header" href="#résumé-18">Résumé</a></h2>
<!--
Whew! Now you have some Rust features in your toolbox that you won’t use often,
but you’ll know they’re available in very particular circumstances. We’ve
introduced several complex topics so that when you encounter them in error
message suggestions or in other peoples’ code, you’ll be able to recognize
these concepts and syntax. Use this chapter as a reference to guide you to
solutions.
-->
<p>Ouah ! Maintenant vous avez quelques fonctionnalités de Rust supplémentaires
dans votre boite à outils que vous utiliserez probablement rarement, mais vous
savez maintenant qu'elles vous aideront dans des situations très particulières.
Nous avons abordé plusieurs sujets complexes afin que vous puissiez les
reconnaître ainsi que leur syntaxe lorsque vous les rencontrerez dans des
messages de suggestions dans des erreurs ou dans du code de quelqu'un d'autre.
Utilisez ce chapitre comme référence pour vous guider vers ces solutions.</p>
<!--
Next, we’ll put everything we’ve discussed throughout the book into practice
and do one more project!
-->
<p>Au chapitre suivant, nous allons mettre en pratique tout ce que nous avons
appris dans ce livre en l'appliquant à un nouveau projet !</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--31"><a class="header" href="#-attention-peinture-fraîche--31">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/214">Pull Request</a>.</p>
</blockquote>
<!--
# Final Project: Building a Multithreaded Web Server
-->
<h1 id="projet-final--construire-un-serveur-web-multitâches"><a class="header" href="#projet-final--construire-un-serveur-web-multitâches">Projet final : construire un serveur web multitâches</a></h1>
<!--
It’s been a long journey, but we’ve reached the end of the book. In this
chapter, we’ll build one more project together to demonstrate some of the
concepts we covered in the final chapters, as well as recap some earlier
lessons.
-->
<p>Cela a été un long voyage, mais nous avons atteint la fin de ce livre. Dans ce
chapitre, nous allons construire un nouveau projet ensemble pour mettre en
application certains concepts que nous avons vu dans les derniers chapitres, et
aussi pour récapituler quelques leçons précédentes.</p>
<!--
For our final project, we’ll make a web server that says “hello” and looks like
Figure 20-1 in a web browser.
-->
<p>Pour notre projet final, nous allons construire un serveur web qui dit
“salutations” et qui ressemble dans un navigateur web à l'illustration 20-1.</p>
<!--
![hello from rust](img/trpl20-01.png)
-->
<p><img src="img/trpl20-01.png" alt="bonjour de la part de Rust" /></p>
<!--
<span class="caption">Figure 20-1: Our final shared project</span>
-->
<p><span class="caption">Illustration 20-1 : notre dernier projet en commun</span></p>
<!--
Here is the plan to build the web server:
-->
<p>Voici le plan de construction du serveur web :</p>
<!--
1. Learn a bit about TCP and HTTP.
2. Listen for TCP connections on a socket.
3. Parse a small number of HTTP requests.
4. Create a proper HTTP response.
5. Improve the throughput of our server with a thread pool.
-->
<ol>
<li>En savoir plus sur TCP et HTTP.</li>
<li>Ecouter les connections TCP sur un port.</li>
<li>Interpréter une petite quantité de requêtes HTTP.</li>
<li>Créer une réponse HTTP adéquate.</li>
<li>Augmenter le débit de notre serveur avec un groupe de tâches.</li>
</ol>
<!--
But before we get started, we should mention one detail: the method we’ll use
won’t be the best way to build a web server with Rust. A number of
production-ready crates are available on [crates.io](https://crates.io/) that
provide more complete web server and thread pool implementations than we’ll
build.
-->
<p>Mais avant de commencer, nous devons signaler une chose : les méthodes que nous
allons utiliser ne sont pas les meilleures pour construire un serveur web avec
Rust. Un certain nombre de crate mâtures pour la production disponibles sur
<a href="https://crates.io/">crates.io</a> fourniront des serveurs web et des
implémentations de groupe de tâches plus complets que ce que nous allons
construire.</p>
<!--
However, our intention in this chapter is to help you learn, not to take the
easy route. Because Rust is a systems programming language, we can choose the
level of abstraction we want to work with and can go to a lower level than is
possible or practical in other languages. We’ll write the basic HTTP server and
thread pool manually so you can learn the general ideas and techniques behind
the crates you might use in the future.
-->
<p>Toutefois, notre intention dans ce chapitre est de vous aider à apprendre, et
non pas de se laisser aller à la facilité. Comme Rust est un langage de
programmation de systèmes, nous pouvons choisir le niveau d'abstraction sur
lequel nous souhaitons travailler et nous pouvons descendre à un niveau plus bas
que ce qui est possible ou praticable dans d'autres langages. Nous allons écrire
manuellement le serveur HTTP basique et le groupe de tâches pour que vous
puissiez apprendre les idées et techniques générales derrière les crates que
vous serez peut-être amenés à utiliser à l'avenir.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--32"><a class="header" href="#-attention-peinture-fraîche--32">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/215">Pull Request</a>.</p>
</blockquote>
<!--
## Building a Single-Threaded Web Server
-->
<h2 id="développer-un-serveur-web-monotâche"><a class="header" href="#développer-un-serveur-web-monotâche">Développer un serveur web monotâche</a></h2>
<!--
We’ll start by getting a single-threaded web server working. Before we begin,
let’s look at a quick overview of the protocols involved in building web
servers. The details of these protocols are beyond the scope of this book, but
a brief overview will give you the information you need.
-->
<p>Nous allons commencer par faire fonctionner un serveur web avec une seule tâche.
Avant de commencer, faisons un survol rapide des protocoles utilisés dans les
serveurs web. Les détails de ces protocoles ne sont pas le sujet de ce livre,
mais un rapide aperçu vous donnera les informations dont vous avez besoin.</p>
<!--
The two main protocols involved in web servers are the *Hypertext Transfer
Protocol* *(HTTP)* and the *Transmission Control Protocol* *(TCP)*. Both
protocols are *request-response* protocols, meaning a *client* initiates
requests and a *server* listens to the requests and provides a response to the
client. The contents of those requests and responses are defined by the
protocols.
-->
<p>Les deux principaux protocoles utilisés dans les serveurs web sont le
<em>Hypertext Transfer Protocol</em> <em>(HTTP)</em> et le <em>Transmission Control Protocol</em>
<em>(TCP)</em>. Ces deux protocoles sont des protocoles de type <em>demande-réponse</em>, ce
qui signifie qu'un <em>client</em> démarre les requêtes, et le <em>serveur</em> écoute les
requêtes et fournit une réponse au client. Le contenu de ces requêtes et
réponses est défini par les protocoles.</p>
<!--
TCP is the lower-level protocol that describes the details of how information
gets from one server to another but doesn’t specify what that information is.
HTTP builds on top of TCP by defining the contents of the requests and
responses. It’s technically possible to use HTTP with other protocols, but in
the vast majority of cases, HTTP sends its data over TCP. We’ll work with the
raw bytes of TCP and HTTP requests and responses.
-->
<p>TCP est le protocole le plus bas-niveau qui décrit les détails de comment une
information passe d'un serveur à un autre mais ne précise pas ce qu'est cette
information. HTTP est construit sur TCP en définissant le contenu des requêtes et
des réponses. Il est techniquement possible d'utiliser HTTP avec d'autres
protocoles, mais dans la grande majorité des cas, HTTP envoie ses données via
TCP. Nous allons travailler avec les octets bruts des requêtes et des réponses
de TCP et HTTP.</p>
<!--
### Listening to the TCP Connection
-->
<h3 id="ecouter-les-connexions-tcp"><a class="header" href="#ecouter-les-connexions-tcp">Ecouter les connexions TCP</a></h3>
<!--
Our web server needs to listen to a TCP connection, so that’s the first part
we’ll work on. The standard library offers a `std::net` module that lets us do
this. Let’s make a new project in the usual fashion:
-->
<p>Notre serveur web a besoin d'écouter les connexions TCP, donc cela sera la
première partie sur laquelle nous travaillerons. La bibliothèque standard offre
un module <code>std::net</code> qui nous permet de faire ceci. Créons un nouveau projet de
manière habituelle :</p>
<!--
```console
$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
```
-->
<pre><code class="language-console">$ cargo new salutations
     Created binary (application) `salutations` project
$ cd salutations
</code></pre>
<!--
Now enter the code in Listing 20-1 in *src/main.rs* to start. This code will
listen at the address `127.0.0.1:7878` for incoming TCP streams. When it gets
an incoming stream, it will print `Connection established!`.
-->
<p>Maintenant, saisissez le code de l'encart 20-1 dans <em>src/main.rs</em> pour
commencer. Ce code va écouter les flux TCP entrants à l'adresse
<code>127.0.0.1:7878</code>. Lorsqu'il obtiendra un flux entrant, il va afficher
<code>Connexion établie !</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,no_run
use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("Connection established!");
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for flux in ecouteur.incoming() {
        let flux = flux.unwrap();

        println!(&quot;Connexion établie !&quot;);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-1: Listening for incoming streams and printing
a message when we receive a stream</span>
-->
<p><span class="caption">Encart 20-1 : écoute des flux entrants et affichage d'un
message lorsque nous recevons un flux</span></p>
<!--
Using `TcpListener`, we can listen for TCP connections at the address
`127.0.0.1:7878`. In the address, the section before the colon is an IP address
representing your computer (this is the same on every computer and doesn’t
represent the authors’ computer specifically), and `7878` is the port. We’ve
chosen this port for two reasons: HTTP is normally accepted on this port, and
7878 is *rust* typed on a telephone.
-->
<p>En utilisant <code>TcpListener</code>, nous pouvons écouter les connexions TCP à l'adresse
<code>127.0.0.1:7878</code>. Dans cette adresse, la partie avant les double-points est une
adresse IP qui représente votre ordinateur (c'est la même sur chaque ordinateur
et ne représente pas précisément l'ordinateur de l'auteur), et <code>7878</code> est le
port. Nous avons choisi ce port pour deux raisons : HTTP est habituellement
accepté sur ce port, et 7878 correspond aux touches utilisées sur un clavier de
téléphone pour écrire <em>Rust</em>.</p>
<!--
The `bind` function in this scenario works like the `new` function in that it
will return a new `TcpListener` instance. The reason the function is called
`bind` is that in networking, connecting to a port to listen to is known as
“binding to a port.”
-->
<p>La fonction <code>bind</code> dans ce scénario fonctionne comme la fonction <code>new</code> dans le
sens où elle retourne une nouvelle instance de <code>TcpListener</code>. La raison pour
laquelle cette fonction s'appelle <code>bind</code> <em>(NdT : signifie &quot;lier&quot;)</em> est que dans
les réseaux, connecter un port à écouter se dit aussi “lier à un port”.</p>
<!--
The `bind` function returns a `Result<T, E>`, which indicates that binding
might fail. For example, connecting to port 80 requires administrator
privileges (nonadministrators can listen only on ports higher than 1024), so if
we tried to connect to port 80 without being an administrator, binding wouldn’t
work. As another example, binding wouldn’t work if we ran two instances of our
program and so had two programs listening to the same port. Because we’re
writing a basic server just for learning purposes, we won’t worry about
handling these kinds of errors; instead, we use `unwrap` to stop the program if
errors happen.
-->
<p>La fonction <code>bind</code> retourne un <code>Result&lt;T, E&gt;</code>, ce qui signifie que la création
de lien peut échouer. Par exemple, la connexion au port 80 nécessite d'être
administrateur (les utilisateurs non-administrateur ne peuvent écouter que sur
les ports supérieurs à 1024), donc si nous essayons de connecter un port 80
sans être administrateur, le lien ne va pas fonctionner. Un autre exemple, le
lien ne va pas fonctionner si nous exécutons deux instances de notre programme
et que nous avons deux programmes qui écoutent sur le même port. Comme nous
écrivons un serveur basique uniquement à but pédagogique, nous n'avons pas à
nous soucier de la gestion de ce genre d'erreur ; c'est pourquoi nous utilisons
<code>unwrap</code> pour arrêter l'exécution du programme si des erreurs arrivent.</p>
<!--
The `incoming` method on `TcpListener` returns an iterator that gives us a
sequence of streams (more specifically, streams of type `TcpStream`). A single
*stream* represents an open connection between the client and the server. A
*connection* is the name for the full request and response process in which a
client connects to the server, the server generates a response, and the server
closes the connection. As such, `TcpStream` will read from itself to see what
the client sent and then allow us to write our response to the stream. Overall,
this `for` loop will process each connection in turn and produce a series of
streams for us to handle.
-->
<p>La méthode <code>incoming</code> d'un <code>TcpListener</code> retourne l'itérateur qui nous donne une
séquence de flux (plus précisément, des flux de type <code>TcpStream</code>). Un seul
<em>flux</em> représente une connexion entre le client et le serveur. Une <em>connexion</em>
est le nom qui désigne tout le processus désignant la requête ainsi que la
réponse, durant lequel le client se connecte au serveur, le serveur génère une
réponse, et le serveur ferme la connexion. Ainsi, <code>TcpStream</code> va se lire
lui-même pour voir ce que le client a envoyé et nous permettre ensuite d'écrire
notre réponse dans le flux. De manière générale, cette boucle <code>for</code> traitera
chaque connexion dans l'ordre et produire nous une série de flux pour que nous
puissions les gérer.</p>
<!--
For now, our handling of the stream consists of calling `unwrap` to terminate
our program if the stream has any errors; if there aren’t any errors, the
program prints a message. We’ll add more functionality for the success case in
the next listing. The reason we might receive errors from the `incoming` method
when a client connects to the server is that we’re not actually iterating over
connections. Instead, we’re iterating over *connection attempts*. The
connection might not be successful for a number of reasons, many of them
operating system specific. For example, many operating systems have a limit to
the number of simultaneous open connections they can support; new connection
attempts beyond that number will produce an error until some of the open
connections are closed.
-->
<p>Pour l'instant, notre gestion des flux consiste à appeler <code>unwrap</code> pour arrêter
notre programme si le flux rencontre une erreur ; s'il n'y a pas d'erreurs, le
programme affiche un message. Nous allons ajouter plus de fonctionnalités dans
le cas de succès dans le prochain encart. La raison pour laquelle nous pourrions
recevoir des erreurs de la méthode <code>incoming</code> lorsqu'un client se connecte au
serveur est qu'en réalité nous n'itérons pas sur les connexions. En effet, nous
itérons sur des <em>tentatives de connexion</em>. La connexion peut échouer pour de
nombreuses raisons, beaucoup d'entre elles sont spécifiques au système
d'exploitation. Par exemple, de nombreux systèmes d'exploitation ont une limite
sur le nombre de connexions ouvertes simultanément qu'ils peuvent supporter ;
les tentatives de nouvelles connexions une fois ce nombre dépassé produiront une
erreur jusqu'à ce que certaines connexions soient fermées.</p>
<!--
Let’s try running this code! Invoke `cargo run` in the terminal and then load
*127.0.0.1:7878* in a web browser. The browser should show an error message
like “Connection reset,” because the server isn’t currently sending back any
data. But when you look at your terminal, you should see several messages that
were printed when the browser connected to the server!
-->
<p>Essayons d'exécuter ce code ! Saisissez <code>cargo run</code> dans le terminal et ensuite
ouvrez <em>127.0.0.1:7878</em> dans un navigateur web. Le navigateur devrait afficher
un message d'erreur comme “La connexion a été réinitialisée”, car le serveur ne
renvois pas de données pour le moment. Mais si vous regardez le terminal, vous
devriez voir quelques messages qui se sont affichés lorsque le navigateur s'est
connecté au serveur !</p>
<!--
```text
     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
```
-->
<pre><code class="language-text">     Running `target/debug/salutations`
Connexion établie !
Connexion établie !
Connexion établie !
</code></pre>
<!--
Sometimes, you’ll see multiple messages printed for one browser request; the
reason might be that the browser is making a request for the page as well as a
request for other resources, like the *favicon.ico* icon that appears in the
browser tab.
-->
<p>Des fois, vous pourriez voir plusieurs messages s'afficher pour une seule
requête de navigateur ; la raison à cela est peut-être que le navigateur fait
une requête pour la page ainsi que des requêtes pour d'autres ressources, comme
l'icone <em>favicon.ico</em> qui s'affiche dans l'onglet du navigateur.</p>
<!--
It could also be that the browser is trying to connect to the server multiple
times because the server isn’t responding with any data. When `stream` goes out
of scope and is dropped at the end of the loop, the connection is closed as
part of the `drop` implementation. Browsers sometimes deal with closed
connections by retrying, because the problem might be temporary. The important
factor is that we’ve successfully gotten a handle to a TCP connection!
-->
<p>Peut-être que le navigateur essaye aussi de se connecter plusieurs fois au
serveur car le serveur ne répond aucune donnée. Lorsque <code>flux</code> sort de la portée
et est nettoyé à la fin de la boucle, la connexion est fermée car cela est
implémenté dans le <code>drop</code>. Les navigateurs réagissent à ces connexions fermées
en ré-essayant, car le problème peut être temporaire. La partie importante est
que nous avons obtenu avec succès un manipulateur de connexion TCP !</p>
<!--
Remember to stop the program by pressing <span class="keystroke">ctrl-c</span>
when you’re done running a particular version of the code. Then restart `cargo
run` after you’ve made each set of code changes to make sure you’re running the
newest code.
-->
<p>Souvenez-vous que vous pouvez arrêter le programme en appuyant sur
<span class="keystroke">ctrl-c</span> lorsque vous avez fini d'exécuter une
version du code. Relancez ensuite <code>cargo run</code> après avoir appliqué un jeu de
modifications pour vous assurer d'exécuter le nouveau code.</p>
<!--
### Reading the Request
-->
<h3 id="lire-la-requête"><a class="header" href="#lire-la-requête">Lire la requête</a></h3>
<!--
Let’s implement the functionality to read the request from the browser! To
separate the concerns of first getting a connection and then taking some action
with the connection, we’ll start a new function for processing connections. In
this new `handle_connection` function, we’ll read data from the TCP stream and
print it so we can see the data being sent from the browser. Change the code to
look like Listing 20-2.
-->
<p>Commençons à implémenter la fonctionnalité pour lire la requête du navigateur !
Pour séparer les parties où nous obtenons une connexion et celle où nous
agissons avec la connexion, nous allons créer une nouvelle fonction pour traiter
les connexions. Dans cette nouvelle fonction <code>gestion_connexion</code>, nous allons
lire des données provenant du flux TCP et les afficher afin que nous puissions
voir les données envoyées par le navigateur. Changez le code pour qu'il
ressemble à l'encart 20-2.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,no_run
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&mut buffer).unwrap();

    println!("Request: {}", String::from_utf8_lossy(&buffer[..]));
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run">use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for flux in ecouteur.incoming() {
        let flux = flux.unwrap();

        gestion_connexion(flux);
    }
}

fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];

    flux.read(&amp;mut tampon).unwrap();

    println!(&quot;Requête : {}&quot;, String::from_utf8_lossy(&amp;tampon[..]));
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-2: Reading from the `TcpStream` and printing
the data</span>
-->
<p><span class="caption">Encart 20-2 : lecture du <code>TcpStream</code> et affichage des
données</span></p>
<!--
We bring `std::io::prelude` into scope to get access to certain traits that let
us read from and write to the stream. In the `for` loop in the `main` function,
instead of printing a message that says we made a connection, we now call the
new `handle_connection` function and pass the `stream` to it.
-->
<p>Nous avons importé <code>std::io::prelude</code> dans la portée pour accéder à certains
traits qui nous permettent de lire et d'écrire dans le flux. Dans la boucle
<code>for</code> de la fonction <code>main</code>, au lieu d'afficher un message qui dit que nous
avons établi une connexion, nous faisons maintenant appel à <code>gestion_connexion</code>
et nous lui passons le <code>flux</code>.</p>
<!--
In the `handle_connection` function, we’ve made the `stream` parameter mutable.
The reason is that the `TcpStream` instance keeps track of what data it returns
to us internally. It might read more data than we asked for and save that data
for the next time we ask for data. It therefore needs to be `mut` because its
internal state might change; usually, we think of “reading” as not needing
mutation, but in this case we need the `mut` keyword.
-->
<p>Dans la fonction <code>gestion_connexion</code>, nous avons fait en sorte que le paramètre
<code>flux</code> soit mutable. La raison à cela est que l'instance de <code>TcpStream</code> garde en
mémoire interne quelles données il nous a retourné. Il peut avoir plus de
données que celles que nous avons demandé, et il peut alors conserver ces
données jusqu'à la prochaine fois où nous demanderons des données. Il doit donc
être <code>mut</code> car son état interne doit pouvoir changer ; d'habitude, nous n'avons
pas besoin que la “lecture” nécessite d'être mutable, mais dans ce cas nous
avons besoin du mot-clé <code>mut</code>.</p>
<!--
Next, we need to actually read from the stream. We do this in two steps:
first, we declare a `buffer` on the stack to hold the data that is read in.
We’ve made the buffer 1024 bytes in size, which is big enough to hold the
data of a basic request and sufficient for our purposes in this chapter. If
we wanted to handle requests of an arbitrary size, buffer management would
need to be more complicated; we’ll keep it simple for now. We pass the buffer
to `stream.read`, which will read bytes from the `TcpStream` and put them in
the buffer.
-->
<p>Ensuite, nous devons lire les données du flux. Nous faisons cela en deux
temps : d'abord, nous déclarons un <code>tampon</code> sur la pile pour y stocker les
données qui seront lues. Nous avons fait en sorte que le tampon fasse 1024
octets, ce qui est suffisamment grand pour stocker les données d'un requête
basique, ce qui est suffisant pour nos besoins dans ce chapitre. Si nous
aurions voulu gérer des requêtes de tailles quelconques, la gestion du tampon
aurait été plus complexe ; nous allons la garder simplifiée pour l'instant.
Nous envoyons le tampon dans <code>flux.read</code>, qui va lire les octets provenant du
<code>TcpStream</code> et les ajouter dans le tampon.</p>
<!--
Second, we convert the bytes in the buffer to a string and print that string.
The `String::from_utf8_lossy` function takes a `&[u8]` and produces a `String`
from it. The “lossy” part of the name indicates the behavior of this function
when it sees an invalid UTF-8 sequence: it will replace the invalid sequence
with `�`, the `U+FFFD REPLACEMENT CHARACTER`. You might see replacement
characters for characters in the buffer that aren’t filled by request data.
-->
<p>Ensuite, nous convertissons les octets présents dans le tampon en chaînes de
caractères et nous affichons cette chaîne de caractères. La fonction
<code>String::from_utf8_lossy</code> prends en paramètres un <code>&amp;[u8]</code> le transforme en une
<code>String</code>. La partie “lossy” du nom indique le comportement de cette fonction
lorsqu'elle rencontre une séquence UTF-8 invalide : elle va remplacer la
séquence invalide par <code>�</code>, le caractère <code>U+FFFD REPLACEMENT CHARACTER</code>. Vous
devriez voir ces caractères de remplacement pour les caractères dans le
tampon qui ne correspondent pas aux données de la demande.</p>
<!--
Let’s try this code! Start the program and make a request in a web browser
again. Note that we’ll still get an error page in the browser, but our
program’s output in the terminal will now look similar to this:
-->
<p>Essayons ce code ! Démarrez le programme et faites à nouveau une requête dans
un navigateur web. Notez que nous obtenons toujours une page d'erreur dans le
navigateur web, mais que la sortie de notre programme dans le terminal devrait
ressembler à ceci :</p>
<!--
```console
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
������������������������������������
```
-->
<pre><code class="language-console">$ cargo run
   Compiling salutations v0.1.0 (file:///projects/salutations)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/salutations`
Requête : GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
������������������������������������
</code></pre>
<!--
Depending on your browser, you might get slightly different output. Now that
we’re printing the request data, we can see why we get multiple connections
from one browser request by looking at the path after `Request: GET`. If the
repeated connections are all requesting */*, we know the browser is trying to
fetch */* repeatedly because it’s not getting a response from our program.
-->
<p>En fonction de votre navigateur, vous pourriez voir une sortie légèrement
différente. Maintenant que nous affichons les données des requêtes, nous
pouvons constater pourquoi nous obtenons pourquoi nous obtenons plusieurs
connexions pour un seul chargement de page dans le navigateur web en analysant
le chemin après le <code>Requête : GET</code>. Si les connexions répétées sont toutes vers
<em>/</em>, nous pouvons constater que le navigateur essaye d'obtenir <em>/</em> à répétition
car il n'obtient pas de réponse de la part de notre programme.</p>
<!--
Let’s break down this request data to understand what the browser is asking of
our program.
-->
<p>Décomposons les données de cette requête pour comprendre ce que le navigateur
demande à notre programme.</p>
<!--
### A Closer Look at an HTTP Request
-->
<h3 id="une-analyse-plus-poussée-dune-requête-http"><a class="header" href="#une-analyse-plus-poussée-dune-requête-http">Une analyse plus poussée d'une requête HTTP</a></h3>
<!--
HTTP is a text-based protocol, and a request takes this format:
-->
<p>HTTP est un protocole basé sur du texte, et une requête doit suivre cette
forme :</p>
<!--
```text
Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
```
-->
<pre><code class="language-text">Méthode URI-Demandée Version-HTTP CRLF
entêtes CRLF
corps-du-message
</code></pre>
<!--
The first line is the *request line* that holds information about what the
client is requesting. The first part of the request line indicates the *method*
being used, such as `GET` or `POST`, which describes how the client is making
this request. Our client used a `GET` request.
-->
<p>La première ligne est la <em>ligne de requête</em> qui contient les informations sur
ce que demande le client. La première partie de la ligne de requête indique la
<em>méthode</em> utilisée, comme <code>GET</code> ou <code>POST</code>, qui décrit comment le client fait sa
requête. Notre client a utilisé une requête <code>GET</code>.</p>
<!--
The next part of the request line is */*, which indicates the *Uniform Resource
Identifier* *(URI)* the client is requesting: a URI is almost, but not quite,
the same as a *Uniform Resource Locator* *(URL)*. The difference between URIs
and URLs isn’t important for our purposes in this chapter, but the HTTP spec
uses the term URI, so we can just mentally substitute URL for URI here.
-->
<p>La prochaine partie de la ligne de requête est <em>/</em>, qui indique <em>l'URI</em>
<em>(Uniform Resource Identifier)</em> que demande le client : une URI est presque,
mais pas complètement, la même chose qu'une <em>URL</em> <em>(Uniform Resource Locator)</em>.
La différence entre les URI et les URL n'est pas très importante pour nos
besoins dans ce chapitre, mais la spécification de HTTP utilise le terme URI,
donc nous pouvons simplement remplacer URL par URI dans ce cas-ci.</p>
<!--
The last part is the HTTP version the client uses, and then the request line
ends in a *CRLF sequence*. (CRLF stands for *carriage return* and *line feed*,
which are terms from the typewriter days!) The CRLF sequence can also be
written as `\r\n`, where `\r` is a carriage return and `\n` is a line feed. The
CRLF sequence separates the request line from the rest of the request data.
Note that when the CRLF is printed, we see a new line start rather than `\r\n`.
-->
<p>La dernière partie est la version HTTP que le client utilise, et ensuite la
ligne de requête termine avec une <em>séquence CRLF</em> (CRLF signifie
<em>Carriage Return, retour chariot</em>, et <em>Line Feed, saut de ligne</em> qui sont des
termes qui remontent à l'époque des machines à écrire !). La séquence CRLF peut
aussi être écrite <code>\r\n</code>, dans laquelle <code>\r</code> est un retour chariot, et <code>\n</code> est
un saut de ligne. La séquence CRLF sépare la ligne de requête du reste des
données de la requête. Notez toutefois que lorsqu'un CRLF est affiché, nous
voyons une nouvelle ligne plutôt qu'un <code>\r\n</code>.</p>
<!--
Looking at the request line data we received from running our program so far,
we see that `GET` is the method, */* is the request URI, and `HTTP/1.1` is the
version.
-->
<p>D'après la ligne de requête que nous avons reçu après avoir exécuté notre
programme précédemment, nous constatons que la méthode est <code>GET</code>, <em>/</em> est l'URI
demandée, et <code>HTTP/1.1</code> est la version.</p>
<!--
After the request line, the remaining lines starting from `Host:` onward are
headers. `GET` requests have no body.
-->
<p>Après la ligne de requête, les lignes après celle où nous avons <code>Host:</code> sont
des entêtes. Les requêtes <code>GET</code> n'ont pas de corps.</p>
<!--
Try making a request from a different browser or asking for a different
address, such as *127.0.0.1:7878/test*, to see how the request data changes.
-->
<p>Essayez de faire une requête dans un navigateur différent ou de demander une
adresse différente, comme <em>127.0.0.1:7878/test</em>, pour observer comment les
données de requête changent.</p>
<!--
Now that we know what the browser is asking for, let’s send back some data!
-->
<p>Maintenant que nous savons ce que demande le navigateur, envoyons-lui quelques
données !</p>
<!--
### Writing a Response
-->
<h3 id="ecrire-une-réponse"><a class="header" href="#ecrire-une-réponse">Ecrire une réponse</a></h3>
<!--
Now we’ll implement sending data in response to a client request. Responses
have the following format:
-->
<p>Maintenant, nous allons implémenter l'envoi d'une réponse à requête client. Les
réponses suivent le format suivant :</p>
<!--
```text
HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
```
-->
<pre><code class="language-text">Version-HTTP Code-Statut Phrase-De-Raison CRLF
entêtes CRLF
corps-message
</code></pre>
<!--
The first line is a *status line* that contains the HTTP version used in the
response, a numeric status code that summarizes the result of the request, and
a reason phrase that provides a text description of the status code. After the
CRLF sequence are any headers, another CRLF sequence, and the body of the
response.
-->
<p>La première ligne est une <em>ligne de statut</em> qui contient la version HTTP
utilisée dans la réponse, un code numérique de statut qui résume le résultat
de la requête, et une phrase de raison qui fournit une description textuelle du
code de statut. Après la séquence CRLF viennent tous les entêtes, une autre
séquence CRLF, et enfin le corps de la réponse.</p>
<!--
Here is an example response that uses HTTP version 1.1, has a status code of
200, an OK reason phrase, no headers, and no body:
-->
<p>Voici un exemple de réponse qui utilise HTTP version 1.1, qui a un code de
statut de 200, une phrase de raison à OK, pas d'entêtes, et pas de corps :</p>
<!--
```text
HTTP/1.1 200 OK\r\n\r\n
```
-->
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<!--
The status code 200 is the standard success response. The text is a tiny
successful HTTP response. Let’s write this to the stream as our response to a
successful request! From the `handle_connection` function, remove the
`println!` that was printing the request data and replace it with the code in
Listing 20-3.
-->
<p>Le code de statut 200 est la réponse standard de succès. Le texte est une toute
petite réponse HTTP de succès. Ecrivons ceci dans le flux de notre réponse à
une requête avec succès ! Dans la fonction <code>gestion_connexion</code>, enlevez le
<code>println!</code> qui affiche les données de requête et remplacez-la par le code de
l'encart 20-3.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,no_run
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&mut buffer).unwrap();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];

    flux.read(&amp;mut tampon).unwrap();

    let reponse = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    flux.write(reponse.as_bytes()).unwrap();
    flux.flush().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-3: Writing a tiny successful HTTP response to
the stream</span>
-->
<p><span class="caption">Encart 20-3 : écriture d'une toute petite réponse HTTP de
réussite dans le flux</span></p>
<!--
The first new line defines the `response` variable that holds the success
message’s data. Then we call `as_bytes` on our `response` to convert the string
data to bytes. The `write` method on `stream` takes a `&[u8]` and sends those
bytes directly down the connection.
-->
<p>La première ligne définit la variable <code>reponse</code> qui contient les données du
message de réussite. Ensuite, nous faisons appel à <code>as_bytes</code> sur notre
<code>reponse</code> pour convertir la chaîne de caractères en octets. La méthode <code>write</code>
sur le <code>flux</code> prend en argument un <code>&amp;[u8]</code> et envoie ces octets directement
dans la connexion.</p>
<!--
Because the `write` operation could fail, we use `unwrap` on any error result
as before. Again, in a real application you would add error handling here.
Finally, `flush` will wait and prevent the program from continuing until all
the bytes are written to the connection; `TcpStream` contains an internal
buffer to minimize calls to the underlying operating system.
-->
<p>Comme l'opération <code>write</code> peut échouer, nous utilisons <code>unwrap</code> sur toutes les
erreurs, comme précédemment. Encore une fois ; dans un véritable application,
vous devriez gérer les cas d'erreur ici. Enfin, <code>flush</code> va attendre et empêcher
le programme de continuer à s'exécuter jusqu'à ce que tous les octets soient
écrits dans la connexion ; <code>TcpStream</code> contient un tampon interne pour réduire
les appels au système d'exploitation concerné.</p>
<!--
With these changes, let’s run our code and make a request. We’re no longer
printing any data to the terminal, so we won’t see any output other than the
output from Cargo. When you load *127.0.0.1:7878* in a web browser, you should
get a blank page instead of an error. You’ve just hand-coded an HTTP request
and response!
-->
<p>Avec ces modifications, exécutons à nouveau notre code et lançons une requête
dans le navigateur. Nous n'affichons plus les données dans le terminal, donc
nous ne voyons plus aucune sortie autre que celle de Cargo. Lorsque vous
chargez <em>127.0.0.1:7878</em> dans un navigateur web, vous devriez obtenir une page
blanche plutôt qu'une erreur. Vous venez de coder en dur une réponse à une
requête HTTP !</p>
<!--
### Returning Real HTML
-->
<h3 id="retourner-du-vrai-html"><a class="header" href="#retourner-du-vrai-html">Retourner du vrai HTML</a></h3>
<!--
Let’s implement the functionality for returning more than a blank page. Create
a new file, *hello.html*, in the root of your project directory, not in the
*src* directory. You can input any HTML you want; Listing 20-4 shows one
possibility.
-->
<p>Implémentons la fonctionnalité pour retourner plus qu'une page blanche. Créez
un nouveau fichier, <em>hello.html</em>, à la racine de votre dossier de projet, et
non pas dans le dossier <em>src</em>. Vous pouvez ajouter le HTML que vous souhaitez ;
l'encart 20-4 vous montre une possibilité.</p>
<!--
<span class="filename">Filename: hello.html</span>
-->
<p><span class="filename">Fichier : salutation.html</span></p>
<!--
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Hello!</title>
  </head>
  <body>
    <h1 id="hello"><a class="header" href="#hello">Hello!</a></h1>
    <p>Hi from Rust</p>
  </body>
</html>
```
-->
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Salutations !&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Salut !&lt;/h1&gt;
    &lt;p&gt;Bonjour de la part de Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!--
<span class="caption">Listing 20-4: A sample HTML file to return in a
response</span>
-->
<p><span class="caption">Encart 20-4 : un exemple de fichier HTML à retourner dans
une réponse</span></p>
<!--
This is a minimal HTML5 document with a heading and some text. To return this
from the server when a request is received, we’ll modify `handle_connection` as
shown in Listing 20-5 to read the HTML file, add it to the response as a body,
and send it.
-->
<p>Ceci est un document HTML5 minimal avec des entêtes et un peu de texte. Pour
retourner ceci à partir d'un serveur lorsqu'une requête est reçue, nous allons
modifier <code>gestion_connexion</code> comme proposé dans l'encart 20-5 pour lire le
fichier HTML, l'ajouter dans la réponse comme faisant partie de son corps, et
l'envoyer.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,no_run
use std::fs;
// --snip--

# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&mut buffer).unwrap();

    let contents = fs::read_to_string("hello.html").unwrap();

    let response = format!(
        "HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}",
        contents.len(),
        contents
    );

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run">use std::fs;
// -- partie masquée ici --

<span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];
    flux.read(&amp;mut tampon).unwrap();

    let contenu = fs::read_to_string(&quot;hello.html&quot;).unwrap();

    let reponse = format!(
        &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
        contenu.len(),
        contenu
    );

    flux.write(reponse.as_bytes()).unwrap();
    flux.flush().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-5: Sending the contents of *hello.html* as the
body of the response</span>
-->
<p><span class="caption">Encart 20-5 : envoi du contenu de <em>salutation.html</em> dans
le corps de la réponse</span></p>
<!--
We’ve added a line at the top to bring the standard library’s filesystem module
into scope. The code for reading the contents of a file to a string should look
familiar; we used it in Chapter 12 when we read the contents of a file for our
I/O project in Listing 12-4.
-->
<p>Nous avons ajouté une ligne en haut pour importer le module de système de
fichiers de la bibliothèque standard. Le code pour lire le contenu d'un fichier
dans une <code>String</code> devrait vous être familier ; nous n'avons utilisé dans le
chapitre 12 lorsque nous lisions le contenu d'un fichier pour notre projet
d'entrée/sortie, dans l'encart 12-4.</p>
<!--
Next, we use `format!` to add the file’s contents as the body of the success
response. To ensure a valid HTTP response, we add the `Content-Length` header
which is set to the size of our response body, in this case the size of `hello.html`.
-->
<p>Ensuite, nous avons utilisé <code>format!</code> pour ajouter le contenu du fichier comme
étant le corps de la réponse avec succès. Pour garantir que ce soit une réponse
HTTP valide, nous avons ajouté l'entête <code>Content-Length</code> qui définit la taille
du corps de notre réponse, qui dans ce cas est la taille de <code>hello.html</code>.</p>
<!--
Run this code with `cargo run` and load *127.0.0.1:7878* in your browser; you
should see your HTML rendered!
-->
<p>Exécutez ce code avec <code>cargo run</code> et ouvrez <em>127.0.0.1:7878</em> dans votre
navigateur web ; vous devriez voir le résultat de votre HTML !</p>
<!--
Currently, we’re ignoring the request data in `buffer` and just sending back
the contents of the HTML file unconditionally. That means if you try requesting
*127.0.0.1:7878/something-else* in your browser, you’ll still get back this
same HTML response. Our server is very limited and is not what most web servers
do. We want to customize our responses depending on the request and only send
back the HTML file for a well-formed request to */*.
-->
<p>Pour le moment, nous ignorons les données de la requête présentes dans
<code>tampon</code> et nous renvoyons sans conditions le contenu du fichier HTML. Cela
signifie que si vous essayez de demander <em>127.0.0.1:7878/autre-chose</em> dans
votre navigateur web, vous obtiendrez la même réponse HTML. Notre serveur est
très limité, et ne correspond pas à ce que font la plupart des serveurs web.
Nous souhaitons désormais personnaliser nos réponses en fonction de la requête
et renvoyer seulement le fichier HTML pour la bonne requête faite à <em>/</em>.</p>
<!--
### Validating the Request and Selectively Responding
-->
<h3 id="valider-la-requête-et-répondre-de-manière-sélective"><a class="header" href="#valider-la-requête-et-répondre-de-manière-sélective">Valider la requête et répondre de manière sélective</a></h3>
<!--
Right now, our web server will return the HTML in the file no matter what the
client requested. Let’s add functionality to check that the browser is
requesting */* before returning the HTML file and return an error if the
browser requests anything else. For this we need to modify `handle_connection`,
as shown in Listing 20-6. This new code checks the content of the request
received against what we know a request for */* looks like and adds `if` and
`else` blocks to treat requests differently.
-->
<p>Jusqu'à présent, notre serveur web devrait retourner le HTML du fichier peu
importe ce que demande le client. Ajoutons une fonctionnalité pour vérifier que
le navigateur demande bien <em>/</em> avant de retourner le fichier HTML et retournons
une erreur si le navigateur demande autre chose. Pour cela, nous devons
modifier <code>gestion_connexion</code> comme l'encart 20-6. Ce nouveau code compare le
contenu de la requête que nous recevons à une requête que nous voudrions pour
<em>/</em> en ajoutant des blocs <code>if</code> et <code>else</code> pour traiter différemment les requêtes.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&mut buffer).unwrap();

    let get = b"GET / HTTP/1.1\r\n";

    if buffer.starts_with(get) {
        let contents = fs::read_to_string("hello.html").unwrap();

        let response = format!(
            "HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}",
            contents.len(),
            contents
        );

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } else {
        // some other request
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquée ici --

fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];
    flux.read(&amp;mut tampon).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;

    if tampon.starts_with(get) {
        let contenu = fs::read_to_string(&quot;hello.html&quot;).unwrap();

        let reponse = format!(
            &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
            contenu.len(),
            contenu
        );

        flux.write(reponse.as_bytes()).unwrap();
        flux.flush().unwrap();
    } else {
        // autres requêtes
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-6: Matching the request and handling requests
to */* differently from other requests</span>
-->
<p><span class="caption">Encart 20-6 : détection et gestion des requêtes vers <em>/</em>,
qui est différente en fonction des autres requêtes</span></p>
<!--
First, we hardcode the data corresponding to the */* request into the `get`
variable. Because we’re reading raw bytes into the buffer, we transform `get`
into a byte string by adding the `b""` byte string syntax at the start of the
content data. Then we check whether `buffer` starts with the bytes in `get`. If
it does, it means we’ve received a well-formed request to */*, which is the
success case we’ll handle in the `if` block that returns the contents of our
HTML file.
-->
<p>D'abord, nous codons en dur les données correspondant à la requête <em>/</em> dans la
variable <code>get</code>. Comme nous lisons des octets bruts provenant du tampon, nous
transformons <code>get</code> en une chaîne d'octets en ajoutant la syntaxe de chaîne
d'octets <code>b&quot;&quot;</code> au début du contenu des données. Ensuite, nous attendons le
moment où le <code>tampon</code> commence par les mêmes octets que ceux dans <code>get</code>.
Lorsque c'est le cas, cela signifie que nous avons reçu une requête
correctement bien formulée vers <em>/</em>, qui est le cas de réussite que nous allons
gérer dans le bloc <code>if</code> qui retourne le contenu de notre fichier HTML.</p>
<!--
If `buffer` does *not* start with the bytes in `get`, it means we’ve received
some other request. We’ll add code to the `else` block in a moment to respond
to all other requests.
-->
<p>Si <code>tampon</code> ne <em>commence pas</em> avec les octets présents dans <code>get</code>, cela
signifie que nous avons reçu une autre requête. Nous allons bientôt ajouter du
code au bloc <code>else</code> pour répondre à toutes les autres requêtes.</p>
<!--
Run this code now and request *127.0.0.1:7878*; you should get the HTML in
*hello.html*. If you make any other request, such as
*127.0.0.1:7878/something-else*, you’ll get a connection error like those you
saw when running the code in Listing 20-1 and Listing 20-2.
-->
<p>Exécutez ce code maintenant et demandez <em>127.0.0.1:7878</em> ; vous devriez obtenir
le HTML de <em>salutation.html</em>. Si vous faites n'importe quelle autre requête,
comme <em>127.0.0.1:7878/autre-chose</em>, vous allez obtenir une erreur de connexion
comme celle que vous avez vu lorsque vous exécutiez le code l'encart 20-1 et de
l'encart 20-2.</p>
<!--
Now let’s add the code in Listing 20-7 to the `else` block to return a response
with the status code 404, which signals that the content for the request was
not found. We’ll also return some HTML for a page to render in the browser
indicating the response to the end user.
-->
<p>Maintenant ajoutons le code de l'encart 20-7 au bloc <code>else</code> pour retourner une
réponse avec le code de statut 404, qui signale que le contenu demandé par
cette requête n'est pas trouvé. Nous allons aussi retourner du HTML pour qu'une
page s'affiche dans le navigateur, indiquant la réponse à l'utilisateur final.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
# fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
# 
#     if buffer.starts_with(get) {
#         let contents = fs::read_to_string("hello.html").unwrap();
# 
#         let response = format!(
#             "HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}",
#             contents.len(),
#             contents
#         );
# 
#         stream.write(response.as_bytes()).unwrap();
#         stream.flush().unwrap();
    // --snip--
    } else {
        let status_line = "HTTP/1.1 404 NOT FOUND\r\n\r\n";
        let contents = fs::read_to_string("404.html").unwrap();

        let response = format!("{}{}", status_line, contents);

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    }
# }
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn gestion_connexion(mut flux: TcpStream) {
</span><span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    if tampon.starts_with(get) {
</span><span class="boring">        let contenu = fs::read_to_string(&quot;hello.html&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">        let reponse = format!(
</span><span class="boring">            &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
</span><span class="boring">            contenu.len(),
</span><span class="boring">            contenu
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">        flux.flush().unwrap();
</span>    // -- partie masquée ici --
    } else {
        let ligne_statut = &quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;;
        let contenu = fs::read_to_string(&quot;404.html&quot;).unwrap();

        let reponse = format!(&quot;{}{}&quot;, ligne_statut, contenu);

        flux.write(reponse.as_bytes()).unwrap();
        flux.flush().unwrap();
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-7: Responding with status code 404 and an
error page if anything other than */* was requested</span>
-->
<p><span class="caption">Encart 20-7 : répondre un code de statut 404 et une page
d'erreur s'il y autre chose que <em>/</em> qui est demandé</span></p>
<!--
Here, our response has a status line with status code 404 and the reason
phrase `NOT FOUND`. We’re still not returning headers, and the body of the
response will be the HTML in the file *404.html*. You’ll need to create a
*404.html* file next to *hello.html* for the error page; again feel free to use
any HTML you want or use the example HTML in Listing 20-8.
-->
<p>Ici, notre réponse a une ligne de statut avec le code de statut 404 et la
phrase de raison <code>NOT FOUND</code>. Nous ne retournons toujours pas d'entêtes, et le
corps de la réponse sera le HTML présent dans le fichier <em>404.html</em>. Nous aurons
besoin de créer un fichier <code>404.html</code> à côté de <em>salutation.html</em> pour la page
d'erreur ; n'hésitez pas à nouveau à utiliser le HTML que vous souhaitez ou à
défaut utiliser le HTML d'exemple présent dans l'encart 20-8.</p>
<!--
<span class="filename">Filename: 404.html</span>
-->
<p><span class="filename">Fichier : 404.html</span></p>
<!--
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Hello!</title>
  </head>
  <body>
    <h1 id="oops"><a class="header" href="#oops">Oops!</a></h1>
    <p>Sorry, I don't know what you're asking for.</p>
  </body>
</html>
```
-->
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Salutations !&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oups !&lt;/h1&gt;
    &lt;p&gt;Désolé, je ne connaît pas ce que vous demandez.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!--
<span class="caption">Listing 20-8: Sample content for the page to send back
with any 404 response</span>
-->
<p><span class="caption">Encart 20-8 : contenu d'exemple pour la page à renvoyer
avec les réponses 404</span></p>
<!--
With these changes, run your server again. Requesting *127.0.0.1:7878*
should return the contents of *hello.html*, and any other request, like
*127.0.0.1:7878/foo*, should return the error HTML from *404.html*.
-->
<p>Une fois ces modifications appliquées, exécutez à nouveau votre serveur. Les
requêtes vers <em>127.0.0.1:7878</em> devraient retourner le contenu de
<em>salutation.html</em>, et toutes les autres requêtes, comme
<em>127.0.0.1:7878/autre-chose</em>, devraient retourner le HTML d'erreur présent dans
<em>404.html</em>.</p>
<!--
### A Touch of Refactoring
-->
<h3 id="un-peu-de-remaniement"><a class="header" href="#un-peu-de-remaniement">Un peu de remaniement</a></h3>
<!--
At the moment the `if` and `else` blocks have a lot of repetition: they’re both
reading files and writing the contents of the files to the stream. The only
differences are the status line and the filename. Let’s make the code more
concise by pulling out those differences into separate `if` and `else` lines
that will assign the values of the status line and the filename to variables;
we can then use those variables unconditionally in the code to read the file
and write the response. Listing 20-9 shows the resulting code after replacing
the large `if` and `else` blocks.
-->
<p>Pour l'instant, les blocs <code>if</code> et <code>else</code> contiennent beaucoup de code répété :
ils lisent tous les deux des fichiers et écrivent le contenu de ces fichiers
dans le flux. La seule différence entre eux sont la ligne de statut et le nom
du fichier. Rendons le code plus concis en isolant ces différences dans des
lignes <code>if</code> et <code>else</code> qui vont assigner les valeurs de la ligne de statut et du
nom de fichier à des variables ; nous pourrons ensuite utiliser ces variables
sans avoir à se préoccuper du contexte dans du code qui va lire le fichier et
écrire la réponse. L'encart 20-9 montre le code qui découle du remplacement des
gros blocs <code>if</code> et <code>else</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }
# 
// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--

#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
# 
    let (status_line, filename) = if buffer.starts_with(get) {
        ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!("{}{}", status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquée ici--

fn gestion_connexion(mut flux: TcpStream) {
    // -- partie masquée ici--

<span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span>    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let contenu = fs::read_to_string(nom_fichier).unwrap();

    let reponse = format!(&quot;{}{}&quot;, ligne_statut, contenu);

    flux.write(reponse.as_bytes()).unwrap();
    flux.flush().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-9: Refactoring the `if` and `else` blocks to
contain only the code that differs between the two cases</span>
-->
<p><span class="caption">Encart 20-9 : remaniement des blocs <code>if</code> et <code>else</code> pour
qu'ils contiennent uniquement le code qui différencie les deux cas</span></p>
<!--
Now the `if` and `else` blocks only return the appropriate values for the
status line and filename in a tuple; we then use destructuring to assign these
two values to `status_line` and `filename` using a pattern in the `let`
statement, as discussed in Chapter 18.
-->
<p>Maintenant que les blocs <code>if</code> et <code>else</code> retournent uniquement les valeurs
correctes pour la ligne de statut et le nom du fichier dans un tuple ; nous
pouvons utiliser la déstructuration pour assigner ces deux valeurs à
<code>ligne_statut</code> et <code>nom_fichier</code> en utilisant un motif dans l'instruction <code>let</code>,
comme nous l'avons vu dans le chapitre 18.</p>
<!--
The previously duplicated code is now outside the `if` and `else` blocks and
uses the `status_line` and `filename` variables. This makes it easier to see
the difference between the two cases, and it means we have only one place to
update the code if we want to change how the file reading and response writing
work. The behavior of the code in Listing 20-9 will be the same as that in
Listing 20-8.
-->
<p>Le code précédent qui était en double se trouve maintenant à l'extérieur des
blocs <code>if</code> et <code>else</code> et utilise les variables <code>ligne_statut</code> et <code>nom_fichier</code>.
Cela permet de mettre en évidence plus facilement les différences entre les
deux cas, et cela signifie que nous n'avons qu'un seul endroit du code à
modifier si nous souhaitons changer le fonctionnement de lecture du fichier et
d'écriture de la réponse. Le comportement du code de l'encart 20-9 devrait être
identique à celui de l'encart 20-8.</p>
<!--
Awesome! We now have a simple web server in approximately 40 lines of Rust code
that responds to one request with a page of content and responds to all other
requests with a 404 response.
-->
<p>Super ! Nous avons maintenant un serveur web simple qui tient dans environ 40
lignes de code, qui répond à une requête précise par sa page de contenu et
répond à toutes les autres avec une réponse 404.</p>
<!--
Currently, our server runs in a single thread, meaning it can only serve one
request at a time. Let’s examine how that can be a problem by simulating some
slow requests. Then we’ll fix it so our server can handle multiple requests at
once.
-->
<p>Actuellement, notre serveur fonctionne dans une seule tâche, ce qui signifie
qu'il ne peut répondre qu'à une seule requête à la fois. Examinons maintenant
à quel point cela peut être un problème en simulant des réponses lentes à des
requêtes. Ensuite, nous corrigerons notre serveur pour qu'il puisse gérer
plusieurs requêtes à la fois.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--33"><a class="header" href="#-attention-peinture-fraîche--33">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/216">Pull Request</a>.</p>
</blockquote>
<!--
## Turning Our Single-Threaded Server into a Multithreaded Server
-->
<h2 id="transformer-notre-serveur-monotâche-en-serveur-multitâches"><a class="header" href="#transformer-notre-serveur-monotâche-en-serveur-multitâches">Transformer notre serveur monotâche en serveur multitâches</a></h2>
<!--
Right now, the server will process each request in turn, meaning it won’t
process a second connection until the first is finished processing. If the
server received more and more requests, this serial execution would be less and
less optimal. If the server receives a request that takes a long time to
process, subsequent requests will have to wait until the long request is
finished, even if the new requests can be processed quickly. We’ll need to fix
this, but first, we’ll look at the problem in action.
-->
<p>Jusqu'à présent, le serveur va traiter chaque requête dans l'ordre, ce qui
signifie qu'il ne va pas traiter une seconde connexion tant que la première
n'a pas fini d'être traitée. Si le serveur reçoit encore plus de requêtes,
cette exécution à la chaîne sera de moins en moins optimale. Si le serveur
reçoit une requête qui prend longtemps à traiter, les demandes suivantes
devront attendre que la longue requête à traiter soit terminée, même si les
nouvelles requêtes peuvent être traitées rapidement. Nous devons corriger cela,
mais d'abord, observons ce problème en pratique.</p>
<!--
### Simulating a Slow Request in the Current Server Implementation
-->
<h3 id="simuler-une-longue-requête-à-traiter-avec-limplémentation-actuelle-du-serveur"><a class="header" href="#simuler-une-longue-requête-à-traiter-avec-limplémentation-actuelle-du-serveur">Simuler une longue requête à traiter avec l'implémentation actuelle du serveur</a></h3>
<!--
We’ll look at how a slow-processing request can affect other requests made to
our current server implementation. Listing 20-10 implements handling a request
to */sleep* with a simulated slow response that will cause the server to sleep
for 5 seconds before responding.
-->
<p>Nous allons voir comment une requête longue à traiter peut influer sur le
traitement des autres requêtes par l'implémentation actuelle de notre serveur.
L'encart 20-10 rajoute le traitement d'une requête pour <em>/pause</em> qui va simuler
une longue réponse qui va faire en sorte que le serveur soit en pause pendant 5
secondes avant de répondre à nouveau.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
use std::thread;
use std::time::Duration;
// --snip--
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         handle_connection(stream);
#     }
# }

fn handle_connection(mut stream: TcpStream) {
    // --snip--

#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
    let get = b"GET / HTTP/1.1\r\n";
    let sleep = b"GET /sleep HTTP/1.1\r\n";

    let (status_line, filename) = if buffer.starts_with(get) {
        ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")
    };

    // --snip--
# 
#     let contents = fs::read_to_string(filename).unwrap();
# 
#     let response = format!("{}{}", status_line, contents);
# 
#     stream.write(response.as_bytes()).unwrap();
#     stream.flush().unwrap();
}
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span>use std::thread;
use std::time::Duration;
// -- partie masquée ici--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        gestion_connexion(flux);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn gestion_connexion(mut flux: TcpStream) {
    // -- partie masquée ici--

<span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span>    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;

    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if tampon.starts_with(pause) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    // -- partie masquée ici--
<span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier).unwrap();
</span><span class="boring">
</span><span class="boring">    let reponse = format!(&quot;{}{}&quot;, ligne_statut, contenu);
</span><span class="boring">
</span><span class="boring">    flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">    flux.flush().unwrap();
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 20-10: Simulating a slow request by recognizing
*/sleep* and sleeping for 5 seconds</span>
-->
<p><span class="caption">Encart 20-10 : simulation d'un long traitement de requête
en détectant <em>/pause</em> et en faisant une pause de 5 secondes</span></p>
<!--
This code is a bit messy, but it’s good enough for simulation purposes. We
created a second request `sleep`, whose data our server recognizes. We added an
`else if` after the `if` block to check for the request to */sleep*. When that
request is received, the server will sleep for 5 seconds before rendering the
successful HTML page.
-->
<p>Ce code est peu brouillon, mais est suffisant pour nos besoins de simulation.
Nous avons créé une seconde possibilité de requête <code>pause</code>, avec les données que
notre serveur va détecter. Nous avons ajouté un <code>else if</code> après le bloc <code>if</code>
pour vérifier les requêtes vers <em>/pause</em>. Lorsque cette requête est reçue, le
serveur va se mettre en pause pendant 5 secondes avant de générer la page HTML
de succès.</p>
<!--
You can see how primitive our server is: real libraries would handle the
recognition of multiple requests in a much less verbose way!
-->
<p>Vous pouvez constater à quel point notre serveur est primitif : une
bibliothèque digne de ce nom devrait gérer la détection de différents types de
requêtes de manière bien moins verbeuse !</p>
<!--
Start the server using `cargo run`. Then open two browser windows: one for
*http://127.0.0.1:7878/* and the other for *http://127.0.0.1:7878/sleep*. If
you enter the */* URI a few times, as before, you’ll see it respond quickly.
But if you enter */sleep* and then load */*, you’ll see that */* waits until
`sleep` has slept for its full 5 seconds before loading.
-->
<p>Démarrez le serveur en utilisant <code>cargo run</code>. Ouvrez ensuite deux fenêtres de
navigateur web : une pour <em>http://127.0.0.1:7878/</em> et l'autre pour
<em>http://127.0.0.1:7878/pause</em>. Si vous demandez l'URI <em>/</em> plusieurs fois, comme
vous l'avez fait précédemment, vous constaterez que le serveur répond
rapidement. Mais lorsque vous saisirez <em>/pause</em> et que vous chargerez ensuite
<em>/</em>, vous constaterez que <em>/</em> attend que <code>pause</code> ai fini sa pause des 5
secondes avant de se charger.</p>
<!--
There are multiple ways we could change how our web server works to avoid
having more requests back up behind a slow request; the one we’ll implement is
a thread pool.
-->
<p>Il y a plusieurs manières de changer le fonctionnement de notre serveur web
pour éviter d'accumuler des requêtes après une requête dont le traitement est
long ; celle que nous allons implémenter est un groupe de tâches.</p>
<!--
### Improving Throughput with a Thread Pool
-->
<h3 id="améliorer-le-débit-avec-un-groupe-de-tâches"><a class="header" href="#améliorer-le-débit-avec-un-groupe-de-tâches">Améliorer le débit avec un groupe de tâches</a></h3>
<!--
A *thread pool* is a group of spawned threads that are waiting and ready to
handle a task. When the program receives a new task, it assigns one of the
threads in the pool to the task, and that thread will process the task. The
remaining threads in the pool are available to handle any other tasks that come
in while the first thread is processing. When the first thread is done
processing its task, it’s returned to the pool of idle threads, ready to handle
a new task. A thread pool allows you to process connections concurrently,
increasing the throughput of your server.
-->
<p>Un <em>groupe de tâches</em> est un groupe constitué de tâches qui ont été crées et
qui attendent des missions. Lorsque le programme reçoit une nouvelle mission,
il assigne une des tâches du groupe pour cette mission, et cette tâche va
traiter la mission. Les tâches restantes dans le groupe restent disponibles
pour traiter d'autres missions qui peuvent arriver pendant que la première
tâche est en cours de traitement. Lorsque la première tâche a fini avec sa
mission, elle retourne dans le groupe de tâches inactives, prête à gérer une
nouvelle tâche. Un groupe de tâches vous permet de traiter plusieurs connexions
en simultané, ce qui augmente le débit de votre serveur.</p>
<!--
We’ll limit the number of threads in the pool to a small number to protect us
from Denial of Service (DoS) attacks; if we had our program create a new thread
for each request as it came in, someone making 10 million requests to our
server could create havoc by using up all our server’s resources and grinding
the processing of requests to a halt.
-->
<p>Nous allons limiter le nombre de tâches dans le groupe à un petit nombre pour
nous protéger d'attaques par déni de service (Denial of Service, DoS) ; si notre
programme créait une nouvelle tâche à chaque requête qu'il reçoit, quelqu'un qui
fait 10 millions de requêtes à notre serveur pourrait faire des ravages en
utilisant toutes les ressources de notre serveur et paralyser le traitement des
demandes.</p>
<!--
Rather than spawning unlimited threads, we’ll have a fixed number of threads
waiting in the pool. As requests come in, they’ll be sent to the pool for
processing. The pool will maintain a queue of incoming requests. Each of the
threads in the pool will pop off a request from this queue, handle the request,
and then ask the queue for another request. With this design, we can process
`N` requests concurrently, where `N` is the number of threads. If each thread
is responding to a long-running request, subsequent requests can still back up
in the queue, but we’ve increased the number of long-running requests we can
handle before reaching that point.
-->
<p>Plutôt que de générer des tâches en quantité illimitée, nous allons faire en
sorte qu'il y ait un nombre fixe de tâches qui seront en attente dans le
groupe. Lorsqu'une requête arrive, une tâche sera choisie dans le groupe pour
procéder au traitement. Le groupe gérera une file d'attente pour les requêtes
entrantes. Chaque tâche dans le groupe va récupérer une requête dans cette
liste d'attente, traiter cette requête, et ensuite demander une autre requête
à la file d'attente. Avec ce fonctionnement, nous pouvons traiter <code>N</code> requêtes
en concurrence, où <code>N</code> est le nombre de tâches. Si toutes les tâches répondent
chacune à une requête longue à traiter, les requêtes suivantes vont se stocker
dans la file d'attente, mais nous augmentons alors le nombre de requêtes
longues à traiter que nous devons traiter avant d'arriver à la fin.</p>
<!--
This technique is just one of many ways to improve the throughput of a web
server. Other options you might explore are the fork/join model and the
single-threaded async I/O model. If you’re interested in this topic, you can
read more about other solutions and try to implement them in Rust; with a
low-level language like Rust, all of these options are possible.
-->
<p>Cette technique n'est qu'une des nombreuses manières d'améliorer le débit d'un
serveur web. D'autres options que vous devriez envisager sont le modèle
fork/join et le modèle d'entrée-sortie asynchrone monotâche. Si vous êtes
intéressés par ce sujet, vous pouvez aussi en apprendre plus sur d'autres
solutions et essayer de les implémenter en Rust ; avec un langage bas niveau
comme Rust, toutes les options restent possibles.</p>
<!--
Before we begin implementing a thread pool, let’s talk about what using the
pool should look like. When you’re trying to design code, writing the client
interface first can help guide your design. Write the API of the code so it’s
structured in the way you want to call it; then implement the functionality
within that structure rather than implementing the functionality and then
designing the public API.
-->
<p>Avant que nous commencions l'implémentation du groupe de tâches, parlons de
l'utilisation du groupe. Lorsque vous essayez de concevoir du code, commencer
par écrire l'interface client peut vous aider à vous guider dans la conception.
Ecrivez l'API du code afin qu'il soit structuré de la manière dont vous
souhaitez l'appeler ; puis implémentez ensuite la fonctionnalité au sein de
cette structure, plutôt que d'implémenter la fonctionnalité puis de concevoir
l'API publique.</p>
<!--
Similar to how we used test-driven development in the project in Chapter 12,
we’ll use compiler-driven development here. We’ll write the code that calls the
functions we want, and then we’ll look at errors from the compiler to determine
what we should change next to get the code to work.
-->
<p>De la même manière que nous avons utilisé le développement piloté par les tests
dans le projet du chapitre 12, nous allons utiliser ici le développement
orienté par le compilateur. Nous allons écrire le code qui appelle les
fonctions que nous souhaitons, et ensuite nous analyserons les erreurs du
compilateur pour déterminer ce qu'il faut ensuite corriger pour que le code
fonctionne.</p>
<!--
#### Code Structure If We Could Spawn a Thread for Each Request
-->
<h4 id="la-structure-du-code-si-nous-pouvions-créer-une-tâche-pour-chaque-requête"><a class="header" href="#la-structure-du-code-si-nous-pouvions-créer-une-tâche-pour-chaque-requête">La structure du code si nous pouvions créer une tâche pour chaque requête</a></h4>
<!--
First, let’s explore how our code might look if it did create a new thread for
every connection. As mentioned earlier, this isn’t our final plan due to the
problems with potentially spawning an unlimited number of threads, but it is a
starting point. Listing 20-11 shows the changes to make to `main` to spawn a
new thread to handle each stream within the `for` loop.
-->
<p>Pour commencer, voyons à quoi ressemblerait notre code s'il créait une nouvelle
tâche pour chaque connexion. Comme nous l'avons évoqué précédemment, cela ne
sera pas notre solution finale à cause des problèmes liés à la création
potentielle d'un nombre illimité de tâches, mais c'est un début. L'encart 20-11
montre les changements à apporter au <code>main</code> pour créer une nouvelle tâche pour
gérer chaque flux avec une boucle <code>for</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,no_run
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# use std::thread;
# use std::time::Duration;
# 
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
# 
# fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
#     let sleep = b"GET /sleep HTTP/1.1\r\n";
# 
#     let (status_line, filename) = if buffer.starts_with(get) {
#         ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
#     } else if buffer.starts_with(sleep) {
#         thread::sleep(Duration::from_secs(5));
#         ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
#     } else {
#         ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")
#     };
# 
#     let contents = fs::read_to_string(filename).unwrap();
# 
#     let response = format!("{}{}", status_line, contents);
# 
#     stream.write(response.as_bytes()).unwrap();
#     stream.flush().unwrap();
# }
```
-->
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for flux in ecouteur.incoming() {
        let flux = flux.unwrap();

        thread::spawn(|| {
            gestion_connexion(flux);
        });
    }
}
<span class="boring">
</span><span class="boring">fn gestion_connexion(mut flux: TcpStream) {
</span><span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if tampon.starts_with(pause) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier).unwrap();
</span><span class="boring">
</span><span class="boring">    let reponse = format!(&quot;{}{}&quot;, ligne_statut, contenu);
</span><span class="boring">
</span><span class="boring">    flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">    flux.flush().unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-11: Spawning a new thread for each
stream</span>
-->
<p><span class="caption">Encart 20-11 : création d'une nouvelle tâche pour chaque
flux</span></p>
<!--
As you learned in Chapter 16, `thread::spawn` will create a new thread and then
run the code in the closure in the new thread. If you run this code and load
*/sleep* in your browser, then */* in two more browser tabs, you’ll indeed see
that the requests to */* don’t have to wait for */sleep* to finish. But as we
mentioned, this will eventually overwhelm the system because you’d be making
new threads without any limit.
-->
<p>Comme vous l'avez appris au chapitre 16, <code>thread::spawn</code> va créer une nouvelle
tâche et ensuite exécuter dans cette nouvelle tâche le code présent dans la
fermeture. Si vous exécutez ce code et chargez <em>/pause</em> dans votre navigateur,
et que vous ouvrez <em>/</em> dans deux nouveaux onglets, vous constaterez en effet
que les requêtes vers <em>/</em> n'aurons pas à attendre que <em>/pause</em> se finisse. Mais
comme nous l'avons mentionné, cela peut potentiellement surcharger le système
si vous créez des nouvelles tâches sans limite.</p>
<!--
#### Creating a Similar Interface for a Finite Number of Threads
-->
<h4 id="créer-une-interface-similaire-pour-un-nombre-fini-de-tâches"><a class="header" href="#créer-une-interface-similaire-pour-un-nombre-fini-de-tâches">Créer une interface similaire pour un nombre fini de tâches</a></h4>
<!--
We want our thread pool to work in a similar, familiar way so switching from
threads to a thread pool doesn’t require large changes to the code that uses
our API. Listing 20-12 shows the hypothetical interface for a `ThreadPool`
struct we want to use instead of `thread::spawn`.
-->
<p>Nous souhaitons faire en sorte que notre groupe de tâches fonctionne de la même
manière, donc le remplacement des tâches par le groupe de tâches ne devrait pas
nécessiter de gros changements au code qui utilise notre API. L'encart 20-12
montre une interface éventuelle pour une structure <code>GroupeTaches</code> que nous
souhaitons utiliser à la place de <code>thread::spawn</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# use std::thread;
# use std::time::Duration;
# 
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
# 
# fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
#     let sleep = b"GET /sleep HTTP/1.1\r\n";
# 
#     let (status_line, filename) = if buffer.starts_with(get) {
#         ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
#     } else if buffer.starts_with(sleep) {
#         thread::sleep(Duration::from_secs(5));
#         ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
#     } else {
#         ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")
#     };
# 
#     let contents = fs::read_to_string(filename).unwrap();
# 
#     let response = format!("{}{}", status_line, contents);
# 
#     stream.write(response.as_bytes()).unwrap();
#     stream.flush().unwrap();
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let groupe = GroupeTaches::new(4);

    for flux in ecouteur.incoming() {
        let flux = flux.unwrap();

        groupe.executer(|| {
            gestion_connexion(flux);
        });
    }
}
<span class="boring">
</span><span class="boring">fn gestion_connexion(mut flux: TcpStream) {
</span><span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if tampon.starts_with(pause) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier).unwrap();
</span><span class="boring">
</span><span class="boring">    let reponse = format!(&quot;{}{}&quot;, ligne_statut, contenu);
</span><span class="boring">
</span><span class="boring">    flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">    flux.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 20-12: Our ideal `ThreadPool` interface</span>
-->
<p><span class="caption">Encart 20-12 : Notre interface idéale <code>GroupeTaches</code>
</span></p>
<!--
We use `ThreadPool::new` to create a new thread pool with a configurable number
of threads, in this case four. Then, in the `for` loop, `pool.execute` has a
similar interface as `thread::spawn` in that it takes a closure the pool should
run for each stream. We need to implement `pool.execute` so it takes the
closure and gives it to a thread in the pool to run. This code won’t yet
compile, but we’ll try so the compiler can guide us in how to fix it.
-->
<p>Nous avons utilisé <code>GroupeTaches::new</code> pour créer un nouveau groupe de tâches
avec un nombre configurable de tâches, dans notre cas, quatre. Ensuite, dans
la boucle <code>for</code>, <code>groupe.executer</code> a une interface similaire à <code>thread::spawn</code>
qui prend une fermeture que le groupe devra exécuter pour chaque flux. Nous
devons implémenter <code>groupe.executer</code> pour qu'il prenne la fermeture et la donne
à une tâche dans le groupe pour qu'elle l'exécute. Ce code ne se compile pas
encore, mais nous allons essayer de faire comme ceci pour que le compilateur
puisse nous guider dans la résolution des problèmes.</p>
<!--
#### Building the `ThreadPool` Struct Using Compiler Driven Development
-->
<h4 id="construire-la-structure-groupetaches-en-utilisant-le-développement-orienté-par-le-compilateur"><a class="header" href="#construire-la-structure-groupetaches-en-utilisant-le-développement-orienté-par-le-compilateur">Construire la structure <code>GroupeTaches</code> en utilisant le développement orienté par le compilateur</a></h4>
<!--
Make the changes in Listing 20-12 to *src/main.rs*, and then let’s use the
compiler errors from `cargo check` to drive our development. Here is the first
error we get:
-->
<p>Faites les changements de l'encart 20-12 dans votre <em>src/main.rs</em>, et utilisez
ensuite les erreurs du compilateur lors du <code>cargo check</code> pour orienter votre
développement. Voici la première erreur que nous obtenons :</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type or module `ThreadPool`
  -- > src/main.rs:10:16
   |
10 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type or module `ThreadPool`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0433]: failed to resolve: use of undeclared type or module `GroupeTaches`
  --&gt; src/main.rs:10:16
   |
10 |     let groupe = GroupeTaches::new(4);
   |                  ^^^^^^^^^^^^ use of undeclared type or module `GroupeTaches`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0433`.
error: could not compile `salutations`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Great! This error tells us we need a `ThreadPool` type or module, so we’ll
build one now. Our `ThreadPool` implementation will be independent of the kind
of work our web server is doing. So, let’s switch the `hello` crate from a
binary crate to a library crate to hold our `ThreadPool` implementation. After
we change to a library crate, we could also use the separate thread pool
library for any work we want to do using a thread pool, not just for serving
web requests.
-->
<p>Bien ! Cette erreur nous informe que nous avons besoin d'un type ou d'un module
qui s'appelle <code>GroupeTaches</code>, donc nous allons le créer. Notre implémentation
de <code>GroupeTaches</code> sera indépendante du type de travail qu'accomplira notre
serveur web. Donc, transformons la crate binaire <code>salutations</code> en crate de
bibliothèque pour y implémenter notre <code>GroupeTaches</code>. Après l'avoir changé en
crate de bibliothèque, nous pourrons utiliser ensuite cette bibliothèque de
groupe de tâches dans n'importe quel projet où nous aurons besoin d'un groupe
de tâches, et non pas seulement pour servir des requêtes web.</p>
<!--
Create a *src/lib.rs* that contains the following, which is the simplest
definition of a `ThreadPool` struct that we can have for now:
-->
<p>Créez un <em>src/lib.rs</em> qui contient ceci, qui est la définition la plus
simpliste d'une structure <code>GroupeTaches</code> que nous pouvons avoir pour le
moment :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
pub struct ThreadPool;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GroupeTaches;
<span class="boring">}
</span></code></pre></pre>
<!--
Then create a new directory, *src/bin*, and move the binary crate rooted in
*src/main.rs* into *src/bin/main.rs*. Doing so will make the library crate the
primary crate in the *hello* directory; we can still run the binary in
*src/bin/main.rs* using `cargo run`. After moving the *main.rs* file, edit it
to bring the library crate in and bring `ThreadPool` into scope by adding the
following code to the top of *src/bin/main.rs*:
-->
<p>Créez ensuite un nouveau dossier, <em>src/bin</em>, et déplacez-y la crate binaire qui
est le <em>src/main.rs</em> dans <em>src/bin/main.rs</em>. Faire ceci va faire en sorte que
la crate de bibliothèque soit la crate principale dans le dossier
<em>salutations</em> ; nous pouvons quand même continuer à exécuter le binaire dans
<em>src/bin/main.rs</em> en utilisant <code>cargo run</code>. Après avoir déplacé le fichier
<em>main.rs</em>, modifiez-le pour importer la crate de bibliothèque et importer
<code>GroupeTaches</code> dans la portée en ajoutant le code suivant en haut de
<em>src/bin/main.rs</em> :</p>
<!--
<span class="filename">Filename: src/bin/main.rs</span>
-->
<p><span class="filename">Fichier : src/bin/main.rs</span></p>
<!--
```rust,ignore
use hello::ThreadPool;
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# use std::thread;
# use std::time::Duration;
# 
# fn main() {
#     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
#     let pool = ThreadPool::new(4);
# 
#     for stream in listener.incoming() {
#         let stream = stream.unwrap();
# 
#         pool.execute(|| {
#             handle_connection(stream);
#         });
#     }
# }
# 
# fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
#     let sleep = b"GET /sleep HTTP/1.1\r\n";
# 
#     let (status_line, filename) = if buffer.starts_with(get) {
#         ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
#     } else if buffer.starts_with(sleep) {
#         thread::sleep(Duration::from_secs(5));
#         ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
#     } else {
#         ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")
#     };
# 
#     let contents = fs::read_to_string(filename).unwrap();
# 
#     let response = format!("{}{}", status_line, contents);
# 
#     stream.write(response.as_bytes()).unwrap();
#     stream.flush().unwrap();
# }
```
-->
<pre><code class="language-rust ignore">use salutations::GroupeTaches;
<span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">    let groupe = GroupeTaches::new(4);
</span><span class="boring">
</span><span class="boring">    for flux in ecouteur.incoming() {
</span><span class="boring">        let flux = flux.unwrap();
</span><span class="boring">
</span><span class="boring">        groupe.executer(|| {
</span><span class="boring">            gestion_connexion(flux);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn gestion_connexion(mut flux: TcpStream) {
</span><span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if tampon.starts_with(pause) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier).unwrap();
</span><span class="boring">
</span><span class="boring">    let reponse = format!(&quot;{}{}&quot;, ligne_statut, contenu);
</span><span class="boring">
</span><span class="boring">    flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">    flux.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<!--
This code still won’t work, but let’s check it again to get the next error that
we need to address:
-->
<p>Ce code ne fonctionne toujours pas, mais vérifions-le à nouveau pour obtenir
l'erreur suivante que nous devons résoudre :</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for type `hello::ThreadPool` in the current scope
  -- > src/bin/main.rs:11:28
   |
11 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `hello::ThreadPool`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0599]: no function or associated item named `new` found for type `salutations::GroupeTaches` in the current scope
  --&gt; src/bin/main.rs:11:28
   |
11 |     let groupe = GroupeTaches::new(4);
   |                                ^^^ function or associated item not found in `salutations::GroupeTaches`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `salutations`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
This error indicates that next we need to create an associated function named
`new` for `ThreadPool`. We also know that `new` needs to have one parameter
that can accept `4` as an argument and should return a `ThreadPool` instance.
Let’s implement the simplest `new` function that will have those
characteristics:
-->
<p>Cette erreur indique que nous devons ensuite créer une fonction associée <code>new</code>
pour <code>GroupeTaches</code>. Nous savons aussi que <code>new</code> nécessite d'avoir un paramètre
qui peut accepter <code>4</code> comme argument et doit retourner une instance de
<code>GroupeTaches</code>. Implémentons la fonction <code>new</code> la plus simple possible qui aura
ces caractéristiques :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -> ThreadPool {
        ThreadPool
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
We chose `usize` as the type of the `size` parameter, because we know that a
negative number of threads doesn’t make any sense. We also know we’ll use this
4 as the number of elements in a collection of threads, which is what the
`usize` type is for, as discussed in the [“Integer Types”][integer-types]<!--
ignore -- > section of Chapter 3.
-->
<p>Nous avons choisi <code>usize</code> comme type du paramètre <code>taille</code>, car nous savons
qu'un nombre négatif de tâches n'as pas de sens. Nous savons également que nous
allons utiliser ce 4 comme étant le nombre d'éléments dans une collection de
tâches, ce à quoi sert le type <code>usize</code>, comme nous l'avons vu dans la section
<a href="ch03-02-data-types.html">“Types de nombres entiers”</a><!-- ignore --> du chapitre 3.</p>
<!--
Let’s check the code again:
-->
<p>Vérifions à nouveau le code :</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for type `hello::ThreadPool` in the current scope
  -- > src/bin/main.rs:16:14
   |
16 |         pool.execute(|| {
   |              ^^^^^^^ method not found in `hello::ThreadPool`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0599]: no method named `executer` found for type `salutations::GroupeTaches` in the current scope
  --&gt; src/bin/main.rs:16:14
   |
16 |         groupe.executer(|| {
   |                ^^^^^^^^ method not found in `salutations::GroupeTaches`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `salutations`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Now the error occurs because we don’t have an `execute` method on `ThreadPool`.
Recall from the [“Creating a Similar Interface for a Finite Number of
Threads”](#creating-a-similar-interface-for-a-finite-number-of-threads)<!--
ignore -- > section that we decided our thread pool should have an interface
similar to `thread::spawn`. In addition, we’ll implement the `execute` function
so it takes the closure it’s given and gives it to an idle thread in the pool
to run.
-->
<p>Désormais, nous obtenons une erreur car nous n'avons pas implémenté la méthode
<code>executer</code> sur <code>GroupeTaches</code>. Souvenez-vous que nous avions décidé dans la
section <a href="ch20-02-multithreaded.html#cr%C3%A9er-une-interface-similaire-pour-un-nombre-fini-de-t%C3%A2ches">“Créer une interface similaire pour un nombre fini de
tâches”</a><!--
ignore --> que notre groupe de tâches devrait avoir une interface similaire à
<code>thread::spawn</code>. C'est pourquoi nous allons implémenter la fonction <code>executer</code>
pour qu'elle prenne en argument la fermeture qu'on lui donne et elle la passera
à une tâche inactive du groupe pour qu'elle l'exécute.</p>
<!--
We’ll define the `execute` method on `ThreadPool` to take a closure as a
parameter. Recall from the [“Storing Closures Using Generic Parameters and the
`Fn` Traits”][storing-closures-using-generic-parameters-and-the-fn-traits]<!--
ignore -- > section in Chapter 13 that we can take closures as parameters with
three different traits: `Fn`, `FnMut`, and `FnOnce`. We need to decide which
kind of closure to use here. We know we’ll end up doing something similar to
the standard library `thread::spawn` implementation, so we can look at what
bounds the signature of `thread::spawn` has on its parameter. The documentation
shows us the following:
-->
<p>Nous allons définir la méthode <code>executer</code> sur <code>GroupeTaches</code> pour prendre en
paramètres une fermeture. Souvenez-vous que nous avions vu dans <a href="ch13-01-closures.html">une section du
chapitre 13</a><!--
ignore --> que nous pouvions prendre en paramètre les fermetures avec trois
différents traits : <code>Fn</code>, <code>FnMut</code>, et <code>FnOnce</code>. Nous devons décider quel genre
de fermeture nous allons utiliser ici. Nous savons que nous allons faire quelque
chose de sensiblement identique à l'implémentation du <code>thread::spawn</code> de la
bibliothèque standard, donc nous pouvons nous inspirer de ce qui est attaché à
la signature de <code>thread::spawn</code>. La documentation nous donne ceci :</p>
<!--
```rust,ignore
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T + Send + 'static,
        T: Send + 'static
```
-->
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<!--
The `F` type parameter is the one we’re concerned with here; the `T` type
parameter is related to the return value, and we’re not concerned with that. We
can see that `spawn` uses `FnOnce` as the trait bound on `F`. This is probably
what we want as well, because we’ll eventually pass the argument we get in
`execute` to `spawn`. We can be further confident that `FnOnce` is the trait we
want to use because the thread for running a request will only execute that
request’s closure one time, which matches the `Once` in `FnOnce`.
-->
<p>Le paramètre de type <code>F</code> est celui qui nous intéresse ici ; le paramètre de
type <code>T</code> est lié à la valeur de retour, et nous ne sommes pas intéressés par
ceci. Nous pouvons constater que <code>spawn</code> utilise le trait <code>FnOnce</code> lié à <code>F</code>.
Cela est probablement ce dont nous avons besoin, parce que nous allons sûrement
passer cet argument dans le <code>execute</code> de <code>spawn</code>. Nous pouvons aussi être sûr
que <code>FnOnce</code> est le trait dont nous avons besoin car la tâche qui va exécuter la
requête va exécuter le traitement la requête uniquement une seule fois, ce qui
correspond à la partie <code>Once</code> dans <code>FnOnce</code>.</p>
<!--
The `F` type parameter also has the trait bound `Send` and the lifetime bound
`'static`, which are useful in our situation: we need `Send` to transfer the
closure from one thread to another and `'static` because we don’t know how long
the thread will take to execute. Let’s create an `execute` method on
`ThreadPool` that will take a generic parameter of type `F` with these bounds:
-->
<p>Le paramètre de type <code>F</code> a aussi le trait lié <code>Send</code> et la durée de vie liée
<code>'static</code>, qui sont utiles dans notre situation : nous avons besoin de <code>Send</code>
pour transférer la fermeture d'une tâche vers une autre et de <code>'static</code> car nous
ne savons pas la durée d'exécution de la tâche. Créons donc une méthode
<code>executer</code> sur <code>GroupeTaches</code> qui va utiliser un paramètre générique de type <code>F</code>
avec les liens suivants :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# pub struct ThreadPool;
# 
impl ThreadPool {
    // --snip--
#     pub fn new(size: usize) -> ThreadPool {
#         ThreadPool
#     }
# 
    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct GroupeTaches;
</span><span class="boring">
</span>impl GroupeTaches {
    // -- partie masquée ici--
<span class="boring">    pub fn new(size: usize) -&gt; GroupeTaches {
</span><span class="boring">        GroupeTaches
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn executer&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct GroupeTaches;
</span>impl GroupeTaches {
    // -- partie masquée ici --

    pub fn executer&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {

    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
We still use the `()` after `FnOnce` because this `FnOnce` represents a closure
that takes no parameters and returns the unit type `()`. Just like function
definitions, the return type can be omitted from the signature, but even if we
have no parameters, we still need the parentheses.
-->
<p>Nous utilisons toujours le <code>()</code> après <code>FnOne</code> car ce <code>FnOnce</code> représente une
fermeture qui ne prend pas de paramètres et retourne le type unité <code>()</code>.
Exactement comme les définitions de fonctions, le type de retour peut être omis
de la signature, mais même si elle n'a pas de paramètre, nous avons tout de
même besoin des parenthèses.</p>
<!--
Again, this is the simplest implementation of the `execute` method: it does
nothing, but we’re trying only to make our code compile. Let’s check it again:
-->
<p>A nouveau, c'est l'implémentation la plus simpliste de la méthode <code>executer</code> :
elle ne fait rien, mais nous essayons seulement de faire en sorte que notre code
se compile. Vérifions-le à nouveau :</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<!--
It compiles! But note that if you try `cargo run` and make a request in the
browser, you’ll see the errors in the browser that we saw at the beginning of
the chapter. Our library isn’t actually calling the closure passed to `execute`
yet!
-->
<p>Cela se compile ! Mais remarquez que si vous lancez <code>cargo run</code> et faites la
requête dans votre navigateur web, vous verrez l'erreur dans le navigateur que
nous avions tout au début du chapitre. Notre bibliothèque n'exécute pas encore
la fermeture envoyée à <code>executer</code> !</p>
<!--
> Note: A saying you might hear about languages with strict compilers, such as
> Haskell and Rust, is “if the code compiles, it works.” But this saying is not
> universally true. Our project compiles, but it does absolutely nothing! If we
> were building a real, complete project, this would be a good time to start
> writing unit tests to check that the code compiles *and* has the behavior we
> want.
-->
<blockquote>
<p>Remarque : un dicton que vous avez probablement déjà entendu à propos des
compilateurs strictes, comme Haskell et Rust, est que “si le code se compile,
il fonctionne”. Mais ce dicton n'est pas vrai universellement. Notre projet se
compile, mais il ne fait absolument rien ! Si nous construisions un vrai
projet, complexe, il serait bon de commencer à écrire des tests unitaires pour
vérifier que ce code compile <em>et</em> qu'il suit le comportement que nous
souhaitons.</p>
</blockquote>
<!--
#### Validating the Number of Threads in `new`
-->
<h4 id="valider-le-nombre-de-tâches-envoyé-à-new"><a class="header" href="#valider-le-nombre-de-tâches-envoyé-à-new">Valider le nombre de tâches envoyé à <code>new</code></a></h4>
<!--
We aren’t doing anything with the parameters to `new` and `execute`. Let’s
implement the bodies of these functions with the behavior we want. To start,
let’s think about `new`. Earlier we chose an unsigned type for the `size`
parameter, because a pool with a negative number of threads makes no sense.
However, a pool with zero threads also makes no sense, yet zero is a perfectly
valid `usize`. We’ll add code to check that `size` is greater than zero before
we return a `ThreadPool` instance and have the program panic if it receives a
zero by using the `assert!` macro, as shown in Listing 20-13.
-->
<p>Nous ne faisons rien avec les paramètres <code>new</code> et <code>executer</code>. Implémentons le
corps de ces fonctions avec le comportement que nous souhaitons. Pour commencer,
réfléchissons à <code>new</code>. Précédemment, nous avions choisi un type sans signe pour
le paramètre <code>taille</code>, car un groupe avec un nombre négatif de tâches n'a pas de
sens. Cependant, un groupe avec aucune tâche n'a pas non plus de sens, alors que
zéro est une valeur parfaitement valide pour <code>usize</code>. Nous allons ajouter du
code pour vérifier que <code>taille</code> est plus grand que zéro avant de retourner une
instance de <code>GroupeTaille</code> et faire en sorte que le programme panique s'il
reçoit un zéro, en utilisant la macro <code>assert!</code> comme dans l'encart 20-13.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Filename : src/lib.rs</span></p>
<!--
```rust
# pub struct ThreadPool;
# 
impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        ThreadPool
    }

    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct GroupeTaches;
</span><span class="boring">
</span>impl GroupeTaches {
    /// Crée un nouveau GroupeTaches.
    ///
    /// La taille est le nom de tâches présentes dans le groupe.
    ///
    /// # Panics
    ///
    /// La fonction `new` devrait paniquer si la taille vaut zéro.
    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        GroupeTaches
    }

    // -- partie masquée ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-13: Implementing `ThreadPool::new` to panic if
`size` is zero</span>
-->
<p><span class="caption">Encart 20-13 : implémentation de <code>GroupeTaches::new</code> qui
devrait paniquer si <code>taille</code> vaut zéro</span></p>
<!--
We’ve added some documentation for our `ThreadPool` with doc comments. Note
that we followed good documentation practices by adding a section that calls
out the situations in which our function can panic, as discussed in Chapter 14.
Try running `cargo doc --open` and clicking the `ThreadPool` struct to see what
the generated docs for `new` look like!
-->
<p>Nous avons ajouté un peu de documentation pour notre <code>GroupeTaches</code> avec des
commentaires de documentation. Remarquez que nous avons suivi les pratiques de
bonne documentation en ajoutant une section qui liste les situations pour
lesquelles notre fonction peut paniquer, comme nous l'avons vu dans le
chapitre 14. Essayez de lancer <code>cargo doc --open</code> et de cliquer sur la structure
<code>GroupeTaches</code> pour voir à quoi ressemble la documentation générée pour <code>new</code> !</p>
<!--
Instead of adding the `assert!` macro as we’ve done here, we could make `new`
return a `Result` like we did with `Config::new` in the I/O project in Listing
12-9. But we’ve decided in this case that trying to create a thread pool
without any threads should be an unrecoverable error. If you’re feeling
ambitious, try to write a version of `new` with the following signature to
compare both versions:
-->
<p>Au lieu d'ajouter la macro <code>assert!</code> comme nous venons de faire, nous aurions pu
faire en sorte que <code>new</code> retourne un <code>Result</code> comme nous l'avions fait avec
<code>Config::new</code> dans le projet d'entrée/sortie dans l'encart 12-9. Mais nous avons
décidé que dans le cas d'une création d'un groupe de tâche sans aucune tâche
devrait être une erreur irrécupérable. Si vous en sentez l'envie, essayez
d'écrire une version de <code>new</code> avec la signature suivante, pour comparer les deux
versions :</p>
<!--
```rust,ignore
pub fn new(size: usize) -> Result<ThreadPool, PoolCreationError> {
```
-->
<pre><code class="language-rust ignore">pub fn new(taille: usize) -&gt; Result&lt;GroupeTaches, ErreurGroupeTaches&gt; {
</code></pre>
<!--
#### Creating Space to Store the Threads
-->
<h4 id="créer-lespace-de-rangement-des-tâches"><a class="header" href="#créer-lespace-de-rangement-des-tâches">Créer l'espace de rangement des tâches</a></h4>
<!--
Now that we have a way to know we have a valid number of threads to store in
the pool, we can create those threads and store them in the `ThreadPool` struct
before returning it. But how do we “store” a thread? Let’s take another look at
the `thread::spawn` signature:
-->
<p>Maintenant que nous avons une manière de savoir si nous avons un nombre valide
de tâches à stocker dans le groupe, nous pouvons créer ces tâches et les stocker
dans la structure <code>GroupeTaches</code> avant de la retourner. Mais comment “stocker”
une tâche ? Regardons à nouveau la signature de <code>thread::spawn</code> :</p>
<!--
```rust,ignore
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T + Send + 'static,
        T: Send + 'static
```
-->
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<!--
The `spawn` function returns a `JoinHandle<T>`, where `T` is the type that the
closure returns. Let’s try using `JoinHandle` too and see what happens. In our
case, the closures we’re passing to the thread pool will handle the connection
and not return anything, so `T` will be the unit type `()`.
-->
<p>La fonction <code>spawn</code> retourne un <code>JoinHandle&lt;T&gt;</code>, où <code>T</code> est le type que retourne
notre fermeture. Essayons d'utiliser nous aussi <code>JoinHandle</code> pour voir ce qu'il
se passe. Dans notre cas, les fermetures que nous passons dans le groupe de
tâches vont traiter les connexions mais ne vont rien retourner, donc <code>T</code> sera le
type unité, <code>()</code>.</p>
<!--
The code in Listing 20-14 will compile but doesn’t create any threads yet.
We’ve changed the definition of `ThreadPool` to hold a vector of
`thread::JoinHandle<()>` instances, initialized the vector with a capacity of
`size`, set up a `for` loop that will run some code to create the threads, and
returned a `ThreadPool` instance containing them.
-->
<p>Le code de l'encart 20-14 va se compiler mais ne va pas encore créer de tâches
pour le moment. Nous avons changé la définition du <code>GroupeTaches</code> pour qu'il
possède un vecteur d'instances <code>thread::JoinHandle&lt;()&gt;</code>, nous avons initialisé
le vecteur avec une capacité de la valeur de <code>taille</code>, mis en place une boucle
<code>for</code> qui va exécuter du code pour créer les tâches, et nous avons retourné une
instance de <code>GroupeTaches</code> qui les contient.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,not_desired_behavior
use std::thread;

pub struct ThreadPool {
    threads: Vec<thread::JoinHandle<()>>,
}

impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }

    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}
```
-->
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct GroupeTaches {
    taches: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl GroupeTaches {
    // -- partie masquée ici --
<span class="boring">    /// Crée un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tâches présentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zéro.
</span>    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let mut taches = Vec::with_capacity(taille);

        for _ in 0..taille {
            // on crée quelques tâches ici et on les stocke dans le vecteur
        }

        GroupeTaches { taches }
    }

    // -- partie masquée ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
</code></pre>
<!--
<span class="caption">Listing 20-14: Creating a vector for `ThreadPool` to hold
the threads</span>
-->
<p><span class="caption">Encart 20-14 : création d'un vecteur pour <code>GroupeTaches</code>
pour stocker les tâches</span></p>
<!--
We’ve brought `std::thread` into scope in the library crate, because we’re
using `thread::JoinHandle` as the type of the items in the vector in
`ThreadPool`.
-->
<p>Nous avons importé <code>std::thread</code> dans la portée de la crate de bibliothèque, car
nous utilisons <code>thread::JoinHandle</code> comme étant le type des éléments du vecteur
dans <code>GroupeTaches</code>.</p>
<!--
Once a valid size is received, our `ThreadPool` creates a new vector that can
hold `size` items. We haven’t used the `with_capacity` function in this book
yet, which performs the same task as `Vec::new` but with an important
difference: it preallocates space in the vector. Because we know we need to
store `size` elements in the vector, doing this allocation up front is slightly
more efficient than using `Vec::new`, which resizes itself as elements are
inserted.
-->
<p>Une fois qu'une taille valide est reçue, notre <code>GroupeTaches</code> crée un nouveau
vecteur qui peut stocker <code>taille</code> éléments. Nous n'avons pas encore utilisé la
fonction <code>with_capacity</code> dans ce livre, qui fait la même chose que <code>Vec::new</code>
mais avec une grosse différence : elle pré-alloue l'espace dans le vecteur.
Comme nous savons que nous avons besoin de stocker <code>taille</code> éléments dans le
vecteur, faire cette allocation en amont est bien plus efficace que d'utiliser
<code>Vec::new</code>, qui va se redimentionner lorsque des éléments lui seront rajoutés.</p>
<!--
When you run `cargo check` again, you’ll get a few more warnings, but it should
succeed.
-->
<p>Lorsque vous lancez à nouveau <code>cargo check</code>, vous devriez avoir quelques
avertissements en plus, mais cela devrait être un succès.</p>
<!-- markdownlint-disable -->
<!--
#### A `Worker` Struct Responsible for Sending Code from the `ThreadPool` to a Thread
-->
<!-- markdownlint-enable -->
<h4 id="une-structure-operateur-chargé-denvoyer-le-code-de-groupetaches-à-une-tâche"><a class="header" href="#une-structure-operateur-chargé-denvoyer-le-code-de-groupetaches-à-une-tâche">Une structure <code>Operateur</code> chargé d'envoyer le code de <code>GroupeTaches</code> à une tâche</a></h4>
<!--
We left a comment in the `for` loop in Listing 20-14 regarding the creation of
threads. Here, we’ll look at how we actually create threads. The standard
library provides `thread::spawn` as a way to create threads, and
`thread::spawn` expects to get some code the thread should run as soon as the
thread is created. However, in our case, we want to create the threads and have
them *wait* for code that we’ll send later. The standard library’s
implementation of threads doesn’t include any way to do that; we have to
implement it manually.
-->
<p>Nous avons laissé un commentaire dans la boucle <code>for</code> dans l'encart 20-14 qui
concernait la création des tâches. Ici, nous allons voir comment nous créer les
tâches. La bibliothèque standard fournit une manière de créer les tâches avec
<code>thread::spawn</code>, et <code>thread::spawn</code> doit recevoir du code que la tâche doit
exécuter dès que la tâche est créée. Cependant, dans notre cas, nous souhaitons
créer les tâches et qu'elles <em>attendent</em> du code que nous leur enverrons plus
tard. L'implémentation des tâches de la bibliothèque standard n'offre pas les
moyens de faire ceci ; nous devons implémenter cela manuellement.</p>
<!--
We’ll implement this behavior by introducing a new data structure between the
`ThreadPool` and the threads that will manage this new behavior. We’ll call
this data structure `Worker`, which is a common term in pooling
implementations. Think of people working in the kitchen at a restaurant: the
workers wait until orders come in from customers, and then they’re responsible
for taking those orders and filling them.
-->
<p>Nous allons implémenter ce comportement en introduisant une nouvelle structure
de données entre le <code>GroupeTaches</code> et les tâches qui va gérer ce nouveau
comportement. Nous allons appeler cette structure <code>Operateur</code>, qui est souvent
appelé <code>Worker</code> dans les implémentations de groupe. C'est comme des personnes
qui travaillent dans la cuisine d'un restaurant : les opérateurs attendent les
commandes des clients, et ils sont chargés de prendre en charge ces commandes et
d'y répondre.</p>
<!--
Instead of storing a vector of `JoinHandle<()>` instances in the thread pool,
we’ll store instances of the `Worker` struct. Each `Worker` will store a single
`JoinHandle<()>` instance. Then we’ll implement a method on `Worker` that will
take a closure of code to run and send it to the already running thread for
execution. We’ll also give each worker an `id` so we can distinguish between
the different workers in the pool when logging or debugging.
-->
<p>Au lieu de stocker un vecteur d'instances <code>JoinHandle&lt;()&gt;</code> dans le groupe de
tâches, nous allons stocker les instances de structure <code>Operateur</code>. Chaque
<code>Operateur</code> va stocker une seule instance de <code>JoinHandle&lt;()&gt;</code>. Ensuite nous
implémenterons une méthode sur <code>Operateur</code> qui va prendre en argument une
fermeture de code à exécuter et l'envoyer à une tâche qui fonctionne déjà pour
exécution. Nous allons aussi donner à chacun des opérateurs un identifiant <code>id</code>
afin que nous puissions distinguer les différents opérateurs dans le groupe
dans les journaux ou lors de déboguages.</p>
<!--
Let’s make the following changes to what happens when we create a `ThreadPool`.
We’ll implement the code that sends the closure to the thread after we have
`Worker` set up in this way:
-->
<p>Appliquons ces changements à l'endroit où nous créons un <code>GroupeTaches</code>. Nous
allons implémenter le code de <code>Operateur</code> qui envoie la fermeture à la tâche
selon ces instructions :</p>
<!--
1. Define a `Worker` struct that holds an `id` and a `JoinHandle<()>`.
2. Change `ThreadPool` to hold a vector of `Worker` instances.
3. Define a `Worker::new` function that takes an `id` number and returns a
   `Worker` instance that holds the `id` and a thread spawned with an empty
   closure.
4. In `ThreadPool::new`, use the `for` loop counter to generate an `id`, create
   a new `Worker` with that `id`, and store the worker in the vector.
-->
<ol>
<li>Définir une structure <code>Operateur</code> qui possède un <code>id</code> et un <code>JoinHandle&lt;()&gt;</code>.</li>
<li>Changer le <code>GroupeTaches</code> pour posséder un vecteur d'instances de
<code>Operateur</code>.</li>
<li>Définir une fonction <code>Operateur::new</code> qui prend en argument un nombre <code>id</code>
et retourne une instance de <code>Operateur</code> qui contient le <code>id</code> et une tâche
créée avec une fermeture vide.</li>
<li>Dans <code>GroupeTaches::new</code>, utilisons le compteur de la boucle <code>for</code> pour
générer un <code>id</code>, créer un nouveau <code>Operateur</code> avec cet <code>id</code>, et stocker
l'opérateur dans le vecteur.</li>
</ol>
<!--
If you’re up for a challenge, try implementing these changes on your own before
looking at the code in Listing 20-15.
-->
<p>Si vous vous sentez prêt(e) à relever le défi, essayez de faire ces changements
de votre côté avant de regarder le code de l'encart 20-15.</p>
<!--
Ready? Here is Listing 20-15 with one way to make the preceding modifications.
-->
<p>Vous êtes prêt(e) ? Voici l'encart 20-15 qui propose une solution pour procéder
aux changements listés précédemment.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
use std::thread;

pub struct ThreadPool {
    workers: Vec<Worker>,
}

impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
    fn new(id: usize) -> Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::thread;

pub struct GroupeTaches {
    operateurs: Vec&lt;Operateur&gt;,
}

impl GroupeTaches {
    // -- partie masquée ici --
<span class="boring">    /// Crée un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tâches présentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zéro.
</span>    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let mut operateurs = Vec::with_capacity(taille);

        for id in 0..taille {
            operateurs.push(Operateur::new(id));
        }

        GroupeTaches { operateurs }
    }
    // -- partie masquée ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Operateur {
    id: usize,
    tache: thread::JoinHandle&lt;()&gt;,
}

impl Operateur {
    fn new(id: usize) -&gt; Operateur {
        let tache = thread::spawn(|| {});

        Operateur { id, tache }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-15: Modifying `ThreadPool` to hold `Worker`
instances instead of holding threads directly</span>
-->
<p><span class="caption">Encart 20-15 : modification de <code>GroupeTaches</code> pour
stocker des instances de <code>Operateur</code> plutôt que de stocker directement des
tâches</span></p>
<!--
We’ve changed the name of the field on `ThreadPool` from `threads` to `workers`
because it’s now holding `Worker` instances instead of `JoinHandle<()>`
instances. We use the counter in the `for` loop as an argument to
`Worker::new`, and we store each new `Worker` in the vector named `workers`.
-->
<p>Nous avons changé le nom du champ <code>taches</code> sur <code>GroupeTaches</code> par <code>operateurs</code>
car il stocke maintenant des instances de <code>Operateur</code> plutôt que des instances
de <code>JoinHandle&lt;()&gt;</code>. Nous utilisons le compteur de la boucle <code>for</code> en argument
de <code>Operateur::new</code>, et nous stockons chacun des nouveaux <code>Operateur</code> dans le
vecteur <code>operateurs</code>.</p>
<!--
External code (like our server in *src/bin/main.rs*) doesn’t need to know the
implementation details regarding using a `Worker` struct within `ThreadPool`,
so we make the `Worker` struct and its `new` function private. The
`Worker::new` function uses the `id` we give it and stores a `JoinHandle<()>`
instance that is created by spawning a new thread using an empty closure.
-->
<p>Le code externe (comme celui de notre serveur dans <em>src/bin/main.rs</em>) n'a pas
besoin de connaître les détails de l'implémentation qui utilise une structure
<code>Operateur</code> dans <code>GroupeTaches</code>, donc nous faisons en sorte que la structure
<code>Operateur</code> et sa fonction <code>new</code> restent privées. La fonction <code>Operateur::new</code>
utilise le <code>id</code> que nous lui donnons et stocke une instance de <code>JoinHandle&lt;()&gt;</code>
qui est créée en créant une nouvelle tâche en utilisant une fermeture vide.</p>
<!--
This code will compile and will store the number of `Worker` instances we
specified as an argument to `ThreadPool::new`. But we’re *still* not processing
the closure that we get in `execute`. Let’s look at how to do that next.
-->
<p>Ce code va se compiler et stocker le nombre d'instances de <code>Operateur</code> que nous
avons renseigné en argument de <code>GroupeTaches::new</code>. Mais nous n'exécutons
<em>toujours pas</em> la fermeture que nous obtenons de <code>executer</code>. Voyons désormais
comment faire cela.</p>
<!--
#### Sending Requests to Threads via Channels
-->
<h4 id="envoyer-des-requêtes-à-des-tâches-via-les-canaux"><a class="header" href="#envoyer-des-requêtes-à-des-tâches-via-les-canaux">Envoyer des requêtes à des tâches via les canaux</a></h4>
<!--
Now we’ll tackle the problem that the closures given to `thread::spawn` do
absolutely nothing. Currently, we get the closure we want to execute in the
`execute` method. But we need to give `thread::spawn` a closure to run when we
create each `Worker` during the creation of the `ThreadPool`.
-->
<p>Maintenant nous allons nous pencher sur le problème qui fait que les fermetures
passées à <code>thread::spawn</code> ne font absolument rien. Actuellement, nous obtenons
la fermeture que nous souhaitons exécuter dans la méthode <code>executer</code>. Mais nous
avons besoin de donner une fermeture à <code>thread::spawn</code> pour qu'elle l'exécute
lorsque nous créons chaque <code>Operateur</code> pendant la création de <code>GroupeTaches</code>.</p>
<!--
We want the `Worker` structs that we just created to fetch code to run from a
queue held in the `ThreadPool` and send that code to its thread to run.
-->
<p>Nous souhaitons que les structures <code>Operateur</code> que nous venons de créer
récupèrent du code à exécuter dans une liste d'attente présente dans le
<code>GroupeTaches</code> et renvoient ce code à leur tâche pour l'exécuter.</p>
<!--
In Chapter 16, you learned about *channels*—a simple way to communicate between
two threads—that would be perfect for this use case. We’ll use a channel to
function as the queue of jobs, and `execute` will send a job from the
`ThreadPool` to the `Worker` instances, which will send the job to its thread.
Here is the plan:
-->
<p>Dans le chapitre 16, vous avez appris les <em>canaux</em> (une manière simple de
communiquer entre deux tâches) qui seront parfaits pour ce cas d'emploi. Nous
allons utiliser un canal pour les fonctions pour créer la liste d'attente des
missions, et <code>executer</code> devrait envoyer une mission de <code>GroupeTaches</code> vers les
instances <code>Operateur</code>, qui vont passer la mission à leurs tâches. Voici le
plan :</p>
<!--
1. The `ThreadPool` will create a channel and hold on to the sending side of
   the channel.
2. Each `Worker` will hold on to the receiving side of the channel.
3. We’ll create a new `Job` struct that will hold the closures we want to send
   down the channel.
4. The `execute` method will send the job it wants to execute down the sending
   side of the channel.
5. In its thread, the `Worker` will loop over its receiving side of the channel
   and execute the closures of any jobs it receives.
-->
<ol>
<li>Le <code>GroupeTaches</code> va créer un canal et conserver la partie d'envoi du canal.</li>
<li>Chaque <code>Operateur</code> va conserver la partie de réception du canal.</li>
<li>Nous allons créer une nouvelle structure <code>Mission</code> qui va stocker les
fermetures que nous souhaitons envoyer dans le canal.</li>
<li>La méthode <code>executer</code> va envoyer la mission qu'elle souhaite executer dans
la zone d'envoi du canal.</li>
<li>Dans sa propre tâche, le <code>Operateur</code> va vérifier en permanence la partie
réception du canal et exécuter les fermetures des missions qu'il va
recevoir.</li>
</ol>
<!--
Let’s start by creating a channel in `ThreadPool::new` and holding the sending
side in the `ThreadPool` instance, as shown in Listing 20-16. The `Job` struct
doesn’t hold anything for now but will be the type of item we’re sending down
the channel.
-->
<p>Commençons par créer un canal dans <code>GroupeTaches::new</code> et stocker la partie
d'envoi dans l'instance de <code>GroupeTaches</code>, comme dans l'encart 20-16. La
structure <code>Mission</code> ne contient rien pour le moment, mais sera le type
d'éléments que nous enverrons dans le canal.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# use std::thread;
// --snip--
use std::sync::mpsc;

pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Job>,
}

struct Job;

impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}
# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
# impl Worker {
#     fn new(id: usize) -> Worker {
#         let thread = thread::spawn(|| {});
# 
#         Worker { id, thread }
#     }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span>// -- partie masquée ici --
use std::sync::mpsc;

pub struct GroupeTaches {
    operateurs: Vec&lt;Operateur&gt;,
    envoi: mpsc::Sender&lt;Mission&gt;,
}

struct Mission;

impl GroupeTaches {
    // -- partie masquée ici --
<span class="boring">    /// Crée un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tâches présentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zéro.
</span>    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let (envoi, reception) = mpsc::channel();

        let mut operateurs = Vec::with_capacity(taille);

        for id in 0..taille {
            operateurs.push(Operateur::new(id));
        }

        GroupeTaches { operateurs, envoi }
    }
    // -- partie masquée ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Operateur { id, tache }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-16: Modifying `ThreadPool` to store the
sending end of a channel that sends `Job` instances</span>
-->
<p><span class="caption">Encart 20-16 : modification de <code>GroupeTaches</code> pour
stocker la partie d'envoi du canal qui envoie des instances de <code>Mission</code></span></p>
<!--
In `ThreadPool::new`, we create our new channel and have the pool hold the
sending end. This will successfully compile, still with warnings.
-->
<p>Dans <code>GroupeTaches::new</code>, nous créons notre nouveau canal et faisons en sorte
que le groupe stocke la partie d'envoi. Cela devrait pouvoir se compiler, mais
il subsiste des avertissements.</p>
<!--
Let’s try passing a receiving end of the channel into each worker as the thread
pool creates the channel. We know we want to use the receiving end in the
thread that the workers spawn, so we’ll reference the `receiver` parameter in
the closure. The code in Listing 20-17 won’t quite compile yet.
-->
<p>Essayons de donner la partie réceptrice du canal à chacun des opérateurs
lorsque le groupe de tâches crée le canal. Nous savons que nous voulons
utiliser la partie réceptrice dans la tâche que l'opérateur utilise, donc nous
allons créer une référence vers le paramètre <code>reception</code> dans la fermeture. Le
code de l'encart 20-17 ne se compile pas encore.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::sync::mpsc;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# struct Job;
# 
impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}

// --snip--

# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Mission;
</span><span class="boring">
</span>impl GroupeTaches {
    // -- partie masquée ici --
<span class="boring">    /// Crée un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tâches présentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zéro.
</span>    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let (envoi, reception) = mpsc::channel();

        let mut operateurs = Vec::with_capacity(taille);

        for id in 0..taille {
            operateurs.push(Operateur::new(id, reception));
        }

        GroupeTaches { operateurs, envoi }
    }
    // -- partie masquée ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// -- partie masquée ici --

<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Operateur {
    fn new(id: usize, reception: mpsc::Receiver&lt;Mission&gt;) -&gt; Operateur {
        let tache = thread::spawn(|| {
            reception;
        });

        Operateur { id, tache }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-17: Passing the receiving end of the channel
to the workers</span>
-->
<p><span class="caption">Encart 20-17 : envoi de la partie réceptrice du canal aux
opérateurs</span></p>
<!--
We’ve made some small and straightforward changes: we pass the receiving end of
the channel into `Worker::new`, and then we use it inside the closure.
-->
<p>Nous avons fait des petites et simples modifications : nous envoyons la partie
réceptrice du canal dans <code>Operateur::new</code>, et ensuite nous l'utilisons dans la
fermeture.</p>
<!--
When we try to check this code, we get this error:
-->
<p>Lorsque nous essayons de vérifier ce code, nous obtenons cette erreur :</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  -- > src/lib.rs:27:42
   |
22 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver<Job>`, which does not implement the `Copy` trait
...
27 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0382]: use of moved value: `reception`
  --&gt; src/lib.rs:27:42
   |
22 |         let (envoi, reception) = mpsc::channel();
   |                     --------- move occurs because `reception` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
27 |             operateurs.push(Worker::new(id, reception));
   |                                             ^^^^^^^^^ value moved here, in previous iteration of loop

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `salutations`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The code is trying to pass `receiver` to multiple `Worker` instances. This
won’t work, as you’ll recall from Chapter 16: the channel implementation that
Rust provides is multiple *producer*, single *consumer*. This means we can’t
just clone the consuming end of the channel to fix this code. Even if we could,
that is not the technique we would want to use; instead, we want to distribute
the jobs across threads by sharing the single `receiver` among all the workers.
-->
<p>Le code essaye d'envoyer <code>reception</code> dans plusieurs instances de <code>Operateur</code>.
Ceci ne fonctionne pas, comme vous l'avez appris au chapitre 16 :
l'implémentation du canal que fournit Rust est du type plusieurs <em>producteurs</em>,
un seul <em>consommateur</em>. Cela signifie que nous ne pouvons pas simplement cloner
la partie réceptrice du canal pour corriger ce code. Même si nous aurions pu le
faire, ce n'est pas la solution que nous souhaitons utiliser ; nous voulons
plutôt distribuer les missions entre les tâches en partageant la même réception
entre tous les opérateurs.</p>
<!--
Additionally, taking a job off the channel queue involves mutating the
`receiver`, so the threads need a safe way to share and modify `receiver`;
otherwise, we might get race conditions (as covered in Chapter 16).
-->
<p>De plus, obtenir une mission de la file d'attente du canal implique de muter le
<code>reception</code>, donc les tâches ont besoin d'une méthode sécurisée pour partager
et modifier <code>reception</code> ; autrement, nous allons avoir des situations de
concurrence (comme nous l'avons vu dans le chapitre 16).</p>
<!--
Recall the thread-safe smart pointers discussed in Chapter 16: to share
ownership across multiple threads and allow the threads to mutate the value, we
need to use `Arc<Mutex<T>>`. The `Arc` type will let multiple workers own the
receiver, and `Mutex` will ensure that only one worker gets a job from the
receiver at a time. Listing 20-18 shows the changes we need to make.
-->
<p>Souvenez-vous des pointeurs intelligents conçus pour les échanges entre les
tâches que nous avons vus au chapitre 16 : pour partager la possession entre
plusieurs tâches et permettre aux tâches de muter la valeur, nous avons besoin
d'utiliser <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. Le type <code>Arc</code> va permettre à plusieurs opérateurs
de posséder la réception, et <code>Mutex</code> va s'assurer que seulement un seul
opérateur obtienne la mission dans la réception au même moment. L'encart 20-18
montre les changements que nous devons apporter.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# use std::sync::mpsc;
# use std::thread;
use std::sync::Arc;
use std::sync::Mutex;
// --snip--

# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# struct Job;
# 
impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#     }
}

// --snip--

# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        // --snip--
#         let thread = thread::spawn(|| {
#             receiver;
#         });
# 
#         Worker { id, thread }
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span>use std::sync::Arc;
use std::sync::Mutex;
// -- partie masquée ici --

<span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Mission;
</span><span class="boring">
</span>impl GroupeTaches {
    // -- partie masquée ici --
<span class="boring">    /// Crée un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tâches présentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zéro.
</span>    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let (envoi, reception) = mpsc::channel();

        let reception = Arc::new(Mutex::new(reception));

        let mut operateurs = Vec::with_capacity(taille);

        for id in 0..taille {
            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
        }

        GroupeTaches { operateurs, envoi }
    }

    // -- partie masquée ici --
<span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// -- partie masquée ici --

<span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
        // -- partie masquée ici --
<span class="boring">        let tache = thread::spawn(|| {
</span><span class="boring">            reception;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur { id, tache }
</span>    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-18: Sharing the receiving end of the channel
among the workers using `Arc` and `Mutex`</span>
-->
<p><span class="caption">Encart 20-18 : partage de la partie réceptrice du canal
entre les opérateurs en utilisant <code>Arc</code> et <code>Mutex</code></span></p>
<!--
In `ThreadPool::new`, we put the receiving end of the channel in an `Arc` and a
`Mutex`. For each new worker, we clone the `Arc` to bump the reference count so
the workers can share ownership of the receiving end.
-->
<p>Dans <code>GroupeTaches::new</code>, nous installons la partie réceptrice du canal dans un
<code>Arc</code> et un <code>Mutex</code>. Pour chaque nouvel opérateur, nous clonons le <code>Arc</code> pour
augmenter le compteur de références afin que les opérateurs puissent se
partager la possession de la partie réceptrice.</p>
<!--
With these changes, the code compiles! We’re getting there!
-->
<p>Grâce à ces changements, le code se compile ! Nous touchons au but !</p>
<!--
#### Implementing the `execute` Method
-->
<h4 id="implémenter-la-méthode-executer"><a class="header" href="#implémenter-la-méthode-executer">Implémenter la méthode <code>executer</code></a></h4>
<!--
Let’s finally implement the `execute` method on `ThreadPool`. We’ll also change
`Job` from a struct to a type alias for a trait object that holds the type of
closure that `execute` receives. As discussed in the [“Creating Type Synonyms
with Type Aliases”][creating-type-synonyms-with-type-aliases]<!-- ignore -- >
section of Chapter 19, type aliases allow us to make long types shorter. Look
at Listing 20-19.
-->
<p>Finissons par implémenter la méthode <code>executer</code> sur <code>GroupeTaches</code>. Nous allons
aussi modifier la structure <code>Mission</code> pour devenir un alias de type pour un
objet trait qui contiendra le type de la fermeture que <code>executer</code> recevra.
Comme nous l'avons vu dans <a href="ch19-04-advanced-types.html">une section du
chapitre 19</a><!-- ignore -->, les
alias de type nous permettent de raccourcir les types un peu trop longs.
Voyez cela dans l'encart 20-19.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
// --snip--

type Job = Box<dyn FnOnce() + Send + 'static>;

impl ThreadPool {
    // --snip--
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
#         let thread = thread::spawn(|| {
#             receiver;
#         });
# 
#         Worker { id, thread }
#     }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquée ici --

type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl GroupeTaches {
    // -- partie masquée ici --
<span class="boring">    /// Crée un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tâches présentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zéro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span>
    pub fn executer&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let mission = Box::new(f);

        self.envoi.send(mission).unwrap();
    }
}

// -- partie masquée ici --
<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(|| {
</span><span class="boring">            reception;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur { id, tache }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-19: Creating a `Job` type alias for a `Box`
that holds each closure and then sending the job down the channel</span>
-->
<p><span class="caption">Encart 20-19 : création d'un alias de type <code>Mission</code>
pour une <code>Box</code> qui contient chaque fermeture et qui transportera la mission
dans le canal</span></p>
<!--
After creating a new `Job` instance using the closure we get in `execute`, we
send that job down the sending end of the channel. We’re calling `unwrap` on
`send` for the case that sending fails. This might happen if, for example, we
stop all our threads from executing, meaning the receiving end has stopped
receiving new messages. At the moment, we can’t stop our threads from
executing: our threads continue executing as long as the pool exists. The
reason we use `unwrap` is that we know the failure case won’t happen, but the
compiler doesn’t know that.
-->
<p>Après avoir créé une nouvelle instance <code>Mission</code> en utilisant la fermeture que
nous obtenons dans <code>executer</code>, nous envoyons cette mission dans le canal via la
partie émettrice. Nous utilisons <code>unwrap</code> sur <code>send</code> pour les cas où l'envoi
échoue. Cela peut arriver si, par exemple, nous stoppons l'exécution de toutes
les tâches, ce qui signifiera que les parties réceptrices auront finis de
recevoir des nouveaux messages. Pour le moment, nous ne pouvons pas stopper
l'exécution de nos tâches : nos tâches continuerons à s'exécuter aussi
longtemps que le groupe existe. La raison pour laquelle nous utilisons <code>unwrap</code>
est que nous savons que le cas d'échec ne va pas se produire, mais le
compilateur ne le sait pas.</p>
<!--
But we’re not quite done yet! In the worker, our closure being passed to
`thread::spawn` still only *references* the receiving end of the channel.
Instead, we need the closure to loop forever, asking the receiving end of the
channel for a job and running the job when it gets one. Let’s make the change
shown in Listing 20-20 to `Worker::new`.
-->
<p>Mais nous n'avons pas encore fini ! Dans l'opérateur, notre fermeture envoyée
à <code>thread::spawn</code> ne fait que <em>référencer</em> la sortie du canal. Nous avons
plutôt besoin d'une fermeture pour faire une boucle à l'infini, qui demandera
une mission à la sortie du canal et exécuter cette mission lorsqu'il en obtient
un. Appliquons les changements montrés dans l'encart 20-20 à <code>Operateur::new</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!("Worker {} got a job; executing.", id);

            job();
        });

        Worker { id, thread }
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// Crée un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tâches présentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zéro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// -- partie masquée ici --

impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
        let tache = thread::spawn(move || loop {
            let mission = reception.lock().unwrap().recv().unwrap();

            println!(&quot;L'opérateur {} a obtenu une mission ; il l'exécute.&quot;, id);

            mission();
        });

        Operateur { id, tache }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-20: Receiving and executing the jobs in the
worker’s thread</span>
-->
<p><span class="caption">Encart 20-20 : réception et exécution des missions dans
la tâche de l'opérateur</span></p>
<!--
Here, we first call `lock` on the `receiver` to acquire the mutex, and then we
call `unwrap` to panic on any errors. Acquiring a lock might fail if the mutex
is in a *poisoned* state, which can happen if some other thread panicked while
holding the lock rather than releasing the lock. In this situation, calling
`unwrap` to have this thread panic is the correct action to take. Feel free to
change this `unwrap` to an `expect` with an error message that is meaningful to
you.
-->
<p>Ici, nous faisons d'abord appel à <code>lock</code> sur <code>reception</code> pour obtenir le mutex,
et ensuite nous faisons appel à <code>unwrap</code> pour paniquer dès qu'il y a une
erreur. L'acquisition d'un verrou peut échouer si le mutex est dans un état
<em>empoisonné</em>, ce qui peut arriver si d'autres tâches ont paniqué pendant
qu'elles avaient le verrou, au lieu de le rendre. Dans cette situation, l'appel
à <code>unwrap</code> fera paniquer la tâche, ce qui est la bonne chose à faire. Vous
pouvez aussi changer ce <code>unwrap</code> en un <code>expect</code> avec un message d'erreur qui
vous est plus explicite.</p>
<!--
If we get the lock on the mutex, we call `recv` to receive a `Job` from the
channel. A final `unwrap` moves past any errors here as well, which might occur
if the thread holding the sending side of the channel has shut down, similar to
how the `send` method returns `Err` if the receiving side shuts down.
-->
<p>Si nous obtenons le verrou du mutex, nous faisons appel à <code>recv</code> pour recevoir
une <code>Mission</code> provenant du canal. Un <code>unwrap</code> final s'occupe lui aussi des cas
d'erreurs, qui peuvent se produire si la tâche qui contient la partie émettrice
du canal se termine, de la même manière que la méthode <code>send</code> enverrait <code>Err</code>
si la partie réceptrice se fermerait.</p>
<!--
The call to `recv` blocks, so if there is no job yet, the current thread will
wait until a job becomes available. The `Mutex<T>` ensures that only one
`Worker` thread at a time is trying to request a job.
-->
<p>L'appel à <code>recv</code> bloque l'exécution, donc s'il n'y a pas encore de mission, la
tâche courante va attendre jusqu'à ce qu'une mission soit disponible. Le
<code>Mutex&lt;T&gt;</code> s'assure qu'une seule tâche d'<code>Operateur</code> obtienne une même mission
à la fois.</p>
<!--
With the implementation of this trick, our thread pool is in a working state!
Give it a `cargo run` and make some requests:
-->
<p>Avec l'implémentation de cette astuce, notre groupe de tâches est en état de
fonctionner ! Faites un <code>cargo run</code> et faites quelques requêtes :</p>
<!--
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-- >
-->
<!--
```console
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 -- > src/lib.rs:7:5
  |
7 |     workers: Vec<Worker>,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  -- > src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  -- > src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle<()>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/main`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
```
-->
<pre><code class="language-console">$ cargo run
   Compiling salutations v0.1.0 (file:///projects/salutations)
warning: field is never read: `operateurs`
 -- &gt; src/lib.rs:7:5
  |
7 |     operateurs: Vec&lt;Operateur&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  -- &gt; src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `tache`
  -- &gt; src/lib.rs:49:5
   |
49 |     tache: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/main`
L'opérateur 0 a obtenu une mission ; il l'exécute.
L'opérateur 2 a obtenu une mission ; il l'exécute.
L'opérateur 1 a obtenu une mission ; il l'exécute.
L'opérateur 3 a obtenu une mission ; il l'exécute.
L'opérateur 0 a obtenu une mission ; il l'exécute.
L'opérateur 2 a obtenu une mission ; il l'exécute.
L'opérateur 1 a obtenu une mission ; il l'exécute.
L'opérateur 3 a obtenu une mission ; il l'exécute.
L'opérateur 0 a obtenu une mission ; il l'exécute.
L'opérateur 2 a obtenu une mission ; il l'exécute.
</code></pre>
<!--
Success! We now have a thread pool that executes connections asynchronously.
There are never more than four threads created, so our system won’t get
overloaded if the server receives a lot of requests. If we make a request to
*/sleep*, the server will be able to serve other requests by having another
thread run them.
-->
<p>Parfait ! Nous avons maintenant un groupe de tâches qui exécute des connexions
de manière asynchrone. Il n'y a pas plus que quatre tâches qui sont créées,
donc notre système ne sera pas surchargé si le serveur reçoit beaucoup de
requêtes. Si nous faisons une requête vers <em>/pause</em>, le serveur sera toujours
capable de servir les autres requêtes grâce aux autres tâches qui pourront les
exécuter.</p>
<!--
> Note: if you open */sleep* in multiple browser windows simultaneously, they
> might load one at a time in 5 second intervals. Some web browsers execute
> multiple instances of the same request sequentially for caching reasons. This
> limitation is not caused by our web server.
-->
<blockquote>
<p>Remarque : si vous ouvrez <em>/pause</em> dans plusieurs fenêtres de navigation en
simultané, elles peuvent parfois être chargées une par une avec 5 secondes
d'intervalle. Certains navigateurs web exécutent plusieurs instances de la
même requête de manière séquentielle pour des raisons de cache. Cette
limitation n'est pas la faute de notre serveur web.</p>
</blockquote>
<!--
After learning about the `while let` loop in Chapter 18, you might be wondering
why we didn’t write the worker thread code as shown in Listing 20-21.
-->
<p>Après avoir appris la boucle <code>while let</code> dans le chapitre 18, vous pourriez
vous demander pourquoi nous n'avons pas écrit le code des tâches des opérateurs
comme dans l'encart 20-21.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,not_desired_behavior
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("Worker {} got a job; executing.", id);

                job();
            }
        });

        Worker { id, thread }
    }
}
```
-->
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// Crée un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tâches présentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zéro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// -- partie masquée ici --

impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
        let tache = thread::spawn(move || {
            while let Ok(mission) = reception.lock().unwrap().recv() {
                println!(&quot;L'opérateur {} a obtenu une mission ; il l'exécute.&quot;, id);

                mission();
            }
        });

        Operateur { id, tache }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-21: An alternative implementation of
`Worker::new` using `while let`</span>
-->
<p><span class="caption">Encart 20-21 : une implémentation alternative de
<code>Operateur::new</code> qui utilise <code>while let</code></span></p>
<!--
This code compiles and runs but doesn’t result in the desired threading
behavior: a slow request will still cause other requests to wait to be
processed. The reason is somewhat subtle: the `Mutex` struct has no public
`unlock` method because the ownership of the lock is based on the lifetime of
the `MutexGuard<T>` within the `LockResult<MutexGuard<T>>` that the `lock`
method returns. At compile time, the borrow checker can then enforce the rule
that a resource guarded by a `Mutex` cannot be accessed unless we hold the
lock. But this implementation can also result in the lock being held longer
than intended if we don’t think carefully about the lifetime of the
`MutexGuard<T>`. Because the values in the `while let` expression remain in
scope for the duration of the block, the lock remains held for the duration of
the call to `job()`, meaning other workers cannot receive jobs.
-->
<p>Ce code se compile et s'exécute mais ne se comporte pas comme nous
souhaiterions que les tâches se comportent : une requête lente à traiter va
continuer à faire en sorte que les autres requêtes vont attendre d'être
traitées. La raison à cela est subtile : la structure <code>Mutex</code> n'a pas de
méthode publique <code>unlock</code> car la propriété du verrou se base sur la durée de
vie du <code>MutexGuard&lt;T&gt;</code> au sein du <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> que retourne la
méthode <code>lock</code>. A la compilation, le vérificateur d'emprunt peut ensuite
vérifier la règle qui dit qu'une ressource gardée par un <code>Mutex</code> ne peut pas
être accessible que si nous avons ce verrou. Mais cette implémentation peut
aussi faire en sorte que nous gardions le verrou plus longtemps que prévu si
nous ne réfléchissons pas avec attention sur la durée de vie du
<code>MutexGuard&lt;T&gt;</code>. Comme les valeurs dans l'expression du <code>while let</code> restent dans
la portée pour la durée de ce bloc, le verrou reste verrouillé pendant la durée
de l'appel à <code>mission()</code>, ce qui signifie que les autres opérateurs ne peuvent
pas recevoir d'autres missions.</p>
<!--
By using `loop` instead and acquiring the lock without assigning to a variable,
the temporary `MutexGuard` returned from the `lock` method is dropped as soon
as the `let job` statement ends. This ensures that the lock is held during the
call to `recv`, but it is released before the call to `job()`, allowing
multiple requests to be serviced concurrently.
-->
<p>En utilisant <code>loop</code> à la place et en obtenant le verrou sans l'assigner à une
variable, le <code>MutexGuard</code> temporairement retourné par la méthode <code>lock</code> est
libéré dès que l'instruction <code>let mission</code> se termine. Cela fait en sorte que le
verrou est gardé pendant l'appel à <code>recv</code>, mais il est libéré avant l'appel à
<code>mission()</code>, ce qui permet à plusieurs requêtes qu'être servies en concurrence.</p>
<!--
[creating-type-synonyms-with-type-aliases]:
ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases
[integer-types]: ch03-02-data-types.html#integer-types
[storing-closures-using-generic-parameters-and-the-fn-traits]:
ch13-01-closures.html#storing-closures-using-generic-parameters-and-the-fn-traits
-->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--34"><a class="header" href="#-attention-peinture-fraîche--34">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/217">Pull Request</a>.</p>
</blockquote>
<!--
## Graceful Shutdown and Cleanup
-->
<h2 id="arrêt-propre-et-nettoyage"><a class="header" href="#arrêt-propre-et-nettoyage">Arrêt propre et nettoyage</a></h2>
<!--
The code in Listing 20-20 is responding to requests asynchronously through the
use of a thread pool, as we intended. We get some warnings about the `workers`,
`id`, and `thread` fields that we’re not using in a direct way that reminds us
we’re not cleaning up anything. When we use the less elegant <span
class="keystroke">ctrl-c</span> method to halt the main thread, all other
threads are stopped immediately as well, even if they’re in the middle of
serving a request.
-->
<p>Le code de l'encart 20-20 réponds aux requêtes de manière asynchrone grâce à
l'utilisation du groupe de tâches, comme nous l'espérions. Nous avons quelques
avertissements sur les champs <code>operateurs</code>, <code>id</code> et <code>tâche</code> que nous
n'utilisons pas directement qui nous rappelle que nous ne nettoyons rien.
Lorsque nous utilisons la méthode <span class="keystroke">ctrl-c</span> pour
terminer la tâche principale, toutes les autres tâches sont aussi stoppées
immédiatement, même si nous sommes en train de servir une requête.</p>
<!--
Now we’ll implement the `Drop` trait to call `join` on each of the threads in
the pool so they can finish the requests they’re working on before closing.
Then we’ll implement a way to tell the threads they should stop accepting new
requests and shut down. To see this code in action, we’ll modify our server to
accept only two requests before gracefully shutting down its thread pool.
-->
<p>Nous allons implémenter le trait <code>Drop</code> pour faire appel à <code>join</code> sur chacune
des tâches dans le groupe afin qu'elles puissent finir les requêtes qu'elles
sont en train de traiter avant l'arrêt. Ensuite, nous allons implémenter un
moyen de demander aux tâches d'arrêter d'accepter des nouvelles requêtes et de
s'arrêter. Pour voir ce code à l'action, nous allons modifier notre serveur
pour accepter seulement deux requêtes avant d'arrêter proprement son groupe de
tâches.</p>
<!--
### Implementing the `Drop` Trait on `ThreadPool`
-->
<h3 id="implémenter-le-trait-drop-sur-groupetaches"><a class="header" href="#implémenter-le-trait-drop-sur-groupetaches">Implémenter le trait <code>Drop</code> sur <code>GroupeTaches</code></a></h3>
<!--
Let’s start with implementing `Drop` on our thread pool. When the pool is
dropped, our threads should all join to make sure they finish their work.
Listing 20-22 shows a first attempt at a `Drop` implementation; this code won’t
quite work yet.
-->
<p>Commençons par implémenter <code>Drop</code> sur notre groupe de tâches. Lorsque le groupe
est nettoyé, nos tâches doivent toutes faire appel à <code>join</code> pour s'assurer
qu'elles finissent leur travail. L'encart 20-22 montre une première tentative
d'implémentation de <code>Drop</code> ; ce code ne fonctionne pas encore tout à fait.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
impl Drop for ThreadPool {
    fn drop(&mut self) {
        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
# 
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle<()>,
# }
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
#         let thread = thread::spawn(move || loop {
#             let job = receiver.lock().unwrap().recv().unwrap();
# 
#             println!("Worker {} got a job; executing.", id);
# 
#             job();
#         });
# 
#         Worker { id, thread }
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// Crée un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tâches présentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zéro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for GroupeTaches {
    fn drop(&amp;mut self) {
        for operateur in &amp;mut self.operateurs {
            println!(&quot;Arrêt de l'opérateur {}&quot;, operateur.id);

            operateur.tache.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let mission = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;L'opérateur {} a reçu une mission ; il l'exécute.&quot;, id);
</span><span class="boring">
</span><span class="boring">            mission();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur { id, tache }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 20-22: Joining each thread when the thread pool
goes out of scope</span>
-->
<p><span class="caption">Encart 20-22 : utilisation de <code>join</code> sur chaque tâche
lorsque le groupe de tâches sort de la portée</span></p>
<!--
First, we loop through each of the thread pool `workers`. We use `&mut` for
this because `self` is a mutable reference, and we also need to be able to
mutate `worker`. For each worker, we print a message saying that this
particular worker is shutting down, and then we call `join` on that worker’s
thread. If the call to `join` fails, we use `unwrap` to make Rust panic and go
into an ungraceful shutdown.
-->
<p>D'abord, nous faisons une boucle sur les <code>operateurs</code>. Nous utilisons <code>&amp;mut</code>
pour cela car <code>self</code> est une référence mutable, et nous avons aussi besoin de
pouvoir muter <code>operateur</code>. Pour chaque opérateur, nous affichons un message qui
indique que cet opérateur s'arrête, et ensuite nous faisons appel à <code>join</code> sur
la tâche de cet opérateur. Si l'appel à <code>join</code> échoue, nous utilisons <code>unwrap</code>
pour faire paniquer Rust et ainsi procéder à un arrêt brutal.</p>
<!--
Here is the error we get when we compile this code:
-->
<p>Voici l'erreur que nous obtenons lorsque nous compilons ce code :</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
  -- > src/lib.rs:52:13
   |
52 |             worker.thread.join().unwrap();
   |             ^^^^^^^^^^^^^ move occurs because `worker.thread` has type `std::thread::JoinHandle<()>`, which does not implement the `Copy` trait

error: aborting due to previous error

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0507]: cannot move out of `operateur.tache` which is behind a mutable reference
  --&gt; src/lib.rs:52:13
   |
52 |             operateur.tache.join().unwrap();
   |             ^^^^^^^^^^^^^^^ move occurs because `operateur.tache` has type `std::thread::JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait

error: aborting due to previous error

For more information about this error, try `rustc --explain E0507`.
error: could not compile `salutations`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The error tells us we can’t call `join` because we only have a mutable borrow
of each `worker` and `join` takes ownership of its argument. To solve this
issue, we need to move the thread out of the `Worker` instance that owns
`thread` so `join` can consume the thread. We did this in Listing 17-15: if
`Worker` holds an `Option<thread::JoinHandle<()>>` instead, we can call the
`take` method on the `Option` to move the value out of the `Some` variant and
leave a `None` variant in its place. In other words, a `Worker` that is running
will have a `Some` variant in `thread`, and when we want to clean up a
`Worker`, we’ll replace `Some` with `None` so the `Worker` doesn’t have a
thread to run.
-->
<p>L'erreur nous informe que nous ne pouvons pas faire appel à <code>join</code> car nous
faisons seulement un emprunt mutable pour chacun des <code>operateur</code> et que <code>join</code>
prend possession de son argument. Pour résoudre ce problème, nous devons
sortir la tâche de l'instance de <code>Operateur</code> qui possède la <code>tache</code> afin que
<code>join</code> puisse consommer la tâche. Nous faisons ceci dans l'encart 17-15 : si
<code>Operateur</code> contient un <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>, nous pouvons utiliser
la méthode <code>take</code> sur <code>Option</code> pour sortir la valeur de la variante <code>Some</code> et
la remplacer par la variante <code>None</code> à la place. Autrement dit, un <code>Operateur</code>
qui est en cours d'exécution aura une variante <code>Some</code> dans <code>tache</code>, et lorsque
nous souhaitons nettoyer <code>Operateur</code>, nous remplacerons <code>Some</code> par <code>None</code> afin
que <code>Operateur</code> n'ai pas de tâche à exécuter.</p>
<!--
So we know we want to update the definition of `Worker` like this:
-->
<p>Donc nous savons que nous voulons modifier la définition de <code>Operateur</code> comme
ceci :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore,does_not_compile
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
# impl Drop for ThreadPool {
#     fn drop(&mut self) {
#         for worker in &mut self.workers {
#             println!("Shutting down worker {}", worker.id);
# 
#             worker.thread.join().unwrap();
#         }
#     }
# }
# 
struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
#         let thread = thread::spawn(move || loop {
#             let job = receiver.lock().unwrap().recv().unwrap();
# 
#             println!("Worker {} got a job; executing.", id);
# 
#             job();
#         });
# 
#         Worker { id, thread }
#     }
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// Crée un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tâches présentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zéro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for GroupeTaches {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for operateur in &amp;mut self.operateurs {
</span><span class="boring">            println!(&quot;Arrêt de l'opérateur {}&quot;, operateur.id);
</span><span class="boring">
</span><span class="boring">            operateur.tache.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Operateur {
    id: usize,
    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
<span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let mission = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;L'opérateur {} a reçu une mission ; il l'exécute.&quot;, id);
</span><span class="boring">
</span><span class="boring">            mission();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur { id, tache }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Now let’s lean on the compiler to find the other places that need to change.
Checking this code, we get two errors:
-->
<p>Maintenant, aidons-nous du compilateur pour trouver les autres endroits qui ont
besoin de changer. En vérifiant ce code, nous obtenons deux erreurs :</p>
<!--
```console
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `join` found for type `std::option::Option<std::thread::JoinHandle<()>>` in the current scope
  -- > src/lib.rs:52:27
   |
52 |             worker.thread.join().unwrap();
   |                           ^^^^ method not found in `std::option::Option<std::thread::JoinHandle<()>>`

error[E0308]: mismatched types
  -- > src/lib.rs:72:22
   |
72 |         Worker { id, thread }
   |                      ^^^^^^
   |                      |
   |                      expected enum `std::option::Option`, found struct `std::thread::JoinHandle`
   |                      help: try using a variant of the expected enum: `Some(thread)`
   |
   = note: expected enum `std::option::Option<std::thread::JoinHandle<()>>`
            found struct `std::thread::JoinHandle<_>`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
```
-->
<pre><code class="language-console">$ cargo check
    Checking salutations v0.1.0 (file:///projects/salutations)
error[E0599]: no method named `join` found for type `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;` in the current scope
  --&gt; src/lib.rs:52:27
   |
52 |             operateur.tache.join().unwrap();
   |                             ^^^^ method not found in `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`

error[E0308]: mismatched types
  --&gt; src/lib.rs:72:22
   |
72 |         Worker { id, tache }
   |                      ^^^^^
   |                      |
   |                      expected enum `std::option::Option`, found struct `std::thread::JoinHandle`
   |                      help: try using a variant of the expected enum: `Some(tache)`
   |
   = note: expected enum `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`
            found struct `std::thread::JoinHandle&lt;_&gt;`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `salutations`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Let’s address the second error, which points to the code at the end of
`Worker::new`; we need to wrap the `thread` value in `Some` when we create a
new `Worker`. Make the following changes to fix this error:
-->
<p>Corrigeons la seconde erreur, qui se situe dans le code à la fin de
<code>Operateur::new</code> ; nous devons intégrer la valeur de <code>tache</code> dans un <code>Some</code>
lorsque nous créons un nouvel <code>Operateur</code>. Faites les changements suivants pour
corriger cette erreur :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
# impl Drop for ThreadPool {
#     fn drop(&mut self) {
#         for worker in &mut self.workers {
#             println!("Shutting down worker {}", worker.id);
# 
#             worker.thread.join().unwrap();
#         }
#     }
# }
# 
# struct Worker {
#     id: usize,
#     thread: Option<thread::JoinHandle<()>>,
# }
# 
impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        // --snip--

#         let thread = thread::spawn(move || loop {
#             let job = receiver.lock().unwrap().recv().unwrap();
# 
#             println!("Worker {} got a job; executing.", id);
# 
#             job();
#         });
# 
        Worker {
            id,
            thread: Some(thread),
        }
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// Crée un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tâches présentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zéro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for GroupeTaches {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for operateur in &amp;mut self.operateurs {
</span><span class="boring">            println!(&quot;Arrêt de l'opérateur {}&quot;, operateur.id);
</span><span class="boring">
</span><span class="boring">            operateur.tache.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
        // -- partie masquée ici --

<span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let mission = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;L'opérateur {} a reçu une mission ; il l'exécute.&quot;, id);
</span><span class="boring">
</span><span class="boring">            mission();
</span><span class="boring">        });
</span><span class="boring">
</span>        Operateur {
            id,
            tache: Some(tache),
        }
    }
}
</code></pre>
<pre><code class="language-rust ignore">impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
        // -- partie masquée ici --

        Operateur {
            id,
            tache: Some(tache),
        }
    }
}
</code></pre>
<!--
The first error is in our `Drop` implementation. We mentioned earlier that we
intended to call `take` on the `Option` value to move `thread` out of `worker`.
The following changes will do so:
-->
<p>La première erreur se situe dans notre implémentation de <code>Drop</code>. Nous avions
mentionné plus tôt que nous voulions faire appel à <code>take</code> sur la valeur de
<code>Option</code> pour déplacer <code>tache</code> en dehors de <code>operateur</code>. Voici les changements
à apporter pour ceci :</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
impl Drop for ThreadPool {
    fn drop(&mut self) {
        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
# 
# struct Worker {
#     id: usize,
#     thread: Option<thread::JoinHandle<()>>,
# }
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
#         let thread = thread::spawn(move || loop {
#             let job = receiver.lock().unwrap().recv().unwrap();
# 
#             println!("Worker {} got a job; executing.", id);
# 
#             job();
#         });
# 
#         Worker {
#             id,
#             thread: Some(thread),
#         }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// Crée un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tâches présentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zéro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for GroupeTaches {
    fn drop(&amp;mut self) {
        for operateur in &amp;mut self.operateurs {
            println!(&quot;Arrêt de l'opérateur {}&quot;, operateur.id);

            if let Some(tache) = operateur.tache.take() {
                tache.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let mission = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;L'opérateur {} a reçu une mission ; il l'exécute.&quot;, id);
</span><span class="boring">
</span><span class="boring">            mission();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur {
</span><span class="boring">            id,
</span><span class="boring">            tache: Some(tache),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
As discussed in Chapter 17, the `take` method on `Option` takes the `Some`
variant out and leaves `None` in its place. We’re using `if let` to destructure
the `Some` and get the thread; then we call `join` on the thread. If a worker’s
thread is already `None`, we know that worker has already had its thread
cleaned up, so nothing happens in that case.
-->
<p>Comme nous l'avons vu au chapitre 17, la méthode <code>take</code> sur <code>Option</code> sort la
variante <code>Some</code> et laisse un <code>None</code> à la place. Nous utilisons <code>if let</code> pour
destructurer le <code>Some</code> et obtenir la tâche ; ensuite nous faisons appel à <code>join</code>
sur cette tâche. Si la tâche d'un opérateur est déjà un <code>None</code>, nous savons que
cet opérateur a déjà nettoyé sa tâche, donc nous ne faisons rien dans ce cas.</p>
<!--
### Signaling to the Threads to Stop Listening for Jobs
-->
<h3 id="demander-aux-tâches-darrêter-dattendre-des-missions"><a class="header" href="#demander-aux-tâches-darrêter-dattendre-des-missions">Demander aux tâches d'arrêter d'attendre des missions</a></h3>
<!--
With all the changes we’ve made, our code compiles without any warnings. But
the bad news is this code doesn’t function the way we want it to yet. The key
is the logic in the closures run by the threads of the `Worker` instances: at
the moment, we call `join`, but that won’t shut down the threads because they
`loop` forever looking for jobs. If we try to drop our `ThreadPool` with our
current implementation of `drop`, the main thread will block forever waiting
for the first thread to finish.
-->
<p>Avec tous ces changements, notre code se compile sans aucun avertissement. Mais
la mauvaise nouvelle est que ce code ne fonctionne pas de la façon dont nous
souhaitons, pour l'instant. La cause se situe dans la logique des fermetures
qui sont exécutées par les tâches des instances de <code>Operateur</code> : pour le
moment, nous faisons faisons appel à <code>join</code>, mais cela ne va pas arrêter les
tâches car elles font une boucle infinie avec <code>loop</code> pour attendre des
missions. Si nous essayons de nettoyer notre <code>GroupeTaches</code> avec
l'implémentation actuelle de <code>drop</code>, la tâche principale va se bloquer à
l'infini en attendant que la première tâche se termine.</p>
<!--
To fix this problem, we’ll modify the threads so they listen for either a `Job`
to run or a signal that they should stop listening and exit the infinite loop.
Instead of `Job` instances, our channel will send one of these two enum
variants.
-->
<p>Pour corriger ce problème, nous allons modifier les tâches pour qu'elles
attendent soit une <code>Mission</code> à exécuter, ou le signal qui leur dit qu'elles
doivent arrêter d'attendre des missions et arrêter la boucle infinie. Notre
canal va envoyer une de ces deux variantes d'énumération au lieu d'uniquement
des instances de <code>Job</code>.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Job>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
enum Message {
    NewJob(Job),
    Terminate,
}
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(job).unwrap();
#     }
# }
# 
# impl Drop for ThreadPool {
#     fn drop(&mut self) {
#         for worker in &mut self.workers {
#             println!("Shutting down worker {}", worker.id);
# 
#             if let Some(thread) = worker.thread.take() {
#                 thread.join().unwrap();
#             }
#         }
#     }
# }
# 
# struct Worker {
#     id: usize,
#     thread: Option<thread::JoinHandle<()>>,
# }
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
#         let thread = thread::spawn(move || loop {
#             let job = receiver.lock().unwrap().recv().unwrap();
# 
#             println!("Worker {} got a job; executing.", id);
# 
#             job();
#         });
# 
#         Worker {
#             id,
#             thread: Some(thread),
#         }
#     }
# }
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Mission&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>enum Message {
    NouvelleMission(Mission),
    Extinction,
}
<span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// Crée un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tâches présentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zéro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(mission).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for GroupeTaches {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for operateur in &amp;mut self.operateurs {
</span><span class="boring">            println!(&quot;Arrêt de l'opérateur {}&quot;, operateur.id);
</span><span class="boring">
</span><span class="boring">            if let Some(tache) = operateur.tache.take() {
</span><span class="boring">                tache.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Mission&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let mission = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;L'opérateur {} a reçu une mission ; il l'exécute.&quot;, id);
</span><span class="boring">
</span><span class="boring">            mission();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur {
</span><span class="boring">            id,
</span><span class="boring">            tache: Some(tache),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
This `Message` enum will either be a `NewJob` variant that holds the `Job` the
thread should run, or it will be a `Terminate` variant that will cause the
thread to exit its loop and stop.
-->
<p>Cette énumération <code>Message</code> aura pour valeurs une variante <code>NouvelleMission</code>
qui contiendra la <code>Mission</code> que la tâche devra exécuter, ou la variante
<code>Extinction</code> qui va faire en sorte que la tâche sorte de sa boucle et se
termine.</p>
<!--
We need to adjust the channel to use values of type `Message` rather than type
`Job`, as shown in Listing 20-23.
-->
<p>Nous devons corriger le canal pour utiliser les valeurs du type <code>Message</code>
plutôt que le type <code>Mission</code>, comme dans l'encart 20-23.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Message>,
}

// --snip--

# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# enum Message {
#     NewJob(Job),
#     Terminate,
# }
# 
impl ThreadPool {
    // --snip--

#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

// --snip--

# impl Drop for ThreadPool {
#     fn drop(&mut self) {
#         for worker in &mut self.workers {
#             println!("Shutting down worker {}", worker.id);
# 
#             if let Some(thread) = worker.thread.take() {
#                 thread.join().unwrap();
#             }
#         }
#     }
# }
# 
# struct Worker {
#     id: usize,
#     thread: Option<thread::JoinHandle<()>>,
# }
# 
impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Message>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv().unwrap();

            match message {
                Message::NewJob(job) => {
                    println!("Worker {} got a job; executing.", id);

                    job();
                }
                Message::Terminate => {
                    println!("Worker {} was told to terminate.", id);

                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span>pub struct GroupeTaches {
    operateurs: Vec&lt;Operateur&gt;,
    envoi: mpsc::Sender&lt;Message&gt;,
}

// -- partie masquée ici --

<span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">enum Message {
</span><span class="boring">    NouvelleMission(Mission),
</span><span class="boring">    Extinction,
</span><span class="boring">}
</span><span class="boring">
</span>impl GroupeTaches {
    // -- partie masquée ici --

<span class="boring">    /// Crée un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tâches présentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zéro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn executer&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let mission = Box::new(f);

        self.envoi.send(Message::NouvelleMission(mission)).unwrap();
    }
}

// -- partie masquée ici --

<span class="boring">impl Drop for GroupeTaches {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for operateur in &amp;mut self.operateurs {
</span><span class="boring">            println!(&quot;Arrêt de l'opérateur {}&quot;, operateur.id);
</span><span class="boring">
</span><span class="boring">            if let Some(tache) = operateur.tache.take() {
</span><span class="boring">                tache.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Operateur {
        let tache = thread::spawn(move || loop {
            let message = reception.lock().unwrap().recv().unwrap();

            match message {
                Message::NouvelleMission(mission) =&gt; {
                    println!(&quot;L'opérateur {} a reçu une mission ; il l'exécute.&quot;, id);

                    mission();
                }
                Message::Extinction =&gt; {
                    println!(&quot;L'opérateur {} a reçu l'instruction d'arrêt.&quot;, id);

                    break;
                }
            }
        });

        Operateur {
            id,
            tache: Some(tache),
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-23: Sending and receiving `Message` values and
exiting the loop if a `Worker` receives `Message::Terminate`</span>
-->
<p><span class="caption">Encart 20-23 : envoi et réception de valeurs de <code>Message</code>
et sortie de la boucle si un <code>Operateur</code> reçoit <code>Message:Extinction</code></span></p>
<!--
To incorporate the `Message` enum, we need to change `Job` to `Message` in two
places: the definition of `ThreadPool` and the signature of `Worker::new`. The
`execute` method of `ThreadPool` needs to send jobs wrapped in the
`Message::NewJob` variant. Then, in `Worker::new` where a `Message` is received
from the channel, the job will be processed if the `NewJob` variant is
received, and the thread will break out of the loop if the `Terminate` variant
is received.
-->
<p>Pour intégrer l'énumération <code>Message</code>, nous devons changer <code>Mission</code> par
<code>Message</code> à deux endroits : la définition de <code>GroupeTaches</code> et la signature de
<code>Operateur::new</code>. La méthode <code>executer</code> de <code>GroupeTaches</code> doit envoyer des
missions intégrées dans des variantes de <code>Message::NouvelleTache</code>. Ensuite,
dans <code>Operateur::new</code> où nous recevons des <code>Message</code> du canal, la mission sera
traitée si la variante <code>NouvelleTache</code> est reçue, et la tâche arrêtera la
boucle si la variante <code>Extinction</code> est reçue.</p>
<!--
With these changes, the code will compile and continue to function in the same
way as it did after Listing 20-20. But we’ll get a warning because we aren’t
creating any messages of the `Terminate` variety. Let’s fix this warning by
changing our `Drop` implementation to look like Listing 20-24.
-->
<p>Grâce à ces changements, le code va se compiler et continuer de fonctionner de
la même manière qu'il le faisait après l'encart 20-20. Mais nous allons obtenir
un avertissement car nous ne créons aucun message de la variante <code>Extinction</code>.
Corrigeons cet avertissement en corrigeant l'implémentation de notre <code>Drop</code>
pour qu'elle ressemble à l'encart 20-24.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,ignore
# use std::sync::mpsc;
# use std::sync::Arc;
# use std::sync::Mutex;
# use std::thread;
# 
# pub struct ThreadPool {
#     workers: Vec<Worker>,
#     sender: mpsc::Sender<Message>,
# }
# 
# type Job = Box<dyn FnOnce() + Send + 'static>;
# 
# enum Message {
#     NewJob(Job),
#     Terminate,
# }
# 
# impl ThreadPool {
#     /// Create a new ThreadPool.
#     ///
#     /// The size is the number of threads in the pool.
#     ///
#     /// # Panics
#     ///
#     /// The `new` function will panic if the size is zero.
#     pub fn new(size: usize) -> ThreadPool {
#         assert!(size > 0);
# 
#         let (sender, receiver) = mpsc::channel();
# 
#         let receiver = Arc::new(Mutex::new(receiver));
# 
#         let mut workers = Vec::with_capacity(size);
# 
#         for id in 0..size {
#             workers.push(Worker::new(id, Arc::clone(&receiver)));
#         }
# 
#         ThreadPool { workers, sender }
#     }
# 
#     pub fn execute<F>(&self, f: F)
#     where
#         F: FnOnce() + Send + 'static,
#     {
#         let job = Box::new(f);
# 
#         self.sender.send(Message::NewJob(job)).unwrap();
#     }
# }
# 
impl Drop for ThreadPool {
    fn drop(&mut self) {
        println!("Sending terminate message to all workers.");

        for _ in &self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!("Shutting down all workers.");

        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
# 
# struct Worker {
#     id: usize,
#     thread: Option<thread::JoinHandle<()>>,
# }
# 
# impl Worker {
#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Message>>>) -> Worker {
#         let thread = thread::spawn(move || loop {
#             let message = receiver.lock().unwrap().recv().unwrap();
# 
#             match message {
#                 Message::NewJob(job) => {
#                     println!("Worker {} got a job; executing.", id);
# 
#                     job();
#                 }
#                 Message::Terminate => {
#                     println!("Worker {} was told to terminate.", id);
# 
#                     break;
#                 }
#             }
#         });
# 
#         Worker {
#             id,
#             thread: Some(thread),
#         }
#     }
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct GroupeTaches {
</span><span class="boring">    operateurs: Vec&lt;Operateur&gt;,
</span><span class="boring">    envoi: mpsc::Sender&lt;Message&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">enum Message {
</span><span class="boring">    NouvelleMission(Mission),
</span><span class="boring">    Extinction,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl GroupeTaches {
</span><span class="boring">    /// Crée un nouveau GroupeTaches.
</span><span class="boring">    ///
</span><span class="boring">    /// La taille est le nom de tâches présentes dans le groupe.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// La fonction `new` devrait paniquer si la taille vaut zéro.
</span><span class="boring">    pub fn new(taille: usize) -&gt; GroupeTaches {
</span><span class="boring">        assert!(taille &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (envoi, reception) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let reception = Arc::new(Mutex::new(reception));
</span><span class="boring">
</span><span class="boring">        let mut operateurs = Vec::with_capacity(taille);
</span><span class="boring">
</span><span class="boring">        for id in 0..taille {
</span><span class="boring">            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        GroupeTaches { operateurs, envoi }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn executer&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let mission = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.envoi.send(Message::NouvelleMission(mission)).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for GroupeTaches {
    fn drop(&amp;mut self) {
        println!(&quot;Envoi du message d'extinction à tous les opérateurs.&quot;);

        for _ in &amp;self.operateurs {
            self.envoi.send(Message::Extinction).unwrap();
        }

        println!(&quot;Arrêt de tous les opérateurs.&quot;);

        for operateur in &amp;mut self.operateurs {
            println!(&quot;Arrêt de l'opérateur {}&quot;, operateur.id);

            if let Some(tache) = operateur.tache.take() {
                tache.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Operateur {
</span><span class="boring">    id: usize,
</span><span class="boring">    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Operateur {
</span><span class="boring">    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Operateur {
</span><span class="boring">        let tache = thread::spawn(move || loop {
</span><span class="boring">            let message = reception.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            match message {
</span><span class="boring">                Message::NouvelleMission(mission) =&gt; {
</span><span class="boring">                    println!(&quot;L'opérateur {} a reçu une mission ; il l'exécute.&quot;, id);
</span><span class="boring">
</span><span class="boring">                    mission();
</span><span class="boring">                }
</span><span class="boring">                Message::Extinction =&gt; {
</span><span class="boring">                    println!(&quot;L'opérateur {} a reçu l'instruction d'arrêt.&quot;, id);
</span><span class="boring">
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Operateur {
</span><span class="boring">            id,
</span><span class="boring">            tache: Some(tache),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 20-24: Sending `Message::Terminate` to the
workers before calling `join` on each worker thread</span>
-->
<p><span class="caption">Encart 20-24 : envoi de <code>Message::Extinction</code> aux
opérateurs avant de faire appel à <code>join</code> sur toutes les tâches des
opérateurs</span></p>
<!--
We’re now iterating over the workers twice: once to send one `Terminate`
message for each worker and once to call `join` on each worker’s thread. If we
tried to send a message and `join` immediately in the same loop, we couldn’t
guarantee that the worker in the current iteration would be the one to get the
message from the channel.
-->
<p>Nous itérons deux fois sur les opérateurs : une fois pour envoyer un message
<code>Extinction</code> pour chaque opérateur, et une fois pour utiliser <code>join</code> sur la
tâche de chacun des opérateurs. Si nous essayons d'envoyer le message et
d'utiliser immédiatement <code>join</code> dans la même boucle, nous ne pouvons pas
garantir que l'opérateur dans l'itération en cours sera celui qui obtiendra le
message envoyé dans le canal.</p>
<!--
To better understand why we need two separate loops, imagine a scenario with
two workers. If we used a single loop to iterate through each worker, on the
first iteration a terminate message would be sent down the channel and `join`
called on the first worker’s thread. If that first worker was busy processing a
request at that moment, the second worker would pick up the terminate message
from the channel and shut down. We would be left waiting on the first worker to
shut down, but it never would because the second thread picked up the terminate
message. Deadlock!
-->
<p>Pour mieux comprendre pourquoi nous avons besoin de séparer les boucles,
imaginez un scénario avec deux opérateurs. Si nous avions utilisé une seule
boucle pour itérer sur chacun des opérateurs, dans la première itération un
message d'extinction sera envoyé dans le canal et <code>join</code> sera utilisé sur la
tâche du premier opérateur. Si ce premier opérateur était occupé à traiter une
requête à ce moment-là, le second opérateur devrait alors récupérer le message
d'extinction dans le canal et s'arrêter. Nous resterons alors à attendre que le
premier opérateur s'arrête, mais cela ne sera jamais le cas car c'est la
seconde tâche qui aura obtenu le message d'extinction. Nous serions alors dans
une situation d'interblocage !</p>
<!--
To prevent this scenario, we first put all of our `Terminate` messages on the
channel in one loop; then we join on all the threads in another loop. Each
worker will stop receiving requests on the channel once it gets a terminate
message. So, we can be sure that if we send the same number of terminate
messages as there are workers, each worker will receive a terminate message
before `join` is called on its thread.
-->
<p>Pour éviter ce scénario, nous allons commencer par insérer tous nos messages
<code>Extinction</code> dans le canal dans une boucle ; et ensuite nous utiliserons <code>join</code>
sur toutes les tâches dans une autre boucle. Chaque opérateur va arrêter de
recevoir des nouvelles requêtes du canal dès qu'ils recevront le message
d'extinction. Donc, nous pouvons nous assurer que si nous envoyons la même
quantité de messages d'extinction qu'il y a d'opérateurs, chaque opérateur
devrait recevoir un message d'extinction avant que <code>join</code> soit utilisé sur leur
tâche.</p>
<!--
To see this code in action, let’s modify `main` to accept only two requests
before gracefully shutting down the server, as shown in Listing 20-25.
-->
<p>Pour observer ce code en action, modifions notre <code>main</code> pour accepter
uniquement deux requêtes avant d'arrêter proprement le serveur, comme dans
l'encart 20-25.</p>
<!--
<span class="filename">Filename: src/bin/main.rs</span>
-->
<p><span class="filename">Fichier : src/bin/main.rs</span></p>
<!--
```rust,ignore
# use hello::ThreadPool;
# use std::fs;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# use std::thread;
# use std::time::Duration;
# 
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}
# 
# fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 1024];
#     stream.read(&mut buffer).unwrap();
# 
#     let get = b"GET / HTTP/1.1\r\n";
#     let sleep = b"GET /sleep HTTP/1.1\r\n";
# 
#     let (status_line, filename) = if buffer.starts_with(get) {
#         ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
#     } else if buffer.starts_with(sleep) {
#         thread::sleep(Duration::from_secs(5));
#         ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
#     } else {
#         ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")
#     };
# 
#     let contents = fs::read_to_string(filename).unwrap();
# 
#     let response = format!("{}{}", status_line, contents);
# 
#     stream.write(response.as_bytes()).unwrap();
#     stream.flush().unwrap();
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use salutations::GroupeTaches;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let groupe = GroupeTaches::new(4);

    for flux in ecouteur.incoming().take(2) {
        let flux = flux.unwrap();

        groupe.executer(|| {
            gestion_connexion(flux);
        });
    }

    println!(&quot;Arrêt complet.&quot;);
}
<span class="boring">
</span><span class="boring">fn gestion_connexion(mut flux: TcpStream) {
</span><span class="boring">    let mut tampon = [0; 1024];
</span><span class="boring">    flux.read(&amp;mut tampon).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if tampon.starts_with(pause) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contenu = fs::read_to_string(nom_fichier).unwrap();
</span><span class="boring">
</span><span class="boring">    let reponse = format!(&quot;{}{}&quot;, ligne_statut, contenu);
</span><span class="boring">
</span><span class="boring">    flux.write(reponse.as_bytes()).unwrap();
</span><span class="boring">    flux.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 20-25: Shut down the server after serving two
requests by exiting the loop</span>
-->
<p><span class="caption">Encart 20-25 : arrêt du serveur après avoir servi deux
requêtes en sortant de la boucle</span></p>
<!--
You wouldn’t want a real-world web server to shut down after serving only two
requests. This code just demonstrates that the graceful shutdown and cleanup is
in working order.
-->
<p>Dans la réalité on ne voudrait pas qu'un serveur web s'arrête après avoir servi
seulement deux requêtes. Ce code sert uniquement à montrer que l'arrêt et le
nettoyage s'effectuent bien proprement.</p>
<!--
The `take` method is defined in the `Iterator` trait and limits the iteration
to the first two items at most. The `ThreadPool` will go out of scope at the
end of `main`, and the `drop` implementation will run.
-->
<p>La méthode <code>take</code> est définie dans le trait <code>Iterator</code> et limite l'itération
aux deux premiers éléments au maximum. Le <code>GroupeTaches</code> va sortir de la portée
à la fin du <code>main</code>, et l'implémentation de <code>drop</code> va s'exécuter.</p>
<!--
Start the server with `cargo run`, and make three requests. The third request
should error, and in your terminal you should see output similar to this:
-->
<p>Démarrez le serveur avec <code>cargo run</code>, et faites trois requêtes. La troisième
requête devrait faire une erreur, et dans votre terminal vous devriez avoir une
sortie similaire à ceci :</p>
<!--
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-- >
-->
<!--
```console
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/main`
Worker 0 got a job; executing.
Worker 3 got a job; executing.
Shutting down.
Sending terminate message to all workers.
Shutting down all workers.
Shutting down worker 0
Worker 1 was told to terminate.
Worker 2 was told to terminate.
Worker 0 was told to terminate.
Worker 3 was told to terminate.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
```
-->
<pre><code class="language-console">$ cargo run
   Compiling salutations v0.1.0 (file:///projects/salutations)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/main`
L'opérateur 0 a reçu une mission ; il l'exécute.
L'opérateur 3 a reçu une mission ; il l'exécute.
Arrêt.
Envoi du message d'extinction à tous les opérateurs.
Arrêt de tous les opérateurs.
Arrêt de l'opérateur 0
L'opérateur 1 a reçu l'instruction d'arrêt.
L'opérateur 2 a reçu l'instruction d'arrêt.
L'opérateur 0 a reçu l'instruction d'arrêt.
L'opérateur 3 a reçu l'instruction d'arrêt.
Arrêt de l'opérateur 1
Arrêt de l'opérateur 2
Arrêt de l'opérateur 3
</code></pre>
<!--
You might see a different ordering of workers and messages printed. We can see
how this code works from the messages: workers 0 and 3 got the first two
requests, and then on the third request, the server stopped accepting
connections. When the `ThreadPool` goes out of scope at the end of `main`, its
`Drop` implementation kicks in, and the pool tells all workers to terminate.
The workers each print a message when they see the terminate message, and then
the thread pool calls `join` to shut down each worker thread.
-->
<p>Vous devriez voir un ordre différent entre les opérateurs et les messages
affichés. Nous pouvons constater comment ce code fonction avec les messages :
les opérateurs 0 et 3 obtiennent les deux premières requêtes, et ensuite lors
de la troisième requête, le serveur arrête d'accepter des connexions. Lorsque
le <code>GroupeTaches</code> sort de la portée à la fin du <code>main</code>, son implémentation de
<code>Drop</code> rentre en action, et le groupe demande à tous les opérateurs de
s'arrêter. Chaque opérateur va afficher un message lorsqu'il recevra le message
d'extinction, et ensuite le groupe de tâche utilisera <code>join</code> pour arrêter
chaque tâche de chaque opérateur.</p>
<!--
Notice one interesting aspect of this particular execution: the `ThreadPool`
sent the terminate messages down the channel, and before any worker received
the messages, we tried to join worker 0. Worker 0 had not yet received the
terminate message, so the main thread blocked waiting for worker 0 to finish.
In the meantime, each of the workers received the termination messages. When
worker 0 finished, the main thread waited for the rest of the workers to
finish. At that point, they had all received the termination message and were
able to shut down.
-->
<p>Remarquez un aspect intéressant spécifique à cette exécution : le
<code>GroupeTaches</code> a envoyé les messages d'extinction dans le canal, et avant que
tous les opérateurs aient reçu les messages, nous avons essayé d'utiliser
<code>join</code> sur l'opérateur 0. L'opérateur 0 n'avait pas encore reçu le message
d'extinction, donc la tâche principale attendait que l'opérateur 0 finisse.
Pendant ce temps, tous les autres opérateurs ont reçu les messages
d'extinction. Lorsque l'opérateur 0 a fini, la tâche principale a attendu que
les opérateurs restant se terminent. A partir de là, ils ont tous reçu le
message d'extinction et sont disposés à s'arrêter.</p>
<!--
Congrats! We’ve now completed our project; we have a basic web server that uses
a thread pool to respond asynchronously. We’re able to perform a graceful
shutdown of the server, which cleans up all the threads in the pool.
-->
<p>Félicitations ! Nous avons maintenant terminé notre projet ; nous avons un
serveur web basique qui utilise un groupe de tâches pour répondre de manière
asynchrone. Nous pouvons demander un arrêt propre du serveur, qui va alors
nettoyer les tâches dans le groupe.</p>
<!--
Here’s the full code for reference:
-->
<p>Voici le code complet pour pouvoir vous y référer :</p>
<!--
<span class="filename">Filename: src/bin/main.rs</span>
-->
<p><span class="filename">Fichier : src/bin/main.rs</span></p>
<!--
```rust,ignore
use hello::ThreadPool;
use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&mut buffer).unwrap();

    let get = b"GET / HTTP/1.1\r\n";
    let sleep = b"GET /sleep HTTP/1.1\r\n";

    let (status_line, filename) = if buffer.starts_with(get) {
        ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!("{}{}", status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```
-->
<pre><code class="language-rust ignore">use salutations::GroupeTaches;
use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn main() {
    let ecouteur = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let groupe = GroupeTaches::new(4);

    for flux in ecouteur.incoming().take(2) {
        let flux = flux.unwrap();

        groupe.executer(|| {
            gestion_connexion(flux);
        });
    }

    println!(&quot;Arrêt complet.&quot;);
}

fn gestion_connexion(mut flux: TcpStream) {
    let mut tampon = [0; 1024];
    flux.read(&amp;mut tampon).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let pause = b&quot;GET /pause HTTP/1.1\r\n&quot;;

    let (ligne_statut, nom_fichier) = if tampon.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if tampon.starts_with(pause) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let contenu = fs::read_to_string(nom_fichier).unwrap();

    let reponse = format!(&quot;{}{}&quot;, ligne_statut, contenu);

    flux.write(reponse.as_bytes()).unwrap();
    flux.flush().unwrap();
}
</code></pre>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust
use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;
use std::thread;

pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Message>,
}

type Job = Box<dyn FnOnce() + Send + 'static>;

enum Message {
    NewJob(Job),
    Terminate,
}

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&mut self) {
        println!("Sending terminate message to all workers.");

        for _ in &self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!("Shutting down all workers.");

        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Message>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv().unwrap();

            match message {
                Message::NewJob(job) => {
                    println!("Worker {} got a job; executing.", id);

                    job();
                }
                Message::Terminate => {
                    println!("Worker {} was told to terminate.", id);

                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;
use std::thread;

pub struct GroupeTaches {
    operateurs: Vec&lt;Operateur&gt;,
    envoi: mpsc::Sender&lt;Message&gt;,
}

type Mission = Box&lt;dyn FnOnce() + Send + 'static&gt;;

enum Message {
    NouvelleMission(Mission),
    Extinction,
}

impl GroupeTaches {
    /// Crée un nouveau GroupeTaches.
    ///
    /// La taille est le nom de tâches présentes dans le groupe.
    ///
    /// # Panics
    ///
    /// La fonction `new` devrait paniquer si la taille vaut zéro.
    pub fn new(taille: usize) -&gt; GroupeTaches {
        assert!(taille &gt; 0);

        let (envoi, reception) = mpsc::channel();

        let reception = Arc::new(Mutex::new(reception));

        let mut operateurs = Vec::with_capacity(taille);

        for id in 0..taille {
            operateurs.push(Operateur::new(id, Arc::clone(&amp;reception)));
        }

        GroupeTaches { operateurs, envoi }
    }

    pub fn executer&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let mission = Box::new(f);

        self.envoi.send(Message::NouvelleMission(mission)).unwrap();
    }
}

impl Drop for GroupeTaches {
    fn drop(&amp;mut self) {
        println!(&quot;Envoi du message d'extinction à tous les opérateurs.&quot;);

        for _ in &amp;self.operateurs {
            self.envoi.send(Message::Extinction).unwrap();
        }

        println!(&quot;Arrêt de tous les opérateurs.&quot;);

        for operateur in &amp;mut self.operateurs {
            println!(&quot;Arrêt de l'opérateur {}&quot;, operateur.id);

            if let Some(tache) = operateur.tache.take() {
                tache.join().unwrap();
            }
        }
    }
}

struct Operateur {
    id: usize,
    tache: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Operateur {
    fn new(id: usize, reception: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Operateur {
        let tache = thread::spawn(move || loop {
            let message = reception.lock().unwrap().recv().unwrap();

            match message {
                Message::NouvelleMission(mission) =&gt; {
                    println!(&quot;L'opérateur {} a reçu une mission ; il l'exécute.&quot;, id);

                    mission();
                }
                Message::Extinction =&gt; {
                    println!(&quot;L'opérateur {} a reçu l'instruction d'arrêt.&quot;, id);

                    break;
                }
            }
        });

        Operateur {
            id,
            tache: Some(tache),
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
We could do more here! If you want to continue enhancing this project, here are
some ideas:
-->
<p>Nous aurions pu faire bien plus là-dedans ! Si vous souhaitez continuer à
améliorer ce projet, voici quelques idées :</p>
<!--
* Add more documentation to `ThreadPool` and its public methods.
* Add tests of the library’s functionality.
* Change calls to `unwrap` to more robust error handling.
* Use `ThreadPool` to perform some task other than serving web requests.
* Find a thread pool crate on [crates.io](https://crates.io/) and implement a
  similar web server using the crate instead. Then compare its API and
  robustness to the thread pool we implemented.
-->
<ul>
<li>Ajouter de la documentation sur <code>GroupeTaches</code> et les méthodes publiques.</li>
<li>Ajouter des tests sur les fonctionnalités de la bibliothèque.</li>
<li>Corriger les appels à <code>unwrap</code> pour une meilleure gestion des erreurs.</li>
<li>Utiliser <code>GroupeTaches</code> pour faire d'autres tâches que de répondre à des
requêtes web.</li>
<li>Trouver une crate de groupe tâches <em>(NdT : thread pool)</em> sur
<a href="https://crates.io/">crates.io</a> et implémenter un serveur web similaire en
utilisant plutôt cette crate. Comparer ensuite son API et sa robustesse au
groupe de tâches que nous avons implémenté.</li>
</ul>
<!--
## Summary
-->
<h2 id="résumé-19"><a class="header" href="#résumé-19">Résumé</a></h2>
<!--
Well done! You’ve made it to the end of the book! We want to thank you for
joining us on this tour of Rust. You’re now ready to implement your own Rust
projects and help with other peoples’ projects. Keep in mind that there is a
welcoming community of other Rustaceans who would love to help you with any
challenges you encounter on your Rust journey.
-->
<p>Bravo ! Vous êtes arrivé à la fin du livre ! Nous tenons à vous remercier
chaleureusement pour nous avoir accompagné pendant cette présentation de Rust.
Vous êtes maintenant fin prêt(e) à créer vos propres projets Rust et aider les
projets des autres développeurs. Rappelez-vous qu'il existe une communauté
chaleureuse de Rustacés qui est prête à vous aider dans tous les défis que vous
rencontrerez dans votre aventure avec Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--35"><a class="header" href="#-attention-peinture-fraîche--35">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/221">Pull Request</a>.</p>
</blockquote>
<!--
# Appendix
-->
<h1 id="annexes"><a class="header" href="#annexes">Annexes</a></h1>
<!--
The following sections contain reference material you may find useful in your
Rust journey.
-->
<p>Les sections suivantes contiennent du contenu de référence que vous pourriez
trouver utile dans votre aventure avec Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--36"><a class="header" href="#-attention-peinture-fraîche--36">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/222">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix A: Keywords
-->
<h2 id="annexe-a--les-mots-clés"><a class="header" href="#annexe-a--les-mots-clés">Annexe A : les mots-clés</a></h2>
<!--
The following list contains keywords that are reserved for current or future
use by the Rust language. As such, they cannot be used as identifiers (except
as raw identifiers as we’ll discuss in the “[Raw
Identifiers][raw-identifiers]<!-- ignore -- >” section), including names of
functions, variables, parameters, struct fields, modules, crates, constants,
macros, static values, attributes, types, traits, or lifetimes.
-->
<p>La liste suivante contient des mots-clés qui sont réservés pour être utilisés
actuellement ou à l'avenir dans le langage Rust. Ainsi, ils ne peuvent pas
être utilisés comme identificateurs (sauf comme identificateurs bruts, ce que
nous allons voir dans la section
“<a href="appendix-01-keywords.html#les-identificateurs-bruts">les identificateurs bruts</a><!-- ignore -->”), y compris les
noms de fonctions, de variables, de paramètres, de champs de structures, de
modules, de crates, de constantes, de macros, de valeurs statiques, d'attributs,
de types, de traits, ou de durées de vie.</p>
<!--
[raw-identifiers]: #raw-identifiers
-->
<!--
### Keywords Currently in Use
-->
<h3 id="les-mots-clés-actuellement-utilisés"><a class="header" href="#les-mots-clés-actuellement-utilisés">Les mots-clés actuellement utilisés</a></h3>
<!--
The following keywords currently have the functionality described.
-->
<p>Les mots-clés suivants apportent actuellement les fonctionnalités décrites.</p>
<!--
* `as` - perform primitive casting, disambiguate the specific trait containing
  an item, or rename items in `use` and `extern crate` statements
* `async` -  return a `Future` instead of blocking the current thread
* `await` - suspend execution until the result of a `Future` is ready
* `break` - exit a loop immediately
* `const` - define constant items or constant raw pointers
* `continue` - continue to the next loop iteration
* `crate` - link an external crate or a macro variable representing the crate in
  which the macro is defined
* `dyn` - dynamic dispatch to a trait object
* `else` - fallback for `if` and `if let` control flow constructs
* `enum` - define an enumeration
* `extern` - link an external crate, function, or variable
* `false` - Boolean false literal
* `fn` - define a function or the function pointer type
* `for` - loop over items from an iterator, implement a trait, or specify a
  higher-ranked lifetime
* `if` - branch based on the result of a conditional expression
* `impl` - implement inherent or trait functionality
* `in` - part of `for` loop syntax
* `let` - bind a variable
* `loop` - loop unconditionally
* `match` - match a value to patterns
* `mod` - define a module
* `move` - make a closure take ownership of all its captures
* `mut` - denote mutability in references, raw pointers, or pattern bindings
* `pub` - denote public visibility in struct fields, `impl` blocks, or modules
* `ref` - bind by reference
* `return` - return from function
* `Self` - a type alias for the type we are defining or implementing
* `self` - method subject or current module
* `static` - global variable or lifetime lasting the entire program execution
* `struct` - define a structure
* `super` - parent module of the current module
* `trait` - define a trait
* `true` - Boolean true literal
* `type` - define a type alias or associated type
* `union` - define a [union] and is only a keyword when used in a union declaration
* `unsafe` - denote unsafe code, functions, traits, or implementations
* `use` - bring symbols into scope
* `where` - denote clauses that constrain a type
* `while` - loop conditionally based on the result of an expression
-->
<ul>
<li><code>as</code> - effectue une transformation primitive, précise le trait que contient un
élément, ou renomme des éléments dans les instructions <code>use</code> et <code>extern crate</code></li>
<li><code>async</code> - retourne un <code>Future</code> plutôt que de bloquer la tâche de cours</li>
<li><code>await</code> - mets en pause l'exécution jusqu'à ce que le résultat d'un <code>Future</code>
soit prêt</li>
<li><code>break</code> - sort immédiatement d'une boucle</li>
<li><code>const</code> - définit des éléments fixes ou des pointeurs bruts fixes</li>
<li><code>continue</code> - va directement à la prochaine itération de la boucle en cours</li>
<li><code>crate</code> - crée un lien vers une crate externe ou une variable de macro qui
représente la crate dans laquelle la macro est définie</li>
<li><code>dyn</code> - utilisation dynamique d'un objet trait</li>
<li><code>else</code> - une branche de secours pour les structures de contrôle de flux <code>if</code>
et <code>if let</code></li>
<li><code>enum</code> - définit une énumération</li>
<li><code>extern</code> - crée un lien vers une crate, une fonction, ou une variable externe</li>
<li><code>false</code> - le litéral qui vaut &quot;faux&quot; pour un booléen</li>
<li><code>fn</code> - définit une fonction ou le type de pointeur de fonction</li>
<li><code>for</code> - crée une boucle sur des éléments d'un itérateur, implémente un trait,
ou renseigne une durée de vie nécessaire pour un niveau supérieur</li>
<li><code>if</code> - une branche liée au résultat d'une expression conditionnelle</li>
<li><code>impl</code> - implémente des fonctionnalités propres à l'élément ou à celles d'un
trait</li>
<li><code>in</code> - fait partie de la syntaxe de la boucle <code>for</code></li>
<li><code>let</code> - lie une valeur à une variable</li>
<li><code>loop</code> - fait une boucle sans condition (théoriquement infinie)</li>
<li><code>match</code> - compare une valeur à des motifs</li>
<li><code>mod</code> - définit un module</li>
<li><code>move</code> - fait en sorte qu'une fermeture prenne possession de tout ce qu'elle
utilise</li>
<li><code>mut</code> - autorise la mutabilité sur des références, des pointeurs bruts, ou des
éléments issus de motifs</li>
<li><code>pub</code> - autorise la visibilité publique sur des champs de structures, des
blocs <code>impl</code>, ou des modules</li>
<li><code>ref</code> - lie une valeur avec une référence</li>
<li><code>return</code> - retourne quelque chose, dans une fonction</li>
<li><code>Self</code> - un alias de type pour le type que nous définissons ou implementons</li>
<li><code>self</code> - désigne le sujet d'une méthode, ou du module courant</li>
<li><code>static</code> - une variable globale ou une durée de vie qui dure tout le long de
l'exécution du programme</li>
<li><code>struct</code> - définit une structure</li>
<li><code>super</code> - le module parent du module courant</li>
<li><code>trait</code> - définit un trait</li>
<li><code>true</code> - le litéral qui vaut &quot;vrai&quot; pour un booléen</li>
<li><code>type</code> - définit un alias de type ou un type associé</li>
<li><code>union</code> - définit un <a href="../reference/items/unions.html">union</a> et n'est qu'un mot-clé lorsqu'il est utilisé dans
la décalation d'un union</li>
<li><code>unsafe</code> - autorise du code, des fonctions, des traits ou des implémentations
non sécurisées</li>
<li><code>use</code> - importe des éléments dans la portée</li>
<li><code>where</code> - indique des conditions pour contraindre un type</li>
<li><code>while</code> - crée une boucle en fonction des résultats d'une expression</li>
</ul>
<!--
[union]: ../reference/items/unions.html
-->
<!--
### Keywords Reserved for Future Use
-->
<h3 id="les-mots-clés-réservés-pour-une-utilisation-future"><a class="header" href="#les-mots-clés-réservés-pour-une-utilisation-future">Les mots-clés réservés pour une utilisation future</a></h3>
<!--
The following keywords do not have any functionality but are reserved by Rust
for potential future use.
-->
<p>Les mots-clés suivants n'offrent actuellement aucune fonctionnalitée mais sont
réservés par Rust pour une potentielle utilisation future.</p>
<!--
* `abstract`
* `become`
* `box`
* `do`
* `final`
* `macro`
* `override`
* `priv`
* `try`
* `typeof`
* `unsized`
* `virtual`
* `yield`
-->
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<!--
### Raw Identifiers
-->
<h3 id="les-identificateurs-bruts"><a class="header" href="#les-identificateurs-bruts">Les identificateurs bruts</a></h3>
<!--
*Raw identifiers* are the syntax that lets you use keywords where they wouldn’t
normally be allowed. You use a raw identifier by prefixing a keyword with `r#`.
-->
<p>Un <em>identificateur brut</em> est une syntaxe qui vous permet d'utiliser les
mots-clés là où ils ne devraient pas pouvoir l'être. Vous pouvez utiliser un
identificateur brut en faisant précéder un mot-clé par un <code>r#</code>.</p>
<!--
For example, `match` is a keyword. If you try to compile the following function
that uses `match` as its name:
-->
<p>Par exemple, <code>match</code> est un mot-clé. Si vous essayez de compiler la fonction
suivante qui utilise <code>match</code> comme nom :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn match(aiguille: &amp;str, botte_de_foin: &amp;str) -&gt; bool {
    botte_de_foin.contains(aiguille)
}
</code></pre>
<!--
you’ll get this error:
-->
<p>... vous allez obtenir l'erreur suivante :</p>
<!--
```text
error: expected identifier, found keyword `match`
 -- > src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```
-->
<pre><code class="language-text">error: expected identifier, found keyword `match`
 -- &gt; src/main.rs:4:4
  |
4 | fn match(aiguille: &amp;str, botte_de_foin: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<!--
The error shows that you can’t use the keyword `match` as the function
identifier. To use `match` as a function name, you need to use the raw
identifier syntax, like this:
-->
<p>L'erreur montre que vous ne pouvez pas utiliser le mot-clé <code>match</code> comme
identificateur de la fonction. Pour utiliser <code>match</code> comme nom de fonction, vous
allez avoir besoin d'utiliser la syntaxe d'identificateur brut, comme ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn r#match(aiguille: &amp;str, botte_de_foin: &amp;str) -&gt; bool {
    botte_de_foin.contains(aiguille)
}

fn main() {
    assert!(r#match(&quot;rem&quot;, &quot;lorem ipsum&quot;));
}
</code></pre></pre>
<!--
This code will compile without any errors. Note the `r#` prefix on the function
name in its definition as well as where the function is called in `main`.
-->
<p>Ce code va se compiler sans erreur. Remarquez aussi le préfixe <code>r#</code> sur le nom
de la fonction dans sa définition mais aussi lorsque cette fonction est appelée
dans <code>main</code>.</p>
<!--
Raw identifiers allow you to use any word you choose as an identifier, even if
that word happens to be a reserved keyword. In addition, raw identifiers allow
you to use libraries written in a different Rust edition than your crate uses.
For example, `try` isn’t a keyword in the 2015 edition but is in the 2018
edition. If you depend on a library that’s written using the 2015 edition and
has a `try` function, you’ll need to use the raw identifier syntax, `r#try` in
this case, to call that function from your 2018 edition code. See [Appendix
E][appendix-e]<!-- ignore -- > for more information on editions.
-->
<p>Les identificateurs bruts vous permettent d'utiliser n'importe quel mot que vous
souhaitez comme identificateur, même si ce mot est un mot-clé réservé. De plus,
les identificateurs bruts vous permettent d'utiliser des bibliothèques écrites
dans des éditions de Rust différentes que celle qu'utilise votre crate. Par
exemple, <code>try</code> n'est pas un mot-clé dans l'édition 2015 mais l'est dans
l'édition 2018. Si vous dépendez d'une bibliothèque qui était écrite avec
l'édition 2015 et qui avait une fonction <code>try</code>, vous allez avoir besoin
d'utiliser la syntaxe d'identificateur brut, <code>r#try</code> dans ce cas, pour faire
appel à cette fonction à partir de code écrit avec l'édition 2018. Voir
<a href="appendix-05-editions.html">l'annexe E</a><!-- ignore --> pour en savoir plus les éditions.</p>
<!--
[appendix-e]: appendix-05-editions.html
-->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--37"><a class="header" href="#-attention-peinture-fraîche--37">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/223">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix B: Operators and Symbols
-->
<h2 id="annexe-b--les-opérateurs-et-les-symboles"><a class="header" href="#annexe-b--les-opérateurs-et-les-symboles">Annexe B : les opérateurs et les symboles</a></h2>
<!--
This appendix contains a glossary of Rust’s syntax, including operators and
other symbols that appear by themselves or in the context of paths, generics,
trait bounds, macros, attributes, comments, tuples, and brackets.
-->
<p>Cette annexe contient un glossaire de syntaxes Rust, comprenant les opérateurs
et les autres symboles qui s'utilisent tout seuls ou alors dans le cadre de
chemins, de génériques, de traits liés, de macros, d'attributs, de commentaires,
de tuples, de crochets ou d'accolades.</p>
<!--
### Operators
-->
<h3 id="opérateurs"><a class="header" href="#opérateurs">Opérateurs</a></h3>
<!--
Table B-1 contains the operators in Rust, an example of how the operator would
appear in context, a short explanation, and whether that operator is
overloadable. If an operator is overloadable, the relevant trait to use to
overload that operator is listed.
-->
<p>Le tableau B-1 contient une liste d'opérateurs en Rust, un exemple de comment
l'opérateur devrait être utilisé dans ce contexte, une petite explication, et si
cet opérateur est surchargeable. Si un opérateur est surchargeable, le trait
concerné à utiliser pour la surcharge est indiqué.</p>
<!--
<span class="caption">Table B-1: Operators</span>
-->
<p><span class="caption">Tableau B-1 : les opérateurs</span></p>
<!--
| Operator | Example | Explanation | Overloadable? |
|----------|---------|-------------|---------------|
| `!` | `ident!(...)`, `ident!{...}`, `ident![...]` | Macro expansion | |
| `!` | `!expr` | Bitwise or logical complement | `Not` |
| `!=` | `var != expr` | Nonequality comparison | `PartialEq` |
| `%` | `expr % expr` | Arithmetic remainder | `Rem` |
| `%=` | `var %= expr` | Arithmetic remainder and assignment | `RemAssign` |
| `&` | `&expr`, `&mut expr` | Borrow | |
| `&` | `&type`, `&mut type`, `&'a type`, `&'a mut type` | Borrowed pointer type | |
| `&` | `expr & expr` | Bitwise AND | `BitAnd` |
| `&=` | `var &= expr` | Bitwise AND and assignment | `BitAndAssign` |
| `&&` | `expr && expr` | Short-circuiting logical AND | |
| `*` | `expr * expr` | Arithmetic multiplication | `Mul` |
| `*=` | `var *= expr` | Arithmetic multiplication and assignment | `MulAssign` |
| `*` | `*expr` | Dereference | |
| `*` | `*const type`, `*mut type` | Raw pointer | |
| `+` | `trait + trait`, `'a + trait` | Compound type constraint | |
| `+` | `expr + expr` | Arithmetic addition | `Add` |
| `+=` | `var += expr` | Arithmetic addition and assignment | `AddAssign` |
| `,` | `expr, expr` | Argument and element separator | |
| `-` | `- expr` | Arithmetic negation | `Neg` |
| `-` | `expr - expr` | Arithmetic subtraction | `Sub` |
| `-=` | `var -= expr` | Arithmetic subtraction and assignment | `SubAssign` |
| `->` | `fn(...) -> type`, <code>&vert;...&vert; -> type</code> | Function and closure return type | |
| `.` | `expr.ident` | Member access | |
| `..` | `..`, `expr..`, `..expr`, `expr..expr` | Right-exclusive range literal | |
| `..=` | `..=expr`, `expr..=expr` | Right-inclusive range literal | |
| `..` | `..expr` | Struct literal update syntax | |
| `..` | `variant(x, ..)`, `struct_type { x, .. }` | “And the rest” pattern binding | |
| `...` | `expr...expr` | In a pattern: inclusive range pattern | |
| `/` | `expr / expr` | Arithmetic division | `Div` |
| `/=` | `var /= expr` | Arithmetic division and assignment | `DivAssign` |
| `:` | `pat: type`, `ident: type` | Constraints | |
| `:` | `ident: expr` | Struct field initializer | |
| `:` | `'a: loop {...}` | Loop label | |
| `;` | `expr;` | Statement and item terminator | |
| `;` | `[...; len]` | Part of fixed-size array syntax | |
| `<<` | `expr << expr` | Left-shift | `Shl` |
| `<<=` | `var <<= expr` | Left-shift and assignment | `ShlAssign` |
| `<` | `expr < expr` | Less than comparison | `PartialOrd` |
| `<=` | `expr <= expr` | Less than or equal to comparison | `PartialOrd` |
| `=` | `var = expr`, `ident = type` | Assignment/equivalence | |
| `==` | `expr == expr` | Equality comparison | `PartialEq` |
| `=>` | `pat => expr` | Part of match arm syntax | |
| `>` | `expr > expr` | Greater than comparison | `PartialOrd` |
| `>=` | `expr >= expr` | Greater than or equal to comparison | `PartialOrd` |
| `>>` | `expr >> expr` | Right-shift | `Shr` |
| `>>=` | `var >>= expr` | Right-shift and assignment | `ShrAssign` |
| `@` | `ident @ pat` | Pattern binding | |
| `^` | `expr ^ expr` | Bitwise exclusive OR | `BitXor` |
| `^=` | `var ^= expr` | Bitwise exclusive OR and assignment | `BitXorAssign` |
| <code>&vert;</code> | <code>pat &vert; pat</code> | Pattern alternatives | |
| <code>&vert;</code> | <code>expr &vert; expr</code> | Bitwise OR | `BitOr` |
| <code>&vert;=</code> | <code>var &vert;= expr</code> | Bitwise OR and assignment | `BitOrAssign` |
| <code>&vert;&vert;</code> | <code>expr &vert;&vert; expr</code> | Short-circuiting logical OR | |
| `?` | `expr?` | Error propagation | |
-->
<table><thead><tr><th>Opérateur</th><th>Exemple</th><th>Explication</th><th>Surchargeable ?</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Identificateur de macro</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>Négation binaire ou logique</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>var != expr</code></td><td>Comparaison de non-égalité</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Reste arithmétique</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Reste arithmétique et assignation</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>Emprunt</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>Type de pointeur emprunté</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>ET binaire</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>ET binaire et assignation</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>ET logique</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>Multiplication arithmétique</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>Multiplication arithmétique et assignation</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>Déréférencement</td><td></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>Pointeur brut</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>Contrainte de type composé</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Addition arithmétique</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Addition arithmétique et assignation</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>Séparateur d'arguments et d'éléments</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>Négation arithmétique</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Soustraction arithmétique</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>Soustraction arithmétique et assignation</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code></td><td>Type de retour de fonction et de fermeture</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>Accès à un membre</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>Littéral d'intervalle d'exclusion</td><td></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>Littéral d'intervalle d'inclusion</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>Syntaxe de mise à jour de litéraux de structure</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>Motif “ainsi que la suite”</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>Dans un motif : motif d'intervalle inclusif</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>Division arithmétique</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>Division arithmétique et assignation</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>Contrainte</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>Initialisateur de champ de structure</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>Une identification de boucle</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>Fin d'élément et d'instruction</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>Syntaxe désignant une partie d'un tableau à taille finie</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>Décalage à gauche</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>Décalage à gauche et assignation</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>Comparaison &quot;inférieur à&quot;</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>Comparaison &quot;inférieur ou égal à&quot;</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>Assignation ou équivalence</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>Comparaison d'égalité</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>Syntaxe d'une partie d'une branche correspondante</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>Comparaison &quot;supérieur à&quot;</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>Comparaison &quot;supérieur ou égal à&quot;</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>Décalage à droite</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>Décalage à droite et assignation</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>Création d'un identificateur à partir du motif</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>OU exclusif binaire</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>OU exclusif binaire et assignation</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>Alternatives à un motif</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>OU binaire</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>OU binaire et assignation</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>OU logique</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>Propagation d'erreur</td><td></td></tr>
</tbody></table>
<!--
### Non-operator Symbols
-->
<h3 id="les-symboles-non-opérateurs"><a class="header" href="#les-symboles-non-opérateurs">Les symboles non-opérateurs</a></h3>
<!--
The following list contains all non-letters that don’t function as operators;
that is, they don’t behave like a function or method call.
-->
<p>La liste suivante contient tout ce qui n'est pas une lettre et qui ne fonctionne
pas comme un opérateur ; autrement dit tout ce qui ne se comporte pas comme un
appel de fonction ou de méthode.</p>
<!--
Table B-2 shows symbols that appear on their own and are valid in a variety of
locations.
-->
<p>Le tableau B-2 montre des symboles qui s'utilisent tout seuls et qui sont
valables dans plusieurs situations.</p>
<!--
<span class="caption">Table B-2: Stand-Alone Syntax</span>
-->
<p><span class="caption">Tableau B-2 : syntaxes autonomes</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `'ident` | Named lifetime or loop label |
| `...u8`, `...i32`, `...f64`, `...usize`, etc. | Numeric literal of specific type |
| `"..."` | String literal |
| `r"..."`, `r#"..."#`, `r##"..."##`, etc. | Raw string literal, escape characters not processed |
| `b"..."` | Byte string literal; constructs a `[u8]` instead of a string |
| `br"..."`, `br#"..."#`, `br##"..."##`, etc. | Raw byte string literal, combination of raw and byte string literal |
| `'...'` | Character literal |
| `b'...'` | ASCII byte literal |
| <code>&vert;...&vert; expr</code> | Closure |
| `!` | Always empty bottom type for diverging functions |
| `_` | “Ignored” pattern binding; also used to make integer literals readable |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>Nom d'une durée de vie ou nom boucle</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, etc.</td><td>Nombre littéral d'un type spécifique</td></tr>
<tr><td><code>&quot;...&quot;</code></td><td>Chaîne de caractère littérale</td></tr>
<tr><td><code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code>, etc.</td><td>Chaîne de caractères brute littérale, les caractères d'échappement ne sont pas traités</td></tr>
<tr><td><code>b&quot;...&quot;</code></td><td>Chaîne d'octet littéral ; construit un <code>[u8]</code> au lieu d'une chaîne de caractères</td></tr>
<tr><td><code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code>, etc.</td><td>Chaîne d'octets brute littérale, combinaison de la chaîne d'octets brute et de la chaîne d'octets littérale</td></tr>
<tr><td><code>'...'</code></td><td>Caractère littéral</td></tr>
<tr><td><code>b'...'</code></td><td>Octet ASCII littéral</td></tr>
<tr><td><code>|...| expr</code></td><td>Une fermeture</td></tr>
<tr><td><code>!</code></td><td>Le type “jamais&quot;, toujours vide pour les fonctions divergentes</td></tr>
<tr><td><code>_</code></td><td>Le motif “ignoré&quot; ; aussi utilisé pour rendre lisibles les nombres entiers littéraux</td></tr>
</tbody></table>
<!--
Table B-3 shows symbols that appear in the context of a path through the module
hierarchy to an item.
-->
<p>Le tableau B-3 montre des symboles qui s'utilisent dans le contexte d'un chemin
dans une structure de modules pour obtenir un élément.</p>
<!--
<span class="caption">Table B-3: Path-Related Syntax</span>
-->
<p><span class="caption">Tableau B-3 : syntaxes utilisés pour les chemins</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `ident::ident` | Namespace path |
| `::path` | Path relative to the crate root (i.e., an explicitly absolute path) |
| `self::path` | Path relative to the current module (i.e., an explicitly relative path).
| `super::path` | Path relative to the parent of the current module |
| `type::ident`, `<type as trait>::ident` | Associated constants, functions, and types |
| `<type>::...` | Associated item for a type that cannot be directly named (e.g., `<&T>::...`, `<[T]>::...`, etc.) |
| `trait::method(...)` | Disambiguating a method call by naming the trait that defines it |
| `type::method(...)` | Disambiguating a method call by naming the type for which it’s defined |
| `<type as trait>::method(...)` | Disambiguating a method call by naming the trait and type |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>Chemin d'un espace de nom</td></tr>
<tr><td><code>::path</code></td><td>Chemin relatif à la crate racine (c'est à dire un chemin explicitement absolu)</td></tr>
<tr><td><code>self::path</code></td><td>Chemin relatif au module courant (c'est à dire un chemin explicitement relatif)</td></tr>
<tr><td><code>super::path</code></td><td>Chemin relatif au parent du module courant</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>Des constantes, fonctions et types associées</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>Un élément associé pour un type qui ne peut pas être directement nommé (par exemple, <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>, etc)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>Clarifier l'appel d'une méthode en nommant le trait qui le définit</td></tr>
<tr><td><code>type::method(...)</code></td><td>Clarifier l'appel d'une fonction en nommant le type pour laquelle elle est définie</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>Clarifier l'appel d'une méthode en nommant le trait et le type</td></tr>
</tbody></table>
<!--
Table B-4 shows symbols that appear in the context of using generic type
parameters.
-->
<p>Le tableau B-4 montre des symboles qui apparaissent dans le contexte
d'utilisation de paramètres de type génériques.</p>
<!--
<span class="caption">Table B-4: Generics</span>
-->
<p><span class="caption">Tableau B-4 : génériques</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `path<...>` | Specifies parameters to generic type in a type (e.g., `Vec<u8>`) |
| `path::<...>`, `method::<...>` | Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., `"42".parse::<i32>()`) |
| `fn ident<...> ...` | Define generic function |
| `struct ident<...> ...` | Define generic structure |
| `enum ident<...> ...` | Define generic enumeration |
| `impl<...> ...` | Define generic implementation |
| `for<...> type` | Higher-ranked lifetime bounds |
| `type<ident=type>` | A generic type where one or more associated types have specific assignments (e.g., `Iterator<Item=T>`) |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>Précise des paramètres sur un type générique utilisé dans un type (par exemple, <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>Précise des paramètres sur un type générique, une fonction, ou une méthode dans une expression ; parfois appelé turbofish (par exemple, <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>Définit une fonction générique</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>Définit une structure générique</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>Définit une énumération générique</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>Définit une implémentation générique</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>Augmente la durée de vie</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>Un type générique sur lequel un ou plusieurs types associés ont des affectations spécifiques (par exemple, <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
<!--
Table B-5 shows symbols that appear in the context of constraining generic type
parameters with trait bounds.
-->
<p>Le tableau B-5 montre des symboles qui s'utilisent pour contraindre des
paramètres de type génériques avec des traits liés.</p>
<!--
<span class="caption">Table B-5: Trait Bound Constraints</span>
-->
<p><span class="caption">Tableau B-5 : contraintes de trait lié</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `T: U` | Generic parameter `T` constrained to types that implement `U` |
| `T: 'a` | Generic type `T` must outlive lifetime `'a` (meaning the type cannot transitively contain any references with lifetimes shorter than `'a`) |
| `T : 'static` | Generic type `T` contains no borrowed references other than `'static` ones |
| `'b: 'a` | Generic lifetime `'b` must outlive lifetime `'a` |
| `T: ?Sized` | Allow generic type parameter to be a dynamically sized type |
| `'a + trait`, `trait + trait` | Compound type constraint |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>Paramètre générique <code>T</code> contraint aux types qui implémentent <code>U</code></td></tr>
<tr><td><code>T: 'a</code></td><td>Type générique <code>T</code> doit vivre aussi longtemps que la durée de vie <code>'a</code> (ce qui signifie que le type ne peut pas contenir temporairement de références avec une durée de vie plus petite que <code>'a</code>)</td></tr>
<tr><td><code>T : 'static</code></td><td>Type générique <code>T</code> qui ne contient pas d'autres références empruntées autres que des <code>'static</code></td></tr>
<tr><td><code>'b: 'a</code></td><td>La durée de vie générique <code>'b</code> doit vivre aussi longtemps que <code>'a</code></td></tr>
<tr><td><code>T: ?Sized</code></td><td>Permet aux paramètres de type génériques d'être de type à taille dynamique</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>Contrainte de type composé</td></tr>
</tbody></table>
<!--
Table B-6 shows symbols that appear in the context of calling or defining
macros and specifying attributes on an item.
-->
<p>Le tableau B-6 montre des symboles qui s'utilisent lors de l'appel ou de la
définition de macros et pour spécifier des attributs sur un élément.</p>
<!--
<span class="caption">Table B-6: Macros and Attributes</span>
-->
<p><span class="caption">Tableau B-6 : macros et attributs</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `#[meta]` | Outer attribute |
| `#![meta]` | Inner attribute |
| `$ident` | Macro substitution |
| `$ident:kind` | Macro capture |
| `$(…)…` | Macro repetition |
| `ident!(...)`, `ident!{...}`, `ident![...]` | Macro invocation |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>Attribut externe</td></tr>
<tr><td><code>#![meta]</code></td><td>Attribut interne</td></tr>
<tr><td><code>$ident</code></td><td>Substitution de macro</td></tr>
<tr><td><code>$ident:kind</code></td><td>Capture de macro</td></tr>
<tr><td><code>$(…)…</code></td><td>Répétition de macro</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Appel d'une macro</td></tr>
</tbody></table>
<!--
Table B-7 shows symbols that create comments.
-->
<p>Le tableau B-7 montre des symboles pour créer des commentaires.</p>
<!--
<span class="caption">Table B-7: Comments</span>
-->
<p><span class="caption">Tableau B-7 : commentaires</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `//` | Line comment |
| `//!` | Inner line doc comment |
| `///` | Outer line doc comment |
| `/*...*/` | Block comment |
| `/*!...*/` | Inner block doc comment |
| `/**...*/` | Outer block doc comment |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>Ligne commentée</td></tr>
<tr><td><code>//!</code></td><td>Commentaire de documentation sur l'élément contenant actuel</td></tr>
<tr><td><code>///</code></td><td>Commentaire de documentation sur l'élément suivant ce commentaire</td></tr>
<tr><td><code>/*...*/</code></td><td>Bloc de commentaire</td></tr>
<tr><td><code>/*!...*/</code></td><td>Bloc de commentaire de documentation sur l'élément contenant actuel</td></tr>
<tr><td><code>/**...*/</code></td><td>Bloc de commentaire de documentation sur l'élément suivant ce commentaire</td></tr>
</tbody></table>
<!--
Table B-8 shows symbols that appear in the context of using tuples.
-->
<p>Le tableau B-8 montre des symboles utilisés avec les tuples.</p>
<!--
<span class="caption">Table B-8: Tuples</span>
-->
<p><span class="caption">Tableau B-8 : les tuples</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `()` | Empty tuple (aka unit), both literal and type |
| `(expr)` | Parenthesized expression |
| `(expr,)` | Single-element tuple expression |
| `(type,)` | Single-element tuple type |
| `(expr, ...)` | Tuple expression |
| `(type, ...)` | Tuple type |
| `expr(expr, ...)` | Function call expression; also used to initialize tuple `struct`s and tuple `enum` variants |
| `expr.0`, `expr.1`, etc. | Tuple indexing |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>Un tuple vide (aussi appelé unitaire), à la fois un type et un litéral</td></tr>
<tr><td><code>(expr)</code></td><td>Une expression entre parenthèses</td></tr>
<tr><td><code>(expr,)</code></td><td>Un tuple d'un seul élement qui est une expression</td></tr>
<tr><td><code>(type,)</code></td><td>Un tuple d'un seul élement qui est un type</td></tr>
<tr><td><code>(expr, ...)</code></td><td>Une expression dans un tuple</td></tr>
<tr><td><code>(type, ...)</code></td><td>Un type dans un tuple</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>Une expression d'appel à une fonction ; aussi utilisé pour initialiser une structure tuple ou une variante d'énumération tuple</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, etc.</td><td>Utilisation d'indices sur un tuple</td></tr>
</tbody></table>
<!--
Table B-9 shows the contexts in which curly braces are used.
-->
<p>Le tableau B-9 montre les contextes d'utilisation des accolades.</p>
<!--
<span class="caption">Table B-9: Curly Brackets</span>
-->
<p><span class="caption">Tableau B-9 : accolades</span></p>
<!--
| Context | Explanation |
|---------|-------------|
| `{...}` | Block expression |
| `Type {...}` | `struct` literal |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>Bloc d'expression</td></tr>
<tr><td><code>Type {...}</code></td><td>Un littéral de <code>struct</code></td></tr>
</tbody></table>
<!--
Table B-10 shows the contexts in which square brackets are used.
-->
<p>Le tableau B-10 montre les contextes d'utilisation des crochets.</p>
<!--
<span class="caption">Table B-10: Square Brackets</span>
-->
<p><span class="caption">Tableau B-10 : crochets</span></p>
<!--
| Context | Explanation |
|---------|-------------|
| `[...]` | Array literal |
| `[expr; len]` | Array literal containing `len` copies of `expr` |
| `[type; len]` | Array type containing `len` instances of `type` |
| `expr[expr]` | Collection indexing. Overloadable (`Index`, `IndexMut`) |
| `expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]` | Collection indexing pretending to be collection slicing, using `Range`, `RangeFrom`, `RangeTo`, or `RangeFull` as the “index” |
-->
<table><thead><tr><th>Symbole</th><th>Explication</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>Un littéral de tableau</td></tr>
<tr><td><code>[expr; len]</code></td><td>Un littéral de tableau qui contient <code>len</code> copies de <code>expr</code></td></tr>
<tr><td><code>[type; len]</code></td><td>Un type de tableau qui contient <code>len</code> instances de <code>type</code></td></tr>
<tr><td><code>expr[expr]</code></td><td>Une collection indexée. C'est surchargeable (via <code>Index</code> et <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>Une collection indexée qui se comporte comme une slice de collection, grâce à l'utilisation de <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, ou de <code>RangeFull</code> comme “indice”</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--38"><a class="header" href="#-attention-peinture-fraîche--38">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/224">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix C: Derivable Traits
-->
<h2 id="annexe-c--les-traits-dérivables"><a class="header" href="#annexe-c--les-traits-dérivables">Annexe C : les traits dérivables</a></h2>
<!--
In various places in the book, we’ve discussed the `derive` attribute, which
you can apply to a struct or enum definition. The `derive` attribute generates
code that will implement a trait with its own default implementation on the
type you’ve annotated with the `derive` syntax.
-->
<p>Dans de nombreux endroits du livre, nous avons vu l'attribut <code>derive</code>, que vous
pouvez appliquer à une définition de structure ou d'énumération. L'attribut
<code>derive</code> génère du code qui va implémenter un trait avec sa propre
implémentation par défaut sur le type que vous avez annoté avec la syntaxe
<code>derive</code>.</p>
<!--
In this appendix, we provide a reference of all the traits in the standard
library that you can use with `derive`. Each section covers:
-->
<p>Dans cette annexe, nous allons produire une référence de tous les traits de la
bibliothèque standard que vous pouvez utiliser avec <code>derive</code>. Chaque section
va donner :</p>
<!--
* What operators and methods deriving this trait will enable
* What the implementation of the trait provided by `derive` does
* What implementing the trait signifies about the type
* The conditions in which you’re allowed or not allowed to implement the trait
* Examples of operations that require the trait
-->
<ul>
<li>Quels opérateurs et méthodes seront activés en dérivant de ce trait</li>
<li>Ce que fait l'implémentation du trait appliqué par le <code>derive</code></li>
<li>Ce que l'implémentation du trait implique sur le type concerné</li>
<li>Les conditions dans lesquelles vous pouvez ou non implémenter le trait</li>
<li>Des exemples d'opérations qui nécessitent que le trait soit implémenté</li>
</ul>
<!--
If you want different behavior from that provided by the `derive` attribute,
consult the [standard library documentation](../std/index.html)<!-- ignore -- >
for each trait for details of how to manually implement them.
-->
<p>Si vous souhaitez appliquer un comportement différent de celui fourni par
l'attribut <code>derive</code>, consultez <a href="https://doc.rust-lang.org/std/index.html">la documentation de la bibliothèque
standard</a><!-- ignore --> pour le trait
concerné afin d'en savoir plus sur son implémentation manuelle.</p>
<!--
The rest of the traits defined in the standard library can’t be implemented on
your types using `derive`. These traits don’t have sensible default behavior,
so it’s up to you to implement them in the way that makes sense for what you’re
trying to accomplish.
-->
<p>Le reste des traits définis dans la bibliothèque standard ne peuvent pas être
implémentés sur des types en utilisant <code>derive</code>. Ces traits n'ont pas de
comportement logique par défaut, donc c'est à vous de les implémenter de la
façon la plus appropriée pour ce que vous souhaitez accomplir.</p>
<!--
An example of a trait that can’t be derived is `Display`, which handles
formatting for end users. You should always consider the appropriate way to
display a type to an end user. What parts of the type should an end user be
allowed to see? What parts would they find relevant? What format of the data
would be most relevant to them? The Rust compiler doesn’t have this insight, so
it can’t provide appropriate default behavior for you.
-->
<p>Un exemple de trait qui ne peut pas être dérivé est <code>Display</code>, qui permet de
formater la donnée pour les utilisateurs finaux. Vous devez toujours réfléchir
au formatage du type le plus approprié pour un utilisateur final. Quelles
parties d'un type un utilisateur final devrait pouvoir voir ? Sous quelle forme
les données devraient être les plus intéressantes pour eux ? Le compilateur de
Rust n'a pas cette intuition, donc il ne peut pas fournir un comportement par
défaut à votre place.</p>
<!--
The list of derivable traits provided in this appendix is not comprehensive:
libraries can implement `derive` for their own traits, making the list of
traits you can use `derive` with truly open-ended. Implementing `derive`
involves using a procedural macro, which is covered in the
[“Macros”][macros]<!-- ignore -- > section of Chapter 19.
-->
<p>La liste des traits dérivables fournis dans cette annexe n'est pas exhaustive :
les bibliothèques peuvent implémenter <code>derive</code> pour leurs propres traits,
étendant potentiellement à l'infini la liste de traits que vous pouvez utiliser
avec <code>derive</code>. L'implémentation de <code>derive</code> implique l'utilisation d'une macro
procédurale, que nous avons vu dans <a href="ch19-06-macros.html">une section</a><!-- ignore --> du
chapitre 19.</p>
<!--
### `Debug` for Programmer Output
-->
<h3 id="debug-pour-laffichage-au-développeur"><a class="header" href="#debug-pour-laffichage-au-développeur"><code>Debug</code> pour l'affichage au développeur</a></h3>
<!--
The `Debug` trait enables debug formatting in format strings, which you
indicate by adding `:?` within `{}` placeholders.
-->
<p>Le trait <code>Debug</code> permet le formatage de déboguage pour mettre en forme en tant
que chaînes de caractères, que vous pouvez utiliser en ajoutant <code>:?</code> dans un
espace réservé <code>{}</code>.</p>
<!--
The `Debug` trait allows you to print instances of a type for debugging
purposes, so you and other programmers using your type can inspect an instance
at a particular point in a program’s execution.
-->
<p>Le trait <code>Debug</code> vous permet d'afficher des instances d'un type pour des besoins
de déboguage, afin que vous et les autres développeurs qui utilisent votre type
puissent inspecter une de ses instances à un endroit précis de l'exécution du
programme.</p>
<!--
The `Debug` trait is required, for example, in use of the `assert_eq!` macro.
This macro prints the values of instances given as arguments if the equality
assertion fails so programmers can see why the two instances weren’t equal.
-->
<p>Le trait <code>Debug</code> est nécessaire, par exemple, pour l'utilisation de la macro
<code>assert_eq!</code>. Cette macro affiche les valeurs des instances passées en argument
dans le cas où l'affirmation échoue afin que le développeur puisse voir pourquoi
les deux instances ne sont pas égales.</p>
<!--
### `PartialEq` and `Eq` for Equality Comparisons
-->
<h3 id="partialeq-et-eq-pour-comparer-légalité"><a class="header" href="#partialeq-et-eq-pour-comparer-légalité"><code>PartialEq</code> et <code>Eq</code> pour comparer l'égalité</a></h3>
<!--
The `PartialEq` trait allows you to compare instances of a type to check for
equality and enables use of the `==` and `!=` operators.
-->
<p>Le trait <code>PartialEq</code> vous permet de comparer des instances d'un type pour
vérifier leur égalité et permet l'utilisation des opérateurs <code>==</code> et <code>!=</code>.</p>
<!--
Deriving `PartialEq` implements the `eq` method. When `PartialEq` is derived on
structs, two instances are equal only if *all* fields are equal, and the
instances are not equal if any fields are not equal. When derived on enums,
each variant is equal to itself and not equal to the other variants.
-->
<p>L'application de <code>derive</code> avec <code>PartialEq</code> implémente la méthode <code>eq</code>. Lorsque
<code>PartialEq</code> est dérivé sur une structure, deux instances ne peuvent être égales
seulement si <em>tous</em> leurs champs sont égaux, et les instances ne sont pas égales
si un des champs n'est pas égal. Lorsque ce trait est dérivé sur une
énumération, chaque variante est égale à elle-même et n'est pas égale aux autres
variantes.</p>
<!--
The `PartialEq` trait is required, for example, with the use of the
`assert_eq!` macro, which needs to be able to compare two instances of a type
for equality.
-->
<p>Le trait <code>Eq</code> est nécessaire, par exemple, pour utiliser la macro <code>assert_eq!</code>,
qui nécessite de pouvoir comparer l'égalité de deux instances d'un type.</p>
<!--
The `Eq` trait has no methods. Its purpose is to signal that for every value of
the annotated type, the value is equal to itself. The `Eq` trait can only be
applied to types that also implement `PartialEq`, although not all types that
implement `PartialEq` can implement `Eq`. One example of this is floating point
number types: the implementation of floating point numbers states that two
instances of the not-a-number (`NaN`) value are not equal to each other.
-->
<p>Le trait <code>Eq</code> n'a pas de méthode. Son rôle est de signaler que pour chaque
valeur du type annoté, la valeur est égale à elle-même. Le trait <code>Eq</code> peut
seulement être appliqué sur des types qui implémentent <code>PartialEq</code>, bien que
tous les types qui implémentent <code>PartialEq</code> ne puissent pas implémenter <code>Eq</code>. Un
exemple de ceci sont les types de nombres à virgule flottante : l'implémentation
des nombres à virgule flottante stipule que deux instances ayant la valeur
“not-a-number” (<code>NaN</code>, c'est-à-dire “ceci n'est pas un nombre”) ne sont pas
égales entre elles.</p>
<!--
An example of when `Eq` is required is for keys in a `HashMap<K, V>` so the
`HashMap<K, V>` can tell whether two keys are the same.
-->
<p>Par exemple, <code>Eq</code> est nécessaire est pour les clés dans un <code>HashMap&lt;K, V&gt;</code> afin
que le <code>HashMap&lt;K, V&gt;</code> puisse déterminer si deux clés sont identiques.</p>
<!--
### `PartialOrd` and `Ord` for Ordering Comparisons
-->
<h3 id="partialord-et-ord-pour-comparer-les-ordres-de-grandeur"><a class="header" href="#partialord-et-ord-pour-comparer-les-ordres-de-grandeur"><code>PartialOrd</code> et <code>Ord</code> pour comparer les ordres de grandeur</a></h3>
<!--
The `PartialOrd` trait allows you to compare instances of a type for sorting
purposes. A type that implements `PartialOrd` can be used with the `<`, `>`,
`<=`, and `>=` operators. You can only apply the `PartialOrd` trait to types
that also implement `PartialEq`.
-->
<p>Le trait <code>PartialOrd</code> vous permet de comparer des instances d'un type pour
pouvoir les trier. Un type qui implémente <code>PartialOrd</code> peut être utilisé avec
les opérateurs <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, et <code>&gt;=</code>. Vous pouvez appliquer uniquement le
trait <code>PartialOrd</code> aux types qui implémentent aussi <code>PartialEq</code>.</p>
<!--
Deriving `PartialOrd` implements the `partial_cmp` method, which returns an
`Option<Ordering>` that will be `None` when the values given don’t produce an
ordering. An example of a value that doesn’t produce an ordering, even though
most values of that type can be compared, is the not-a-number (`NaN`) floating
point value. Calling `partial_cmp` with any floating point number and the `NaN`
floating point value will return `None`.
-->
<p>L'application de <code>derive</code> avec <code>PartialOrd</code> implémente la méthode <code>partial_cmp</code>,
qui retourne un <code>Option&lt;Ordering&gt;</code> qui vaudra <code>None</code> lorsque les valeurs
fournies ne fournissent pas un ordre. Un exemple de valeur qui ne produit pas
d'ordre, même si la plupart des valeurs de ce type peuvent être comparées, est
la valeur “not-a-number” (<code>NaN</code>) des virgules flottantes. L'appel à
<code>partial_cmp</code> entre n'importe quel nombre à virgule flottante et la valeur <code>NaN</code>
de virgule flottante va retourner <code>None</code>.</p>
<!--
When derived on structs, `PartialOrd` compares two instances by comparing the
value in each field in the order in which the fields appear in the struct
definition. When derived on enums, variants of the enum declared earlier in the
enum definition are considered less than the variants listed later.
-->
<p>Lorsqu'il est dérivé sur une structure, <code>PartialOrd</code> compare deux instances en
comparant les valeurs de chaque champ dans l'ordre dans lequel les champs
apparaissent dans la définition de la structure. Lorsqu'il est dérivé sur des
énumérations, les variantes de l'énumération déclarées plus tôt dans la
définition de l'énumération sont considérées inférieures aux variantes déclarées
ensuite.</p>
<!--
The `PartialOrd` trait is required, for example, for the `gen_range` method
from the `rand` crate that generates a random value in the range specified by a
low value and a high value.
-->
<p>Le trait <code>PartialOrd</code> est nécessaire, par exemple, pour la méthode <code>gen_range</code>
de la crate <code>rand</code> qui génère une valeur aléatoire dans l'intervalle contrainte
par une valeur minimale et une valeur maximale.</p>
<!--
The `Ord` trait allows you to know that for any two values of the annotated
type, a valid ordering will exist. The `Ord` trait implements the `cmp` method,
which returns an `Ordering` rather than an `Option<Ordering>` because a valid
ordering will always be possible. You can only apply the `Ord` trait to types
that also implement `PartialOrd` and `Eq` (and `Eq` requires `PartialEq`). When
derived on structs and enums, `cmp` behaves the same way as the derived
implementation for `partial_cmp` does with `PartialOrd`.
-->
<p>Le trait <code>Ord</code> vous permet de savoir si un ordre valide existe toujours entre
deux valeurs du type annoté. Le trait <code>Ord</code> implémente la méthode <code>cmp</code>, qui
retourne un <code>Ordering</code> plutôt qu'une <code>Option&lt;Ordering&gt;</code> car un ordre valide sera
toujours possible. Vous pouvez appliquer le trait <code>Ord</code> uniquement sur les types
qui implémentent aussi <code>PartialOrd</code> et <code>Eq</code> (et <code>Eq</code> nécessite <code>PartialEq</code>).
Lorsqu'il est dérivé sur des structures et des énumérations, <code>cmp</code> se comporte
de la même manière que l'implémentation de <code>partial_cmp</code> dérivée de
<code>PartialOrd</code>.</p>
<!--
An example of when `Ord` is required is when storing values in a `BTreeSet<T>`,
a data structure that stores data based on the sort order of the values.
-->
<p>Par exemple, <code>Ord</code> doit être implémenté sur le type de valeurs que nous stockons
dans un <code>BTreeSet&lt;T&gt;</code>, qui est une structure de donnée qui stocke des données en
fonction de l'ordre de tri de ces valeurs.</p>
<!--
### `Clone` and `Copy` for Duplicating Values
-->
<h3 id="clone-et-copy-pour-dupliquer-des-valeurs"><a class="header" href="#clone-et-copy-pour-dupliquer-des-valeurs"><code>Clone</code> et <code>Copy</code> pour dupliquer des valeurs</a></h3>
<!--
The `Clone` trait allows you to explicitly create a deep copy of a value, and
the duplication process might involve running arbitrary code and copying heap
data. See the [“Ways Variables and Data Interact:
Clone”][ways-variables-and-data-interact-clone]<!-- ignore -- > section in
Chapter 4 for more information on `Clone`.
-->
<p>Le trait <code>Clone</code> vous permet de créer explicitement une copie profonde d'une
valeur, et le processus de duplication peut impliquer l'exécution d'un code
arbitraire pour copier les données stockées dans le tas. Rendez-vous à la
section <a href="ch04-01-what-is-ownership.html#les-interactions-entre-les-variables-et-les-donn%C3%A9es--le-d%C3%A9placement">“Les interactions entre les variables et les données : le
déplacement”</a><!-- ignore --> du
chapitre 4 pour plus d'informations sur <code>Clone</code>.</p>
<!--
Deriving `Clone` implements the `clone` method, which when implemented for the
whole type, calls `clone` on each of the parts of the type. This means all the
fields or values in the type must also implement `Clone` to derive `Clone`.
-->
<p>Utiliser <code>derive</code> avec <code>Clone</code> implémente la méthode <code>clone</code>, qui, lorsqu'elle
est implémentée sur tout le type, fait appel à <code>clone</code> sur chaque constituant du
type. Cela signifie que tous les champs ou les valeurs dans le type doivent
aussi implémenter <code>Clone</code> pour dériver de <code>Clone</code>.</p>
<!--
An example of when `Clone` is required is when calling the `to_vec` method on a
slice. The slice doesn’t own the type instances it contains, but the vector
returned from `to_vec` will need to own its instances, so `to_vec` calls
`clone` on each item. Thus, the type stored in the slice must implement `Clone`.
-->
<p><code>Clone</code> est par exemple nécessaire lorsque nous appelons la méthode <code>to_vec</code> sur
une slice. La slice ne prend pas possession des instances du type qu'il
contient, mais le vecteur retourné par <code>to_vec</code> va avoir besoin de prendre
possession de ses instances, donc <code>to_vec</code> fait appel à <code>clone</code> sur chaque
élément. C'est pourquoi le type stocké dans la slice doit implémenter <code>Clone</code>.</p>
<!--
The `Copy` trait allows you to duplicate a value by only copying bits stored on
the stack; no arbitrary code is necessary. See the [“Stack-Only Data:
Copy”][stack-only-data-copy]<!-- ignore -- > section in Chapter 4 for more
information on `Copy`.
-->
<p>Le trait <code>Copy</code> vous permet de dupliquer une valeur en copiant uniquement les
éléments stockés sur la pile ; il n'est pas nécessaire d'avoir de code
arbitraire. Rendez-vous à la section <a href="ch04-01-what-is-ownership.html#donn%C3%A9es-uniquement-sur-la-pile--la-copie">“Données uniquement sur la pile : la
copie”</a><!-- ignore --> du chapitre 4 pour plus
d'informations sur <code>Copy</code>.</p>
<!--
The `Copy` trait doesn’t define any methods to prevent programmers from
overloading those methods and violating the assumption that no arbitrary code
is being run. That way, all programmers can assume that copying a value will be
very fast.
-->
<p>Le trait <code>Copy</code> ne définit pas de méthode, volontairement pour empêcher les
développeurs de surcharger ces méthodes et ainsi violer l'affirmation qu'aucun
code arbitraire est exécuté à la copie. Ainsi, tous les développeurs peuvent
compter sur le fait qu'une copie de valeur est très rapide.</p>
<!--
You can derive `Copy` on any type whose parts all implement `Copy`. You can
only apply the `Copy` trait to types that also implement `Clone`, because a
type that implements `Copy` has a trivial implementation of `Clone` that
performs the same task as `Copy`.
-->
<p>Vous pouvez utiliser <code>derive</code> avec <code>Copy</code> sur n'importe quel type constitué
d'éléments qui implémentent aussi <code>Copy</code>. Vous ne pouvez appliquer le trait
<code>Copy</code> que sur des types qui implémentent aussi <code>Clone</code>, car un type qui
implémente <code>Copy</code> a aussi une implémentation triviale de <code>Clone</code> qui procède
aux mêmes actions que <code>Copy</code>.</p>
<!--
The `Copy` trait is rarely required; types that implement `Copy` have
optimizations available, meaning you don’t have to call `clone`, which makes
the code more concise.
-->
<p>Le trait <code>Copy</code> est rarement nécessaire ; les types qui implémentent <code>Copy</code>
peuvent être optimisés, ce qui veut dire que vous n'avez pas à appeler <code>clone</code>,
ce qui rend le code plus concis.</p>
<!--
Everything possible with `Copy` you can also accomplish with `Clone`, but the
code might be slower or have to use `clone` in places.
-->
<p>Tout ce que vous pouvez accomplir avec <code>Copy</code>, vous pouvez le faire avec
<code>Clone</code>, mais le code risque d'être plus lent ou doit parfois utiliser <code>clone</code>.</p>
<!--
### `Hash` for Mapping a Value to a Value of Fixed Size
-->
<h3 id="hash-pour-faire-correspondre-une-valeur-avec-une-valeur-de-taille-fixe"><a class="header" href="#hash-pour-faire-correspondre-une-valeur-avec-une-valeur-de-taille-fixe"><code>Hash</code> pour faire correspondre une valeur avec une valeur de taille fixe</a></h3>
<!--
The `Hash` trait allows you to take an instance of a type of arbitrary size and
map that instance to a value of fixed size using a hash function. Deriving
`Hash` implements the `hash` method. The derived implementation of the `hash`
method combines the result of calling `hash` on each of the parts of the type,
meaning all fields or values must also implement `Hash` to derive `Hash`.
-->
<p>Le trait <code>Hash</code> vous permet d'obtenir une valeur à taille fixe en utilisant une
fonction de hachage sur une instance d'un type d'une taille quelconque. Utiliser
<code>derive</code> avec <code>Hash</code> implémente la méthode <code>hash</code>. L'implémentation dérive de la
méthode <code>hash</code> combine le résultat de l'appel de <code>hash</code> sur chaque élément du
type, ce qui signifie que tous ses champs ou valeurs doivent aussi implémenter
<code>Hash</code> pour pouvoir lui appliquer le trait <code>Hash</code>.</p>
<!--
An example of when `Hash` is required is in storing keys in a `HashMap<K, V>`
to store data efficiently.
-->
<p>Pour stocker des clés efficacement dans un <code>HashMap&lt;K, V&gt;</code>, les clés doivent
nécessairement implémenter <code>Hash</code>.</p>
<!--
### `Default` for Default Values
-->
<h3 id="default-pour-des-valeurs-par-défaut"><a class="header" href="#default-pour-des-valeurs-par-défaut"><code>Default</code> pour des valeurs par défaut</a></h3>
<!--
The `Default` trait allows you to create a default value for a type. Deriving
`Default` implements the `default` function. The derived implementation of the
`default` function calls the `default` function on each part of the type,
meaning all fields or values in the type must also implement `Default` to
derive `Default`.
-->
<p>Le trait <code>Default</code> vous permet de créer une valeur par défaut pour un type.
Implémenter <code>Default</code> avec <code>derive</code> ajoute la fonction <code>default</code>. Cette fonction
<code>default</code> fait elle-même appel à la fonction <code>default</code> sur chaque élément du
type, ce qui signifie que tous les champs ou les valeurs dans le type doit aussi
implémenter <code>Default</code> pour que ce type puisse dériver de <code>Default</code>.</p>
<!-- markdownlint-disable -->
<!--
The `Default::default` function is commonly used in combination with the struct
update syntax discussed in the [“Creating Instances From Other Instances With
Struct Update
Syntax”][creating-instances-from-other-instances-with-struct-update-syntax]<!-- ignore -- >
section in Chapter 5. You can customize a few fields of a struct and then
set and use a default value for the rest of the fields by using
`..Default::default()`.
-->
<p>La fonction <code>Default::default</code> est couramment utilisé en association avec la
syntaxe de modification de structures que nous avons vu dans la section <a href="ch05-01-defining-structs.html#cr%C3%A9er-des-instances-%C3%A0-partir-dautres-instances-avec-la-syntaxe-de-mise-%C3%A0-jour-de-structure">“Créer
des instances à partir d'autres instances avec la syntaxe de mise à jour de
structure”</a><!-- ignore -->
du chapitre 5. Vous pouvez personnaliser quelques champs d'une structure et
ensuite définir et utiliser une valeur par défaut pour le reste des champs en
utilisant <code>..Default::default()</code>.</p>
<!--
The `Default` trait is required when you use the method `unwrap_or_default` on
`Option<T>` instances, for example. If the `Option<T>` is `None`, the method
`unwrap_or_default` will return the result of `Default::default` for the type
`T` stored in the `Option<T>`.
-->
<p>Le trait <code>Default</code> est nécessaire lorsque vous utilisez la méthode
<code>unwrap_or_default</code> sur les instances de <code>Option&lt;T&gt;</code>, par exemple. Si le
<code>Option&lt;T&gt;</code> vaut <code>None</code>, la méthode <code>unwrap_or_default</code> va retourner le résultat
de <code>Default::default</code> sur le type <code>T</code> provenant du <code>Option&lt;T&gt;</code>.</p>
<!--
[creating-instances-from-other-instances-with-struct-update-syntax]:
ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax
[stack-only-data-copy]:
ch04-01-what-is-ownership.html#stack-only-data-copy
[ways-variables-and-data-interact-clone]:
ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone
[macros]: ch19-06-macros.html#macros
-->
<!-- markdownlint-enable -->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--39"><a class="header" href="#-attention-peinture-fraîche--39">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/225">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix D - Useful Development Tools
-->
<h2 id="annexe-d---des-outils-de-développement-utiles"><a class="header" href="#annexe-d---des-outils-de-développement-utiles">Annexe D - Des outils de développement utiles</a></h2>
<!--
In this appendix, we talk about some useful development tools that the Rust
project provides. We’ll look at automatic formatting, quick ways to apply
warning fixes, a linter, and integrating with IDEs.
-->
<p>Dans cette annexe, nous allons découvrir quelques outils de développement utiles
que propose le projet Rust. Nous allons voir le formatage automatique, des
moyens rapides pour corriger des avertissements, un analyseur statique, et
l'intégration avec un IDE.</p>
<!--
### Automatic Formatting with `rustfmt`
-->
<h3 id="le-formatage-automatique-avec-rustfmt"><a class="header" href="#le-formatage-automatique-avec-rustfmt">Le formatage automatique avec <code>rustfmt</code></a></h3>
<!--
The `rustfmt` tool reformats your code according to the community code style.
Many collaborative projects use `rustfmt` to prevent arguments about which
style to use when writing Rust: everyone formats their code using the tool.
-->
<p>L'outil <code>rustfmt</code> reformate votre code suivant le style de code de la
communauté. De nombreux projets collaboratifs utilisent <code>rustfmt</code> pour éviter
des désaccords sur le style à utiliser lorsqu'ils écrivent du code Rust : tout le
monde formate leur code en utilisant l'outil.</p>
<!--
To install `rustfmt`, enter the following:
-->
<p>Pour installer <code>rustfmt</code>, saisissez ceci :</p>
<!--
```console
$ rustup component add rustfmt
```
-->
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<!--
This command gives you `rustfmt` and `cargo-fmt`, similar to how Rust gives you
both `rustc` and `cargo`. To format any Cargo project, enter the following:
-->
<p>Cette commande vous offre <code>rustfmt</code> et <code>cargo-fmt</code>, de la même manière que Rust
vous installe <code>rustc</code> et <code>cargo</code>. Pour formater un projet Cargo, saisissez
ceci :</p>
<!--
```console
$ cargo fmt
```
-->
<pre><code class="language-console">$ cargo fmt
</code></pre>
<!--
Running this command reformats all the Rust code in the current crate. This
should only change the code style, not the code semantics. For more information
on `rustfmt`, see [its documentation][rustfmt].
-->
<p>L'exécution de cette commande reformate tout le code Rust dans la crate
courante. Cela va uniquement changer le style de code, pas sa sémantique. Pour
plus d'informations sur <code>rustfmt</code>, voyez <a href="https://github.com/rust-lang/rustfmt">sa documentation</a>.</p>
<!--
[rustfmt]: https://github.com/rust-lang/rustfmt
-->
<!--
### Fix Your Code with `rustfix`
-->
<h3 id="corriger-votre-code-avec-rustfix"><a class="header" href="#corriger-votre-code-avec-rustfix">Corriger votre code avec <code>rustfix</code></a></h3>
<!--
The rustfix tool is included with Rust installations and can automatically fix
some compiler warnings. If you’ve written code in Rust, you’ve probably seen
compiler warnings. For example, consider this code:
-->
<p>L'outil rustfix est inclus lors de l'installation de Rust et peut
automatiquement corriger certains avertissements de compilateur. Si vous avez
déjà écrit du code en Rust, vous avez probablement vu des avertissements du
compilateur. Par exemple, avec le code suivant :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn fait_quelquechose() {}

fn main() {
    for i in 0..100 {
        fait_quelquechose();
    }
}
</code></pre></pre>
<!--
Here, we’re calling the `do_something` function 100 times, but we never use the
variable `i` in the body of the `for` loop. Rust warns us about that:
-->
<p>Ici, nous appelons la fonction <code>fait_quelquechose</code> 100 fois, mais nous
n'utilisons jamais la variable <code>i</code> dans le corps de la boucle <code>for</code>. Rust nous
avertit de cela :</p>
<!--
```console
$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 -- > src/main.rs:4:9
  |
4 |     for i in 1..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
```
-->
<pre><code class="language-console">$ cargo build
   Compiling mon_programme v0.1.0 (file:///projects/mon_programme)
warning: unused variable: `i`
 -- &gt; src/main.rs:4:9
  |
4 |     for i in 1..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<!--
The warning suggests that we use `_i` as a name instead: the underscore
indicates that we intend for this variable to be unused. We can automatically
apply that suggestion using the `rustfix` tool by running the command `cargo
fix`:
-->
<p>L'avertissement indique que nous devrions utiliser <code>_i</code> comme nom à sa place :
le tiret bas indique que nous avons l'intention de ne pas utiliser cette
variable. Nous pouvons appliquer automatiquement cette suggestion en utilisant
l'outil <code>rustfix</code> en lançant la commande <code>cargo fix</code> :</p>
<!--
```console
$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
```
-->
<pre><code class="language-console">$ cargo fix
    Checking mon_programme v0.1.0 (file:///projects/mon_programme)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<!--
When we look at *src/main.rs* again, we’ll see that `cargo fix` has changed the
code:
-->
<p>Lorsque nous regardons à nouveau <em>src/main.rs</em>, nous pouvons constater que
<code>cargo fix</code> a changé le code :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn fait_quelquechose() {}

fn main() {
    for _i in 0..100 {
        fait_quelquechose();
    }
}
</code></pre></pre>
<!--
The `for` loop variable is now named `_i`, and the warning no longer appears.
-->
<p>La variable de la boucle <code>for</code> s'appelle maintenant <code>_i</code>, et l'avertissement ne
s'affiche plus.</p>
<!--
You can also use the `cargo fix` command to transition your code between
different Rust editions. Editions are covered in Appendix E.
-->
<p>Vous pouvez aussi utiliser la commande <code>cargo fix</code> pour corriger votre code
entre différentes éditions de Rust. Les éditions sont abordées à l'annexe E.</p>
<!--
### More Lints with Clippy
-->
<h3 id="une-analyse-statique-plus-complète-avec-clippy"><a class="header" href="#une-analyse-statique-plus-complète-avec-clippy">Une analyse statique plus complète avec Clippy</a></h3>
<!--
The Clippy tool is a collection of lints to analyze your code so you can catch
common mistakes and improve your Rust code.
-->
<p>L'outil Clippy est une collection d'analyses statiques pour analyser votre code
afin que vous puissiez débusquer certaines erreurs courantes et ainsi améliorer
votre code.</p>
<!--
To install Clippy, enter the following:
-->
<p>Pour installer Clippy, saisissez ceci :</p>
<!--
```console
$ rustup component add clippy
```
-->
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<!--
To run Clippy’s lints on any Cargo project, enter the following:
-->
<p>Pour lancer l'analyse statique de Clippy sur un projet Cargo, saisissez ceci :</p>
<!--
```console
$ cargo clippy
```
-->
<pre><code class="language-console">$ cargo clippy
</code></pre>
<!--
For example, say you write a program that uses an approximation of a
mathematical constant, such as pi, as this program does:
-->
<p>Par exemple, imaginons que vous écrivez un programme qui utilise une
approximation d'une constante mathématique, comme pi, comme le fait ce
programme :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!("the area of the circle is {}", x * r * r);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!(&quot;l'aire du cercle vaut {}&quot;, x * r * r);
}
</code></pre></pre>
<!--
Running `cargo clippy` on this project results in this error:
-->
<p>L'exécution de <code>cargo clippy</code> sur ce projet va afficher cette erreur :</p>
<!--
```text
error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly
 -- > src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: #[deny(clippy::approx_constant)] on by default
  = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/master/index.html#approx_constant
```
-->
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly
 -- &gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: #[deny(clippy::approx_constant)] on by default
  = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<!--
This error lets you know that Rust has this constant defined more precisely and
that your program would be more correct if you used the constant instead. You
would then change your code to use the `PI` constant. The following code
doesn’t result in any errors or warnings from Clippy:
-->
<p>Cette erreur vous fais savoir que Rust a cette constante qui est définie plus
précisément et que votre programme serait plus pertinent si vous utilisiez à la
place la constante. Vous changeriez alors votre code pour utiliser la constante
<code>PI</code>. Le code suivant ne donne pas d'erreur ou d'avertissement avec Clippy :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!("the area of the circle is {}", x * r * r);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!(&quot;l'aire du cercle vaut {}&quot;, x * r * r);
}
</code></pre></pre>
<!--
For more information on Clippy, see [its documentation][clippy].
-->
<p>Pour en savoir plus Clippy, voyez <a href="https://github.com/rust-lang/rust-clippy">sa documentation</a>.</p>
<!--
[clippy]: https://github.com/rust-lang/rust-clippy
-->
<!--
### IDE Integration Using the Rust Language Server
-->
<h3 id="lintégration-aux-ide-en-utilisant-le-rust-language-server"><a class="header" href="#lintégration-aux-ide-en-utilisant-le-rust-language-server">L'intégration aux IDE en utilisant le Rust Language Server</a></h3>
<!--
To help IDE integration, the Rust project distributes the *Rust Language
Server* (`rls`). This tool speaks the [Language Server
Protocol][lsp], which is a specification for IDEs and programming
languages to communicate with each other. Different clients can use the `rls`,
such as [the Rust plug-in for Visual Studio Code][vscode].
-->
<p>Pour aider l'intégration aux IDE, le projet Rust distribue le
<em>Rust Language Server</em> (<code>rls</code>). Cet outil suit le
<a href="http://langserver.org/">Language Server Protocol</a>, qui est une spécification entre les IDE et les
langages pour communiquer entre eux. Différents clients peuvent utiliser le
<code>rls</code>, comme <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">le plug-in Rust pour Visual Studio Code</a>.</p>
<!--
[lsp]: http://langserver.org/
[vscode]: https://marketplace.visualstudio.com/items?itemName=rust-lang.rust
-->
<!--
To install the `rls`, enter the following:
-->
<p>Pour installer le <code>rls</code>, saisissez ceci :</p>
<!--
```console
$ rustup component add rls
```
-->
<pre><code class="language-console">$ rustup component add rls
</code></pre>
<!--
Then install the language server support in your particular IDE; you’ll gain
abilities such as autocompletion, jump to definition, and inline errors.
-->
<p>Installez ensuite le système du <em>language server</em> dans votre IDE ; vous devriez
obtenir des capacités supplémentaires comme l'auto-complétion, pouvoir se rendre
à la définition de l'élément, et la mise en valeur d'erreurs sur la ligne
concernée.</p>
<!--
For more information on the `rls`, see [its documentation][rls].
-->
<p>Pour plus d'information sur <code>rls</code>, rendez-vous <a href="https://github.com/rust-lang/rls">à sa documentation</a>.</p>
<!--
[rls]: https://github.com/rust-lang/rls
-->
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--40"><a class="header" href="#-attention-peinture-fraîche--40">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/226">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix E - Editions
-->
<h2 id="annexe-e---les-éditions"><a class="header" href="#annexe-e---les-éditions">Annexe E - Les éditions</a></h2>
<!--
In Chapter 1, you saw that `cargo new` adds a bit of metadata to your
*Cargo.toml* file about an edition. This appendix talks about what that means!
-->
<p>Au chapitre 1, vous avez constaté que <code>cargo new</code> ajoutait une petite métadonnée
à propos d'une édition dans votre fichier <em>Cargo.toml</em>. Cette annexe vous
explique ce que cela signifie !</p>
<!--
The Rust language and compiler have a six-week release cycle, meaning users get
a constant stream of new features. Other programming languages release larger
changes less often; Rust releases smaller updates more frequently. After a
while, all of these tiny changes add up. But from release to release, it can be
difficult to look back and say, “Wow, between Rust 1.10 and Rust 1.31, Rust has
changed a lot!”
-->
<p>Le langage Rust et son compilateur suivent un cycle de publication de six
semaines, ce qui signifie que leurs utilisateurs suivent un flux constant de
nouvelles fonctionnalités. Les autres langages de programmation publient moins
souvent des changements mais qui sont plus gros ; Rust a fait le choix de
publier des petits changements plus fréquemment. Au bout d'un certain moment,
tous ces petits changements s'accumulent. Mais de mise à jour en mise à jour, il
devient difficile de regarder en arrière et de dire : “Ouah, Rust a beaucoup
changé entre Rust 1.10 et Rust 1.31”.</p>
<!--
Every two or three years, the Rust team produces a new Rust *edition*. Each
edition brings together the features that have landed into a clear package with
fully updated documentation and tooling. New editions ship as part of the usual
six-week release process.
-->
<p>Tous les deux ou trois ans, l'équipe Rust produit une nouvelle <em>édition</em> de
Rust. Chaque édition rassemble des fonctionnalités qui ont convergé en un
ensemble clair, avec une documentation et des outils complètement à jour. Les
nouvelles éditions sont livrées comme faisant partie du cycle habituel de
publication toutes les six semaines.</p>
<!--
Editions serve different purposes for different people:
-->
<p>Les éditions apportent différentes choses pour différentes personnes :</p>
<!--
* For active Rust users, a new edition brings together incremental changes into
  an easy-to-understand package.
* For non-users, a new edition signals that some major advancements have
  landed, which might make Rust worth another look.
* For those developing Rust, a new edition provides a rallying point for the
  project as a whole.
-->
<ul>
<li>Pour les utilisateurs actifs de Rust, une nouvelle édition regroupe les
différents changements progressifs dans un ensemble clair.</li>
<li>Pour ceux qui n'utilisent pas Rust, une nouvelle édition signale la livraison
d'avancées majeures, qui pourrait être le signal que Rust mériterait un
nouveau coup d'œil.</li>
<li>Pour ceux qui développent Rust, une nouvelle édition est un point de
ralliement pour l'ensemble du projet.</li>
</ul>
<!--
At the time of this writing, two Rust editions are available: Rust 2015 and
Rust 2018. This book is written using Rust 2018 edition idioms.
-->
<p>Au moment de cette écriture, deux éditions de Rust sont disponibles : Rust 2015
et Rust 2018. Ce livre est écrit selon les termes de l'édition Rust 2018.</p>
<!--
The `edition` key in *Cargo.toml* indicates which edition the compiler should
use for your code. If the key doesn’t exist, Rust uses `2015` as the edition
value for backward compatibility reasons.
-->
<p>La clé <code>edition</code> dans <em>Cargo.toml</em> indique quelle édition le compilateur doit
utiliser dans votre code. Si la clé n'existe pas, Rust utilise <code>2015</code> comme
valeur de l'édition, pour des raisons de rétro-compatibilité.</p>
<!--
Each project can opt in to an edition other than the default 2015 edition.
Editions can contain incompatible changes, such as including a new keyword that
conflicts with identifiers in code. However, unless you opt in to those
changes, your code will continue to compile even as you upgrade the Rust
compiler version you use.
-->
<p>Chaque projet peut opter pour une autre édition que l'édition 2015 par défaut.
Les éditions peuvent impliquer des changements incompatibles, comme
l'introduction d'un nouveau mot-clé qui rentre en conflit avec des
identificateurs (noms de variables, de fonctions, ...) utilisés dans le code.
Cependant, à moins que vous ne décidiez d'opter pour ces changements, votre code
va continuer à se compiler même si vous augmentez la version du compilateur Rust
que vous utilisez.</p>
<!--
All Rust compiler versions support any edition that existed prior to that
compiler’s release, and they can link crates of any supported editions
together. Edition changes only affect the way the compiler initially parses
code. Therefore, if you’re using Rust 2015 and one of your dependencies uses
Rust 2018, your project will compile and be able to use that dependency. The
opposite situation, where your project uses Rust 2018 and a dependency uses
Rust 2015, works as well.
-->
<p>Toutes les versions du compilateur Rust supporte toutes les éditions qui ont
existé avant la publication courante du compilateur, et ils peuvent lier
ensemble les crates de n'importe quelle édition supportée. Les changements de
chaque édition changent uniquement la façon dont le compilateur interprète
initialement le code. Par conséquent, si vous utilisez Rust 2015 et qu'une de
vos dépendances utilise Rust 2018, votre programme va se compiler et être
capable d'utiliser cette dépendance. La situation inverse, dans laquelle votre
projet utilise Rust 2018 et qu'une dépendance utilise Rust 2015, va aussi
fonctionner.</p>
<!--
To be clear: most features will be available on all editions. Developers using
any Rust edition will continue to see improvements as new stable releases are
made. However, in some cases, mainly when new keywords are added, some new
features might only be available in later editions. You will need to switch
editions if you want to take advantage of such features.
-->
<p>En clair : la plupart des fonctionnalités seront disponibles sur toutes les
versions. Les développeurs qui utilisent n'importe quelle édition de Rust vont
continuer à constater des améliorations au fur et à mesure que des nouvelles
éditions stables sont publiées. Cependant, dans certains cas, principalement
lorsque des nouveaux mot-clés serons rajoutés, certaines nouvelles
fonctionnalités ne seront disponibles que dans les nouvelles éditions. Vous
aurez alors besoin de changer d'édition si vous souhaitez profiter des avantages
de ces fonctionnalités.</p>
<!--
For more details, the [*Edition
Guide*](https://doc.rust-lang.org/stable/edition-guide/) is a complete book
about editions that enumerates the differences between editions and explains
how to automatically upgrade your code to a new edition via `cargo fix`.
-->
<p>Pour en savoir plus, le
<a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Edition Guide</em></a> est un livre
complet sur les éditions, qui énumère les différences entre les éditions et qui
explique comment mettre à jour automatiquement votre code vers une nouvelle
édition via <code>cargo fix</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--41"><a class="header" href="#-attention-peinture-fraîche--41">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/227">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix F: Translations of the Book
-->
<h2 id="annexe-f--les-traductions-de-ce-livre"><a class="header" href="#annexe-f--les-traductions-de-ce-livre">Annexe F : les traductions de ce livre</a></h2>
<!--
For resources in languages other than English. Most are still in progress; see
[the Translations label][label] to help or let us know about a new translation!
-->
<p>Voici des ressources dans d'autres langages qu'en Français. Certaines sont
toujours en cours de construction ; consultez <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">le drapeau Translation</a>
pour les aider, ou nous informer de la création d'une nouvelle traduction !</p>
<!--
[label]: https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations
-->
<!--
- [Português](https://github.com/rust-br/rust-book-pt-br) (BR)
- [Português](https://github.com/nunojesus/rust-book-pt-pt) (PT)
- [简体中文](https://github.com/KaiserY/trpl-zh-cn)
- [Українська](https://github.com/pavloslav/rust-book-uk-ua)
- [Español](https://github.com/thecodix/book), [alternate](https://github.com/ManRR/rust-book-es)
- [Italiano](https://github.com/AgeOfWar/rust-book-it)
- [Русский](https://github.com/rust-lang-ru/book)
- [한국어](https://github.com/rinthel/rust-lang-book-ko)
- [日本語](https://github.com/rust-lang-ja/book-ja)
- [Français](https://github.com/Jimskapt/rust-book-fr)
- [Polski](https://github.com/paytchoo/book-pl)
- [עברית](https://github.com/idanmel/rust-book-heb)
- [Cebuano](https://github.com/agentzero1/book)
- [Tagalog](https://github.com/josephace135/book)
- [Esperanto](https://github.com/psychoslave/Rust-libro)
- [ελληνική](https://github.com/TChatzigiannakis/rust-book-greek)
- [Svenska](https://github.com/sebras/book)
- [Farsi](https://github.com/pomokhtari/rust-book-fa)
- [Deutsch](https://github.com/rust-lang-de/rustbook-de)
- [Turkish](https://github.com/RustDili/dokuman/tree/master/ceviriler), [online](https://rustdili.github.io/)
-->
<ul>
<li><a href="https://github.com/rust-lang/book">English</a></li>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português</a> (PT)</li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">简体中文</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a>, <a href="https://github.com/ManRR/rust-book-es">alternative</a></li>
<li><a href="https://github.com/AgeOfWar/rust-book-it">Italiano</a></li>
<li><a href="https://github.com/rust-lang-ru/book">Русский</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">한국어</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">日本語</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/idanmel/rust-book-heb">עברית</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ελληνική</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/pomokhtari/rust-book-fa">Farsi</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
<li><a href="https://github.com/RustDili/dokuman/tree/master/ceviriler">Turkish</a>, <a href="https://rustdili.github.io/">online</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h1 id="-attention-peinture-fraîche--42"><a class="header" href="#-attention-peinture-fraîche--42">🚧 Attention, peinture fraîche !</a></h1>
<p>Cette page a été traduite par une seule personne et n'a pas été relue et
vérifiée par quelqu'un d'autre ! Les informations peuvent par exemple être
erronées, être formulées maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer à l'amélioration de cette page sur sa
<a href="https://github.com/Jimskapt/rust-book-fr/pull/228">Pull Request</a>.</p>
</blockquote>
<!--
## Appendix G - How Rust is Made and “Nightly Rust”
-->
<h2 id="annexe-g---comment-rust-est-construit-et-nightly-rust"><a class="header" href="#annexe-g---comment-rust-est-construit-et-nightly-rust">Annexe G - Comment Rust est construit, et “Nightly Rust”</a></h2>
<!--
This appendix is about how Rust is made and how that affects you as a Rust
developer.
-->
<p>Cette annexe va expliquer comment Rust est construit et comment cela vous
impacte en tant que développeur Rust.</p>
<!--
### Stability Without Stagnation
-->
<h3 id="la-stabilité-sans-stagnation"><a class="header" href="#la-stabilité-sans-stagnation">La stabilité sans stagnation</a></h3>
<!--
As a language, Rust cares a *lot* about the stability of your code. We want
Rust to be a rock-solid foundation you can build on, and if things were
constantly changing, that would be impossible. At the same time, if we can’t
experiment with new features, we may not find out important flaws until after
their release, when we can no longer change things.
-->
<p>En tant que langage, Rust se soucie <em>beaucoup</em> de la stabilité de votre code.
Nous voulons que Rust soit une solide fondation sur laquelle vous pouvez
construire, et si les choses changent constamment, cela serait impossible. En
même temps, si nous ne pouvions pas expérimenter de nouvelles fonctionnalités,
nous ne pourrions pas découvrir les défauts importants avant leur publication,
ce qui serait trop tard pour changer les choses.</p>
<!--
Our solution to this problem is what we call “stability without stagnation”,
and our guiding principle is this: you should never have to fear upgrading to a
new version of stable Rust. Each upgrade should be painless, but should also
bring you new features, fewer bugs, and faster compile times.
-->
<p>Notre solution à ce problème est ce que nous appelons la “stabilité sans
stagnation”, et notre ligne directrice est la suivante : vous ne devriez jamais
craindre de passer à nouvelle version de Rust stable. Chaque mise à jour devrait
être facile, et devrait aussi vous apporter de nouvelles fonctionnalités, moins
de bogues et un temps de compilation plus rapide.</p>
<!--
### Choo, Choo! Release Channels and Riding the Trains
-->
<h3 id="les-canaux-de-diffusion-et-sauter-dans-le-train"><a class="header" href="#les-canaux-de-diffusion-et-sauter-dans-le-train">Les canaux de diffusion et sauter dans le train</a></h3>
<!--
Rust development operates on a *train schedule*. That is, all development is
done on the `master` branch of the Rust repository. Releases follow a software
release train model, which has been used by Cisco IOS and other software
projects. There are three *release channels* for Rust:
-->
<p>Le développement de Rust suit un <em>planning ferroviaire</em>. Ce que cela veut dire,
c'est que tout le développement est fait sur la branche <code>master</code> du dépôt de
Rust. Les publications suivent le modèle de trains de publication de programmes,
qui a été popularisé par Cisco IOS et d'autres projets logiciels. Il y a trois
<em>canaux de diffusion</em> pour Rust :</p>
<!--
* Nightly
* Beta
* Stable
-->
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable</li>
</ul>
<!--
Most Rust developers primarily use the stable channel, but those who want to
try out experimental new features may use nightly or beta.
-->
<p>La plupart des développeurs Rust utilisent principalement le canal stable, mais
ceux qui souhaitent essayer les nouvelles fonctionnalités expérimentales
utilisent nightly ou beta.</p>
<!--
Here’s an example of how the development and release process works: let’s
assume that the Rust team is working on the release of Rust 1.5. That release
happened in December of 2015, but it will provide us with realistic version
numbers. A new feature is added to Rust: a new commit lands on the `master`
branch. Each night, a new nightly version of Rust is produced. Every day is a
release day, and these releases are created by our release infrastructure
automatically. So as time passes, our releases look like this, once a night:
-->
<p>Voici un exemple du fonctionnement du processus de développement et de
publication : supposons que l'équipe de Rust travaille sur la publication de
Rust 1.5. Cette publication a été faite en décembre 2015, et nous permet de nous
appuyer sur des numéros de version réalistes. Une nouvelle fonctionnalité a été
ajoutée à Rust : un nouveau commit est arrivé sur la branche <code>master</code>. Chaque
nuit, une nouvelle version nightly de Rust est produite. Chaque jour voit une
nouvelle publication, et ces publications sont créées automatiquement par
l'infrastructure de publication. Ainsi, les publications ressemblent à ceci, une
fois par nuit :</p>
<!--
```text
nightly: * - - * - - *
```
-->
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<!--
Every six weeks, it’s time to prepare a new release! The `beta` branch of the
Rust repository branches off from the `master` branch used by nightly. Now,
there are two releases:
-->
<p>Tous les six semaines, c'est le moment de préparer une nouvelle publication ! La
branche <code>beta</code> du dépôt Rust est alors dérivée de la branche <code>master</code> utilisée
par nightly. Ainsi, il y a deux canaux de publications :</p>
<!--
```text
nightly: * - - * - - *
                     |
beta:                *
```
-->
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<!--
Most Rust users do not use beta releases actively, but test against beta in
their CI system to help Rust discover possible regressions. In the meantime,
there’s still a nightly release every night:
-->
<p>La plupart des utilisateurs Rust n'utilisent pas activement les publications en
beta, mais les tests en beta sur leur système d'Intégration Continue aident à
découvrir des potentielles régressions. Pendant ce temps, il continue à avoir
une publication nightly chaque nuit :</p>
<!--
```text
nightly: * - - * - - * - - * - - *
                     |
beta:                *
```
-->
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<!--
Let’s say a regression is found. Good thing we had some time to test the beta
release before the regression snuck into a stable release! The fix is applied
to `master`, so that nightly is fixed, and then the fix is backported to the
`beta` branch, and a new release of beta is produced:
-->
<p>Imaginons qu'une régression soit trouvée. C'est alors une bonne chose que nous
ayons du temps pour tester la publication beta avant que la régression se
retrouve dans une publication stable ! La correction est alors appliquée sur
<code>master</code>, ainsi nightly est corrigé, et ensuite la correction est reportée sur
la branche <code>beta</code>, et une nouvelle publication de beta est produite :</p>
<!--
```text
nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
```
-->
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<!--
Six weeks after the first beta was created, it’s time for a stable release! The
`stable` branch is produced from the `beta` branch:
-->
<p>Six semaines après que la première beta soit créée, c'est le moment de publier
une version stable ! La branche <code>stable</code> est produite à partir de la branche
<code>beta</code> :</p>
<!--
```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
```
-->
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<!--
Hooray! Rust 1.5 is done! However, we’ve forgotten one thing: because the six
weeks have gone by, we also need a new beta of the *next* version of Rust, 1.6.
So after `stable` branches off of `beta`, the next version of `beta` branches
off of `nightly` again:
-->
<p>Youpi ! Rust 1.5 est sorti ! Cependant, nous avons oublié quelque chose : comme
les six semaines sont passées, nous devons aussi publier une nouvelle beta de la
version <em>suivante</em> de Rust, la 1.6. Donc après que la branche <code>stable</code> soit
dérivée de la <code>beta</code>, la prochaine version de la branche <code>beta</code> doit à nouveau
être dérivée de nightly :</p>
<!--
```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
```
-->
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<!--
This is called the “train model” because every six weeks, a release “leaves the
station”, but still has to take a journey through the beta channel before it
arrives as a stable release.
-->
<p>C'est appelé le “modèle ferroviaire” car toutes les six semaines, une nouvelle
publication “quitte la gare”, mais doit encore voyager dans la voie de la
beta avant d'arriver en gare de la publication stable.</p>
<!--
Rust releases every six weeks, like clockwork. If you know the date of one Rust
release, you can know the date of the next one: it’s six weeks later. A nice
aspect of having releases scheduled every six weeks is that the next train is
coming soon. If a feature happens to miss a particular release, there’s no need
to worry: another one is happening in a short time! This helps reduce pressure
to sneak possibly unpolished features in close to the release deadline.
-->
<p>Rust publie régulièrement toutes les six semaines, réglée comme une montre. Si
vous savez la date d'une publication Rust, vous savez la date de la suivante :
elle aura toujours lieu six semaines plus tard. Un des avantages d'avoir des
publications planifiées toutes les six semaines est que le train suivant arrive
rapidement après. Si une fonctionnalité n'est pas intégrée à une publication, il
n'y a pas à s'inquiéter : une autre arrive bientôt ! Cela aide à réduire la
pression pour faire passer en toute discrétion des fonctionnalités
éventuellement inachevées à l'approche de la date limite de diffusion.</p>
<!--
Thanks to this process, you can always check out the next build of Rust and
verify for yourself that it’s easy to upgrade to: if a beta release doesn’t
work as expected, you can report it to the team and get it fixed before the
next stable release happens! Breakage in a beta release is relatively rare, but
`rustc` is still a piece of software, and bugs do exist.
-->
<p>Grâce à ce processus, vous pouvez toujours découvrir la prochaine compilation de
Rust et constater par vous-même qu'il est facile de mettre à jour : si une
publication en beta ne fonctionne pas comme prévu, vous pouvez signaler cela à
l'équipe et cela sera corrigé avant que la prochaine publication stable soit
produite ! La dégradation d'une version bêta est plutôt rare, mais <code>rustc</code> reste
un logiciel, et les bogues peuvent exister malgré tout.</p>
<!--
### Unstable Features
-->
<h3 id="les-fonctionnalités-instables"><a class="header" href="#les-fonctionnalités-instables">Les fonctionnalités instables</a></h3>
<!--
There’s one more catch with this release model: unstable features. Rust uses a
technique called “feature flags” to determine what features are enabled in a
given release. If a new feature is under active development, it lands on
`master`, and therefore, in nightly, but behind a *feature flag*. If you, as a
user, wish to try out the work-in-progress feature, you can, but you must be
using a nightly release of Rust and annotate your source code with the
appropriate flag to opt in.
-->
<p>Il reste une surprise avec ce modèle de publication : les fonctionnalités
instables. Rust utilise une technique qui s'appelle les “drapeaux de
fonctionnalités” pour déterminer quelles fonctionnalités sont activées dans une
publication donnée. Si une nouvelle fonctionnalité est en développement actif,
elle va atterrir sur <code>master</code>, et ainsi, dans nightly, mais derrière un <em>drapeau
de fonctionnalités</em>. Si vous, en tant qu'utilisateur, souhaitez essayer la
fonctionnalité en cours de développement, vous pouvez, mais vous devez utiliser
une publication nightly de Rust et annoter votre code source avec le drapeau
approprié pour l'activer.</p>
<!--
If you’re using a beta or stable release of Rust, you can’t use any feature
flags. This is the key that allows us to get practical use with new features
before we declare them stable forever. Those who wish to opt into the bleeding
edge can do so, and those who want a rock-solid experience can stick with
stable and know that their code won’t break. Stability without stagnation.
-->
<p>Si vous utilisez une publication beta ou stable de Rust, vous ne pouvez pas
utiliser de drapeaux de fonctionnalités. C'est la clé qui permet d'obtenir une
utilisation pratique avec les nouvelles fonctionnalités avant que nous les
déclarions stables pour toujours. Ceux qui souhaitent activer ces
fonctionnalités expérimentales peuvent le faire, et ceux qui souhaitent avoir
une expérience plus solide peuvent s'en tenir au canal stable et leur code ne
sera pas cassé. C'est la stabilité sans stagnation.</p>
<!--
This book only contains information about stable features, as in-progress
features are still changing, and surely they’ll be different between when this
book was written and when they get enabled in stable builds. You can find
documentation for nightly-only features online.
-->
<p>Ce livre contient uniquement des informations sur des fonctionnalités stables,
car les fonctionnalités en cours de développement sont toujours en train de
changer, et elles seront sûrement différentes entre le moment où ce livre sera
écrit et lorsqu'elles seront activées dans les compilations stables. Vous pouvez
trouver la documentation pour les fonctionnalités uniquement pour nightly en
ligne.</p>
<!--
### Rustup and the Role of Rust Nightly
-->
<h3 id="rustup-et-le-role-de-rust-nightly"><a class="header" href="#rustup-et-le-role-de-rust-nightly">Rustup et le role de Rust nightly</a></h3>
<!--
Rustup makes it easy to change between different release channels of Rust, on a
global or per-project basis. By default, you’ll have stable Rust installed. To
install nightly, for example:
-->
<p>Rustup facilite les changements entre les différents canaux de publication de
Rust, de manière globale ou par projet. Par défaut, vous avez Rust stable
d'installé. Pour installer nightly, vous pouvez saisir, par exemple :</p>
<!--
```console
$ rustup toolchain install nightly
```
-->
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<!--
You can see all of the *toolchains* (releases of Rust and associated
components) you have installed with `rustup` as well. Here’s an example on one
of your authors’ Windows computer:
-->
<p>Vous pouvez aussi voir avec <code>rustup</code> toutes les <em>toolchains</em> (les publications
de Rust et leurs composants associés) que vous avez d'installées. Voici un
exemple d'un ordinateur sous Windows d'un des auteurs du livre :</p>
<!--
```powershell
> rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
```
-->
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<!--
As you can see, the stable toolchain is the default. Most Rust users use stable
most of the time. You might want to use stable most of the time, but use
nightly on a specific project, because you care about a cutting-edge feature.
To do so, you can use `rustup override` in that project’s directory to set the
nightly toolchain as the one `rustup` should use when you’re in that directory:
-->
<p>Comme vous pouvez le constater, la toolchain stable est celle par défaut. La
plupart des utilisateurs Rust utilisent celle qui est stable la plupart du
temps. Il est possible que vous souhaitiez utiliser celle qui est stable la
plupart du temps, mais que vous souhaitiez utiliser nightly sur un projet
particulier, car parce que vous vous intéressez à une fonctionnalité
expérimentale. Pour pouvoir faire cela, vous pouvez utiliser <code>rustup override</code>
dans le dossier de ce projet pour régler <code>rustup</code> pour qu'il utilise la
toolchain nightly lorsque vous vous trouvez dans ce dossier :</p>
<!--
```console
$ cd ~/projects/needs-nightly
$ rustup override set nightly
```
-->
<pre><code class="language-console">$ cd ~/projets/necessite-nightly
$ rustup override set nightly
</code></pre>
<!--
Now, every time you call `rustc` or `cargo` inside of
*~/projects/needs-nightly*, `rustup` will make sure that you are using nightly
Rust, rather than your default of stable Rust. This comes in handy when you
have a lot of Rust projects!
-->
<p>Maintenant, à chaque fois que vous faites appel à <code>rustc</code> ou <code>cargo</code> à
l'intérieur de <em>~/projets/necessite-nightly</em>, <code>rustup</code> va s'assurer que vous
utilisez Rust nightly, plutôt que votre Rust stable par défaut. C'est très utile
lorsque vous avez beaucoup de projets Rust !</p>
<!--
### The RFC Process and Teams
-->
<h3 id="le-processus-de-rfc-et-les-équipes"><a class="header" href="#le-processus-de-rfc-et-les-équipes">Le processus de RFC et les équipes</a></h3>
<!--
So how do you learn about these new features? Rust’s development model follows
a *Request For Comments (RFC) process*. If you’d like an improvement in Rust,
you can write up a proposal, called an RFC.
-->
<p>Donc, comment en apprendre plus ces nouvelles fonctionnalités ? Le modèle de
développement de Rust suit le <em>processus de Request For Comments (RFC)</em>. Si vous
souhaitez avoir une amélioration de Rust, vous pouvez rédiger une proposition,
qu'on appelle une RFC.</p>
<!--
Anyone can write RFCs to improve Rust, and the proposals are reviewed and
discussed by the Rust team, which is comprised of many topic subteams. There’s
a full list of the teams [on Rust’s
website](https://www.rust-lang.org/governance), which includes teams for
each area of the project: language design, compiler implementation,
infrastructure, documentation, and more. The appropriate team reads the
proposal and the comments, writes some comments of their own, and eventually,
there’s consensus to accept or reject the feature.
-->
<p>N'importe qui peut écrire de RFC pour améliorer Rust, et les propositions sont
examinées et débattues par l'équipe de Rust, qui est composée de nombreuses
sous-équipes spécialisées dans différents domaines. Voici une liste complète des
équipes <a href="https://www.rust-lang.org/governance">sur le site web de Rust</a>, qui
comprend des équipes pour chaque aspect du projet : la conception du langage,
l'implémentation du compilateur, de l'infrastructure, de la documentation, et
plus encore. L'équipe appropriée lit la proposition et les commentaires, écrit
quelques commentaires la concernant, et finalement, un consensus se crée pour
accepter ou rejeter la fonctionnalité.</p>
<!--
If the feature is accepted, an issue is opened on the Rust repository, and
someone can implement it. The person who implements it very well may not be the
person who proposed the feature in the first place! When the implementation is
ready, it lands on the `master` branch behind a feature gate, as we discussed
in the [“Unstable Features”](#unstable-features)<!-- ignore -- > section.
-->
<p>Si la fonctionnalité est acceptée, un ticket est ouvert sur le dépôt de Rust, et
quelqu'un peut l'implémenter. La personne qui l'implémente ne peut pas être
celle qui a proposé la fonctionnalité ! Lorsque l'implémentation est prête, elle
atterrit sur la branche <code>master</code> derrière un drapeau de fonctionnalité, comme
nous l'avons vu dans la section <a href="appendix-07-nightly-rust.html#les-fonctionnalit%C3%A9s-instables">“Les fonctionnalités
instables”</a><!-- ignore -->.</p>
<!--
After some time, once Rust developers who use nightly releases have been able
to try out the new feature, team members will discuss the feature, how it’s
worked out on nightly, and decide if it should make it into stable Rust or not.
If the decision is to move forward, the feature gate is removed, and the
feature is now considered stable! It rides the trains into a new stable release
of Rust.
-->
<p>Au bout d'un moment, une fois que les développeurs Rust qui utilisent les
publications nightly ont pu tester la nouvelle fonctionnalité, les membres de
l'équipe vont discuter de la fonctionnalité, de voir comment elle a
fonctionné sur nightly, et vont décider si elle doit être publiée sur Rust
stable ou non. Si la décision est d'avancer, le drapeau de fonctionnalité est
enlevé, et la fonctionnalité est maintenant considérée comme stable ! Elle saute
alors dans le train en direction d'une nouvelle publication stable de Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
