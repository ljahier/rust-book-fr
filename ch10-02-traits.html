<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Définir des comportements partagés avec les traits - Le langage de programmation Rust</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilité</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de données</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrôle</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les références et l'emprunt</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des données apparentées</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Définir et instancier des structures</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des méthodes</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les énumérations et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Définir une énumération</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrôle match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrôle concise : if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Gérer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Définir des modules pour gérer la portée et la visibilité</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Désigner un élément dans l'arborescence de modules</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la portée via le mot-clé use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Séparer les modules dans différents fichiers</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encodé en UTF-8 avec les Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Stocker des clés associées à des valeurs dans des tables de hachage</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> La gestion des erreurs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Les erreurs irrécupérables avec panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Des erreurs récupérables avec Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Paniquer ou ne pas paniquer, telle est la question</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Les types génériques, les traits et les durées de vie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Les types de données génériques</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html" class="active"><strong aria-hidden="true">10.2.</strong> Définir des comportements partagés avec les traits</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> La conformité des références avec les durées de vies</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Ecrire des tests automatisés</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Comment écrire des tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Gérer l'exécution des tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> L'organisation des tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un projet d'entrée/sortie : construire un programme en ligne de commande</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Récupérer les arguments de la ligne de commande</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Lire un fichier</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Remanier le code pour améliorer sa modularité et la gestion des erreurs</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Développer les fonctionnalités de la bibliothèque avec le TDD</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Travailler avec des variables d'environnement</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalités des langages fonctionnels : les itérateurs et les fermetures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures : fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une série d'éléments avec un itérateur</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Amélioration de notre projet d'entrée/sortie</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances : les boucles et les itérateurs</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personnaliser les compilations avec les profils de publication</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publier une crate sur crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Les espaces de travail de cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installer des binaires à partir de crates.io avec cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Etendre les fonctionnalités de cargo avec des commandes personnalisées</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Les pointeurs intelligents</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Utiliser Box&lt;T&gt; pour pointer sur des données présentes sur le tas</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Considérer les pointeurs intelligents comme des références grâce au trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Exécuter du code au nettoyage avec le trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, le pointeur intelligent qui compte les références</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; et le motif de mutabilité interne</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Les boucles de références qui peuvent provoquer des fuites de mémoire</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> La concurrence sans craintes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Utiliser les tâches pour exécuter simultanément du code</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Utiliser l'envoi de messages pour transférer des données entre les tâches</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Le partage d'état en concurrence</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalités orientées objet de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Les caractéristiques des langages orientés objet</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Utiliser les objets traits qui permettent des valeurs de types différents</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implémenter un patron de conception orienté-objet</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Tous les endroits où les motifs peuvent être utilisés</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> La réfutabilité : lorsqu'un motif peut échouer à correspondre</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> La syntaxe des motifs</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Les fonctionnalités avancées</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Le Rust non sécurisé (unsafe)</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Les traits avancés</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Les types avancés</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Les fonctions et fermetures avancées</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Les macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Projet final : construire un serveur web multitâches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Développer un serveur web monotâche</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformer notre serveur monotâche en serveur multitâches</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Arrêt propre et nettoyage</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Le langage de programmation Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/rust-book-fr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Traits: Defining Shared Behavior
-->
<h2 id="définir-des-comportements-partagés-avec-les-traits"><a class="header" href="#définir-des-comportements-partagés-avec-les-traits">Définir des comportements partagés avec les traits</a></h2>
<!--
A *trait* tells the Rust compiler about functionality a particular type has and
can share with other types. We can use traits to define shared behavior in an
abstract way. We can use trait bounds to specify that a generic type can be any
type that has certain behavior.
-->
<p>Un <em>trait</em> décrit une fonctionnalité qu'a un type particulier et qu'il peut
partager avec d'autres types, à destination du compilateur Rust. Nous pouvons
utiliser les traits pour définir un comportement partagé de manière abstraite.
Nous pouvons lier ces traits à un type générique pour exprimer le fait qu'il
puisse être de n'importe quel type à condition qu'il ait un comportement donné.</p>
<!--
> Note: Traits are similar to a feature often called *interfaces* in other
> languages, although with some differences.
-->
<blockquote>
<p>Remarque : les traits sont similaires à ce qu'on appelle parfois les
<em>interfaces</em> dans d'autres langages, malgré quelques différences.</p>
</blockquote>
<!--
### Defining a Trait
-->
<h3 id="définir-un-trait"><a class="header" href="#définir-un-trait">Définir un trait</a></h3>
<!--
A type’s behavior consists of the methods we can call on that type. Different
types share the same behavior if we can call the same methods on all of those
types. Trait definitions are a way to group method signatures together to
define a set of behaviors necessary to accomplish some purpose.
-->
<p>Le comportement d'un type s'exprime via les méthodes que nous pouvons appeler
sur ce type. Différents types peuvent partager le même comportement si nous
pouvons appeler les mêmes méthodes sur tous ces types. Définir un trait est une
manière de regrouper des signatures de méthodes pour définir un comportement
nécessaire pour accomplir un objectif.</p>
<!--
For example, let’s say we have multiple structs that hold various kinds and
amounts of text: a `NewsArticle` struct that holds a news story filed in a
particular location and a `Tweet` that can have at most 280 characters along
with metadata that indicates whether it was a new tweet, a retweet, or a reply
to another tweet.
-->
<p>Par exemple, imaginons que nous avons plusieurs structures qui stockent
différents types et quantités de texte : une structure <code>ArticleDePresse</code>, qui
contient un reportage dans un endroit donné et un <code>Tweet</code> qui peut avoir jusqu'à
280 caractères maximum et des métadonnées qui indiquent si cela est un nouveau
tweet, un retweet, ou une réponse à un autre tweet.</p>
<!--
We want to make a media aggregator library crate named `aggregator` that can
display summaries of data that might be stored in a `NewsArticle` or `Tweet`
instance. To do this, we need a summary from each type, and we’ll request
that summary by calling a `summarize` method on an instance. Listing 10-12
shows the definition of a public `Summary` trait that expresses this behavior.
-->
<p>Nous voulons construire une crate de bibliothèque <code>agregateur</code> pour des
agrégateurs de médias qui peut afficher le résumé des données stockées dans une
instance de <code>ArticleDePresse</code> ou de <code>Tweet</code>. Pour cela, il nous faut un résumé
pour chaque type, et nous allons demander ce résumé en appelant la méthode
<code>resumer</code> sur une instance. L'encart 10-12 nous montre la définition d'un trait
public <code>Resumable</code> qui décrit ce comportement.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
pub trait Summary {
    fn summarize(&self) -> String;
}
```
-->
<pre><code class="language-rust noplayground">pub trait Resumable {
    fn resumer(&amp;self) -&gt; String;
}
</code></pre>
<!--
<span class="caption">Listing 10-12: A `Summary` trait that consists of the
behavior provided by a `summarize` method</span>
-->
<p><span class="caption">Encart 10-12 : un trait <code>Resumable</code> qui représente le
comportement fourni par une méthode <code>resumer</code></span></p>
<!--
Here, we declare a trait using the `trait` keyword and then the trait’s name,
which is `Summary` in this case. We’ve also declared the trait as `pub` so that
crates depending on this crate can make use of this trait too, as we’ll see in
a few examples. Inside the curly brackets, we declare the method signatures
that describe the behaviors of the types that implement this trait, which in
this case is `fn summarize(&self) -> String`.
-->
<p>Ici, nous déclarons un trait en utilisant le mot-clé <code>trait</code> et ensuite le nom
du trait, qui est <code>Resumable</code> dans notre cas. Nous avons aussi déclaré le trait
comme <code>pub</code> afin que les crates qui dépendent de cette crate puissent utiliser
aussi utiliser ce trait, comme nous allons le voir dans quelques exemples.
Entre les accolades, nous déclarons la signature de la méthode qui décrit le
comportement des types qui implémentent ce trait, qui est dans notre cas
<code>fn resumer(&amp;self) -&gt; String</code>.</p>
<!--
After the method signature, instead of providing an implementation within curly
brackets, we use a semicolon. Each type implementing this trait must provide
its own custom behavior for the body of the method. The compiler will enforce
that any type that has the `Summary` trait will have the method `summarize`
defined with this signature exactly.
-->
<p>A la fin de la signature de la méthode, au lieu de renseigner une implémentation
entre des accolades, nous utilisons un point-virgule. Chaque type qui implémente
ce trait doit renseigner son propre comportement dans le corps de la méthode. Le
compilateur va s'assurer que tous les types qui ont le trait <code>Resumable</code> auront
la méthode <code>resumer</code> définie avec cette signature précise.</p>
<!--
A trait can have multiple methods in its body: the method signatures are listed
one per line and each line ends in a semicolon.
-->
<p>Un trait peut avoir plusieurs méthodes dans son corps : les signatures des
méthodes sont ajoutées ligne par ligne et chaque ligne se termine avec un
point-virgule.</p>
<!--
### Implementing a Trait on a Type
-->
<h3 id="implémenter-un-trait-sur-un-type"><a class="header" href="#implémenter-un-trait-sur-un-type">Implémenter un trait sur un type</a></h3>
<!--
Now that we’ve defined the desired signatures of the `Summary` trait’s methods,
we can implement it on the types in our media aggregator. Listing 10-13 shows
an implementation of the `Summary` trait on the `NewsArticle` struct that uses
the headline, the author, and the location to create the return value of
`summarize`. For the `Tweet` struct, we define `summarize` as the username
followed by the entire text of the tweet, assuming that tweet content is
already limited to 280 characters.
-->
<p>Maintenant que nous avons défini les signatures souhaitées des méthodes du
trait <code>Resumable</code>, nous pouvons maintenant l'implémenter sur les types de notre
agrégateur de médias. L'encart 10-13 montre une implémentation du trait
<code>Resumable</code> sur la structure <code>ArticleDePresse</code> qui utilise le titre, le nom de
l'auteur, et le lieu pour créer la valeur de retour de <code>resumer</code>. Pour la
structure <code>Tweet</code>, nous définissons <code>resumer</code> avec le nom d'utilisateur suivi
par le texte entier du tweet, en supposant que le contenu du tweet est déjà
limité à 280 caractères.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```
-->
<pre><code class="language-rust noplayground"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct ArticleDePresse {
    pub titre: String,
    pub lieu: String,
    pub auteur: String,
    pub contenu: String,
}

impl Resumable for ArticleDePresse {
    fn resumer(&amp;self) -&gt; String {
        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
    }
}

pub struct Tweet {
    pub nom_utilisateur: String,
    pub contenu: String,
    pub reponse: bool,
    pub retweet: bool,
}

impl Resumable for Tweet {
    fn resumer(&amp;self) -&gt; String {
        format!(&quot;{} : {}&quot;, self.nom_utilisateur, self.contenu)
    }
}
</code></pre>
<!--
<span class="caption">Listing 10-13: Implementing the `Summary` trait on the
`NewsArticle` and `Tweet` types</span>
-->
<p><span class="caption">Encart 10-13 : implémentation du trait <code>Resumable</code> sur les
types <code>ArticleDePresse</code> et <code>Tweet</code></span></p>
<!--
Implementing a trait on a type is similar to implementing regular methods. The
difference is that after `impl`, we put the trait name that we want to
implement, then use the `for` keyword, and then specify the name of the type we
want to implement the trait for. Within the `impl` block, we put the method
signatures that the trait definition has defined. Instead of adding a semicolon
after each signature, we use curly brackets and fill in the method body with
the specific behavior that we want the methods of the trait to have for the
particular type.
-->
<p>L'implémentation d'un trait sur un type est similaire à l'implémentation d'une
méthode classique. La différence est que nous ajoutons le nom du trait que nous
voulons implémenter après le <code>impl</code>, et que nous utilisons ensuite le mot-clé
<code>for</code> suivi du nom du type sur lequel nous souhaitons implémenter le trait. À
l'intérieur du bloc <code>impl</code>, nous ajoutons les signatures des méthodes présentes
dans la définition du trait. Au lieu d'ajouter un point-virgule après chaque
signature, nous plaçons les accolades et on remplit le corps de la méthode avec
le comportement spécifique que nous voulons que les méthodes du trait suivent
pour le type en question.</p>
<!--
Now that the library has implemented the `Summary` trait on `NewsArticle` and
`Tweet`, users of the crate can call the trait methods on instances of
`NewsArticle` and `Tweet` in the same way we call regular methods. The only
difference is that the trait has to be brought into scope as well as the types
to get the additional trait methods. Here’s an example of how a binary crate
could use our `aggregator` library crate:
-->
<p>Maintenant que la bibliothèque a implémenté le trait <code>Resumable</code> sur
<code>ArticleDePresse</code> et <code>Tweet</code>, les utilisateurs de cette crate peuvent appeler
les méthodes de l'instance de <code>ArticleDePresse</code> et <code>Tweet</code> comme si elles
étaient des méthodes classiques. La seule différence est que le trait ainsi que
les types doivent être introduits dans la portée pour obtenir les méthodes de
trait additionnelles. Voici un exemple de comment la crate binaire puisse
utiliser notre crate de bibliothèque <code>agregateur</code> :</p>
<!--
```rust,ignore
use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
```
-->
<pre><code class="language-rust ignore">use agregateur::{Resumable, Tweet};

fn main() {
    let tweet = Tweet {
        nom_utilisateur: String::from(&quot;jean&quot;),
        contenu: String::from(&quot;Bien sûr, les amis, comme vous le savez probablement déjà&quot;),
        reponse: false,
        retweet: false,
    };
    
    println!(&quot;1 nouveau tweet : {}&quot;, tweet.resumer());
}
</code></pre>
<!--
This code prints `1 new tweet: horse_ebooks: of course, as you probably already
know, people`.
-->
<p>Ce code affichera <code>1 nouveau tweet : jean : Bien sûr, les amis, comme vous le savez probablement déjà</code>.</p>
<!--
Other crates that depend on the `aggregator` crate can also bring the `Summary`
trait into scope to implement the trait on their own types. One restriction to
note with trait implementations is that we can implement a trait on a type only
if at least one of the trait or the type is local to our crate. For example, we
can implement standard library traits like `Display` on a custom type like
`Tweet` as part of our `aggregator` crate functionality, because the type
`Tweet` is local to our `aggregator` crate. We can also implement `Summary` on
`Vec<T>` in our `aggregator` crate, because the trait `Summary` is local to our
`aggregator` crate.
-->
<p>Les autres crates qui dépendent de la crate <code>agregateur</code> peuvent aussi importer
dans la portée le trait <code>Resumable</code> afin d'implémenter le trait sur leurs
propres types. Il y a une limitation à souligner avec l'implémentation des
traits, c'est que nous ne pouvons implémenter un trait sur un type qu'à
condition qu'au moins le trait ou le type soit défini localement dans notre
crate. Par exemple, nous pouvons implémenter des traits de la bibliothèque
standard comme <code>Display</code> sur un type personnalisé comme <code>Tweet</code> comme une
fonctionnalité de notre crate <code>agregateur</code>, car le type <code>Tweet</code> est défini
localement dans notre crate <code>agregateur</code>. Nous pouvons aussi implémenter
<code>Resumable</code> sur <code>Vec&lt;T&gt;</code> dans notre crate <code>agregateur</code>, car le trait
<code>Resumable</code> est défini localement dans notre crate <code>agregateur</code>.</p>
<!--
But we can’t implement external traits on external types. For example, we can’t
implement the `Display` trait on `Vec<T>` within our `aggregator` crate,
because `Display` and `Vec<T>` are defined in the standard library and aren’t
local to our `aggregator` crate. This restriction is part of a property of
programs called *coherence*, and more specifically the *orphan rule*, so named
because the parent type is not present. This rule ensures that other people’s
code can’t break your code and vice versa. Without the rule, two crates could
implement the same trait for the same type, and Rust wouldn’t know which
implementation to use.
-->
<p>Mais nous ne pouvons pas implémenter des traits externes sur des types externes.
Par exemple, nous ne pouvons pas implémenter le trait <code>Display</code> sur <code>Vec&lt;T&gt;</code> à
l'intérieur de notre crate <code>agregateur</code>, car <code>Display</code> et <code>Vec&lt;T&gt;</code> sont définis
dans la bibliothèque standard et ne sont donc pas définis localement dans notre
crate <code>agregateur</code>. Cette limitation fait partie d'une propriété des programmes
que l'on appelle la <em>cohérence</em>, et plus précisément la <em>règle de l'orphelin</em>,
qui s'appelle ainsi car le type parent n'est pas présent. Cette règle s'assure
que le code des autres personnes ne casse pas votre code et réciproquement.
Sans cette règle, deux crates pourraient implémenter le même trait sur le même
type, et Rust ne saurait pas quelle implémentation utiliser.</p>
<!--
### Default Implementations
-->
<h3 id="implémentations-par-défaut"><a class="header" href="#implémentations-par-défaut">Implémentations par défaut</a></h3>
<!--
Sometimes it’s useful to have default behavior for some or all of the methods
in a trait instead of requiring implementations for all methods on every type.
Then, as we implement the trait on a particular type, we can keep or override
each method’s default behavior.
-->
<p>Il est parfois utile d'avoir un comportement par défaut pour toutes ou une
partie des méthodes d'un trait plutôt que de demander l'implémentation de toutes
les méthodes sur chaque type. Ainsi, si nous implémentons le trait sur un type
particulier, nous pouvons garder ou réécrire le comportement par défaut de
chaque méthode.</p>
<!--
Listing 10-14 shows how to specify a default string for the `summarize` method
of the `Summary` trait instead of only defining the method signature, as we did
in Listing 10-12.
-->
<p>L'encart 10-14 nous montre comment préciser une String par défaut pour la
méthode <code>resumer</code> du trait <code>Resumable</code> plutôt que de définir uniquement la
signature de la méthode, comme nous l'avons fait dans l'encart 10-12.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {}
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
```
-->
<pre><code class="language-rust noplayground">pub trait Resumable {
    fn resumer(&amp;self) -&gt; String {
        String::from(&quot;(En savoir plus ...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-14: Definition of a `Summary` trait with a
default implementation of the `summarize` method</span>
-->
<p><span class="caption">Encart 10-14 : définition du trait <code>Resumable</code> avec une
implémentation par défaut de la méthode <code>resumer</code></span></p>
<!--
To use a default implementation to summarize instances of `NewsArticle` instead
of defining a custom implementation, we specify an empty `impl` block with
`impl Summary for NewsArticle {}`.
-->
<p>Pour utiliser l'implémentation par défaut pour résumer des instances de
<code>ArticleDePresse</code> au lieu de préciser une implémentation personnalisée, nous
précisons un bloc <code>impl</code> vide avec <code>impl Resumable for ArticleDePresse {}</code>.</p>
<!--
Even though we’re no longer defining the `summarize` method on `NewsArticle`
directly, we’ve provided a default implementation and specified that
`NewsArticle` implements the `Summary` trait. As a result, we can still call
the `summarize` method on an instance of `NewsArticle`, like this:
-->
<p>Même si nous ne définissons plus directement la méthode <code>resumer</code> sur
<code>ArticleDePresse</code>, nous avons fourni une implémentation par défaut et précisé
que <code>ArticleDePresse</code> implémente le trait <code>Resumable</code>. Par conséquent, nous
pouvons toujours appeler la méthode <code>resumer</code> sur une instance de
<code>ArticleDePresse</code>, comme ceci :</p>
<!--
```rust,ignore
# use chapter10::{self, NewsArticle, Summary};
# 
# fn main() {
    let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, ArticleDePresse, Resumable};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = ArticleDePresse {
        titre: String::from(&quot;Les Pinguins ont gagné la Stanley Cup Championship !&quot;),
        lieu: String::from(&quot;Pittsburgh, PA, USA&quot;),
        auteur: String::from(&quot;Iceburgh&quot;),
        contenu: String::from(
            &quot;Les Pinguins de Pittsburgh sont une nouvelle fois la meilleure\
            équipe de hockey de la NHL.&quot;
        ),
    };
    
    println!(&quot;Nouvel article disponible ! {}&quot;, article.resumer());
<span class="boring">}
</span></code></pre>
<!--
This code prints `New article available! (Read more...)`.
-->
<p>Ce code va afficher <code>Nouvel article disponible ! (En savoir plus ...)</code>.</p>
<!--
Creating a default implementation for `summarize` doesn’t require us to change
anything about the implementation of `Summary` on `Tweet` in Listing 10-13. The
reason is that the syntax for overriding a default implementation is the same
as the syntax for implementing a trait method that doesn’t have a default
implementation.
-->
<p>La création d'une implémentation par défaut pour <code>resumer</code> n'a pas besoin que
nous modifiions quelque chose dans l'implémentation de <code>Resumable</code> sur <code>Tweet</code>
dans l'encart 10-13. C'est parce que la syntaxe pour réécrire l'implémentation
par défaut est la même que la syntaxe pour implémenter une méthode qui n'a pas
d'implémentation par défaut.</p>
<!--
Default implementations can call other methods in the same trait, even if those
other methods don’t have a default implementation. In this way, a trait can
provide a lot of useful functionality and only require implementors to specify
a small part of it. For example, we could define the `Summary` trait to have a
`summarize_author` method whose implementation is required, and then define a
`summarize` method that has a default implementation that calls the
`summarize_author` method:
-->
<p>Les implémentations par défaut peuvent appeler d'autres méthodes du même trait,
même si ces autres méthodes n'ont pas d'implémentation par défaut. Ainsi, un
trait peut fournir de nombreuses fonctionnalités utiles et n'exiger du
développeur qui l'utilise que d'en implémenter une petite partie. Par exemple,
nous pouvons définir le trait <code>Resumable</code> comme ayant une méthode
<code>resumer_auteur</code> dont l'implémentation est nécessaire, et ensuite définir une
méthode <code>resumer</code> qui a une implémentation par défaut qui appelle la méthode
<code>resumer_auteur</code> :</p>
<!--
```rust,noplayground
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize_author(&self) -> String {
#         format!("@{}", self.username)
#     }
# }
```
-->
<pre><code class="language-rust noplayground">pub trait Resumable {
    fn resumer_auteur(&amp;self) -&gt; String;

    fn resumer(&amp;self) -&gt; String {
        format!(&quot;(Lire plus d'éléments de {} ...)&quot;, self.resumer_auteur())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer_auteur(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;@{}&quot;, self.nom_utilisateur)
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
To use this version of `Summary`, we only need to define `summarize_author`
when we implement the trait on a type:
-->
<p>Pour pouvoir utiliser cette version de <code>Resumable</code>, nous avons seulement besoin
de définir <code>resumer_auteur</code> lorsqu'on implémente le trait sur le type :</p>
<!--
```rust,ignore
# pub trait Summary {
#     fn summarize_author(&self) -> String;
# 
#     fn summarize(&self) -> String {
#         format!("(Read more from {}...)", self.summarize_author())
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer_auteur(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Lire plus d'éléments de {} ...)&quot;, self.resumer_auteur())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Resumable for Tweet {
    fn resumer_auteur(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.nom_utilisateur)
    }
}
</code></pre>
<!--
After we define `summarize_author`, we can call `summarize` on instances of the
`Tweet` struct, and the default implementation of `summarize` will call the
definition of `summarize_author` that we’ve provided. Because we’ve implemented
`summarize_author`, the `Summary` trait has given us the behavior of the
`summarize` method without requiring us to write any more code.
-->
<p>Après avoir défini <code>resumer_auteur</code>, nous pouvons appeler <code>resumer</code> sur des
instances de la structure <code>Tweet</code>, et l'implémentation par défaut de <code>resumer</code>
va appeler <code>resumer_auteur</code>, que nous avons défini. Comme nous avons implémenté
<code>resumer_auteur</code>, le trait <code>Resumable</code> nous a donné le comportement de la
méthode <code>resumer</code> sans nous obliger à écrire une ligne de code supplémentaire.</p>
<!--
```rust,ignore
# use chapter10::{self, Summary, Tweet};
# 
# fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Resumable, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        nom_utilisateur: String::from(&quot;jean&quot;),
        contenu: String::from(&quot;Bien sûr, les amis, comme vous le savez probablement déjà&quot;),
        reponse: false,
        retweet: false,
    };
    
    println!(&quot;1 nouveau tweet : {}&quot;, tweet.resumer());
<span class="boring">}
</span></code></pre>
<!--
This code prints `1 new tweet: (Read more from @horse_ebooks...)`.
-->
<p>Ce code affichera <code>1 nouveau tweet : (Lire plus d'éléments de @jean ...)</code>.</p>
<!--
Note that it isn’t possible to call the default implementation from an
overriding implementation of that same method.
-->
<p>Notez qu'il n'est pas possible d'appeler l'implémentation par défaut à partir
d'une réécriture de cette même méthode.</p>
<!--
### Traits as Parameters
-->
<h3 id="des-traits-en-paramètres"><a class="header" href="#des-traits-en-paramètres">Des traits en paramètres</a></h3>
<!--
Now that you know how to define and implement traits, we can explore how to use
traits to define functions that accept many different types.
-->
<p>Maintenant que vous savez comment définir et implémenter les traits, nous
pouvons regarder comment utiliser les traits pour définir des fonctions qui
acceptent plusieurs types différents.</p>
<!--
For example, in Listing 10-13, we implemented the `Summary` trait on the
`NewsArticle` and `Tweet` types. We can define a `notify` function that calls
the `summarize` method on its `item` parameter, which is of some type that
implements the `Summary` trait. To do this, we can use the `impl Trait`
syntax, like this:
-->
<p>Par exemple, dans l'encart 10-13, nous avons implémenté le trait <code>Resumable</code>
sur les types <code>ArticleDePresse</code> et <code>Tweet</code>. Nous pouvons définir une fonction
<code>notifier</code> qui va appeler la méthode <code>resumer</code> sur son paramètre <code>element</code>, qui
est d'un type qui implémente le trait <code>Resumable</code>. Pour faire ceci, nous
pouvons utiliser la syntaxe <code>impl Trait</code>, comme ceci :</p>
<!--
```rust,ignore
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {
#     fn summarize(&self) -> String {
#         format!("{}, by {} ({})", self.headline, self.author, self.location)
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
# 
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{} : {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notifier(element: &amp;impl Resumable) {
    println!(&quot;Flash info ! {}&quot;, element.resumer());
}
</code></pre>
<!--
Instead of a concrete type for the `item` parameter, we specify the `impl`
keyword and the trait name. This parameter accepts any type that implements the
specified trait. In the body of `notify`, we can call any methods on `item`
that come from the `Summary` trait, such as `summarize`. We can call `notify`
and pass in any instance of `NewsArticle` or `Tweet`. Code that calls the
function with any other type, such as a `String` or an `i32`, won’t compile
because those types don’t implement `Summary`.
-->
<p>Au lieu d'un type concret pour le paramètre <code>element</code>, nous précisons le mot-clé
<code>impl</code> et le nom du trait. Ce paramètre accepte n'importe quel type qui
implémente le trait spécifié. Dans le corps de <code>notifier</code>, nous pouvons appeler
toutes les méthodes sur <code>element</code> qui proviennent du trait <code>Resumable</code>, comme
<code>resumer</code>. Nous pouvons appeler <code>notifier</code> et passer une instance de
<code>ArticleDePresse</code> ou de <code>Tweet</code>. Le code qui appellera la fonction avec un autre
type, comme une <code>String</code> ou un <code>i32</code>, ne va pas se compiler car ces types
n'implémentent pas <code>Resumable</code>.</p>
<!--
#### Trait Bound Syntax
-->
<h4 id="la-syntaxe-du-trait-lié"><a class="header" href="#la-syntaxe-du-trait-lié">La syntaxe du trait lié</a></h4>
<!--
The `impl Trait` syntax works for straightforward cases but is actually
syntax sugar for a longer form, which is called a *trait bound*; it looks like
this:
-->
<p>La syntaxe <code>impl Trait</code> fonctionne bien pour des cas simples, mais est en
réalité du sucre syntaxique pour une forme plus longue, qui s'appelle le
<em>trait lié</em>, qui ressemble à ceci :</p>
<!--
```rust,ignore
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```
-->
<pre><code class="language-rust ignore">pub fn notifier&lt;T: Resumable&gt;(element: &amp;T) {
    println!(&quot;Flash info ! {}&quot;, element.resumer());
}
</code></pre>
<!--
This longer form is equivalent to the example in the previous section but is
more verbose. We place trait bounds with the declaration of the generic type
parameter after a colon and inside angle brackets.
-->
<p>Cette forme plus longue est équivalente à l'exemple dans la section précédente,
mais est plus verbeuse. Nous plaçons les traits liés dans la déclaration des
paramètres de type génériques après un deux-point entre des chevrons.</p>
<!--
The `impl Trait` syntax is convenient and makes for more concise code in simple
cases. The trait bound syntax can express more complexity in other cases. For
example, we can have two parameters that implement `Summary`. Using the `impl
Trait` syntax looks like this:
-->
<p>La syntaxe <code>impl Trait</code> est pratique pour rendre du code plus concis dans des
cas simples. La syntaxe du trait lié exprime plus de complexité dans certains
cas. Par exemple, nous pouvons avoir deux paramètres qui implémentent
<code>Resumable</code>. En utilisant la syntaxe <code>impl Trait</code>, nous aurons ceci :</p>
<!--
```rust,ignore
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier(element1: &amp;impl Resumable, element2: &amp;impl Resumable) {
</code></pre>
<!--
If we wanted this function to allow `item1` and `item2` to have different
types, using `impl Trait` would be appropriate (as long as both types implement
`Summary`). If we wanted to force both parameters to have the same type, that’s
only possible to express using a trait bound, like this:
-->
<p>Si nous souhaitons permettre à <code>element1</code> et <code>element2</code> d'avoir des types
différents, l'utilisation de <code>impl Trait</code> est appropriée (du moment que chacun
de ces types implémentent <code>Resumable</code>). Mais si nous souhaitons forcer les deux
paramètres à être du même type, cela n'est possible à exprimer qu'avec un trait
lié, comme ceci :</p>
<!--
```rust,ignore
pub fn notify<T: Summary>(item1: &T, item2: &T) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier&lt;T: Resumable&gt;(element1: &amp;T, element2: &amp;T) {
</code></pre>
<!--
The generic type `T` specified as the type of the `item1` and `item2`
parameters constrains the function such that the concrete type of the value
passed as an argument for `item1` and `item2` must be the same.
-->
<p>Le type générique <code>T</code> renseigné comme type des paramètres <code>element1</code> et
<code>element2</code> contraint la fonction de manière à ce que les types concrets des
valeurs passées en arguments pour <code>element1</code> et <code>element2</code> soient identiques.</p>
<!--
#### Specifying Multiple Trait Bounds with the `+` Syntax
-->
<h4 id="renseigner-plusieurs-traits-liés-avec-la-syntaxe-"><a class="header" href="#renseigner-plusieurs-traits-liés-avec-la-syntaxe-">Renseigner plusieurs traits liés avec la syntaxe <code>+</code></a></h4>
<!--
We can also specify more than one trait bound. Say we wanted `notify` to use
display formatting on `item` as well as the `summarize` method: we specify in
the `notify` definition that `item` must implement both `Display` and
`Summary`. We can do so using the `+` syntax:
-->
<p>Nous pouvons aussi préciser que nous attendons plus d'un trait lié. Imaginons
que nous souhaitons que <code>notifier</code> utilise le formatage d'affichage sur
<code>element</code> ainsi que la méthode <code>resumer</code> : nous indiquons dans la définition de
<code>notify</code> que <code>element</code> doit implémenter à la fois <code>Display</code> et <code>Resumable</code>.
Nous pouvons faire ceci avec la syntaxe <code>+</code> :</p>
<!--
```rust,ignore
pub fn notify(item: &(impl Summary + Display)) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier(element: &amp;(impl Resumable + Display)) {
</code></pre>
<!--
The `+` syntax is also valid with trait bounds on generic types:
-->
<p>La syntaxe <code>+</code> fonctionne aussi avec les traits liés sur des types génériques :</p>
<!--
```rust,ignore
pub fn notify<T: Summary + Display>(item: &T) {
```
-->
<pre><code class="language-rust ignore">pub fn notifier&lt;T: Resumable + Display&gt;(element: &amp;T) {
</code></pre>
<!--
With the two trait bounds specified, the body of `notify` can call `summarize`
and use `{}` to format `item`.
-->
<p>Avec les deux traits liés renseignés, le corps de <code>notifier</code> va appeler
<code>resumer</code> et utiliser <code>{}</code> pour formater <code>element</code>.</p>
<!--
#### Clearer Trait Bounds with `where` Clauses
-->
<h4 id="des-traits-liés-plus-clairs-avec-la-clause-where"><a class="header" href="#des-traits-liés-plus-clairs-avec-la-clause-where">Des traits liés plus clairs avec la clause <code>where</code></a></h4>
<!--
Using too many trait bounds has its downsides. Each generic has its own trait
bounds, so functions with multiple generic type parameters can contain lots of
trait bound information between the function’s name and its parameter list,
making the function signature hard to read. For this reason, Rust has alternate
syntax for specifying trait bounds inside a `where` clause after the function
signature. So instead of writing this:
-->
<p>L'utilisation de trop nombreux traits liés a aussi ses désavantages. Chaque
type générique a ses propres traits liés, donc les fonctions avec plusieurs
paramètres de type génériques peuvent aussi avoir de nombreuses informations de
traits liés entre le nom de la fonction et la liste de ses paramètres, ce qui
rend la signature de la fonction difficile à lire. Pour cette raison, Rust a une
syntaxe alternative pour renseigner les traits liés, dans une clause <code>where</code>
après la signature de la fonction. Donc, au lieu d'écrire ceci ...</p>
<!--
```rust,ignore
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
```
-->
<pre><code class="language-rust ignore">fn une_fonction&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
<!--
we can use a `where` clause, like this:
-->
<p>... nous pouvons utiliser la clause <code>where</code>, comme ceci :</p>
<!--
```rust,ignore
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{
```
-->
<pre><code class="language-rust ignore">fn une_fonction&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<!--
This function’s signature is less cluttered: the function name, parameter list,
and return type are close together, similar to a function without lots of trait
bounds.
-->
<p>La signature de cette fonction est moins encombrée : le nom de la fonction, la
liste des paramètres et le type de retour sont plus proches les uns des autres,
comme une fonction sans traits liés.</p>
<!--
### Returning Types that Implement Traits
-->
<h3 id="retourner-des-types-qui-implémentent-des-traits"><a class="header" href="#retourner-des-types-qui-implémentent-des-traits">Retourner des types qui implémentent des traits</a></h3>
<!--
We can also use the `impl Trait` syntax in the return position to return a
value of some type that implements a trait, as shown here:
-->
<p>Nous pouvons aussi utiliser la syntaxe <code>impl Trait</code> à la place du type de
retour afin de retourner une valeur d'un type qui implémente un trait, comme
ci-dessous :</p>
<!--
```rust,ignore
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {
#     fn summarize(&self) -> String {
#         format!("{}, by {} ({})", self.headline, self.author, self.location)
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
# 
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
```
-->
<pre><code class="language-rust ignore"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{} : {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn retourne_resumable() -&gt; impl Resumable {
    Tweet {
        nom_utilisateur: String::from(&quot;jean&quot;),
        contenu: String::from(&quot;Bien sûr, les amis, comme vous le savez probablement déjà&quot;),
        reponse: false,
        retweet: false,
    }
}
</code></pre>
<!--
By using `impl Summary` for the return type, we specify that the
`returns_summarizable` function returns some type that implements the `Summary`
trait without naming the concrete type. In this case, `returns_summarizable`
returns a `Tweet`, but the code calling this function doesn’t know that.
-->
<p>En utilisant <code>impl Resumable</code> pour le type de retour, nous indiquons que la
fonction <code>retourne_resumable</code> retourne un type qui implémente le trait
<code>Resumable</code> sans avoir à écrire le nom du type concret. Dans notre cas,
<code>retourne_resumable</code> retourne un <code>Tweet</code>, mais le code qui appellera cette
fonction ne le saura pas.</p>
<!--
The ability to return a type that is only specified by the trait it implements
is especially useful in the context of closures and iterators, which we cover
in Chapter 13. Closures and iterators create types that only the compiler knows
or types that are very long to specify. The `impl Trait` syntax lets you
concisely specify that a function returns some type that implements the
`Iterator` trait without needing to write out a very long type.
-->
<p>La capacité de retourner un type qui est uniquement caractérisé par le trait
qu'il implémente est tout particulièrement utile dans le cas des fermetures et
des itérateurs, que nous verrons au chapitre 13. Les fermetures et les
itérateurs créent des types que seul le compilateur est en mesure de comprendre
ou alors des types qui sont très longs à définir. La syntaxe <code>impl Trait</code> vous
permet de renseigner de manière concise qu'une fonction retourne un type
particulier qui implémente le trait <code>Iterator</code> sans avoir à écrire un très long
type.</p>
<!--
However, you can only use `impl Trait` if you’re returning a single type. For
example, this code that returns either a `NewsArticle` or a `Tweet` with the
return type specified as `impl Summary` wouldn’t work:
-->
<p>Cependant, vous pouvez seulement utiliser <code>impl Trait</code> si vous retournez un
seul type possible. Par exemple, ce code va retourner soit un
<code>ArticleDePresse</code>, soit un <code>Tweet</code>, alors que le type de retour avec
<code>impl Resumable</code> ne va pas fonctionner :</p>
<!--
```rust,ignore,does_not_compile
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
# 
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
# 
# impl Summary for NewsArticle {
#     fn summarize(&self) -> String {
#         format!("{}, by {} ({})", self.headline, self.author, self.location)
#     }
# }
# 
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
# 
# impl Summary for Tweet {
#     fn summarize(&self) -> String {
#         format!("{}: {}", self.username, self.content)
#     }
# }
# 
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        Tweet {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
            reply: false,
            retweet: false,
        }
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Resumable {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct ArticleDePresse {
</span><span class="boring">    pub titre: String,
</span><span class="boring">    pub lieu: String,
</span><span class="boring">    pub auteur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for ArticleDePresse {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, par {} ({})&quot;, self.titre, self.auteur, self.lieu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub nom_utilisateur: String,
</span><span class="boring">    pub contenu: String,
</span><span class="boring">    pub reponse: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Resumable for Tweet {
</span><span class="boring">    fn resumer(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{} : {}&quot;, self.nom_utilisateur, self.contenu)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn retourne_resumable(estArticle: bool) -&gt; impl Resumable {
    if estArticle {
        ArticleDePresse {
            titre: String::from(&quot;Les Pinguins ont gagné la Stanley Cup Championship !&quot;),
            lieu: String::from(&quot;Pittsburgh, PA, USA&quot;),
            auteur: String::from(&quot;Iceburgh&quot;),
            contenu: String::from(&quot;Les Pinguins de Pittsburgh sont une nouvelle fois la
            meilleure équipe de hockey de la NHL.&quot;),
        }
    } else {
        Tweet {
            nom_utilisateur: String::from(&quot;jean&quot;),
            contenu: String::from(&quot;Bien sûr, les amis, comme vous le savez probablement déjà&quot;),
            reponse: false,
            retweet: false,
        }
    }
}
</code></pre>
<!--
Returning either a `NewsArticle` or a `Tweet` isn’t allowed due to restrictions
around how the `impl Trait` syntax is implemented in the compiler. We’ll cover
how to write a function with this behavior in the [“Using Trait Objects That
Allow for Values of Different
Types”][using-trait-objects-that-allow-for-values-of-different-types]<!--
ignore -- > section of Chapter 17.
-->
<p>Retourner soit un <code>ArticleDePresse</code>, soit un <code>Tweet</code> n'est pas autorisé à cause
des restrictions sur la façon dont la syntaxe <code>impl Trait</code> est implémentée dans
le compilateur. Nous verrons comment écrire une fonction avec ce comportement
dans une section du
<a href="ch17-02-trait-objects.html">chapitre 17</a><!--
ignore -->.</p>
<!--
### Fixing the `largest` Function with Trait Bounds
-->
<h3 id="corriger-la-fonction-le_plus_grand-avec-les-traits-liés"><a class="header" href="#corriger-la-fonction-le_plus_grand-avec-les-traits-liés">Corriger la fonction <code>le_plus_grand</code> avec les traits liés</a></h3>
<!--
Now that you know how to specify the behavior you want to use using the generic
type parameter’s bounds, let’s return to Listing 10-5 to fix the definition of
the `largest` function that uses a generic type parameter! Last time we tried
to run that code, we received this error:
-->
<p>Maintenant que vous savez comment renseigner le comportement que vous souhaitez
utiliser en utilisant les traits liés des paramètres de type génériques,
retournons à l'encart 10-5 pour corriger la définition de la fonction
<code>le_plus_grand</code> qui utilise un paramètre de type générique ! La dernière fois
que nous avons essayé de lancer ce code, nous avions l'erreur suivante :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 -- > src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if element &gt; le_plus_grand {
  |            ------- ^ ------------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn le_plus_grand&lt;T: std::cmp::PartialOrd&gt;(liste: &amp;[T]) -&gt; T {
  |                  ^^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
<!--
In the body of `largest` we wanted to compare two values of type `T` using the
greater than (`>`) operator. Because that operator is defined as a default
method on the standard library trait `std::cmp::PartialOrd`, we need to specify
`PartialOrd` in the trait bounds for `T` so the `largest` function can work on
slices of any type that we can compare. We don’t need to bring `PartialOrd`
into scope because it’s in the prelude. Change the signature of `largest` to
look like this:
-->
<p>Dans le corps de <code>le_plus_grand</code>, nous voulions comparer les deux valeurs du
type <code>T</code> en utilisant l'opérateur <em>plus grand que</em> (<code>&gt;</code>). Comme cet opérateur
est défini comme une méthode par défaut dans le trait de la bibliothèque
standard <code>std::cmp::PartialOrd</code>, nous devons préciser <code>PartialOrd</code> dans les
traits liés pour <code>T</code> afin que la fonction <code>le_plus_grand</code> puisse fonctionner
sur les slices de n'importe quel type que nous pouvons comparer. Nous n'avons
pas besoin d'importer <code>PartialOrd</code> dans la portée car il est importé dans
l'étape préliminaire. Changez la signature de <code>le_plus_grand</code> par quelque chose
comme ceci :</p>
<!--
```rust,ignore
fn largest<T: PartialOrd>(list: &[T]) -> T {
#     let mut largest = list[0];
# 
#     for &item in list {
#         if item > largest {
#             largest = item;
#         }
#     }
# 
#     largest
# }
# 
# fn main() {
#     let number_list = vec![34, 50, 25, 100, 65];
# 
#     let result = largest(&number_list);
#     println!("The largest number is {}", result);
# 
#     let char_list = vec!['y', 'm', 'a', 'q'];
# 
#     let result = largest(&char_list);
#     println!("The largest char is {}", result);
# }
```
-->
<pre><code class="language-rust ignore">fn le_plus_grand&lt;T: PartialOrd&gt;(liste: &amp;[T]) -&gt; T {
<span class="boring">    let mut le_plus_grand = liste[0];
</span><span class="boring">
</span><span class="boring">    for &amp;element in liste {
</span><span class="boring">        if element &gt; le_plus_grand {
</span><span class="boring">            le_plus_grand = element;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    le_plus_grand
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let liste_de_nombres = vec![34, 50, 25, 100, 65];
</span><span class="boring">
</span><span class="boring">    let resultat = le_plus_grand(&amp;liste_de_nombres);
</span><span class="boring">    println!(&quot;Le plus grand nombre est {}&quot;, resultat);
</span><span class="boring">
</span><span class="boring">    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];
</span><span class="boring">
</span><span class="boring">    let resultat = le_plus_grand(&amp;liste_de_caracteres);
</span><span class="boring">    println!(&quot;Le plus grand caractère est {}&quot;, resultat);
</span><span class="boring">}
</span></code></pre>
<!--
This time when we compile the code, we get a different set of errors:
-->
<p>Cette fois, lorsque nous allons compiler le code, nous aurons un ensemble
d'erreurs différent :</p>
<!--
```console
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 -- > src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&list[0]`

error[E0507]: cannot move out of a shared reference
 -- > src/main.rs:4:18
  |
4 |     for &item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&`: `item`

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10` due to 2 previous errors
```
-->
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 -- &gt; src/main.rs:2:23
  |
2 |     let mut le_plus_grand = liste[0];
  |                             ^^^^^^^^
  |                             |
  |                             cannot move out of here
  |                             move occurs because `liste[_]` has type `T`, which does not implement the `Copy` trait
  |                             help: consider borrowing here: `&amp;liste[0]`

error[E0507]: cannot move out of a shared reference
 -- &gt; src/main.rs:4:18
  |
4 |     for &amp;element in liste {
  |         --------    ^^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `element` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&amp;`: `element`

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10` due to 2 previous errors
</code></pre>
<!--
The key line in this error is `cannot move out of type [T], a non-copy slice`.
With our non-generic versions of the `largest` function, we were only trying to
find the largest `i32` or `char`. As discussed in the [“Stack-Only Data:
Copy”][stack-only-data-copy]<!-- ignore -- > section in Chapter 4, types like
`i32` and `char` that have a known size can be stored on the stack, so they
implement the `Copy` trait. But when we made the `largest` function generic,
it became possible for the `list` parameter to have types in it that don’t
implement the `Copy` trait. Consequently, we wouldn’t be able to move the
value out of `list[0]` and into the `largest` variable, resulting in this
error.
-->
<p>L'élement-clé dans ces erreurs est <code>cannot move out of type [T], a non-copy slice</code> (<em>impossible de déplacer une valeur hors du type <code>[T]</code>, slice non
<code>Copy</code></em>). Avec notre version non générique de la fonction <code>le_plus_grand</code>, nous
avions essayé de trouver le plus grand <code>i32</code> ou <code>char</code>. Comme nous l'avons vu
dans la section <a href="ch04-01-what-is-ownership.html#donn%C3%A9es-uniquement-sur-la-pile--la-copie">“Données uniquement sur la pile : la
copie”</a><!-- ignore --> du chapitre 4, les types comme
<code>i32</code> et <code>char</code> ont une taille connue et peuvent être stockés sur la pile, donc
ils implémentent le trait <code>Copy</code>. Mais quand nous avons rendu générique la
fonction <code>le_plus_grand</code>, il est devenu possible que le paramètre <code>liste</code>
contienne des types qui n'implémentent pas le trait <code>Copy</code>. Par conséquent,
nous ne pouvons pas forcément déplacer la valeur de <code>list[0]</code> dans notre
variable <code>le_plus_grand</code>, ce qui engendre cette erreur.</p>
<!--
To call this code with only those types that implement the `Copy` trait, we can
add `Copy` to the trait bounds of `T`! Listing 10-15 shows the complete code of
a generic `largest` function that will compile as long as the types of the
values in the slice that we pass into the function implement the `PartialOrd`
*and* `Copy` traits, like `i32` and `char` do.
-->
<p>Pour pouvoir appeler ce code avec seulement les types qui implémentent le trait
<code>Copy</code>, nous pouvons ajouter <code>Copy</code> aux traits liés de <code>T</code> ! L'encart 10-15 nous
montre le code complet d'une fonction générique <code>le_plus_grand</code> qui va se
compiler tant que le type des valeurs dans la slice que nous passons dans la
fonction implémente les traits <code>PartialOrd</code> <em>et</em> <code>Copy</code>, comme le font <code>i32</code> et
<code>char</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn le_plus_grand&lt;T: PartialOrd + Copy&gt;(liste: &amp;[T]) -&gt; T {
    let mut le_plus_grand = liste[0];

    for &amp;element in liste {
        if element &gt; le_plus_grand {
            le_plus_grand = element;
        }
    }

    le_plus_grand
}

fn main() {
    let liste_de_nombres = vec![34, 50, 25, 100, 65];

    let resultat = le_plus_grand(&amp;liste_de_nombres);
    println!(&quot;Le nombre le plus grand est {}&quot;, resultat);

    let liste_de_caracteres = vec!['y', 'm', 'a', 'q'];

    let resultat = le_plus_grand(&amp;liste_de_caracteres);
    println!(&quot;Le plus grand caractère est {}&quot;, resultat);
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-15: A working definition of the `largest`
function that works on any generic type that implements the `PartialOrd` and
`Copy` traits</span>
-->
<p><span class="caption">Encart 10-15 : une définition de la fonction
<code>le_plus_grand</code> qui fonctionne et s'applique sur n'importe quel type générique
qui implémente les traits <code>PartialOrd</code> et <code>Copy</code></span></p>
<!--
If we don’t want to restrict the `largest` function to the types that implement
the `Copy` trait, we could specify that `T` has the trait bound `Clone` instead
of `Copy`. Then we could clone each value in the slice when we want the
`largest` function to have ownership. Using the `clone` function means we’re
potentially making more heap allocations in the case of types that own heap
data like `String`, and heap allocations can be slow if we’re working with
large amounts of data.
-->
<p>Si nous ne souhaitons pas restreindre la fonction <code>le_plus_grand</code> aux types qui
implémentent le trait <code>Copy</code>, nous pouvons préciser que <code>T</code> a le trait lié
<code>Clone</code> plutôt que <code>Copy</code>. Ainsi, nous pouvons cloner chaque valeur dans la
slice lorsque nous souhaitons que la fonction <code>le_plus_grand</code> en prenne
possession. L'utilisation de la fonction <code>clone</code> signifie que nous allons
potentiellement allouer plus d'espace sur le tas dans le cas des types qui
possèdent des données sur le tas, comme <code>String</code>, et les allocations sur le tas
peuvent être lentes si nous travaillons avec des grandes quantités de données.</p>
<!--
Another way we could implement `largest` is for the function to return a
reference to a `T` value in the slice. If we change the return type to `&T`
instead of `T`, thereby changing the body of the function to return a
reference, we wouldn’t need the `Clone` or `Copy` trait bounds and we could
avoid heap allocations. Try implementing these alternate solutions on your own!
If you get stuck with errors having to do with lifetimes, keep reading: the
“Validating References with Lifetimes” section coming up will explain, but
lifetimes aren’t required to solve these challenges.
-->
<p>Une autre façon d'implémenter <code>le_plus_grand</code> est de faire en sorte que la
fonction retourne une référence à une valeur <code>T</code> de la slice. Si nous changeons
le type de retour en <code>&amp;T</code> à la place de <code>T</code> et que nous adaptons le corps de la
fonction afin de retourner une référence, nous n'aurions alors plus besoin des
traits liés <code>Clone</code> ou <code>Copy</code> et nous pourrions ainsi éviter l'allocation sur
le tas. Essayez d'implémenter ces solutions alternatives par vous-même !
Si vous bloquez sur des erreurs à propos des durées de vie <em>(lifetimes)</em>, lisez
la suite : la section suivante, “La conformité des références avec les durées
de vies” vous expliquera cela, mais les durées de vie ne sont pas nécessaires
pour résoudre ces exercices.</p>
<!--
### Using Trait Bounds to Conditionally Implement Methods
-->
<h3 id="utiliser-les-traits-liés-pour-conditionner-limplémentation-des-méthodes"><a class="header" href="#utiliser-les-traits-liés-pour-conditionner-limplémentation-des-méthodes">Utiliser les traits liés pour conditionner l'implémentation des méthodes</a></h3>
<!--
By using a trait bound with an `impl` block that uses generic type parameters,
we can implement methods conditionally for types that implement the specified
traits. For example, the type `Pair<T>` in Listing 10-16 always implements the
`new` function to return a new instance of `Pair<T>` (recall from the
[”Defining Methods”][methods]<!-- ignore -- > section of Chapter 5 that `Self`
is a type alias for the type of the `impl` block, which in this case is
`Pair<T>`). But in the next `impl` block, `Pair<T>` only implements the
`cmp_display` method if its inner type `T` implements the `PartialOrd` trait
that enables comparison *and* the `Display` trait that enables printing.
-->
<p>En utilisant un trait lié avec un bloc <code>impl</code> qui utilise les paramètres de type
génériques, nous pouvons implémenter des méthodes en fonction des types qui
implémentent des traits particuliers. Par exemple, le type <code>Paire&lt;T&gt;</code> de
l'encart 10-16 implémente toujours la fonction <code>new</code> pour retourner une
nouvelle instance de <code>Paire&lt;T&gt;</code> (pour rappel dans la section
<a href="ch05-03-method-syntax.html#d%C3%A9finir-des-m%C3%A9thodes">”Définir des méthodes”</a><!-- ignore --> du chapitre 5 que <code>Self</code> est
un alias de type pour le type du bloc <code>impl</code>, qui est dans ce cas le
<code>Paire&lt;T&gt;</code>). Mais dans le blochain bloc <code>impl</code>, <code>Paire&lt;T&gt;</code> implémente la
méthode <code>afficher_comparaison</code> uniquement si son type interne <code>T</code> implémente le
trait <code>PartialOrd</code> qui active la comparaison <em>et</em> le trait <code>Display</code> qui permet
l'affichage.</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">Fichier : src/lib.rs</span></p>
<!--
```rust,noplayground
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```
-->
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Paire&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Paire&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Paire&lt;T&gt; {
    fn afficher_comparaison(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;Le plus grand élément est x = {}&quot;, self.x);
        } else {
            println!(&quot;Le plus grand élément est y = {}&quot;, self.y);
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 10-16: Conditionally implement methods on a
generic type depending on trait bounds</span>
-->
<p><span class="caption">Encart 10-16 : implémentation de méthodes sur un type
générique en fonction des traits liés</span></p>
<!--
We can also conditionally implement a trait for any type that implements
another trait. Implementations of a trait on any type that satisfies the trait
bounds are called *blanket implementations* and are extensively used in the
Rust standard library. For example, the standard library implements the
`ToString` trait on any type that implements the `Display` trait. The `impl`
block in the standard library looks similar to this code:
-->
<p>Nous pouvons également implémenter un trait sur tout type qui implémente un
autre trait en particulier. L'implémentation d'un trait sur n'importe quel type
qui a un trait lié est appelée <em>implémentation générale</em> et est largement
utilisée dans la bibliothèque standard Rust. Par exemple, la bibliothèque
standard implémente le trait <code>ToString</code> sur tous les types qui implémentent le
trait <code>Display</code>. Le bloc <code>impl</code> de la bibliothèque standard ressemble au code
suivant :</p>
<!--
```rust,ignore
impl<T: Display> ToString for T {
    // --snip--
}
```
-->
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // -- partie masquée ici --
}
</code></pre>
<!--
Because the standard library has this blanket implementation, we can call the
`to_string` method defined by the `ToString` trait on any type that implements
the `Display` trait. For example, we can turn integers into their corresponding
`String` values like this because integers implement `Display`:
-->
<p>Comme la bibliothèque standard a cette implémentation générale, nous pouvons
appeler la méthode <code>to_string</code> définie par le trait <code>ToString</code> sur n'importe
quel type qui implémente le trait <code>Display</code>. Par exemple, nous pouvons
transformer les nombres entiers en leur équivalent dans une <code>String</code> comme
ci-dessous car les entiers implémentent <code>Display</code> :</p>
<!--
```rust
let s = 3.to_string();
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<!--
Blanket implementations appear in the documentation for the trait in the
“Implementors” section.
-->
<p>Les implémentations générales sont décrites dans la documentation du trait, dans
la section “Implementors”.</p>
<!--
Traits and trait bounds let us write code that uses generic type parameters to
reduce duplication but also specify to the compiler that we want the generic
type to have particular behavior. The compiler can then use the trait bound
information to check that all the concrete types used with our code provide the
correct behavior. In dynamically typed languages, we would get an error at
runtime if we called a method on a type which didn’t define the method. But Rust
moves these errors to compile time so we’re forced to fix the problems before
our code is even able to run. Additionally, we don’t have to write code that
checks for behavior at runtime because we’ve already checked at compile time.
Doing so improves performance without having to give up the flexibility of
generics.
-->
<p>Les traits et les traits liés nous permettent d'écrire du code qui utilise des
paramètres de type génériques pour réduire la duplication de code, mais aussi
pour indiquer au compilateur que nous voulons que le type générique ait un
comportement particulier. Le compilateur peut ensuite utiliser les informations
liées aux traits pour vérifier que tous les types concrets utilisés dans notre
code suivent le comportement souhaité. Dans les langages typés dynamiquement,
nous aurions une erreur à l'exécution si nous appelions une méthode sur un type
qui n'implémentait pas la méthode. Mais Rust décale l'apparition de ces erreurs
au moment de la compilation afin de nous forcer à résoudre les problèmes avant
même que notre code soit capable de s'exécuter. De plus, nous n'avons pas besoin
d'écrire un code qui vérifie le comportement lors de l'exécution car nous
l'avons déjà vérifié au moment de la compilation. Cela permet d'améliorer les
performances sans avoir à sacrifier la flexibilité des types génériques.</p>
<!--
Another kind of generic that we’ve already been using is called *lifetimes*.
Rather than ensuring that a type has the behavior we want, lifetimes ensure
that references are valid as long as we need them to be. Let’s look at how
lifetimes do that.
-->
<p>Une autre sorte de générique que nous avons déjà utilisée est la <em>durée de
vie</em>. Plutôt que de s'assurer qu'un type a le comportement que nous voulons, la
durée de vie s'assure que les références sont en vigueur aussi longtemps que
nous avons besoin qu'elles le soient. Nous allons voir à la page suivante
comment la durée de vie fait cela.</p>
<!-- markdownlint-disable -->
<!--
[stack-only-data-copy]:
ch04-01-what-is-ownership.html#stack-only-data-copy
[using-trait-objects-that-allow-for-values-of-different-types]:
ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[methods]: ch05-03-method-syntax.html#defining-methods
-->
<!-- markdownlint-restore -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-01-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch10-03-lifetime-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-01-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch10-03-lifetime-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../ferris.js"></script>


    </body>
</html>
